<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Personal Organiser</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <meta name="theme-color" content="#ffffff" />
    <style>
        :root {
            --bg: #ffffff;
            --surface: #f7fafc;
            --text: #111827;
            --text-muted: #4b5563;
            --primary: #8b5cf6;
            /* powerpuff vibe */
            --primary-contrast: #ffffff;
            --border: #e5e7eb;
            --focus: #111827;
            --card: #ffffff;
            --ring: 2px solid rgba(17, 24, 39, 0.6);
            --radius: 12px;
            --shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            --u: 8px;
            --bar: 56px;
        }

        [data-theme="dark"] {
            --bg: #0b0b0f;
            --surface: #0f1115;
            --text: #e5e7eb;
            --text-muted: #9ca3af;
            --primary: #7c3aed;
            --primary-contrast: #ffffff;
            --border: #242833;
            --focus: #e5e7eb;
            --card: #111319;
            --ring: 2px solid rgba(229, 231, 235, 0.6);
            --shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
        }

        [data-theme="slate"] {
            --bg: #0f172a;
            --surface: #111827;
            --text: #e2e8f0;
            --text-muted: #cbd5e1;
            --primary: #38bdf8;
            --primary-contrast: #0b1220;
            --border: #1f2937;
            --focus: #e2e8f0;
            --card: #0b1220;
            --ring: 2px solid rgba(226, 232, 240, 0.6);
            --shadow: 0 6px 18px rgba(0, 0, 0, 0.5);
        }

        [data-theme="powerpuff"] {
            --bg: #fff9fb;
            --surface: #fff0f7;
            --text: #1f2937;
            --text-muted: #6b7280;
            --primary: #ff6fa7;
            --primary-contrast: #1f2937;
            --border: #ffd6e7;
            --focus: #1f2937;
            --card: #ffffff;
            --ring: 2px solid rgba(31, 41, 55, 0.6);
            --shadow: 0 4px 16px rgba(255, 111, 167, 0.15);
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.3;
            -webkit-tap-highlight-color: transparent;
        }

        a {
            color: inherit
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            overflow: hidden;
            clip: rect(0 0 0 0);
            white-space: nowrap;
        }

        .app {
            height: 100svh;
            display: grid;
            grid-template-rows: var(--bar) auto 1fr;
        }

        .topbar {
            height: var(--bar);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 50;
        }

        .title {
            font-weight: 800;
            letter-spacing: .01em
        }

        .spacer {
            flex: 1
        }

        .icon-btn {
            appearance: none;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            border-radius: 999px;
            padding: 8px 12px;
            font-weight: 600;
            box-shadow: var(--shadow);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .icon-btn:focus {
            outline: var(--ring);
            box-shadow: var(--shadow)
        }

        .primary {
            background: var(--primary);
            color: var(--primary-contrast);
            border-color: transparent
        }

        .tabbar {
            display: flex;
            gap: 8px;
            overflow: auto;
            padding: 10px 12px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            max-width: 100%;
            flex-wrap: nowrap;
        }

        .tab {
            appearance: none;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            border-radius: 999px;
            padding: 8px 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .tab[aria-selected="true"] {
            background: var(--primary);
            color: var(--primary-contrast);
            border-color: transparent
        }

        .content {
            min-height: 0;
            display: grid;
            grid-template-rows: 1fr;
            height: 100%;
        }

        .panel {
            display: none;
            min-height: 0
        }

        .panel.active {
            display: grid;
            grid-template-rows: auto 1fr;
            min-height: 0;
        }

        .panel-header {
            grid-row: 1
        }

        .panel .panel-body {
            padding: 12px;
            overflow: auto;
            grid-row: 2;
            min-height: 0;
        }

        /* Simple cards */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 12px;
            color: var(--text);
        }

        /* Themed form controls */
        .input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--surface);
            color: var(--text);
        }

        .textarea {
            width: 100%;
            min-height: 0;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--surface);
            color: var(--text);
            resize: vertical;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .input::placeholder,
        .textarea::placeholder {
            color: var(--text-muted);
            opacity: 1;
        }

        .input:disabled,
        .textarea:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        input,
        textarea,
        select {
            accent-color: var(--primary);
            color: var(--text);
        }

        .input-bare {
            border: none;
            background: transparent;
            padding: 6px;
        }

        /* Theme date inputs' picker indicator so it's visible in dark themes */
        input[type="date"] {
            color-scheme: light dark;
            /* hint UA to adjust native parts */
        }

        /* Chromium/WebKit calendar picker icon */
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(0);
            /* default for light */
        }

        /* In dark-like themes, invert the icon for contrast */
        [data-theme="dark"] input[type="date"]::-webkit-calendar-picker-indicator,
        [data-theme="slate"] input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1) brightness(1.1);
        }

        /* Firefox uses a button, not standardized pseudo; color-scheme helps */

        /* Utilities */
        .flex-1 {
            flex: 1;
        }

        .h-200 {
            height: 200px;
        }

        .min-h-220 {
            min-height: 220px;
        }

        .min-h-0 {
            min-height: 0;
        }

        .p-8 {
            padding: 8px;
        }

        .p-10 {
            padding: 10px;
        }

        .mt-0 {
            margin-top: 0;
        }

        .mt-8 {
            margin-top: 8px;
        }

        .mt-12 {
            margin-top: 12px;
        }

        .mb-8 {
            margin-bottom: 8px;
        }

        .fw-700 {
            font-weight: 700;
        }

        .fw-800 {
            font-weight: 800;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .row-end {
            justify-content: flex-end;
        }

        .row-wrap {
            flex-wrap: wrap;
        }

        .gap-6 {
            gap: 6px;
        }

        .gap-8 {
            gap: 8px;
        }

        .grid {
            display: grid;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            min-height: 0;
        }

        .wh-full {
            width: 100%;
            height: 100%;
        }

        .list-reset {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .overflow-auto {
            overflow: auto;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        .hidden {
            display: none !important;
        }

        /* Components */
        .calc-display {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            font-weight: 800;
            text-align: right;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        .cards-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            min-height: 0;
        }

        @media (max-width: 720px) {
            .cards-area {
                grid-template-columns: 1fr;
            }
        }

        .min-h-12u {
            min-height: calc(12 * var(--u));
        }

        .min-h-3u {
            min-height: calc(3 * var(--u));
        }

        /* Selection and scrollbars */
        ::selection {
            background: var(--primary);
            color: var(--primary-contrast);
        }

        * {
            scrollbar-width: thin;
            scrollbar-color: var(--primary) var(--surface);
        }

        *::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        *::-webkit-scrollbar-track {
            background: var(--surface);
        }

        *::-webkit-scrollbar-thumb {
            background-color: var(--primary);
            border-radius: 999px;
            border: 2px solid var(--surface);
        }

        /* Panels and layouts */
        .panel-header {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between
        }

        .layout-notes-body {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            min-height: 0
        }

        .notes-list-card {
            min-height: 0;
            display: flex;
            flex-direction: column
        }

        .notes-list {
            list-style: none;
            padding: 0;
            margin: 0;
            min-height: 0;
            overflow: auto
        }

        .note-editor-row {
            background: var(--surface);
            padding: 8px;
            border: 1px dashed var(--border);
            border-radius: 10px;
            margin: 6px 8px;
            animation: editorIn 160ms ease-out;
        }

        /* Notes inline editor layout: spacious textarea on mobile/desktop */
        .note-editor-row {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 8px;
            min-height: 0;
        }

        .note-editor-row .textarea {
            height: 32vh;
            min-height: 180px;
        }

        @media (min-width: 720px) {
            .note-editor-row .textarea {
                height: 42vh;
                min-height: 240px;
            }
        }

        .card-editor-row {
            background: var(--surface);
            padding: 8px;
            border: 1px dashed var(--border);
            border-radius: 10px;
            margin: 6px 8px;
            animation: editorIn 160ms ease-out;
        }

        @keyframes editorIn {
            from {
                transform: scale(0.98);
                background: color-mix(in oklab, var(--primary) 16%, var(--surface));
            }

            to {
                transform: scale(1);
                background: var(--surface);
            }
        }

        .list-row.selected {
            background: color-mix(in oklab, var(--primary) 12%, var(--surface));
            box-shadow: inset 0 0 0 2px color-mix(in oklab, var(--primary) 50%, transparent);
        }

        .notes-editor {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 8px;
            min-height: 0
        }

        /* Wheel simplified layouts */
        #p-wheel .panel-body {
            min-height: 0;
            display: grid;
            grid-template-rows: 1fr;
        }

        .wheel-mode-bar {
            display: flex;
            gap: 8px;
        }

        .wheel-manage-view {
            display: grid;
            grid-template-rows: 1fr;
            min-height: 0;
        }

        .wheel-manage-view .wheel-input-card {
            min-height: 0;
            display: grid;
            grid-template-rows: 1fr;
        }

        .wheel-manage-view textarea {
            width: 100%;
            height: 100%;
        }

        .wheel-use-view {
            display: grid;
            grid-template-rows: auto minmax(0, 1fr) auto;
            gap: 8px;
            min-height: 0;
        }

        .wheel-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .wheel-canvas-wrap {
            min-height: 0;
            height: 100%;
            display: grid;
            grid-template-rows: 1fr;
            overflow: hidden;
            place-items: center;
        }

        .wheel-canvas-wrap canvas {
            width: auto;
            height: auto;
            max-width: 100%;
            display: block;
            aspect-ratio: 1/1;
        }

        .wheel-result {
            min-height: calc(2 * var(--u));
            font-weight: 600;
            contain: content;
            margin-top: 8px
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px
        }

        /* Calculator layout scales to fill available space */
        #p-calc .panel-body {
            min-height: 0;
            display: grid;
            grid-template-rows: 1fr;
        }

        #p-calc .panel-body {
            overflow: hidden;
        }

        /* Data layout: fixed-height controls row + flexible editor row */
        #p-data .panel-body {
            min-height: 0;
            display: grid;
            grid-template-rows: auto 1fr;
            overflow: hidden;
        }

        #json-area {
            height: 100%;
        }

        /* Tracker layout: single-cell grid, overlay views; inner views manage their own scroll */
        #p-tracker .panel-body {
            min-height: 0;
            display: grid;
            grid-template-rows: 1fr;
            grid-template-columns: 1fr;
            overflow: hidden;
        }

        /* Ensure direct card children fill the track to prevent content-driven growth */
        #p-tracker .panel-body>.card {
            height: 100%;
            min-height: 0;
            min-width: 0;
        }

        #tracker-data-view,
        #tracker-chart-view {
            grid-area: 1 / 1 / 2 / 2;
            min-height: 0;
            min-width: 0;
        }

        #tracker-data-view {
            height: 100%;
            overflow: auto;
        }

        #tracker-chart-view {
            height: 100%;
            display: grid;
            grid-template-rows: 1fr;
        }

        #tracker-chart-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .calc-wrap {
            height: 100%;
            width: 100%;
            display: grid;
            grid-template-rows: var(--calcDisplayH, 64px) 1fr;
            gap: var(--calcGap, 8px);
            min-height: 0;
        }

        .calc-keys {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-auto-rows: minmax(0, 1fr);
            gap: var(--calcGap, 8px);
            justify-content: stretch;
            align-content: stretch;
            min-height: 0;
        }

        /* Wheel responsive: collapse to one column on narrower screens to avoid reflow loops */
        @media (max-width: 900px) {
            .wheel-use-view .wheel-canvas-wrap canvas {
                height: auto;
                aspect-ratio: 1/1;
            }
        }

        .calc-btn {
            border: 1px solid var(--border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            user-select: none;
            font-size: var(--calcBtnFont, 18px);
        }

        .calc-btn:focus {
            outline: 2px solid color-mix(in oklab, var(--primary) 50%, transparent);
            outline-offset: 2px;
        }

        .calc-btn.num {
            background: color-mix(in oklab, var(--primary) 8%, var(--card));
            color: var(--text);
        }

        .calc-btn.op {
            background: color-mix(in oklab, var(--primary) 16%, var(--card));
            color: var(--text);
        }

        .calc-btn.eq {
            background: var(--primary);
            color: var(--primary-contrast);
            border-color: transparent;
        }

        .calc-btn.clear,
        .calc-btn.back {
            background: color-mix(in oklab, var(--text) 12%, var(--card));
            color: var(--text);
        }

        .calc-btn:hover {
            filter: brightness(1.05);
        }

        .calc-btn:active {
            transform: translateY(1px);
        }

        .drag-handle {
            cursor: grab;
            user-select: none;
            padding: 4px 6px;
            touch-action: none;
        }

        .dragging {
            opacity: 0.75;
        }

        .note-editor-row {
            background: var(--surface);
            padding: 8px;
            border: 1px dashed var(--border);
            border-radius: 10px;
            margin: 6px 8px;
        }

        .dragging {
            opacity: 0.6
        }

        .placeholder-line {
            min-height: calc(2 * var(--u));
            display: flex;
            align-items: center
        }

        .icon-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed
        }

        .drop-marker {
            height: 0;
            border-top: 2px solid var(--primary);
            margin: 4px 0;
        }

        /* Settings & About layout */
        .form-row {
            display: flex;
            gap: 12px;
            align-items: center;
            margin: 8px 0
        }

        .radio-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        label {
            font-weight: 600
        }

        /* Calendar theming */
        .cal-head {
            text-align: center;
            font-weight: 700;
            color: var(--text);
        }

        .cal-cell {
            appearance: none;
            padding: 8px;
            text-align: left;
            color: var(--text);
            background: var(--card);
            border: 1px solid var(--border);
            position: relative;
        }

        .cal-today {
            border-color: var(--primary);
        }

        .cal-badge {
            position: absolute;
            top: 6px;
            right: 6px;
            font-size: 10px;
            background: var(--primary);
            color: var(--primary-contrast);
            padding: 2px 6px;
            border-radius: 999px;
        }

        .cal-selected {
            border-color: color-mix(in oklab, var(--primary) 65%, var(--text));
            box-shadow: 0 0 0 2px color-mix(in oklab, var(--primary) 35%, transparent);
        }

        .cal-daynum {
            font-weight: 800;
        }

        .cal-dots {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .cal-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary);
        }

        /* Focus styles */
        :focus-visible {
            outline: var(--ring)
        }

        /* Responsive helpers */
        @media (max-width: 720px) {
            .tabbar {
                flex-wrap: nowrap
            }
        }

        @media (max-width: 900px) {
            .layout-notes-body {
                grid-template-columns: 1fr
            }

            .layout-wheel-body {
                grid-template-columns: 1fr
            }
        }
    </style>
</head>

<body>
    <a href="#main" class="visually-hidden" id="skip">Skip to content</a>
    <div class="app" id="app" aria-live="polite">
        <header class="topbar" role="banner">
            <button class="icon-btn" id="back-btn" aria-label="Back to launcher">⟵ Back</button>
            <div class="title" aria-label="App title">Personal Organiser</div>
            <div class="spacer"></div>
            <button class="icon-btn" id="theme-btn" aria-haspopup="true" aria-controls="p-settings">Theme</button>
        </header>

        <nav class="tabbar" role="tablist" aria-label="Sections">
            <button class="tab" role="tab" aria-selected="true" aria-controls="p-notes" id="t-notes">Notes</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-calendar"
                id="t-calendar">Calendar</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-tasks" id="t-tasks">Tasks</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-cards" id="t-cards">Cards</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-calc" id="t-calc">Calc</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-wheel" id="t-wheel">Wheel</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-tracker"
                id="t-tracker">Tracker</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-data" id="t-data">Data</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-settings"
                id="t-settings">Settings</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="p-about" id="t-about">About</button>
        </nav>

        <main class="content" id="main">
            <!-- Notes Panel -->
            <section class="panel active" id="p-notes" role="tabpanel" aria-labelledby="t-notes">
                <header class="panel-header card">
                    <div class="row gap-8" style="align-items:center; flex:1;">
                        <button class="icon-btn primary" id="add-note">Add Note</button>
                        <div class="spacer"></div>
                        <input id="notes-search-input" class="input" placeholder="Search notes…" aria-label="Search notes" style="max-width: 420px; flex: 0 1 420px;" />
                        <button class="icon-btn" id="notes-search-clear" aria-label="Clear search">✕</button>
                        <button class="icon-btn" id="notes-search-btn">Search</button>
                    </div>
                    <div id="notes-count" aria-live="polite"></div>
                </header>
                <div class="panel-body layout-notes-body">
                    <div class="card notes-list-card">
                        <ul id="notes-list" role="listbox" aria-label="Notes" class="notes-list"></ul>
                    </div>
                </div>
            </section>

            <!-- Calendar Panel -->
            <section class="panel" id="p-calendar" role="tabpanel" aria-labelledby="t-calendar">
                <header class="panel-header card">
                    <div class="row gap-8">
                        <button class="icon-btn" id="cal-prev" aria-label="Previous month">◀</button>
                        <div id="cal-label" aria-live="polite" class="fw-700"></div>
                        <button class="icon-btn" id="cal-next" aria-label="Next month">▶</button>
                        <button class="icon-btn" id="cal-today" aria-label="Today">Today</button>
                    </div>
                    <div></div>
                </header>
                <div class="panel-body">
                    <div id="calendar" class="card calendar-grid"></div>
                    <div id="event-editor" class="card hidden mt-12 min-h-12u">
                        <div id="event-date-label" class="fw-700 mb-8"></div>
                        <div class="row gap-8">
                            <input id="event-text" placeholder="Event details" class="input flex-1" />
                            <button class="icon-btn primary" id="add-event">Add</button>
                        </div>
                        <ul id="event-list" class="list-reset mt-8"></ul>
                    </div>
                </div>
            </section>

            <!-- Tasks Panel -->
            <section class="panel" id="p-tasks" role="tabpanel" aria-labelledby="t-tasks">
                <header class="panel-header card row gap-8">
                    <input id="task-text" placeholder="New task…" class="input flex-1" />
                    <button class="icon-btn primary" id="add-task">Add</button>
                </header>
                <div class="panel-body">
                    <ul id="tasks-list" class="card list-reset p-8"></ul>
                </div>
            </section>

            <!-- Cards Panel -->
            <section class="panel" id="p-cards" role="tabpanel" aria-labelledby="t-cards">
                <header class="panel-header card">
                    <div class="row gap-8">
                        <button class="icon-btn" id="cards-mode-practice" aria-pressed="true">Practice</button>
                        <button class="icon-btn" id="cards-mode-manage" aria-pressed="false">Manage</button>
                    </div>
                    <div id="cards-progress" class="placeholder-line"></div>
                </header>
                <div class="panel-body">
                    <div class="card cards-area" id="cards-area"></div>
                </div>
            </section>

            <!-- Calc Panel -->
            <section class="panel" id="p-calc" role="tabpanel" aria-labelledby="t-calc">
                <div class="panel-body">
                    <div class="card calc-wrap" id="calc">
                        <div id="calc-display" class="calc-display" role="status" aria-live="polite"></div>
                        <div id="calc-keys" class="calc-keys"></div>
                    </div>
                </div>
            </section>

            <!-- Wheel Panel -->
            <section class="panel" id="p-wheel" role="tabpanel" aria-labelledby="t-wheel">
                <header class="panel-header card">
                    <div class="row gap-8">
                        <button class="icon-btn" id="wheel-mode-use" aria-pressed="true">Use</button>
                        <button class="icon-btn" id="wheel-mode-manage" aria-pressed="false">Manage</button>
                    </div>
                    <div></div>
                </header>
                <div class="panel-body">
                    <div id="wheel-use-view" class="wheel-use-view">
                        <div class="card wheel-toolbar">
                            <button class="icon-btn primary" id="wheel-spin">Spin</button>
                            <div class="spacer"></div>
                            <button class="icon-btn" id="wheel-remove" disabled>Remove</button>
                        </div>
                        <div class="card wheel-canvas-wrap">
                            <canvas id="wheel-canvas"></canvas>
                        </div>
                        <div id="wheel-result" class="wheel-result" aria-live="polite"></div>
                    </div>
                    <div id="wheel-manage-view" class="wheel-manage-view hidden">
                        <div class="card wheel-input-card">
                            <textarea id="wheel-input" placeholder="One item per line" class="textarea"></textarea>
                            <div class="row gap-8 row-wrap">
                                <button class="icon-btn" id="wheel-clear">Clear</button>
                                <button class="icon-btn" id="wheel-sample">Sample</button>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Tracker Panel -->
            <section class="panel" id="p-tracker" role="tabpanel" aria-labelledby="t-tracker">
                <header class="panel-header card row gap-8 row-wrap">
                    <div class="row gap-6">
                        <button class="icon-btn" id="tracker-mode-data" aria-pressed="true">Data</button>
                        <button class="icon-btn" id="tracker-mode-chart" aria-pressed="false">Chart</button>
                    </div>
                    <div id="chart-controls" class="hidden min-h-3u"
                        style="display:grid; grid-template-columns: auto 1fr auto 1fr; gap:8px; align-items:center;">
                        <label for="chart-start">Start</label>
                        <input type="date" id="chart-start" class="input" />
                        <label for="chart-end">End</label>
                        <input type="date" id="chart-end" class="input" />
                        <div id="chart-types" class="row gap-6 row-wrap" style="grid-column:1/-1;"></div>
                        <div id="chart-metrics" class="row gap-6 row-wrap" style="grid-column:1/-1;"></div>
                    </div>
                    <div class="spacer"></div>
                    <div id="tracker-add-metric" class="row gap-6">
                        <input id="new-metric-name" placeholder="New metric" class="input" />
                        <button class="icon-btn primary" id="add-metric">Add</button>
                    </div>
                </header>
                <div class="panel-body min-h-0" style="display:grid; grid-template-rows: 1fr; overflow:hidden;">
                    <div id="tracker-data-view" class="card min-h-0 overflow-auto"
                        style="position: relative; min-height:0; height:100%;"></div>
                    <div id="tracker-chart-view" class="card hidden" style="display:grid; grid-template-rows: 1fr;">
                        <canvas id="tracker-chart-canvas" class="wh-full"></canvas>
                    </div>
                </div>
            </section>

            <!-- Data Panel -->
            <section class="panel" id="p-data" role="tabpanel" aria-labelledby="t-data">
                <div class="panel-body">
                    <div class="card row gap-8 row-wrap">
                        <button class="icon-btn" id="export-json">Export</button>
                        <button class="icon-btn" id="to-text">To Text</button>
                        <button class="icon-btn" id="export-schema">Schema</button>
                        <button class="icon-btn" id="import-json">Import</button>
                        <input type="file" id="file-input" accept="application/json" class="hidden" />
                        <button class="icon-btn" id="apply-json">Apply</button>
                        <button class="icon-btn" id="erase-all">Erase All</button>
                    </div>
                    <textarea id="json-area" class="card textarea min-h-220"></textarea>
                </div>
            </section>

            <!-- Settings Panel -->
            <section class="panel" id="p-settings" role="tabpanel" aria-labelledby="t-settings">
                <div class="panel-body">
                    <div class="card">
                        <div class="form-row"><label>Theme</label></div>
                        <div class="radio-group" role="group" aria-label="Theme selection">
                            <label><input type="radio" name="theme" value="system"> System</label>
                            <label><input type="radio" name="theme" value="powerpuff" checked> Powerpuff</label>
                            <label><input type="radio" name="theme" value="slate"> Slate</label>
                            <label><input type="radio" name="theme" value="dark"> Dark</label>
                            <label><input type="radio" name="theme" value="light"> Light</label>
                        </div>
                    </div>
                </div>
            </section>

            <!-- About Panel -->
            <section class="panel" id="p-about" role="tabpanel" aria-labelledby="t-about">
                <div class="panel-body">
                    <div class="card">
                        <h2 class="mt-0">Personal Organiser</h2>
                        <p>Author: <strong>Timeless Prototype</strong></p>
                        <p>Version: <span id="app-version">1.0.0</span></p>
                        <p>This is a modern reimagining of the classic Personal Organiser, rebuilt with accessibility,
                            responsiveness, and clean design in mind.</p>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        (function () {
            'use strict';

            const STORAGE_KEY = 'po-data-v1';
            const THEME_KEY = 'po-theme';
            const VERSION = '1.0.0';

            // Utilities
            const $ = (sel, root = document) => root.querySelector(sel);
            const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
            const gid = id => document.getElementById(id);

            // Unbiased, unseeded RNG (uses Web Crypto when available)
            function randFloat() {
                try {
                    if (window.crypto && window.crypto.getRandomValues) {
                        const a = new Uint32Array(1);
                        window.crypto.getRandomValues(a);
                        return a[0] / 4294967296; // 2^32
                    }
                } catch { }
                return Math.random();
            }
            function randInt(n) {
                if (n <= 0) return 0;
                try {
                    if (window.crypto && window.crypto.getRandomValues) {
                        const a = new Uint32Array(1);
                        const max = 0x100000000; // 2^32
                        const limit = Math.floor(max / n) * n; // rejection sampling to avoid bias
                        while (true) {
                            window.crypto.getRandomValues(a);
                            const x = a[0];
                            if (x < limit) return x % n;
                        }
                    }
                } catch { }
                return Math.floor(randFloat() * n);
            }

            // Theme
            const mqlDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
            let systemListenerSet = false;
            function effectiveTheme(mode) {
                if (!mode || mode === 'light') return null; // light => base :root
                if (mode === 'system') return (mqlDark && mqlDark.matches) ? 'dark' : null;
                return mode; // dark, slate, powerpuff
            }
            function applyTheme(mode) {
                const root = document.documentElement;
                const app = gid('app');
                const eff = effectiveTheme(mode);
                if (eff) root.setAttribute('data-theme', eff); else root.removeAttribute('data-theme');
                try { localStorage.setItem(THEME_KEY, mode || 'system'); } catch { }
                if (mode === 'system' && mqlDark && !systemListenerSet) {
                    mqlDark.addEventListener('change', () => applyTheme('system'));
                    systemListenerSet = true;
                }
                // Update browser UI theme color
                const meta = document.querySelector('meta[name="theme-color"]');
                if (meta) {
                    const cs = getComputedStyle(app);
                    const bg = cs.getPropertyValue('--bg').trim() || '#ffffff';
                    meta.setAttribute('content', bg);
                }
            }

            function loadTheme() {
                try { return localStorage.getItem(THEME_KEY) || 'powerpuff'; } catch { return 'powerpuff'; }
            }

            // State
            function sanitizeState(raw) {
                const def = {
                    ui: { tab: 'notes', trackerMode: 'chart', cardsMode: 'practice', wheelMode: 'use', calendarSelected: null, notesSearch: { query: '' } },
                    notes: [],
                    tasks: [],
                    events: {},
                    cards: [],
                    shuffledCache: { enabled: false, order: [] },
                    cardsPractice: { idx: 0 },
                    wheel: { itemsText: '', lastHit: null },
                    tracker: { metrics: [], data: {}, chartType: 'stacked', selectedMetrics: [], chartRange: { start: null, end: null } },
                };
                const out = JSON.parse(JSON.stringify(def));
                const tabsAllowed = ['notes', 'calendar', 'tasks', 'cards', 'calc', 'wheel', 'tracker', 'data', 'settings', 'about'];
                const isStr = v => typeof v === 'string'; const isBool = v => typeof v === 'boolean'; const isNum = v => typeof v === 'number' && Number.isFinite(v);
                const isDateKey = k => /^\d{4}-\d{2}-\d{2}$/.test(k);
                if (raw && typeof raw === 'object') {
                    if (raw.ui && typeof raw.ui === 'object') {
                        out.ui.tab = tabsAllowed.includes(raw.ui.tab) ? raw.ui.tab : def.ui.tab;
                        out.ui.trackerMode = raw.ui.trackerMode === 'data' ? 'data' : 'chart';
                        out.ui.cardsMode = raw.ui.cardsMode === 'manage' ? 'manage' : 'practice';
                        out.ui.wheelMode = raw.ui.wheelMode === 'manage' ? 'manage' : 'use';
                        out.ui.calendarSelected = (isStr(raw.ui.calendarSelected) && isDateKey(raw.ui.calendarSelected)) ? raw.ui.calendarSelected : null;
                        const q = raw.ui.notesSearch?.query; out.ui.notesSearch = { query: isStr(q) ? q : '' };
                    }
                    if (Array.isArray(raw.notes)) {
                        out.notes = raw.notes.map(n => ({ id: isStr(n?.id) ? n.id : Math.random().toString(36).slice(2, 10), title: isStr(n?.title) ? n.title : '', content: isStr(n?.content) ? n.content : '' }));
                    }
                    if (Array.isArray(raw.tasks)) {
                        out.tasks = raw.tasks.map(t => ({ id: isStr(t?.id) ? t.id : Math.random().toString(36).slice(2, 10), text: isStr(t?.text) ? t.text : '', done: !!t?.done }));
                    }
                    if (raw.events && typeof raw.events === 'object') {
                        const ev = {}; Object.keys(raw.events).forEach(k => { if (isDateKey(k) && Array.isArray(raw.events[k])) ev[k] = raw.events[k].filter(isStr); }); out.events = ev;
                    }
                    if (Array.isArray(raw.cards)) {
                        out.cards = raw.cards.map(c => ({ id: isStr(c?.id) ? c.id : Math.random().toString(36).slice(2, 10), front: isStr(c?.front) ? c.front : '', back: isStr(c?.back) ? c.back : '' }));
                    }
                    if (raw.shuffledCache && typeof raw.shuffledCache === 'object') {
                        out.shuffledCache.enabled = !!raw.shuffledCache.enabled;
                        out.shuffledCache.order = Array.isArray(raw.shuffledCache.order) ? raw.shuffledCache.order.filter(isStr) : [];
                    }
                    if (raw.cardsPractice && typeof raw.cardsPractice === 'object') {
                        out.cardsPractice.idx = Math.max(0, Math.min((out.cards.length || 1) - 1, isNum(raw.cardsPractice.idx) ? Math.floor(raw.cardsPractice.idx) : 0));
                    }
                    if (raw.wheel && typeof raw.wheel === 'object') {
                        out.wheel.itemsText = isStr(raw.wheel.itemsText) ? raw.wheel.itemsText : '';
                        out.wheel.lastHit = isStr(raw.wheel.lastHit) ? raw.wheel.lastHit : null;
                        // drop lastHit if it doesn't exist in items
                        const items = (out.wheel.itemsText || '').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                        if (out.wheel.lastHit && !items.includes(out.wheel.lastHit)) out.wheel.lastHit = null;
                    }
                    if (raw.tracker && typeof raw.tracker === 'object') {
                        if (Array.isArray(raw.tracker.metrics)) out.tracker.metrics = raw.tracker.metrics.map(m => ({ id: isStr(m?.id) ? m.id : Math.random().toString(36).slice(2, 10), name: isStr(m?.name) ? m.name : '' }));
                        if (raw.tracker.data && typeof raw.tracker.data === 'object') {
                            const td = {}; Object.keys(raw.tracker.data).forEach(dk => { if (isDateKey(dk) && raw.tracker.data[dk] && typeof raw.tracker.data[dk] === 'object') { const row = {}; Object.entries(raw.tracker.data[dk]).forEach(([k, v]) => { if (isStr(k) && (v === null || isNum(v))) row[k] = v; }); td[dk] = row; } }); out.tracker.data = td;
                        }
                        out.tracker.chartType = ['stacked', 'normalized', 'line'].includes(raw.tracker.chartType) ? raw.tracker.chartType : 'stacked';
                        // Selected metrics: keep only existing, default to all if empty/missing
                        const idsNow = out.tracker.metrics.map(m => m.id);
                        const selIn = Array.isArray(raw.tracker.selectedMetrics) ? raw.tracker.selectedMetrics.filter(isStr) : [];
                        const selFilt = selIn.filter(id => idsNow.includes(id));
                        out.tracker.selectedMetrics = selFilt.length ? selFilt : idsNow.slice();
                        // Chart range
                        const cr = raw.tracker.chartRange;
                        const valid = (d) => isStr(d) && isDateKey(d);
                        out.tracker.chartRange = { start: valid(cr?.start) ? cr.start : null, end: valid(cr?.end) ? cr.end : null };
                    }
                }
                // clamp cardsPractice idx to order length (after cards copy)
                out.cardsPractice.idx = Math.max(0, Math.min(Math.max(1, out.cards.length) - 1, out.cardsPractice.idx));
                return out;
            }
            let state = (function () {
                const raw = loadState(); return raw ? sanitizeState(raw) : {
                    ui: { tab: 'notes', trackerMode: 'chart', cardsMode: 'practice', wheelMode: 'use', calendarSelected: null, notesSearch: { query: '' } },
                    notes: [],
                    tasks: [],
                    events: {}, // yyyy-mm-dd -> [strings]
                    cards: [], // {id, front, back}
                    shuffledCache: { enabled: false, order: [] },
                    cardsPractice: { idx: 0 },
                    wheel: { itemsText: '', lastHit: null },
                    tracker: { metrics: [], data: {}, chartType: 'stacked', selectedMetrics: [], chartRange: { start: null, end: null } },
                };
            })();

            function saveState() {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            }
            let saveT; function scheduleSave() { clearTimeout(saveT); saveT = setTimeout(saveState, 300); }
            function loadState() {
                try { const s = localStorage.getItem(STORAGE_KEY); return s ? JSON.parse(s) : null; } catch { return null; }
            }

            // Navigation
            const tabs = [
                { id: 'notes' }, { id: 'calendar' }, { id: 'tasks' }, { id: 'cards' }, { id: 'calc' }, { id: 'wheel' }, { id: 'tracker' }, { id: 'data' }, { id: 'settings' }, { id: 'about' }
            ];
            function showTab(id) {
                tabs.forEach(t => {
                    const btn = gid('t-' + t.id);
                    const panel = gid('p-' + t.id);
                    const sel = t.id === id;
                    btn.setAttribute('aria-selected', sel ? 'true' : 'false');
                    panel.classList.toggle('active', sel);
                });
                state.ui.tab = id; scheduleSave();
                // Default focus per tab
                const focusIds = {
                    notes: 'add-note', calendar: 'cal-today', tasks: 'task-text', cards: 'cards-mode-practice', calc: 'calc-display', wheel: 'wheel-spin', tracker: 'add-metric', data: 'export-json', settings: 't-settings', about: 't-about'
                };
                const f = gid(focusIds[id]); if (f) f.focus();
                if (id === 'wheel') { requestAnimationFrame(() => requestAnimationFrame(() => resizeWheelCanvas())); }
                if (id === 'calc') { requestAnimationFrame(() => layoutCalc()); }
                if (id === 'tracker') { setTrackerMode(state.ui.trackerMode || 'chart'); }
            }

            // Back button
            gid('back-btn').addEventListener('click', () => { window.location.href = 'index.html'; });
            // Theme button opens Settings
            gid('theme-btn').addEventListener('click', () => showTab('settings'));

            // Hook up tab clicks & keyboard left/right
            tabs.forEach(t => gid('t-' + t.id).addEventListener('click', () => showTab(t.id)));
            document.addEventListener('keydown', (e) => {
                if (e.altKey || e.ctrlKey || e.metaKey) return;
                // Only handle arrow nav when focus is inside the tabbar
                if (!e.target.closest || !e.target.closest('.tabbar')) return;
                const order = tabs.map(t => t.id);
                const i = order.indexOf(state.ui.tab);
                if (e.key === 'ArrowRight') { e.preventDefault(); showTab(order[(i + 1) % order.length]); }
                if (e.key === 'ArrowLeft') { e.preventDefault(); showTab(order[(i - 1 + order.length) % order.length]); }
            });

            // Theme settings
            const themeRadios = $$('input[name="theme"]');
            function initTheme() {
                const stored = loadTheme();
                applyTheme(stored);
                themeRadios.forEach(r => { r.checked = r.value === stored; });
            }
            themeRadios.forEach(r => r.addEventListener('change', () => {
                const val = themeRadios.find(x => x.checked)?.value || 'system';
                applyTheme(val);
                try { localStorage.setItem(THEME_KEY, val); } catch { }
            }));

            // NOTES
            let currentNoteId = null; let inlineEditorEl = null; let draftNote = null;
            // Search state: query string for current query
            state.ui = state.ui || {}; // ensure
            state.ui.notesSearch = state.ui.notesSearch || { query: '' };
            // Generic reorder helper using Pointer Events
            const reorderBound = new WeakSet();
            function enableReorder(listEl, getItems, setItems) {
                if (reorderBound.has(listEl)) return; // bind once per list element instance
                reorderBound.add(listEl);
                let dragIdx = null; let overIdx = null; let activeId = null;
                let marker = null;
                function insertionIndexFromPoint(clientY) {
                    const rows = Array.from(listEl.children).filter(el => !marker || el !== marker);
                    if (!rows.length) return 0;
                    for (let i = 0; i < rows.length; i++) {
                        const r = rows[i].getBoundingClientRect();
                        const mid = r.top + r.height / 2;
                        if (clientY < mid) return i; // insert before i
                    }
                    return rows.length; // insert at end
                }
                listEl.addEventListener('pointerdown', (e) => {
                    const handle = e.target.closest('.drag-handle'); if (!handle) return;
                    const itemEl = handle.closest('[data-idx]'); if (!itemEl) return;
                    e.preventDefault();
                    try { listEl.setPointerCapture(e.pointerId); activeId = e.pointerId; } catch { }
                    dragIdx = Number(itemEl.getAttribute('data-idx')); overIdx = dragIdx;
                    itemEl.classList.add('dragging');
                    // create marker at the current position
                    marker = document.createElement('div'); marker.className = 'drop-marker';
                    const rows = Array.from(listEl.children).filter(el => el !== marker);
                    const ref = rows[dragIdx]; if (ref) ref.insertAdjacentElement('beforebegin', marker); else listEl.appendChild(marker);
                });
                listEl.addEventListener('pointermove', (e) => {
                    if (dragIdx === null) return;
                    overIdx = insertionIndexFromPoint(e.clientY);
                    const rows = Array.from(listEl.children).filter(el => el !== marker);
                    const target = rows[overIdx];
                    if (marker) {
                        if (target) target.insertAdjacentElement('beforebegin', marker);
                        else listEl.appendChild(marker);
                    }
                });
                function endDrag(e) {
                    if (dragIdx === null) return;
                    if (activeId !== null) { try { listEl.releasePointerCapture(activeId); } catch { } activeId = null; }
                    const items = getItems(); const from = dragIdx; let to = overIdx;
                    if (Number.isInteger(from) && Number.isInteger(to)) {
                        // adjust insertion index if moving down past original position
                        if (to > from) to -= 1;
                        if (from !== to && from >= 0 && to >= 0 && from < items.length && to <= items.length) {
                            const [item] = items.splice(from, 1); items.splice(to, 0, item); setItems(items);
                        }
                    }
                    const dragging = listEl.querySelector('.dragging'); if (dragging) dragging.classList.remove('dragging');
                    if (marker && marker.parentNode) marker.parentNode.removeChild(marker); marker = null;
                    dragIdx = null; overIdx = null;
                }
                listEl.addEventListener('pointerup', endDrag);
                listEl.addEventListener('pointercancel', endDrag);
                listEl.addEventListener('pointerleave', (e) => { if (dragIdx !== null) endDrag(e); });
            }
            // Basic text normalization for similarity
            function tokenize(str) {
                return (str || '').toLowerCase().replace(/[^a-z0-9\s]+/g, ' ').split(/\s+/).filter(Boolean);
            }
            function termFreq(tokens) {
                const m = new Map(); for (const t of tokens) m.set(t, (m.get(t) || 0) + 1); return m;
            }
            function cosineSim(aStr, bStr) {
                const aT = tokenize(aStr); const bT = tokenize(bStr);
                if (!aT.length || !bT.length) return 0;
                const a = termFreq(aT); const b = termFreq(bT);
                let dot = 0; let a2 = 0; let b2 = 0;
                for (const [, v] of a) a2 += v * v;
                for (const [, v] of b) b2 += v * v;
                const keys = new Set([...a.keys(), ...b.keys()]);
                for (const k of keys) dot += (a.get(k) || 0) * (b.get(k) || 0);
                const denom = Math.sqrt(a2) * Math.sqrt(b2);
                return denom ? dot / denom : 0;
            }
            // Simple Soundex implementation (English)
            function soundex(s) {
                s = (s || '').toUpperCase().replace(/[^A-Z]/g, ''); if (!s) return '';
                const first = s[0];
                const map = { B:1,F:1,P:1,V:1, C:2,G:2,J:2,K:2,Q:2,S:2,X:2,Z:2, D:3,T:3, L:4, M:5,N:5, R:6 };
                const codes = [first];
                let prev = map[first] || 0;
                for (let i = 1; i < s.length && codes.length < 4; i++) {
                    const ch = s[i]; const code = map[ch] || 0; if (code !== 0 && code !== prev) codes.push(String(code)); prev = code; if (code === 0) prev = 0;
                }
                while (codes.length < 4) codes.push('0');
                return codes.join('');
            }
            function computeSearchOrder(query) {
                const q = (query || '').trim();
                const notes = state.notes || [];
                if (!q) return { ids: notes.map(n => n.id), map: new Map(notes.map((n, i) => [n.id, i])) };
                const originalIndex = new Map(notes.map((n, i) => [n.id, i]));
                const titleOf = (n) => n.title || '';
                const bodyOf = (n) => n.content || '';

                // Helpers: build ranking maps (id -> 1-based rank) based on earliest index in string
                function rankByIndex(getStr, extractor) {
                    const arr = [];
                    for (const n of notes) {
                        const s = getStr(n);
                        const key = extractor(s);
                        if (key != null && key >= 0) arr.push({ id: n.id, key });
                    }
                    arr.sort((a, b) => a.key - b.key || originalIndex.get(a.id) - originalIndex.get(b.id));
                    return new Map(arr.map((x, i) => [x.id, i + 1]));
                }

                // Substring (case-sensitive) on title and content
                const rSubCsTitle = rankByIndex(titleOf, (s) => s.indexOf(q));
                const rSubCsBody = rankByIndex(bodyOf, (s) => s.indexOf(q));
                // Substring (case-insensitive) on title and content
                const ql = q.toLowerCase();
                const rSubCiTitle = rankByIndex(titleOf, (s) => s.toLowerCase().indexOf(ql));
                const rSubCiBody = rankByIndex(bodyOf, (s) => s.toLowerCase().indexOf(ql));

                // Regex (case-sensitive and case-insensitive) on title and content
                let rReCsTitle = new Map(), rReCsBody = new Map(), rReCiTitle = new Map(), rReCiBody = new Map();
                try {
                    const re = new RegExp(q);
                    rReCsTitle = rankByIndex(titleOf, (s) => { const m = re.exec(s); return m ? (m.index ?? 0) : -1; });
                    rReCsBody = rankByIndex(bodyOf, (s) => { const m = re.exec(s); return m ? (m.index ?? 0) : -1; });
                } catch { /* invalid regex => ignore CS */ }
                try {
                    const rei = new RegExp(q, 'i');
                    rReCiTitle = rankByIndex(titleOf, (s) => { const m = rei.exec(s); return m ? (m.index ?? 0) : -1; });
                    rReCiBody = rankByIndex(bodyOf, (s) => { const m = rei.exec(s); return m ? (m.index ?? 0) : -1; });
                } catch { /* invalid regex => ignore CI */ }

                // Soundex on title and content (rank by earliest matching word index)
                function rankSoundexField(getStr) {
                    const qS = soundex(q); if (!qS) return new Map();
                    const arr = [];
                    for (const n of notes) {
                        const words = getStr(n).split(/\b/);
                        let best = Infinity;
                        for (let i = 0; i < words.length; i++) { const w = words[i].trim(); if (!w) continue; if (soundex(w) === qS) { best = i; break; } }
                        if (Number.isFinite(best)) arr.push({ id: n.id, key: best });
                    }
                    arr.sort((a, b) => a.key - b.key || originalIndex.get(a.id) - originalIndex.get(b.id));
                    return new Map(arr.map((x, i) => [x.id, i + 1]));
                }
                const rSdxTitle = rankSoundexField(titleOf);
                const rSdxBody = rankSoundexField(bodyOf);

                // Cosine similarity on title and content (convert to rank using inverse sim)
                function rankCosineField(getStr) {
                    const arr = [];
                    for (const n of notes) { const sim = cosineSim(q, getStr(n)); if (sim > 0) arr.push({ id: n.id, key: -sim }); }
                    arr.sort((a, b) => a.key - b.key || originalIndex.get(a.id) - originalIndex.get(b.id));
                    return new Map(arr.map((x, i) => [x.id, i + 1]));
                }
                const rCosTitle = rankCosineField(titleOf);
                const rCosBody = rankCosineField(bodyOf);

                const ranks = [
                    rSubCsTitle, rSubCsBody,
                    rSubCiTitle, rSubCiBody,
                    rReCsTitle, rReCsBody,
                    rReCiTitle, rReCiBody,
                    rSdxTitle, rSdxBody,
                    rCosTitle, rCosBody,
                ];
                const totals = new Map(); const hits = new Map();
                for (const r of ranks) {
                    for (const [id, pos] of r.entries()) {
                        totals.set(id, (totals.get(id) || 0) + pos);
                        hits.set(id, (hits.get(id) || 0) + 1);
                    }
                }
                const cand = Array.from(totals.entries()).filter(([id]) => (hits.get(id) || 0) > 0).map(([id, score]) => ({ id, score }));
                cand.sort((a, b) => a.score - b.score || originalIndex.get(a.id) - originalIndex.get(b.id));
                const ids = cand.map(c => c.id);
                const map = new Map(ids.map((id, i) => [id, i]));
                return { ids, map };
            }
            function getNotesRenderSpec() {
                const q = state.ui?.notesSearch?.query || '';
                const { ids } = computeSearchOrder(q);
                return ids.map(id => state.notes.find(n => n.id === id)).filter(Boolean);
            }
            function renderNotes() {
                const ul = gid('notes-list'); ul.innerHTML = '';
                let selectedIdx = -1;
                const viewNotes = getNotesRenderSpec();
                const idToIdx = new Map(state.notes.map((n, i) => [n.id, i]));
                viewNotes.forEach((n, idx) => {
                    const li = document.createElement('li');
                    li.setAttribute('role', 'option');
                    li.setAttribute('tabindex', '0');
                    li.setAttribute('data-idx', String(idx));
                    li.setAttribute('data-id', n.id);
                    li.style.display = 'grid';
                    li.style.gridTemplateColumns = 'auto 1fr auto auto';
                    li.style.gap = '6px';
                    li.style.alignItems = 'center';
                    li.style.padding = '6px 8px';
                    li.style.borderBottom = '1px solid var(--border)';
                    li.classList.add('list-row');
                    li.addEventListener('click', () => { currentNoteId = n.id; openInlineEditor(li, n); });
                    li.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') { currentNoteId = n.id; openInlineEditor(li, n); }
                        if (e.key === 'ArrowDown') { e.preventDefault(); const next = ul.querySelector(`li[data-idx="${idx + 1}"]`); if (next) { next.focus(); selectRow(next); } }
                        if (e.key === 'ArrowUp') { e.preventDefault(); const prev = ul.querySelector(`li[data-idx="${idx - 1}"]`); if (prev) { prev.focus(); selectRow(prev); } }
                    });
                    const drag = document.createElement('span'); drag.className = 'drag-handle'; drag.textContent = '⋮⋮'; drag.title = 'Drag to reorder'; drag.setAttribute('aria-hidden', 'true');
                    const title = document.createElement('div'); title.textContent = n.title || '(untitled)'; title.style.fontWeight = '600';
                    const up = document.createElement('button'); up.className = 'icon-btn'; up.textContent = '↑'; up.title = 'Move up';
                    up.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // Move this note up within the current view; reflect in global ordering
                        if (idx > 0) {
                            const ids = viewNotes.map(x => x.id);
                            const thisId = n.id; const prevId = ids[idx - 1];
                            const gi = idToIdx.get(thisId); const pj = idToIdx.get(prevId);
                            if (gi != null && pj != null) { [state.notes[gi], state.notes[pj]] = [state.notes[pj], state.notes[gi]]; scheduleSave(); renderNotes(); }
                        }
                    });
                    const down = document.createElement('button'); down.className = 'icon-btn'; down.textContent = '↓'; down.title = 'Move down';
                    down.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const ids = viewNotes.map(x => x.id);
                        if (idx < ids.length - 1) {
                            const thisId = n.id; const nextId = ids[idx + 1];
                            const gi = idToIdx.get(thisId); const nk = idToIdx.get(nextId);
                            if (gi != null && nk != null) { [state.notes[gi], state.notes[nk]] = [state.notes[nk], state.notes[gi]]; scheduleSave(); renderNotes(); }
                        }
                    });
                    li.append(drag, title, up, down); ul.appendChild(li);
                });
                // Enable pointer-based reordering for notes list (projected into global order when filtered)
                enableReorder(gid('notes-list'), () => {
                    // return the array currently displayed, not the global backing
                    return getNotesRenderSpec().slice();
                }, (viewItems) => {
                    // Replace view items at their original global positions with the new order
                    const viewIds = viewItems.map(n => n.id);
                    const global = state.notes.slice();
                    const positions = [];
                    for (let i = 0; i < global.length; i++) { if (viewIds.includes(global[i].id)) positions.push(i); }
                    positions.sort((a, b) => a - b);
                    const newGlobal = global.slice();
                    for (let i = 0; i < positions.length; i++) newGlobal[positions[i]] = viewItems[i];
                    state.notes = newGlobal;
                    scheduleSave(); renderNotes();
                });
                const total = state.notes.length; const shown = viewNotes.length; const q = state.ui?.notesSearch?.query || '';
                gid('notes-count').textContent = q ? `${shown}/${total} notes (search)` : `${total} notes`;
                function clearSelection() { ul.querySelectorAll('.selected').forEach(el => el.classList.remove('selected')); }
                function selectRow(row) { clearSelection(); row.classList.add('selected'); }
                ul.addEventListener('focusin', (e) => { const li = e.target.closest('li[data-idx]'); if (li) selectRow(li); });
                ul.addEventListener('focusout', (e) => { if (!ul.contains(e.relatedTarget)) { clearSelection(); } });
                // Re-attach inline editor below the current note if present
                if (inlineEditorEl && currentNoteId) {
                    const idx = getNotesRenderSpec().findIndex(n => n.id === currentNoteId);
                    const li = gid('notes-list').querySelector(`li[data-idx="${idx}"]`);
                    if (li && inlineEditorEl.previousElementSibling !== li) { li.insertAdjacentElement('afterend', inlineEditorEl); }
                }
            }
            function removeInlineEditor() { if (inlineEditorEl && inlineEditorEl.parentNode) { inlineEditorEl.parentNode.removeChild(inlineEditorEl); } inlineEditorEl = null; draftNote = null; }
            function openInlineEditor(afterLi, note) {
                removeInlineEditor();
                inlineEditorEl = document.createElement('li'); inlineEditorEl.className = 'note-editor-row'; inlineEditorEl.setAttribute('role', 'region'); inlineEditorEl.setAttribute('aria-label', 'Edit note');
                const title = document.createElement('input'); title.className = 'input mb-8'; title.placeholder = 'Title'; title.value = note.title || '';
                const body = document.createElement('textarea'); body.className = 'textarea'; body.placeholder = 'Write your note…'; body.value = note.content || '';
                const actions = document.createElement('div'); actions.className = 'row gap-8 row-end';
                const save = document.createElement('button'); save.className = 'icon-btn'; save.textContent = 'Save';
                const cancel = document.createElement('button'); cancel.className = 'icon-btn'; cancel.textContent = 'Cancel';
                const del = document.createElement('button'); del.className = 'icon-btn'; del.textContent = 'Delete';
                actions.append(save, cancel, del);
                inlineEditorEl.append(title, body, actions);
                afterLi.insertAdjacentElement('afterend', inlineEditorEl);
                draftNote = { id: note.id, title: note.title, content: note.content };
                title.addEventListener('input', () => { draftNote.title = title.value; });
                body.addEventListener('input', () => { draftNote.content = body.value; });
                inlineEditorEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') { e.preventDefault(); removeInlineEditor(); }
                    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); save.click(); }
                });
                save.addEventListener('click', () => {
                    const n = state.notes.find(n => n.id === note.id); if (n) { n.title = draftNote.title; n.content = draftNote.content; scheduleSave(); }
                    removeInlineEditor(); renderNotes();
                });
                cancel.addEventListener('click', () => { removeInlineEditor(); });
                del.addEventListener('click', () => { const i = state.notes.findIndex(n => n.id === note.id); if (i >= 0) { state.notes.splice(i, 1); scheduleSave(); } removeInlineEditor(); renderNotes(); });
                title.focus();
            }
            gid('add-note').addEventListener('click', () => {
                const n = { id: Math.random().toString(36).slice(2, 10), title: '', content: '' };
                state.notes.unshift(n); currentNoteId = n.id; scheduleSave(); renderNotes();
                const firstLi = gid('notes-list').querySelector('li[data-idx="0"]'); if (firstLi) { openInlineEditor(firstLi, n); inlineEditorEl?.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
            });
            // Search UI handlers
            const searchInput = gid('notes-search-input');
            const searchBtn = gid('notes-search-btn');
            const searchClear = gid('notes-search-clear');
            function applySearch(q) {
                state.ui.notesSearch.query = (q || '').trim(); scheduleSave(); renderNotes();
            }
            if (searchInput && searchBtn && searchClear) {
                searchBtn.addEventListener('click', () => applySearch(searchInput.value));
                searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); applySearch(searchInput.value); } });
                searchClear.addEventListener('click', () => { searchInput.value = ''; applySearch(''); });
            }

            // TASKS
            function renderTasks() {
                const ul = gid('tasks-list'); ul.innerHTML = '';
                state.tasks.forEach((t, idx) => {
                    const li = document.createElement('li'); li.style.display = 'grid'; li.style.gridTemplateColumns = 'auto auto 1fr auto auto'; li.style.gap = '8px'; li.style.alignItems = 'center';
                    li.setAttribute('data-idx', String(idx));
                    const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = !!t.done; cb.addEventListener('change', () => { t.done = cb.checked; scheduleSave(); renderTasks(); });
                    const drag = document.createElement('span'); drag.className = 'drag-handle'; drag.textContent = '⋮⋮'; drag.title = 'Drag to reorder'; drag.setAttribute('aria-hidden', 'true');
                    const txt = document.createElement('input'); txt.value = t.text || ''; txt.placeholder = 'Task'; txt.className = 'input'; txt.addEventListener('input', () => { t.text = txt.value; scheduleSave(); });
                    const up = document.createElement('button'); up.className = 'icon-btn'; up.textContent = '↑'; up.addEventListener('click', () => { if (idx > 0) { [state.tasks[idx - 1], state.tasks[idx]] = [state.tasks[idx], state.tasks[idx - 1]]; scheduleSave(); renderTasks(); } });
                    const del = document.createElement('button'); del.className = 'icon-btn'; del.textContent = '✕'; del.addEventListener('click', () => { state.tasks.splice(idx, 1); scheduleSave(); renderTasks(); });
                    li.append(cb, drag, txt, up, del); ul.appendChild(li);
                });
                enableReorder(gid('tasks-list'), () => state.tasks.slice(), (items) => { state.tasks = items; scheduleSave(); renderTasks(); });
            }
            gid('add-task').addEventListener('click', () => {
                const input = gid('task-text'); const v = input.value.trim(); if (!v) return; state.tasks.unshift({ id: Math.random().toString(36).slice(2, 10), text: v, done: false }); input.value = ''; scheduleSave(); renderTasks();
            });
            gid('task-text').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); gid('add-task').click(); } });

            // CALENDAR
            let calYear, calMonth; // 0-11
            function setMonth(y, m) { calYear = y; calMonth = m; renderCalendar(); }
            function renderCalendar() {
                const grid = gid('calendar'); grid.innerHTML = '';
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                days.forEach(d => { const h = document.createElement('div'); h.textContent = d; h.className = 'cal-head'; grid.appendChild(h); });
                const first = new Date(calYear, calMonth, 1).getDay();
                const count = new Date(calYear, calMonth + 1, 0).getDate();
                for (let i = 0; i < first; i++) { const s = document.createElement('div'); grid.appendChild(s); }
                for (let d = 1; d <= count; d++) {
                    const cell = document.createElement('button'); cell.className = 'card cal-cell';
                    const dateStr = `${calYear}-${String(calMonth + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                    const todayObj = new Date(); const isToday = todayObj.getFullYear() === calYear && todayObj.getMonth() === calMonth && todayObj.getDate() === d;
                    cell.setAttribute('aria-label', isToday ? `Today, Day ${d}` : `Day ${d}`);
                    if (isToday) { cell.classList.add('cal-today'); const badge = document.createElement('span'); badge.className = 'cal-badge'; badge.textContent = 'Today'; cell.appendChild(badge); }
                    if (state.ui.calendarSelected === dateStr) { cell.classList.add('cal-selected'); }
                    const lbl = document.createElement('div'); lbl.textContent = d; lbl.className = 'cal-daynum'; cell.appendChild(lbl);
                    const dots = document.createElement('div'); dots.className = 'cal-dots';
                    (state.events[dateStr] || []).slice(0, 3).forEach(() => { const dot = document.createElement('div'); dot.className = 'cal-dot'; dots.appendChild(dot); });
                    cell.appendChild(dots);
                    cell.addEventListener('click', () => openEventEditor(dateStr));
                    grid.appendChild(cell);
                }
                $('#cal-label').textContent = new Date(calYear, calMonth, 1).toLocaleString(undefined, { month: 'long', year: 'numeric' });
            }
            // Calendar navigation
            gid('cal-prev').addEventListener('click', () => { const d = new Date(calYear, calMonth - 1, 1); setMonth(d.getFullYear(), d.getMonth()); });
            gid('cal-next').addEventListener('click', () => { const d = new Date(calYear, calMonth + 1, 1); setMonth(d.getFullYear(), d.getMonth()); });
            gid('cal-today').addEventListener('click', () => { const d = new Date(); setMonth(d.getFullYear(), d.getMonth()); const ds = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`; openEventEditor(ds); });
            function openEventEditor(dateStr) {
                state.ui.calendarSelected = dateStr; scheduleSave();
                const wrap = gid('event-editor'); wrap.classList.remove('hidden');
                gid('event-date-label').textContent = new Date(dateStr).toDateString();
                renderEventsFor(dateStr);
                gid('add-event').onclick = () => {
                    const v = gid('event-text').value.trim(); if (!v) return; state.events[dateStr] = state.events[dateStr] || []; state.events[dateStr].push(v); gid('event-text').value = ''; scheduleSave(); renderEventsFor(dateStr); renderCalendar();
                };
                renderCalendar();
            }
            function renderEventsFor(dateStr) {
                const ul = gid('event-list'); ul.innerHTML = '';
                (state.events[dateStr] || []).forEach((txt, idx) => {
                    const li = document.createElement('li'); li.style.display = 'grid'; li.style.gridTemplateColumns = '1fr auto'; li.style.gap = '8px'; li.style.alignItems = 'center';
                    const sp = document.createElement('div'); sp.textContent = txt;
                    const del = document.createElement('button'); del.className = 'icon-btn'; del.textContent = '✕'; del.addEventListener('click', () => { state.events[dateStr].splice(idx, 1); scheduleSave(); renderEventsFor(dateStr); renderCalendar(); });
                    li.append(sp, del); ul.appendChild(li);
                });
            }

            // CARDS
            let cardsMode = 'practice';
            function setCardsMode(m) {
                cardsMode = m; state.ui.cardsMode = m; scheduleSave();
                const practiceBtn = gid('cards-mode-practice'); const manageBtn = gid('cards-mode-manage');
                practiceBtn.setAttribute('aria-pressed', m === 'practice' ? 'true' : 'false');
                manageBtn.setAttribute('aria-pressed', m === 'manage' ? 'true' : 'false');
                renderCards();
            }
            gid('cards-mode-practice').addEventListener('click', () => setCardsMode('practice'));
            gid('cards-mode-manage').addEventListener('click', () => setCardsMode('manage'));
            let cardsKeyHandlerBound = false; let cardsKeyHandlerActive = false; let cardsPracticeCtx = { idx: (state.cardsPractice?.idx || 0), front: true };
            function ensureCardsKeyHandler() {
                if (cardsKeyHandlerBound) return;
                window.addEventListener('keydown', (e) => {
                    if (!cardsKeyHandlerActive) return;
                    if (state.ui.tab !== 'cards') return;
                    if (e.key === ' ') { e.preventDefault(); cardsPracticeCtx.front = !cardsPracticeCtx.front; cardsPracticeCtx.update(); }
                    if (e.key === 'ArrowLeft') { cardsPracticeCtx.idx = Math.max(0, cardsPracticeCtx.idx - 1); state.cardsPractice = state.cardsPractice || { idx: 0 }; state.cardsPractice.idx = cardsPracticeCtx.idx; scheduleSave(); cardsPracticeCtx.front = true; cardsPracticeCtx.update(); }
                    if (e.key === 'ArrowRight') { cardsPracticeCtx.idx = Math.min(state.cards.length - 1, cardsPracticeCtx.idx + 1); state.cardsPractice = state.cardsPractice || { idx: 0 }; state.cardsPractice.idx = cardsPracticeCtx.idx; scheduleSave(); cardsPracticeCtx.front = true; cardsPracticeCtx.update(); }
                });
                cardsKeyHandlerBound = true;
            }
            function renderCards() {
                const area = gid('cards-area'); area.innerHTML = '';
                if (cardsMode === 'practice') {
                    area.style.gridTemplateColumns = '1fr';
                    const topBar = document.createElement('div'); topBar.className = 'row gap-8';
                    const prevBtn = document.createElement('button'); prevBtn.className = 'icon-btn'; prevBtn.textContent = 'Prev';
                    const nextBtn = document.createElement('button'); nextBtn.className = 'icon-btn'; nextBtn.textContent = 'Next';
                    const shuffleBtn = document.createElement('button'); shuffleBtn.className = 'icon-btn'; shuffleBtn.textContent = 'Shuffle';
                    const unshuffleBtn = document.createElement('button'); unshuffleBtn.className = 'icon-btn'; unshuffleBtn.textContent = 'Unshuffle';
                    topBar.append(prevBtn, nextBtn, shuffleBtn, unshuffleBtn);
                    function updateShuffleControls() {
                        unshuffleBtn.disabled = !(state.shuffledCache && state.shuffledCache.enabled);
                    }
                    const viewer = document.createElement('div'); viewer.className = 'card'; viewer.style.minHeight = '220px'; viewer.style.display = 'grid'; viewer.style.placeItems = 'center'; viewer.style.fontSize = '1.2rem'; viewer.style.whiteSpace = 'pre-wrap'; viewer.style.textAlign = 'center'; viewer.style.wordBreak = 'break-word';
                    function getOrder() {
                        const ids = state.cards.map(c => c.id);
                        if (state.shuffledCache?.enabled && Array.isArray(state.shuffledCache.order)) {
                            // filter to existing ids and append any new ones at end
                            const filtered = state.shuffledCache.order.filter(id => ids.includes(id));
                            const missing = ids.filter(id => !filtered.includes(id));
                            const order = filtered.concat(missing);
                            // ensure cache kept in sync
                            state.shuffledCache.order = order.slice();
                            return order;
                        }
                        return ids;
                    }
                    function getCardByIndex(i) { const order = getOrder(); const id = order[i]; return state.cards.find(c => c.id === id); }
                    function clampIdx(i) { const n = getOrder().length; return Math.max(0, Math.min(n - 1, i)); }
                    if (cardsPracticeCtx.idx >= getOrder().length) { cardsPracticeCtx.idx = 0; state.cardsPractice = state.cardsPractice || { idx: 0 }; state.cardsPractice.idx = 0; scheduleSave(); }
                    cardsPracticeCtx.front = true;
                    cardsPracticeCtx.update = function () { const c = getCardByIndex(cardsPracticeCtx.idx); viewer.textContent = cardsPracticeCtx.front ? (c?.front || '') : (c?.back || ''); const n = getOrder().length; gid('cards-progress').textContent = n ? `${cardsPracticeCtx.idx + 1}/${n}` : '0/0'; };
                    function shuffleArray(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / (2 ** 32) * (i + 1));[arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }
                    prevBtn.addEventListener('click', () => { cardsPracticeCtx.idx = clampIdx(cardsPracticeCtx.idx - 1); state.cardsPractice = state.cardsPractice || { idx: 0 }; state.cardsPractice.idx = cardsPracticeCtx.idx; scheduleSave(); cardsPracticeCtx.front = true; cardsPracticeCtx.update(); });
                    nextBtn.addEventListener('click', () => { cardsPracticeCtx.idx = clampIdx(cardsPracticeCtx.idx + 1); state.cardsPractice = state.cardsPractice || { idx: 0 }; state.cardsPractice.idx = cardsPracticeCtx.idx; scheduleSave(); cardsPracticeCtx.front = true; cardsPracticeCtx.update(); });
                    shuffleBtn.addEventListener('click', () => { const ids = state.cards.map(c => c.id); state.shuffledCache = { enabled: true, order: shuffleArray(ids.slice()) }; state.cardsPractice = state.cardsPractice || { idx: 0 }; state.cardsPractice.idx = 0; scheduleSave(); updateShuffleControls(); cardsPracticeCtx.idx = 0; cardsPracticeCtx.front = true; cardsPracticeCtx.update(); });
                    unshuffleBtn.addEventListener('click', () => { if (unshuffleBtn.disabled) return; state.shuffledCache = { enabled: false, order: [] }; state.cardsPractice = state.cardsPractice || { idx: 0 }; state.cardsPractice.idx = 0; scheduleSave(); updateShuffleControls(); cardsPracticeCtx.idx = 0; cardsPracticeCtx.front = true; cardsPracticeCtx.update(); });
                    viewer.addEventListener('click', () => { cardsPracticeCtx.front = !cardsPracticeCtx.front; cardsPracticeCtx.update(); });
                    updateShuffleControls();
                    ensureCardsKeyHandler(); cardsKeyHandlerActive = true; cardsPracticeCtx.update(); area.append(topBar, viewer);
                } else {
                    area.style.gridTemplateColumns = '1fr';
                    const list = document.createElement('ul'); list.className = 'list-reset'; list.setAttribute('role', 'listbox'); list.setAttribute('aria-label', 'Cards'); list.style.padding = '0'; list.style.margin = '0';
                    let cardEditorEl = null; let currentCardId = null; let draftCard = null;
                    function removeCardEditor() { if (cardEditorEl && cardEditorEl.parentNode) { cardEditorEl.parentNode.removeChild(cardEditorEl); } cardEditorEl = null; draftCard = null; }
                    function openCardEditor(afterRow, card) {
                        removeCardEditor(); currentCardId = card.id;
                        cardEditorEl = document.createElement('li'); cardEditorEl.className = 'card-editor-row'; cardEditorEl.setAttribute('role', 'region'); cardEditorEl.setAttribute('aria-label', 'Edit card');
                        const front = document.createElement('textarea'); front.className = 'textarea mb-8'; front.placeholder = 'Front'; front.value = card.front || '';
                        const back = document.createElement('textarea'); back.className = 'textarea'; back.placeholder = 'Back'; back.value = card.back || '';
                        const actions = document.createElement('div'); actions.className = 'row gap-8 row-end';
                        const save = document.createElement('button'); save.className = 'icon-btn'; save.textContent = 'Save';
                        const cancel = document.createElement('button'); cancel.className = 'icon-btn'; cancel.textContent = 'Cancel';
                        const del = document.createElement('button'); del.className = 'icon-btn'; del.textContent = 'Delete';
                        actions.append(save, cancel, del);
                        cardEditorEl.append(front, back, actions);
                        afterRow.insertAdjacentElement('afterend', cardEditorEl);
                        draftCard = { id: card.id, front: card.front, back: card.back };
                        front.addEventListener('input', () => { draftCard.front = front.value; });
                        back.addEventListener('input', () => { draftCard.back = back.value; });
                        cardEditorEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Escape') { e.preventDefault(); removeCardEditor(); }
                            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); save.click(); }
                        });
                        save.addEventListener('click', () => { const c = state.cards.find(x => x.id === card.id); if (c) { c.front = draftCard.front; c.back = draftCard.back; scheduleSave(); } removeCardEditor(); renderCards(); });
                        cancel.addEventListener('click', () => { removeCardEditor(); });
                        del.addEventListener('click', () => { const i = state.cards.findIndex(x => x.id === card.id); if (i >= 0) { state.cards.splice(i, 1); scheduleSave(); } removeCardEditor(); renderCards(); });
                        cardEditorEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        front.focus();
                    }
                    state.cards.forEach((c, idx) => {
                        const row = document.createElement('li'); row.style.display = 'grid'; row.style.gridTemplateColumns = 'auto 1fr auto'; row.style.gap = '6px'; row.style.alignItems = 'center'; row.style.padding = '6px 8px'; row.style.borderBottom = '1px solid var(--border)'; row.classList.add('list-row');
                        row.setAttribute('data-idx', String(idx)); row.setAttribute('role', 'option'); row.setAttribute('tabindex', '0');
                        const drag = document.createElement('span'); drag.className = 'drag-handle'; drag.textContent = '⋮⋮'; drag.title = 'Drag to reorder'; drag.setAttribute('aria-hidden', 'true');
                        const title = document.createElement('div'); title.textContent = c.front || '(blank)'; title.style.fontWeight = '600';
                        const up = document.createElement('button'); up.className = 'icon-btn'; up.textContent = '↑'; up.title = 'Move up';
                        up.addEventListener('click', (e) => { e.stopPropagation(); if (idx > 0) { [state.cards[idx - 1], state.cards[idx]] = [state.cards[idx], state.cards[idx - 1]]; scheduleSave(); renderCards(); } });
                        row.append(drag, title, up);
                        row.addEventListener('click', () => openCardEditor(row, c));
                        row.addEventListener('keydown', (e) => { if (e.key === 'Enter') { openCardEditor(row, c); } if (e.key === 'ArrowDown') { e.preventDefault(); const next = list.querySelector(`li[data-idx="${idx + 1}"]`); if (next) { next.focus(); selectRow(next); } } if (e.key === 'ArrowUp') { e.preventDefault(); const prev = list.querySelector(`li[data-idx="${idx - 1}"]`); if (prev) { prev.focus(); selectRow(prev); } } });
                        list.appendChild(row);
                    });
                    function clearSelection() { list.querySelectorAll('.selected').forEach(el => el.classList.remove('selected')); }
                    function selectRow(row) { clearSelection(); row.classList.add('selected'); }
                    list.addEventListener('focusin', (e) => { const li = e.target.closest('li[data-idx]'); if (li) selectRow(li); });
                    list.addEventListener('focusout', (e) => { if (!list.contains(e.relatedTarget)) { clearSelection(); } });
                    enableReorder(list, () => state.cards.slice(), (items) => { state.cards = items; scheduleSave(); renderCards(); });
                    const wrapper = document.createElement('div'); wrapper.className = 'card'; wrapper.appendChild(list);
                    const addBar = document.createElement('div'); addBar.className = 'row gap-8'; addBar.style.margin = '8px 0';
                    const addBtn = document.createElement('button'); addBtn.className = 'icon-btn primary'; addBtn.textContent = 'Add Card';
                    addBtn.addEventListener('click', () => {
                        const card = { id: Math.random().toString(36).slice(2, 10), front: '', back: '' }; state.cards.unshift(card); scheduleSave(); renderCards();
                        const firstRow = wrapper.querySelector('li[data-idx="0"]'); if (firstRow) { firstRow.click(); }
                    });
                    addBar.appendChild(addBtn);
                    area.append(addBar, wrapper); cardsKeyHandlerActive = false;
                }
            }

            // CALC
            const calcKeys = ['7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', '.', '=', '+', 'C', '⌫'];
            function layoutCalc() {
                const wrap = gid('calc'); if (!wrap) return;
                const r = wrap.getBoundingClientRect();
                const gap = Math.max(6, Math.min(14, Math.floor(Math.min(r.width, r.height) * 0.012)));
                const cols = 4;
                const rowsKeys = Math.ceil(calcKeys.length / cols);
                // Display height target ~22% but stay within bounds
                const minDisplayH = 48;
                const maxDisplayH = Math.max(minDisplayH, Math.floor(r.height * 0.32));
                const displayH = Math.max(minDisplayH, Math.min(maxDisplayH, Math.floor(r.height * 0.22)));
                // Compute a rough per-cell height to size fonts: remaining height / rows
                const keysAreaH = Math.max(60, r.height - displayH - gap);
                const cellH = Math.max(32, Math.floor((keysAreaH - gap * (rowsKeys - 1)) / rowsKeys));
                // Font sizes
                const btnFont = Math.max(14, Math.min(36, Math.floor(cellH * 0.45)));
                const displayFont = Math.max(18, Math.min(48, Math.floor(displayH * 0.5)));
                // Apply CSS variables
                document.documentElement.style.setProperty('--calcGap', gap + 'px');
                document.documentElement.style.setProperty('--calcDisplayH', displayH + 'px');
                document.documentElement.style.setProperty('--calcBtnFont', btnFont + 'px');
                // Apply display font directly
                const display = gid('calc-display');
                display.style.fontSize = displayFont + 'px';
            }
            function renderCalc() {
                gid('calc-display').textContent = '0';
                const grid = gid('calc-keys'); grid.innerHTML = '';
                calcKeys.forEach(k => {
                    const btn = document.createElement('button');
                    const isNum = /[0-9.]/.test(k);
                    const isOp = (k === '+' || k === '-' || k === '*' || k === '/');
                    const isEq = k === '=';
                    const isClr = k === 'C';
                    const isBk = k === '⌫';
                    btn.className = 'calc-btn ' + (isEq ? 'eq' : isClr ? 'clear' : isBk ? 'back' : isOp ? 'op' : 'num');
                    btn.textContent = k;
                    btn.addEventListener('click', () => press(k));
                    grid.appendChild(btn);
                });
                layoutCalc();
            }
            let expr = '';
            function press(k) {
                if (k === 'C') { expr = ''; gid('calc-display').textContent = '0'; return; }
                if (k === '⌫') { expr = expr.slice(0, -1); gid('calc-display').textContent = expr || '0'; return; }
                if (k === '=') {
                    const safe = expr.replace(/[^0-9+\-*/().]/g, '');
                    const val = Function('return (' + safe + ')')();
                    gid('calc-display').textContent = String(val);
                    expr = String(val);
                    return;
                }
                expr += k; gid('calc-display').textContent = expr;
            }
            // Recompute layout on resize and when calc tab is shown
            window.addEventListener('resize', () => { if (state.ui.tab === 'calc') layoutCalc(); });
            // Keyboard support for calculator when active
            document.addEventListener('keydown', (e) => {
                if (state.ui.tab !== 'calc') return;
                if (e.altKey || e.ctrlKey || e.metaKey) return;
                const k = e.key;
                if (/^[0-9]$/.test(k)) { e.preventDefault(); press(k); return; }
                if (k === '.') { e.preventDefault(); press('.'); return; }
                if (k === '+' || k === '-' || k === '*' || k === '/') { e.preventDefault(); press(k); return; }
                if (k === 'Enter' || k === '=') { e.preventDefault(); press('='); return; }
                if (k === 'Backspace') { e.preventDefault(); press('⌫'); return; }
                if (k === 'Escape' || k === 'Delete') { e.preventDefault(); press('C'); return; }
            });
            // Observe calc container for size changes (e.g., when tab is revealed)
            window.addEventListener('DOMContentLoaded', () => {
                const wrap = gid('calc');
                if (wrap && 'ResizeObserver' in window) {
                    const ro = new ResizeObserver(() => { if (state.ui.tab === 'calc') layoutCalc(); });
                    ro.observe(wrap);
                }
            });

            // WHEEL
            const wheelCanvas = gid('wheel-canvas');
            function getWheelItems() { return (state.wheel.itemsText || '').split(/\r?\n/).map(s => s.trim()).filter(Boolean); }
            // Color helpers for theme-aware wheel rendering
            function hexToRgb(hex) {
                if (!hex) return null; const s = hex.trim(); const m = s.match(/^#([\da-f]{3}|[\da-f]{6})$/i); if (!m) return null; let h = m[1]; if (h.length === 3) h = h.split('').map(ch => ch + ch).join(''); const n = parseInt(h, 16); return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
            }
            function rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255; const max = Math.max(r, g, b), min = Math.min(r, g, b); let h = 0, s = 0, l = (max + min) / 2; if (max !== min) { const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return { h: h * 360, s: s * 100, l: l * 100 };
            }
            function hslToRgb(h, s, l) {
                h = ((h % 360) + 360) % 360; s /= 100; l /= 100; const c = (1 - Math.abs(2 * l - 1)) * s; const x = c * (1 - Math.abs((h / 60) % 2 - 1)); const m = l - c / 2; let r1 = 0, g1 = 0, b1 = 0; if (h < 60) { r1 = c; g1 = x; } else if (h < 120) { r1 = x; g1 = c; } else if (h < 180) { g1 = c; b1 = x; } else if (h < 240) { g1 = x; b1 = c; } else if (h < 300) { r1 = x; b1 = c; } else { r1 = c; b1 = x; } return { r: Math.round((r1 + m) * 255), g: Math.round((g1 + m) * 255), b: Math.round((b1 + m) * 255) };
            }
            function relLum(r, g, b) { const sr = [r, g, b].map(v => { v /= 255; return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4); }); return 0.2126 * sr[0] + 0.7152 * sr[1] + 0.0722 * sr[2]; }
            function contrastRatio(l1, l2) { const [L1, L2] = l1 > l2 ? [l1, l2] : [l2, l1]; return (L1 + 0.05) / (L2 + 0.05); }
            function pickTextColorForBg(r, g, b) { const lum = relLum(r, g, b); const black = contrastRatio(lum, relLum(0, 0, 0)); const white = contrastRatio(lum, relLum(255, 255, 255)); return white > black ? '#ffffff' : '#000000'; }
            function clamp01(x) { return Math.max(0, Math.min(1, x)); }
            function rgbaBlendOver(bg, fg) { // bg:{r,g,b}, fg:{r,g,b,a}
                const a = clamp01(fg.a == null ? 1 : fg.a); const inv = 1 - a;
                return { r: Math.round(fg.r * a + bg.r * inv), g: Math.round(fg.g * a + bg.g * inv), b: Math.round(fg.b * a + bg.b * inv) };
            }
            function resizeWheelCanvas() {
                // Compute available square size from panel-body height and wrapper width; subtract wrapper paddings
                const dpr = window.devicePixelRatio || 1;
                const panel = document.getElementById('p-wheel');
                const body = panel?.querySelector('.panel-body');
                const useView = panel?.querySelector('#wheel-use-view');
                const toolbar = panel?.querySelector('.wheel-toolbar');
                const resultEl = panel?.querySelector('#wheel-result');
                const wrap = wheelCanvas.parentElement; // .wheel-canvas-wrap
                if (!panel || !body || !wrap || (useView && useView.classList.contains('hidden'))) return;

                // Available height is derived from the useView content box
                const uvCH = (useView?.clientHeight) || 0; // content box height of the grid container
                // gaps between toolbar|canvas and canvas|result (two gaps in a 3-row grid)
                const uvStyle = getComputedStyle(useView || body);
                const rowGap = parseFloat(uvStyle.rowGap || uvStyle.gap) || 8;
                const gaps = rowGap * 2;
                const toolbarH = toolbar?.offsetHeight || 0;
                const resultH = resultEl?.offsetHeight || 0;
                const availHForWrap = Math.max(0, uvCH - toolbarH - resultH - gaps);

                // wrapper content width/height
                const wrapCW = wrap.clientWidth; // includes padding
                const ws = getComputedStyle(wrap);
                const pl = parseFloat(ws.paddingLeft) || 0, pr = parseFloat(ws.paddingRight) || 0;
                const pt = parseFloat(ws.paddingTop) || 0, pb = parseFloat(ws.paddingBottom) || 0;
                const wrapCH = wrap.clientHeight;
                const contentW = Math.max(0, wrapCW - pl - pr);
                const contentH = Math.max(0, Math.min(availHForWrap, wrapCH) - pt - pb);
                const sideCss = Math.floor(Math.max(1, Math.min(contentW, contentH)));
                const side = Math.max(1, Math.floor(sideCss * dpr));
                // Set device pixel size for crisp rendering
                if (wheelCanvas.width !== side || wheelCanvas.height !== side) {
                    wheelCanvas.width = side;
                    wheelCanvas.height = side;
                }
                // Set CSS size to the computed min dimension to avoid content-driven growth toward width
                wheelCanvas.style.width = sideCss + 'px';
                wheelCanvas.style.height = sideCss + 'px';
                if (wheelCanvas.width > 1 && wheelCanvas.height > 1) drawWheel();
            }
            function updateRemoveSpinEnabled() { const btn = gid('wheel-remove'); if (btn) btn.disabled = !state.wheel.lastHit; }
            let wheelAngle = 0, wheelSpinning = false, spinStart = 0, spinDuration = 0, startAngle = 0, targetAngle = 0;
            function drawWheel() {
                const items = getWheelItems(); const ctx = wheelCanvas.getContext('2d'); const W = wheelCanvas.width, H = wheelCanvas.height; ctx.clearRect(0, 0, W, H);
                const cx = W / 2, cy = H / 2;
                const cs = getComputedStyle(gid('app'));
                const borderCol = cs.getPropertyValue('--border').trim() || '#e5e7eb';
                const primaryCol = cs.getPropertyValue('--primary').trim() || '#8b5cf6';
                const primaryContrastCol = cs.getPropertyValue('--primary-contrast').trim() || '';
                const cardCol = cs.getPropertyValue('--card').trim() || '#ffffff';
                const textCol = cs.getPropertyValue('--text').trim() || '#111827';
                const baseRgb = hexToRgb(primaryCol) || { r: 139, g: 92, b: 246 };
                const baseHsl = rgbToHsl(baseRgb.r, baseRgb.g, baseRgb.b);
                const u = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--u')) || 8;
                const margin = Math.max(10, u * 1.2);
                const r = Math.max(1, Math.min(cx, cy) - margin);

                // Placeholder state: no items -> draw neutral ring and hint text, no colored arc
                if (items.length === 0) {
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.strokeStyle = borderCol; ctx.lineWidth = u * 0.6; ctx.stroke();
                    ctx.fillStyle = textCol; ctx.font = `${Math.max(12, r * 0.12)}px Inter`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('Add items to spin', 0, 0);
                    ctx.restore();
                    // pointer
                    ctx.save(); ctx.fillStyle = primaryCol; ctx.strokeStyle = borderCol; ctx.lineWidth = u * 0.45; ctx.beginPath(); const px0 = Math.min(W - 5, cx + r + u * 1.2); ctx.moveTo(px0 - 15, H / 2); ctx.lineTo(px0, H / 2 - 12); ctx.lineTo(px0, H / 2 + 12); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
                    return;
                }

                // Determine which slice should be highlighted (landed result) when idle
                let highlightIdx = -1; if (!wheelSpinning && state.wheel.lastHit) { const idx = items.indexOf(state.wheel.lastHit); if (idx >= 0) highlightIdx = idx; }

                ctx.save(); ctx.translate(cx, cy); ctx.rotate(wheelAngle);
                const n = items.length;
                for (let i = 0; i < n; i++) {
                    const a0 = (i / n) * Math.PI * 2; const a1 = ((i + 1) / n) * Math.PI * 2;
                    const hue = baseHsl.h;
                    const sat = Math.max(30, baseHsl.s * 0.6);
                    const light = Math.max(40, Math.min(65, baseHsl.l));
                    const rgb = hslToRgb(hue, sat, light);
                    const defaultFillSolid = `hsl(${hue} ${sat}% ${light}%)`;
                    const isSelected = (i === highlightIdx);
                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, r, a0, a1); ctx.closePath();
                    ctx.fillStyle = isSelected ? primaryCol : defaultFillSolid; ctx.fill();
                    // Border ring for separation (selected could be thicker if desired)
                    ctx.lineWidth = u * 0.45; ctx.strokeStyle = borderCol; ctx.stroke();
                    // Label: flat text color based on theme text (selected uses primary-contrast if available)
                    const mid = (a0 + a1) / 2; ctx.save(); ctx.rotate(mid); ctx.translate(r * 0.5, 0);
                    const txt = items[i] || '';
                    const txtCol = isSelected && primaryContrastCol ? primaryContrastCol : textCol;
                    ctx.fillStyle = txtCol; ctx.font = `${Math.max(12, r * 0.12)}px Inter`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(txt, 0, 0);
                    ctx.restore();
                }
                ctx.restore();
                // pointer
                ctx.save(); ctx.fillStyle = primaryCol; ctx.strokeStyle = borderCol; ctx.lineWidth = u * 0.45; ctx.beginPath(); const px = Math.min(W - 5, cx + r + u * 1.2); ctx.moveTo(px - 15, H / 2); ctx.lineTo(px, H / 2 - 12); ctx.lineTo(px, H / 2 + 12); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
            }
            function alignWheelToLastHit() {
                if (wheelSpinning) return;
                const items = getWheelItems();
                const n = items.length; if (!n) return;
                const hit = state.wheel.lastHit; if (!hit) return;
                const idx = items.indexOf(hit); if (idx < 0) return;
                // Align so the center of the slice is under the pointer at angle 0
                const mid = (idx + 0.5) / n * Math.PI * 2;
                const desiredMod = (Math.PI * 2 - mid) % (Math.PI * 2);
                wheelAngle = desiredMod;
                drawWheel();
            }
            function spinWheel(onDone) {
                if (wheelSpinning) return; const items = getWheelItems(); const n = items.length; if (!n) return;
                // Choose a segment uniformly at random
                const hitIdx = randInt(n);
                // Target the center of that segment under the pointer (pointer at angle 0)
                const mid = (hitIdx + 0.5) / n * Math.PI * 2;
                const desiredMod = (Math.PI * 2 - mid) % (Math.PI * 2);
                const currentMod = ((wheelAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                const deltaMod = (desiredMod - currentMod + Math.PI * 2) % (Math.PI * 2);
                const turns = 3 + Math.floor(randFloat() * 3); // 3,4,5 full turns
                if (!Number.isFinite(spinDuration)) spinDuration = 0;
                wheelSpinning = true; spinStart = performance.now(); spinDuration = 2000 + randFloat() * 1500; startAngle = wheelAngle; targetAngle = wheelAngle + deltaMod + turns * Math.PI * 2; requestAnimationFrame(step);
                function step(t) { const p = Math.min(1, (t - spinStart) / spinDuration); const ease = 1 - Math.pow(1 - p, 3); wheelAngle = startAngle + (targetAngle - startAngle) * ease; drawWheel(); if (p < 1) requestAnimationFrame(step); else { wheelSpinning = false; const val = items[hitIdx]; gid('wheel-result').textContent = `Result: ${val}`; state.wheel.lastHit = val; updateRemoveSpinEnabled(); scheduleSave(); requestAnimationFrame(() => requestAnimationFrame(resizeWheelCanvas)); drawWheel(); if (onDone) onDone(hitIdx); } }
            }
            gid('wheel-input').addEventListener('input', () => { state.wheel.itemsText = gid('wheel-input').value; state.wheel.lastHit = null; updateRemoveSpinEnabled(); scheduleSave(); drawWheel(); });
            gid('wheel-mode-use').addEventListener('click', () => { state.ui.wheelMode = 'use'; gid('wheel-mode-use').setAttribute('aria-pressed', 'true'); gid('wheel-mode-manage').setAttribute('aria-pressed', 'false'); gid('wheel-use-view').classList.remove('hidden'); gid('wheel-manage-view').classList.add('hidden'); scheduleSave(); requestAnimationFrame(() => requestAnimationFrame(() => { resizeWheelCanvas(); alignWheelToLastHit(); })); });
            gid('wheel-mode-manage').addEventListener('click', () => { state.ui.wheelMode = 'manage'; gid('wheel-mode-use').setAttribute('aria-pressed', 'false'); gid('wheel-mode-manage').setAttribute('aria-pressed', 'true'); gid('wheel-use-view').classList.add('hidden'); gid('wheel-manage-view').classList.remove('hidden'); scheduleSave(); });
            gid('wheel-spin').addEventListener('click', () => spinWheel());
            gid('wheel-remove').addEventListener('click', () => {
                const items = getWheelItems();
                if (state.wheel.lastHit) {
                    const idx = items.indexOf(state.wheel.lastHit);
                    if (idx >= 0) {
                        items.splice(idx, 1);
                        state.wheel.itemsText = items.join('\n');
                        gid('wheel-input').value = state.wheel.itemsText;
                        gid('wheel-result').textContent = '';
                        state.wheel.lastHit = null; updateRemoveSpinEnabled();
                        scheduleSave();
                        drawWheel();
                    }
                }
                if (getWheelItems().length) spinWheel();
            });
            gid('wheel-clear').addEventListener('click', () => { gid('wheel-input').value = ''; state.wheel.itemsText = ''; state.wheel.lastHit = null; updateRemoveSpinEnabled(); scheduleSave(); drawWheel(); gid('wheel-result').textContent = ''; });
            gid('wheel-sample').addEventListener('click', () => {
                const meals = [
                    'Pizza', 'Curry', 'Pasta', 'Salad', 'Stir-fry', 'Tacos', 'Burgers', 'Sushi',
                    'Soup', 'Sandwich', 'BBQ', 'Roast', 'Noodles', 'Rice Bowl', 'Wraps', 'Dumplings',
                    'Ramen', 'Kebab', 'Fish & Chips', 'Burrito'
                ];
                gid('wheel-input').value = meals.join('\n');
                state.wheel.itemsText = gid('wheel-input').value;
                state.wheel.lastHit = null;
                updateRemoveSpinEnabled();
                scheduleSave();
                drawWheel();
            });
            // Removed ResizeObserver on wheel container to avoid feedback loops; window/tab events handle sizing

            // TRACKER
            function renderTracker() {
                const dataView = gid('tracker-data-view'); const chartView = gid('tracker-chart-view'); dataView.innerHTML = '';
                // table
                const table = document.createElement('table'); table.style.borderCollapse = 'separate';
                // Allow the sheet to grow horizontally and scroll; still fill container if narrow
                table.style.width = 'max-content'; table.style.minWidth = '100%';
                const thead = document.createElement('thead'); thead.style.position = 'sticky'; thead.style.top = '0'; thead.style.zIndex = '4'; const thr = document.createElement('tr');
                const thDate = document.createElement('th'); thDate.textContent = 'Date'; thDate.style.position = 'sticky'; thDate.style.top = '0'; thDate.style.left = '0'; thDate.style.background = 'var(--card)'; thDate.style.zIndex = '5'; thDate.style.borderBottom = '1px solid var(--border)'; thDate.style.padding = '6px'; thDate.style.whiteSpace = 'nowrap'; thDate.style.minWidth = '120px'; thr.appendChild(thDate);
                state.tracker.metrics.forEach(m => {
                    const th = document.createElement('th'); th.style.position = 'sticky'; th.style.top = '0'; th.style.background = 'var(--surface)'; th.style.zIndex = '2'; th.style.borderBottom = '1px solid var(--border)'; th.style.padding = '6px'; th.style.whiteSpace = 'nowrap'; th.style.minWidth = '120px';
                    const wrap = document.createElement('div'); wrap.style.display = 'flex'; wrap.style.alignItems = 'center'; wrap.style.gap = '6px'; wrap.style.justifyContent = 'center';
                    const nameBtn = document.createElement('button'); nameBtn.className = 'icon-btn'; nameBtn.textContent = m.name; nameBtn.title = 'Rename metric'; nameBtn.addEventListener('click', () => { const nv = prompt('Rename metric', m.name); if (nv && nv.trim()) { m.name = nv.trim(); scheduleSave(); renderTracker(); updateChartControls(); } });
                    const delBtn = document.createElement('button'); delBtn.className = 'icon-btn'; delBtn.textContent = '✕'; delBtn.title = 'Delete metric'; delBtn.addEventListener('click', () => {
                        if (!confirm(`Delete metric "${m.name}" and its data?`)) return;
                        const id = m.id; const i = state.tracker.metrics.findIndex(x => x.id === id); if (i >= 0) state.tracker.metrics.splice(i, 1);
                        Object.keys(state.tracker.data).forEach(ds => { if (state.tracker.data[ds]) { delete state.tracker.data[ds][id]; if (Object.keys(state.tracker.data[ds]).length === 0) delete state.tracker.data[ds]; } });
                        scheduleSave(); renderTracker(); updateChartControls(); drawChart();
                    });
                    wrap.append(nameBtn, delBtn); th.appendChild(wrap); thr.appendChild(th);
                });
                thead.appendChild(thr); table.appendChild(thead);
                const tbody = document.createElement('tbody');
                const today = new Date(); const start = new Date(today.getFullYear(), today.getMonth(), 1); const end = new Date(today.getFullYear(), today.getMonth() + 1, 0);
                for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                    const ds = d.toISOString().slice(0, 10);
                    const tr = document.createElement('tr'); const tdDate = document.createElement('td'); tdDate.textContent = ds; tdDate.style.position = 'sticky'; tdDate.style.left = '0'; tdDate.style.whiteSpace = 'nowrap'; tdDate.style.background = 'var(--card)'; tdDate.style.padding = '6px'; tdDate.style.borderRight = '1px solid var(--border)'; tdDate.style.zIndex = '2'; tdDate.style.minWidth = '120px'; tr.appendChild(tdDate);
                    state.tracker.metrics.forEach(m => {
                        const td = document.createElement('td'); td.style.padding = '0'; td.style.borderLeft = '1px solid var(--border)'; td.style.minWidth = '120px';
                        const input = document.createElement('input'); input.type = 'number'; input.step = 'any'; input.className = 'input input-bare'; input.style.width = '100%'; input.value = state.tracker.data[ds]?.[m.id] ?? '';
                        const applyCellValue = () => {
                            const raw = input.value;
                            // Ensure date bucket exists when needed
                            if (raw === '') {
                                if (!state.tracker.data[ds]) return; // nothing to delete
                                delete state.tracker.data[ds][m.id];
                                // prune empty date objects to keep data tidy
                                if (Object.keys(state.tracker.data[ds]).length === 0) delete state.tracker.data[ds];
                                scheduleSave();
                            } else {
                                const v = Number(raw);
                                if (Number.isFinite(v)) {
                                    state.tracker.data[ds] = state.tracker.data[ds] || {};
                                    state.tracker.data[ds][m.id] = v;
                                    scheduleSave();
                                } // ignore transient non-numeric input (e.g., '-') until valid
                            }
                            // Debounced chart redraw so edits reflect immediately
                            clearTimeout(trackerInputRedrawTimer);
                            trackerInputRedrawTimer = setTimeout(() => { requestAnimationFrame(() => drawChart()); }, 100);
                        };
                        input.addEventListener('input', applyCellValue);
                        input.addEventListener('change', applyCellValue);
                        td.appendChild(input); tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                }
                table.appendChild(tbody); dataView.appendChild(table);
                // chart init (defer to next frame for stable sizes)
                requestAnimationFrame(() => { resizeTrackerChart(); drawChart(); });
            }
            function addMetric() { const name = gid('new-metric-name').value.trim(); if (!name) return; const id = Math.random().toString(36).slice(2, 10); state.tracker.metrics.push({ id, name }); gid('new-metric-name').value = ''; scheduleSave(); renderTracker(); updateChartControls(); }
            gid('add-metric').addEventListener('click', addMetric);

            // Chart controls and drawing
            function getChartColors() { return ['#ff6fa7', '#64b5f6', '#a78bfa', '#4ade80', '#fbc02d', '#26c6da', '#ef5350', '#8d6e63']; }
            function getMetricIndexById(id) { return (state.tracker.metrics || []).findIndex(m => m.id === id); }
            function getMetricColorById(id) { const idx = getMetricIndexById(id); const cols = getChartColors(); return cols[((idx >= 0) ? idx : 0) % cols.length]; }
            function readableTextOn(hex) {
                // hex like #rrggbb
                const m = /^#?([0-9a-fA-F]{6})$/.exec(hex.trim()); if (!m) return '#111827';
                const n = parseInt(m[1], 16); const r = (n >> 16) & 255, g = (n >> 8) & 255, b = n & 255;
                const L = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255; return L > 0.55 ? '#111827' : '#ffffff';
            }
            function updateChartControls() {
                const wrap = gid('chart-controls');
                if (state.ui.trackerMode === 'chart') wrap.classList.remove('hidden'); else wrap.classList.add('hidden');
                // Chart type selector
                const typesWrap = gid('chart-types'); typesWrap.innerHTML = '';
                const types = [
                    { id: 'stacked', label: 'Stacked' },
                    { id: 'normalized', label: 'Stacked 0–1' },
                    { id: 'line', label: 'Line' },
                ];
                function updateTypeSelection() {
                    const current = state.tracker.chartType;
                    typesWrap.querySelectorAll('button').forEach(b => {
                        const active = b.dataset.type === current;
                        b.classList.toggle('primary', active);
                        b.setAttribute('aria-pressed', active ? 'true' : 'false');
                    });
                }
                types.forEach(t => {
                    const btn = document.createElement('button'); btn.className = 'icon-btn'; btn.textContent = t.label; btn.dataset.type = t.id;
                    // initial state will be set after all buttons are appended
                    btn.addEventListener('click', () => {
                        state.tracker.chartType = t.id; scheduleSave();
                        updateTypeSelection();
                        drawChart();
                    });
                    typesWrap.appendChild(btn);
                });
                updateTypeSelection();
                const metrics = gid('chart-metrics'); metrics.innerHTML = '';
                // Persisted selection: if defined, even empty, respect it; otherwise default to all
                const selectedSet = new Set(Array.isArray(state.tracker.selectedMetrics) ? state.tracker.selectedMetrics : state.tracker.metrics.map(x => x.id));
                // If selection wasn't persisted, default to all and persist once
                if (!Array.isArray(state.tracker.selectedMetrics)) {
                    state.tracker.selectedMetrics = state.tracker.metrics.map(x => x.id);
                    scheduleSave();
                }
                state.tracker.metrics.forEach((m, i) => {
                    const btn = document.createElement('button'); btn.className = 'icon-btn'; btn.textContent = m.name; btn.dataset.id = m.id;
                    const col = getMetricColorById(m.id);
                    // Default (inactive): plain theme styling; Active: metric color
                    function applyBtnStyle(active) {
                        if (active) {
                            btn.style.background = col;
                            btn.style.color = readableTextOn(col);
                            btn.classList.add('active');
                        } else {
                            btn.style.background = '';
                            btn.style.color = '';
                            btn.classList.remove('active');
                        }
                    }
                    // Start from persisted selection (can be empty)
                    applyBtnStyle(selectedSet.has(m.id));
                    btn.addEventListener('click', () => {
                        const willBeActive = !btn.classList.contains('active');
                        applyBtnStyle(willBeActive);
                        // persist selected metrics
                        const now = new Set(getSelectedMetrics());
                        state.tracker.selectedMetrics = Array.from(now);
                        scheduleSave();
                        drawChart();
                    });
                    metrics.appendChild(btn);
                });
                // hydrate date range inputs from persisted state if present
                if (state.tracker.chartRange?.start) gid('chart-start').value = state.tracker.chartRange.start;
                if (state.tracker.chartRange?.end) gid('chart-end').value = state.tracker.chartRange.end;
            }
            function getSelectedMetrics() {
                const btns = Array.from(gid('chart-metrics').querySelectorAll('.active'));
                return btns.map(b => b.dataset.id);
            }
            function getChartDateRange() { const s = gid('chart-start').value; const e = gid('chart-end').value; return { start: s || null, end: e || null }; }
            function resizeTrackerChart() {
                const dpr = window.devicePixelRatio || 1;
                const c = gid('tracker-chart-canvas');
                const parent = c.parentElement;
                // If hidden, temporarily measure parent by forcing a measurement path after next frame
                const r = parent.getBoundingClientRect();
                const w = Math.max(1, Math.floor(r.width * dpr));
                const h = Math.max(1, Math.floor(r.height * dpr));
                if (c.width !== w) c.width = w;
                if (c.height !== h) c.height = h;
            }
            let trackerResizeTimer = null;
            let trackerInputRedrawTimer = null;
            window.addEventListener('resize', () => {
                if (state.ui.tab !== 'tracker') return;
                requestAnimationFrame(() => { resizeTrackerChart(); drawChart(); });
                clearTimeout(trackerResizeTimer);
                trackerResizeTimer = setTimeout(() => { requestAnimationFrame(() => { resizeTrackerChart(); drawChart(); }); }, 120);
            });
            function drawChart() {
                const c = gid('tracker-chart-canvas'); const ctx = c.getContext('2d'); const W = c.width, H = c.height; ctx.clearRect(0, 0, W, H);
                // Stable ordered ids by metrics list to keep colors/series aligned
                const sel = new Set(getSelectedMetrics());
                const ids = (state.tracker.metrics || []).map(m => m.id).filter(id => sel.has(id));
                let dates = Object.keys(state.tracker.data).sort();
                // Date range filter
                const { start, end } = getChartDateRange();
                if (start) dates = dates.filter(d => d >= start);
                if (end) dates = dates.filter(d => d <= end);
                const cs = getComputedStyle(gid('app'));
                const textCol = cs.getPropertyValue('--text').trim() || '#111827';
                const borderCol = cs.getPropertyValue('--border').trim() || '#e5e7eb';
                if (!dates.length || !ids.length) {
                    ctx.fillStyle = textCol; ctx.globalAlpha = 0.65; ctx.font = '14px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    const msg = !ids.length ? 'Select metrics to see the chart' : 'Add metrics and data to see the chart';
                    ctx.fillText(msg, W / 2, H / 2);
                    ctx.globalAlpha = 1; return;
                }
                const colors = getChartColors();
                const xMargin = 48, yMargin = 24; const bottomMargin = 36; // extra space for x labels, tighten margins
                const chartW = W - xMargin - 10, chartH = H - yMargin - bottomMargin;
                const xVals = dates.length === 1 ? [0] : dates.map((d, i) => i / (dates.length - 1));
                // Determine y scaling based on chart type
                let max = 1; const chartType = state.tracker.chartType || 'stacked';
                if (chartType === 'line') {
                    // max among all selected series individually
                    ids.forEach(id => { dates.forEach(ds => { const v = (state.tracker.data[ds]?.[id] || 0); max = Math.max(max, v); }); });
                } else {
                    // stacked: max of daily sums
                    dates.forEach((ds) => { let sum = 0; ids.forEach(id => { sum += (state.tracker.data[ds]?.[id] || 0); }); max = Math.max(max, sum); });
                }
                // axes
                ctx.strokeStyle = textCol; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(xMargin, yMargin); ctx.lineTo(xMargin, yMargin + chartH); ctx.lineTo(xMargin + chartW, yMargin + chartH); ctx.stroke();
                // grid + labels
                ctx.fillStyle = textCol; ctx.font = '12px Inter'; ctx.textAlign = 'right';
                for (let i = 0; i <= 5; i++) {
                    const y = yMargin + chartH - i / 5 * chartH; const v = (max * i / 5).toFixed(1);
                    ctx.fillText(v, xMargin - 6, y);
                    ctx.strokeStyle = borderCol; ctx.lineWidth = 1; ctx.globalAlpha = 0.6;
                    ctx.beginPath(); ctx.moveTo(xMargin, y); ctx.lineTo(xMargin + chartW, y); ctx.stroke(); ctx.globalAlpha = 1;
                }
                // X-axis date labels with stride to avoid overlap
                ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                const maxLabels = Math.max(2, Math.floor(chartW / 70));
                const stride = Math.max(1, Math.ceil(dates.length / maxLabels));
                for (let i = 0; i < dates.length; i += stride) {
                    const x = xMargin + xVals[i] * chartW;
                    const ds = dates[i];
                    // show as M/D or D Mon depending on locale
                    const lbl = new Date(ds).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                    ctx.fillText(lbl, x, yMargin + chartH + 6);
                    // optional vertical tick
                    ctx.strokeStyle = borderCol; ctx.lineWidth = 1; ctx.globalAlpha = 0.4;
                    ctx.beginPath(); ctx.moveTo(x, yMargin + chartH); ctx.lineTo(x, yMargin + chartH + 4); ctx.stroke(); ctx.globalAlpha = 1;
                }
                if (chartType === 'line') {
                    // draw independent lines (no stacking)
                    ids.forEach((id) => {
                        ctx.beginPath(); const col = getMetricColorById(id); ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.fillStyle = col;
                        for (let i = 0; i < dates.length; i++) {
                            const x = xMargin + xVals[i] * chartW;
                            const v = (state.tracker.data[dates[i]]?.[id] || 0);
                            const y = yMargin + chartH - (v / max) * chartH;
                            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        // optional small points
                        for (let i = 0; i < dates.length; i++) {
                            const x = xMargin + xVals[i] * chartW; const v = (state.tracker.data[dates[i]]?.[id] || 0);
                            const y = yMargin + chartH - (v / max) * chartH; ctx.beginPath(); ctx.arc(x, y, 2.5, 0, Math.PI * 2); ctx.fill();
                        }
                    });
                } else {
                    // stacked (absolute or normalized)
                    const stack = dates.map(() => 0);
                    ids.forEach((id) => {
                        ctx.beginPath(); const col = getMetricColorById(id); ctx.fillStyle = col + '55'; ctx.strokeStyle = col; ctx.lineWidth = 2;
                        for (let i = 0; i < dates.length; i++) {
                            const x = xMargin + xVals[i] * chartW;
                            const dayTotal = ids.reduce((s, j) => s + (state.tracker.data[dates[i]]?.[j] || 0), 0);
                            const val = (state.tracker.data[dates[i]]?.[id] || 0);
                            const base = (state.tracker.chartType === 'normalized' ? (stack[i] / Math.max(1e-9, dayTotal)) : stack[i] / max);
                            const top = (state.tracker.chartType === 'normalized' ? ((stack[i] + val) / Math.max(1e-9, dayTotal)) : ((stack[i] + val) / max));
                            const y0 = yMargin + chartH - base * chartH;
                            const y1 = yMargin + chartH - top * chartH;
                            if (i === 0) { ctx.moveTo(x, y0); } else { ctx.lineTo(x, y0); }
                        }
                        for (let i = dates.length - 1; i >= 0; i--) {
                            const x = xMargin + xVals[i] * chartW;
                            const dayTotal = ids.reduce((s, j) => s + (state.tracker.data[dates[i]]?.[j] || 0), 0);
                            const val = (state.tracker.data[dates[i]]?.[id] || 0);
                            const top = (state.tracker.chartType === 'normalized' ? ((stack[i] + val) / Math.max(1e-9, dayTotal)) : ((stack[i] + val) / max));
                            const y1 = yMargin + chartH - top * chartH;
                            ctx.lineTo(x, y1);
                        }
                        ctx.closePath(); ctx.fill(); ctx.stroke();
                        for (let i = 0; i < dates.length; i++) { stack[i] += (state.tracker.data[dates[i]]?.[id] || 0); }
                    });
                }
            }

            // Modes switch for tracker
            function setTrackerMode(mode) {
                state.ui.trackerMode = (mode === 'chart') ? 'chart' : 'data';
                scheduleSave();
                const dataView = gid('tracker-data-view');
                const chartView = gid('tracker-chart-view');
                const addMetric = gid('tracker-add-metric');
                const controls = gid('chart-controls');
                if (state.ui.trackerMode === 'chart') {
                    dataView.classList.add('hidden');
                    chartView.classList.remove('hidden');
                    controls.classList.remove('hidden');
                    if (addMetric) addMetric.classList.add('hidden');
                    gid('tracker-mode-data').setAttribute('aria-pressed', 'false');
                    gid('tracker-mode-chart').setAttribute('aria-pressed', 'true');
                    requestAnimationFrame(() => { applyDefaultChartRange(); updateChartControls(); resizeTrackerChart(); drawChart(); });
                } else {
                    dataView.classList.remove('hidden');
                    chartView.classList.add('hidden');
                    controls.classList.add('hidden');
                    if (addMetric) addMetric.classList.remove('hidden');
                    gid('tracker-mode-data').setAttribute('aria-pressed', 'true');
                    gid('tracker-mode-chart').setAttribute('aria-pressed', 'false');
                    updateChartControls();
                }
            }
            gid('tracker-mode-data').addEventListener('click', () => setTrackerMode('data'));
            gid('tracker-mode-chart').addEventListener('click', () => setTrackerMode('chart'));
            gid('chart-start').addEventListener('change', () => { state.tracker.chartRange = state.tracker.chartRange || {}; state.tracker.chartRange.start = gid('chart-start').value || null; scheduleSave(); drawChart(); });
            gid('chart-end').addEventListener('change', () => { state.tracker.chartRange = state.tracker.chartRange || {}; state.tracker.chartRange.end = gid('chart-end').value || null; scheduleSave(); drawChart(); });

            // Compute and apply default chart date range if inputs are empty
            function applyDefaultChartRange() {
                const dates = Object.keys(state.tracker.data || {}).sort();
                const todayStr = new Date().toISOString().slice(0, 10);
                const latestData = dates.length ? dates[dates.length - 1] : null;
                const earliestData = dates.length ? dates[0] : null;
                const endDefault = latestData ? (latestData < todayStr ? latestData : todayStr) : todayStr; // min(latest, today)
                // one month before endDefault
                const [y, m, d] = endDefault.split('-').map(Number);
                const endDate = new Date(y, m - 1, d);
                const startMinusMonth = new Date(endDate);
                startMinusMonth.setMonth(startMinusMonth.getMonth() - 1);
                const startMinusMonthStr = startMinusMonth.toISOString().slice(0, 10);
                let startDefault = startMinusMonthStr;
                if (earliestData && earliestData > startDefault) startDefault = earliestData; // max(earliest, end-1mo)
                const startInput = gid('chart-start'); const endInput = gid('chart-end');
                if (!startInput.value) startInput.value = startDefault;
                if (!endInput.value) endInput.value = endDefault;
                // also persist defaults if nothing set yet
                if (!state.tracker.chartRange?.start || !state.tracker.chartRange?.end) {
                    state.tracker.chartRange = { start: startInput.value || null, end: endInput.value || null };
                    scheduleSave();
                }
            }

            // DATA PANEL (basic export/import/erase - strict schema could be extended later)
            function pad2(n) { return String(n).padStart(2, '0'); }
            function makeTimestamp() { const d = new Date(); return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}-${pad2(d.getHours())}${pad2(d.getMinutes())}`; }
            function downloadJSON(obj, filename) { const s = JSON.stringify(obj, null, 2); const blob = new Blob([s], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(url), 0); }
            gid('export-json').addEventListener('click', () => { const name = `personal-organiser-${makeTimestamp()}.json`; downloadJSON(state, name); });
            gid('to-text').addEventListener('click', () => { gid('json-area').value = JSON.stringify(state, null, 2); });
            function stateToText(s) {
                const lines = [];
                lines.push('# Notes');
                if ((s.notes || []).length === 0) { lines.push('(none)'); } else {
                    s.notes.forEach(n => { lines.push(`- ${n.title || '(untitled)'}`); if (n.content) { lines.push(n.content); } lines.push(''); });
                }
                lines.push('\n# Tasks');
                if ((s.tasks || []).length === 0) { lines.push('(none)'); } else {
                    s.tasks.forEach(t => { const chk = t.done ? '[x]' : '[ ]'; lines.push(`${chk} ${t.text || ''}`); });
                }
                lines.push('\n# Calendar Events');
                const dates = Object.keys(s.events || {}).sort();
                if (dates.length === 0) { lines.push('(none)'); } else {
                    dates.forEach(d => { lines.push(`- ${d}`); (s.events[d] || []).forEach(ev => lines.push(`  • ${ev}`)); });
                }
                lines.push('\n# Cards');
                if ((s.cards || []).length === 0) { lines.push('(none)'); } else {
                    s.cards.forEach(c => { lines.push(`- Front:`); if (c.front) lines.push(c.front); lines.push('  Back:'); if (c.back) lines.push(c.back); lines.push(''); });
                }
                lines.push('\n# Wheel Items');
                if (s.wheel?.itemsText) { lines.push(s.wheel.itemsText.trim()); } else { lines.push('(none)'); }
                lines.push('\n# Tracker');
                if (!s.tracker || (s.tracker.metrics || []).length === 0) { lines.push('(no metrics)'); }
                else {
                    lines.push('Metrics:'); (s.tracker.metrics || []).forEach(m => lines.push(`- ${m.name} (${m.id})`));
                    // Settings summary
                    const type = s.tracker.chartType || 'stacked';
                    const selIds = (s.tracker.selectedMetrics && s.tracker.selectedMetrics.length) ? s.tracker.selectedMetrics.slice() : (s.tracker.metrics || []).map(m => m.id);
                    const nameById = Object.fromEntries((s.tracker.metrics || []).map(m => [m.id, m.name]));
                    const selNames = selIds.map(id => nameById[id] || id);
                    const r = s.tracker.chartRange || { start: null, end: null };
                    lines.push(`Chart type: ${type}`);
                    lines.push(`Selected metrics: ${selNames.length ? selNames.join(', ') : '(none)'}`);
                    lines.push(`Range: ${r.start || '—'} to ${r.end || '—'}`);
                    const tdates = Object.keys(s.tracker.data || {}).sort();
                    tdates.forEach(d => { const row = s.tracker.data[d] || {}; const cells = Object.entries(row).map(([k, v]) => `${k}=${v ?? ''}`); lines.push(`${d}: ${cells.join(', ')}`); });
                }
                return lines.join('\n');
            }
            gid('export-schema').addEventListener('click', () => {
                const schema = {
                    $schema: 'https://json-schema.org/draft/2020-12/schema',
                    title: 'Personal Organiser Data',
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        ui: {
                            type: 'object',
                            additionalProperties: false,
                            properties: {
                                tab: { type: 'string' },
                                trackerMode: { enum: ['data', 'chart'] },
                                cardsMode: { enum: ['practice', 'manage'] },
                                wheelMode: { enum: ['use', 'manage'] },
                                calendarSelected: { anyOf: [ { type: 'string', pattern: '^\\d{4}-\\d{2}-\\d{2}$' }, { type: 'null' } ] },
                                notesSearch: { type: 'object', additionalProperties: false, properties: { query: { type: 'string' } } }
                            },
                            required: ['tab']
                        },
                        notes: {
                            type: 'array', items: {
                                type: 'object', additionalProperties: false,
                                properties: {
                                    id: { type: 'string' },
                                    title: { type: 'string' },
                                    content: {
                                        type: 'string',
                                        description: 'Freeform note body; may span multiple lines. Newline characters ("\\n" or Windows "\\r\\n") are preserved in storage. Preferred format: Markdown (optional) — plain text is accepted.',
                                        examples: [
                                            'Shopping list:\\n- Milk\\n- Eggs\\n- Bread',
                                            '| Day | Mood |\\n|---|---|\\n| Mon | 😀 |\\n| Tue | 😐 |\\n\\n![Alt text](https://example.com/image.png)\\n\\nSee [docs](https://example.com).\\n\\nThis is **bold** and *italic*.',
                                            '# The Door\\n\\nIt creaked open.\\n\\nShe paused, listening—then stepped into the quiet room.'
                                        ]
                                    }
                                },
                                required: ['id']
                            }
                        },
                        tasks: {
                            type: 'array', items: {
                                type: 'object', additionalProperties: false,
                                properties: { id: { type: 'string' }, text: { type: 'string' }, done: { type: 'boolean' } },
                                required: ['id']
                            }
                        },
                        events: {
                            type: 'object',
                            patternProperties: {
                                '^\\d{4}-\\d{2}-\\d{2}$': { type: 'array', items: { type: 'string' } }
                            },
                            additionalProperties: false
                        },
                        cards: {
                            type: 'array', items: {
                                type: 'object', additionalProperties: false,
                                properties: { id: { type: 'string' }, front: { type: 'string' }, back: { type: 'string' } },
                                required: ['id']
                            }
                        },
                        shuffledCache: {
                            type: 'object', additionalProperties: false,
                            properties: { enabled: { type: 'boolean' }, order: { type: 'array', items: { type: 'string' } } }
                        },
                        cardsPractice: {
                            type: 'object', additionalProperties: false,
                            properties: { idx: { type: 'number' } }
                        },
                        wheel: {
                            type: 'object', additionalProperties: false,
                            properties: {
                                itemsText: {
                                    type: 'string',
                                    description: 'Multiline string: one item per line. Items are split on newlines ("\n" or Windows "\r\n"). Do not use commas or semicolons as separators—punctuation is treated as part of the item text. Leading/trailing spaces are trimmed and empty lines are ignored.',
                                    examples: [
                                        'Eat cake\nNap aggressively\nDance like noodles\nWrite haiku about socks\nShout \"PLOT TWIST\" randomly\nStart a staring contest with the moon'
                                    ]
                                },
                                lastHit: { type: ['string', 'null'] }
                            }
                        },
                        tracker: {
                            type: 'object', additionalProperties: false,
                            properties: {
                                metrics: { type: 'array', items: { type: 'object', additionalProperties: false, properties: { id: { type: 'string' }, name: { type: 'string' } }, required: ['id', 'name'] } },
                                data: {
                                    type: 'object',
                                    patternProperties: {
                                        '^\\d{4}-\\d{2}-\\d{2}$': { type: 'object', additionalProperties: { type: ['number', 'null'] } }
                                    },
                                    additionalProperties: false
                                },
                                chartType: { enum: ['stacked', 'normalized', 'line'] },
                                selectedMetrics: { type: 'array', items: { type: 'string' } },
                                chartRange: {
                                    type: 'object', additionalProperties: false,
                                    properties: {
                                        start: { anyOf: [{ type: 'string', pattern: '^\\d{4}-\\d{2}-\\d{2}$' }, { type: 'null' }] },
                                        end: { anyOf: [{ type: 'string', pattern: '^\\d{4}-\\d{2}-\\d{2}$' }, { type: 'null' }] }
                                    }
                                }
                            },
                            required: ['metrics', 'data']
                        }
                    },
                    required: ['ui', 'notes', 'tasks', 'events', 'cards', 'shuffledCache', 'cardsPractice', 'wheel', 'tracker']
                };
                downloadJSON(schema, 'personal-organiser.schema.json');
            });
            gid('import-json').addEventListener('click', () => gid('file-input').click());
            gid('file-input').addEventListener('change', () => { const f = gid('file-input').files[0]; if (!f) return; const r = new FileReader(); r.onload = () => { try { const obj = JSON.parse(r.result); if (!obj || typeof obj !== 'object') throw new Error('Invalid data'); state = sanitizeState(obj); scheduleSave(); initAll(); } catch (e) { alert('Import failed: ' + e.message); } }; r.readAsText(f); });
            gid('apply-json').addEventListener('click', () => { try { const obj = JSON.parse(gid('json-area').value); if (!obj || typeof obj !== 'object') throw new Error('Invalid data'); state = sanitizeState(obj); scheduleSave(); initAll(); } catch (e) { alert('Invalid JSON: ' + e.message); } });
            gid('erase-all').addEventListener('click', () => { if (confirm('Erase all Personal Organiser data?')) { localStorage.removeItem(STORAGE_KEY); state = { ui: { tab: 'notes', trackerMode: 'chart', cardsMode: 'practice', wheelMode: 'use', calendarSelected: null, notesSearch: { query: '' } }, notes: [], tasks: [], events: {}, cards: [], shuffledCache: { enabled: false, order: [] }, cardsPractice: { idx: 0 }, wheel: { itemsText: '', lastHit: null }, tracker: { metrics: [], data: {}, chartType: 'stacked', selectedMetrics: [], chartRange: { start: null, end: null } } }; initAll(); } });

            // INIT bundle
            function initAll() {
                // theme
                initTheme();
                // about
                gid('app-version').textContent = VERSION;
                // tabs
                showTab(state.ui.tab || 'notes');
                // notes
                // initialize notes search UI from state
                const si = gid('notes-search-input'); if (si) si.value = (state.ui?.notesSearch?.query || '');
                renderNotes();
                // tasks
                renderTasks();
                // calendar
                const d = new Date(); setMonth(d.getFullYear(), d.getMonth());
                // If a date was previously selected and is in the current month, open its editor
                if (state.ui.calendarSelected) {
                    const sel = new Date(state.ui.calendarSelected);
                    if (!Number.isNaN(sel.getTime()) && sel.getFullYear() === calYear && sel.getMonth() === calMonth) {
                        openEventEditor(state.ui.calendarSelected);
                    }
                }
                // cards
                renderCards();
                // calc
                renderCalc();
                // wheel
                gid('wheel-input').value = state.wheel.itemsText || ''; updateRemoveSpinEnabled();
                gid('wheel-result').textContent = state.wheel.lastHit ? `Result: ${state.wheel.lastHit}` : '';
                // apply wheel mode
                const mode = state.ui.wheelMode || 'use';
                if (mode === 'use') { gid('wheel-mode-use').click(); } else { gid('wheel-mode-manage').click(); }
                requestAnimationFrame(() => requestAnimationFrame(() => { resizeWheelCanvas(); alignWheelToLastHit(); }));
                // tracker
                renderTracker();
                applyDefaultChartRange();
                updateChartControls();
                // ensure correct tracker sub-mode is applied on load
                setTrackerMode(state.ui.trackerMode || 'data');
            }

            // Start
            applyTheme(loadTheme());
            initAll();

            // Resize listeners
            let wheelResizeScheduled = false;
            let wheelResizeTrailingTimer = null;
            window.addEventListener('resize', () => {
                if (state.ui.tab === 'wheel') {
                    if (!wheelResizeScheduled) {
                        wheelResizeScheduled = true;
                        requestAnimationFrame(() => requestAnimationFrame(() => { resizeWheelCanvas(); wheelResizeScheduled = false; }));
                    }
                    // trailing resize after burst
                    if (wheelResizeTrailingTimer) clearTimeout(wheelResizeTrailingTimer);
                    wheelResizeTrailingTimer = setTimeout(() => {
                        requestAnimationFrame(() => requestAnimationFrame(resizeWheelCanvas));
                    }, 120);
                }
                if (state.ui.tab === 'tracker') resizeTrackerChart();
            });

        })();
    </script>
</body>

</html>