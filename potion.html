<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Magic Potion - Physics Toy</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    html, body {
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: 'Courier New', monospace;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #particleCanvas {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      pointer-events: none;
    }

    #liquidCanvas {
      position: absolute;
      top: 0;
      left: 0;
      backdrop-filter: none;
    }

    #glowCanvas {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      pointer-events: none;
    }

    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
    }

    .ui-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #00ffff;
      border-radius: 8px;
      padding: 15px;
      color: #00ffff;
      font-size: 12px;
      z-index: 20;
      backdrop-filter: blur(10px);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .ui-panel.visible {
      opacity: 1;
    }

    .tilt-indicator {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border: 2px solid #00ffff;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .tilt-indicator.visible {
      opacity: 1;
    }

    .tilt-dot {
      width: 8px;
      height: 8px;
      background: #ff00ff;
      border-radius: 50%;
      transition: transform 0.1s ease;
      box-shadow: 0 0 10px #ff00ff;
    }

    .permission-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #00ffff;
      border-radius: 15px;
      padding: 30px;
      text-align: center;
      color: #00ffff;
      z-index: 100;
      backdrop-filter: blur(15px);
    }

    .permission-button {
      background: linear-gradient(45deg, #ff00ff, #00ffff);
      border: none;
      border-radius: 25px;
      padding: 15px 30px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      margin-top: 20px;
      font-size: 16px;
      text-transform: uppercase;
      transition: all 0.3s ease;
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }

    .permission-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
    }

    @media (orientation: landscape) {
      .ui-panel {
        font-size: 10px;
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="particleCanvas"></canvas>
    <canvas id="liquidCanvas"></canvas>
    <canvas id="glowCanvas"></canvas>
    <canvas id="overlayCanvas"></canvas>
    
    <div class="ui-panel">
      <div>Magic Potion Simulator</div>
      <div>Particles: <span id="particleCount">0</span></div>
      <div>Bubbles: <span id="bubbleCount">0</span></div>
      <div>Tilt X: <span id="tiltX">0</span>Â°</div>
      <div>Tilt Y: <span id="tiltY">0</span>Â°</div>
      <div>Physics: <span id="physicsMode">Liquid</span></div>
    </div>

    <div class="tilt-indicator">
      <div class="tilt-dot" id="tiltDot"></div>
    </div>

    <div class="permission-prompt" id="permissionPrompt">
      <h2>ðŸ§ª Magic Potion Physics</h2>
      <p>Tilt your device to control the magical liquid!</p>
      <p>Grant motion sensor access to begin the simulation.</p>
      <button class="permission-button" onclick="requestMotionPermission()">
        Enable Magic âœ¨
      </button>
      <div style="margin-top: 15px; font-size: 11px; opacity: 0.7;">
        Desktop: Click and drag to tilt the bottle
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let canvas, ctx, particleCanvas, particleCtx, overlayCanvas, overlayCtx, glowCanvas, glowCtx;
    let width, height;
    let renderWidth, renderHeight; // Lower resolution for rendering
    let particles = [];
    let bubbles = []; // Array to hold bubble objects
    let gravity = { x: 0, y: 0.2 }; // Reduced gravity for better liquid behavior
    let damping = 0.98;
    let particleRadius = 8; // Base particle radius (will be scaled)
    let numParticles = 100; // Reduced from 150 for better performance and smoother physics
    let maxBubbles = 15; // Maximum number of bubbles at one time
    let motionPermissionGranted = false;
    
    // UI visibility
    let uiVisible = false;
    let uiHideTimeout = null;
    
    // Scaling variables
    let scale = 1; // Will be calculated based on viewport size
    let scaledParticleRadius = 64;
    let scaledMaskRadius = 128;
    let scaledMinDistance = 128;
    let scaledBlurRadius = 8;
    
    // Tilt values
    let tiltX = 0, tiltY = 0;
    let smoothTiltX = 0, smoothTiltY = 0;
    
    // Physics constants (base values, will be scaled)
    const maxTilt = 90; // degrees - now allowing full 90-degree tilt range
    const tiltSensitivity = 0.026; // Reduced by 20% from 0.033 for calmer particle energy
    const viscosity = 0.95;
    const cohesion = 0.8;
    const separation = 0.3;
    const baseMinDistance = 128; // Base minimum distance between particles (scaled with particle size)
    const repulsionStrength = 0.5; // How strong the repulsion force is
    const baseParticleRadius = 64; // Base particle radius (8x larger: 8 * 8 = 64)
    const baseMaskRadius = 128; // Base mask radius for contour (16x base: 8 * 16 = 128)
    const baseBlurRadius = 8; // Base blur radius
    
    // Performance optimization
    let physicsFrame = 0;
    
    // Particle class
    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.radius = scaledParticleRadius + (Math.random() - 0.5) * 4 * scale;
        this.density = 0;
        this.pressure = 0;
        this.nearDensity = 0;
        this.nearPressure = 0;
      }
      
      update() {
        // Apply gravity with tilt
        this.vx += gravity.x;
        this.vy += gravity.y;
        
        // Apply viscosity
        this.vx *= viscosity;
        this.vy *= viscosity;
        
        // Update position
        this.x += this.vx;
        this.y += this.vy;
        
        // Boundary collisions with damping (using render dimensions)
        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.vx *= -damping;
        }
        if (this.x + this.radius > renderWidth) {
          this.x = renderWidth - this.radius;
          this.vx *= -damping;
        }
        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy *= -damping;
        }
        if (this.y + this.radius > renderHeight) {
          this.y = renderHeight - this.radius;
          this.vy *= -damping;
        }
      }
      
      // Fluid dynamics - simplified SPH (Smoothed Particle Hydrodynamics)
      calculateDensity() {
        this.density = 0;
        this.nearDensity = 0;
        
        particles.forEach(other => {
          if (other === this) return;
          
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.radius * 2) {
            const q = distance / (this.radius * 2);
            if (q < 1) {
              const density = (1 - q) * (1 - q);
              this.density += density;
              this.nearDensity += density * (1 - q);
            }
          }
        });
      }
      
      calculatePressure() {
        this.pressure = this.density - 1;
        this.nearPressure = this.nearDensity;
      }
      
      applyPressureForce() {
        particles.forEach(other => {
          if (other === this) return;
          
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.radius * 2 && distance > 0) {
            const q = distance / (this.radius * 2);
            if (q < 1) {
              const force = this.pressure * (1 - q) + this.nearPressure * (1 - q) * (1 - q);
              const forceX = (dx / distance) * force * 0.5;
              const forceY = (dy / distance) * force * 0.5;
              
              this.vx -= forceX;
              this.vy -= forceY;
            }
          }
        });
      }
      
      // Apply separation force to maintain minimum distance between particles
      applySeparationForce() {
        particles.forEach(other => {
          if (other === this) return;
          
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < scaledMinDistance && distance > 0) {
            // Calculate repulsion force - stronger when particles are closer
            const overlap = scaledMinDistance - distance;
            const force = (overlap / scaledMinDistance) * repulsionStrength;
            
            // Apply force in opposite direction (away from other particle)
            const forceX = -(dx / distance) * force;
            const forceY = -(dy / distance) * force;
            
            this.vx += forceX;
            this.vy += forceY;
          }
        });
      }
    }
    
    // Bubble class for magical bubble effects
    class Bubble {
      constructor(particle) {
        this.spawnParticle = particle;
        this.x = particle.x;
        this.y = particle.y;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = (Math.random() - 0.5) * 1; // More neutral initial velocity
        this.radius = 0; // Start at size 0 and grow
        this.targetRadius = scaledParticleRadius;
        this.age = 0;
        this.maxAge = Math.random() * 300 + 200; // Lifespan before removal check
        this.elasticity = 0.1; // How strongly it's pulled toward spawn particle
        this.buoyancy = 0.02; // Upward drift strength
        this.damping = 0.98;
      }
      
      update() {
        this.age++;
        
        // Grow the bubble from 0 to target size
        if (this.radius < this.targetRadius) {
          this.radius += (this.targetRadius - this.radius) * 0.05;
        }
        
        // Elastic connection to spawn particle
        const dx = this.spawnParticle.x - this.x;
        const dy = this.spawnParticle.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Apply elastic force toward spawn particle (but weakly)
        if (distance > 0) {
          const elasticForce = this.elasticity * Math.min(distance / 100, 1);
          this.vx += (dx / distance) * elasticForce;
          this.vy += (dy / distance) * elasticForce;
        }
        
        // Apply buoyancy (opposite to gravity direction)
        this.vx -= gravity.x * this.buoyancy * 10; // Float opposite to gravity X
        this.vy -= gravity.y * this.buoyancy * 10; // Float opposite to gravity Y
        
        // Apply gravity but much weaker than particles (bubbles are lighter)
        this.vx += gravity.x * 0.1;
        this.vy += gravity.y * 0.1;
        
        // Apply damping
        this.vx *= this.damping;
        this.vy *= this.damping;
        
        // Update position
        this.x += this.vx;
        this.y += this.vy;
        
        // Soft boundary collisions (bubbles can float near edges, using render dimensions)
        if (this.x < this.radius) {
          this.x = this.radius;
          this.vx *= -0.5;
        }
        if (this.x > renderWidth - this.radius) {
          this.x = renderWidth - this.radius;
          this.vx *= -0.5;
        }
      }
      
      // Check if bubble is outside the liquid mask area
      isOutsideMask() {
        // Check if bubble is at the edge of the render bounds
        if (this.x < 0 || this.x > renderWidth || this.y < 0 || this.y > renderHeight) {
          return true;
        }
        
        // Check if bubble is too old (failsafe)
        if (this.age > this.maxAge) {
          return true;
        }
        
        // Sample the liquid mask at the bubble's position
        try {
          const imageData = particleCtx.getImageData(
            Math.floor(this.x - 2), 
            Math.floor(this.y - 2), 
            4, 
            4
          );
          
          // Check if there's any liquid pixels in the sampled area
          let hasLiquid = false;
          for (let i = 0; i < imageData.data.length; i += 4) {
            const alpha = imageData.data[i + 3]; // Alpha channel
            if (alpha > 50) { // Threshold for liquid presence
              hasLiquid = true;
              break;
            }
          }
          
          return !hasLiquid; // Remove bubble if no liquid found
        } catch (error) {
          // If sampling fails, fall back to age-based removal
          return this.age > this.maxAge * 0.8;
        }
      }
    }
    
    function initCanvas() {
      // Main liquid rendering canvas
      canvas = document.getElementById('liquidCanvas');
      ctx = canvas.getContext('2d');
      
      // Hidden particle canvas for blur operations (optimized for frequent readback)
      particleCanvas = document.getElementById('particleCanvas');
      particleCtx = particleCanvas.getContext('2d', { willReadFrequently: true });
      
      // Hidden glow canvas for inner glow effect
      glowCanvas = document.getElementById('glowCanvas');
      glowCtx = glowCanvas.getContext('2d', { willReadFrequently: true });
      
      // Overlay canvas for effects
      overlayCanvas = document.getElementById('overlayCanvas');
      overlayCtx = overlayCanvas.getContext('2d');
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }
    
    function resizeCanvas() {
      width = window.innerWidth;
      height = window.innerHeight;
      
      // Calculate render resolution at 1/8th scale for performance
      const renderScale = 0.125; // 1/8th resolution
      renderWidth = Math.floor(width * renderScale);
      renderHeight = Math.floor(height * renderScale);
      
      // Calculate scale based on minimum dimension (responsive scaling)
      const baseSize = 800; // Reference size for scaling
      scale = Math.min(width, height) / baseSize;
      scale = Math.max(0.3, Math.min(scale, 2.0)); // Clamp scale between 0.3x and 2x
      
      // Update scaled values (adjusted for render resolution)
      scaledParticleRadius = baseParticleRadius * scale * renderScale;
      scaledMaskRadius = baseMaskRadius * scale * renderScale;
      scaledMinDistance = baseMinDistance * scale * renderScale;
      scaledBlurRadius = Math.max(1, baseBlurRadius * scale * renderScale); // Minimum blur of 1px at low res
      
      // Set display canvas to full resolution
      canvas.width = width;
      canvas.height = height;
      overlayCanvas.width = width;
      overlayCanvas.height = height;
      
      // Set render canvases to lower resolution
      particleCanvas.width = renderWidth;
      particleCanvas.height = renderHeight;
      glowCanvas.width = renderWidth;
      glowCanvas.height = renderHeight;
      
      // Reinitialize particles if they exist (for resize events)
      if (particles.length > 0) {
        initParticles();
      }
    }
    
    function initParticles() {
      particles = [];
      
      // Create particles in bottom 3/4 of render area (like a bottle filled 3/4)
      const startY = renderHeight * 0.25;
      const particlesPerRow = Math.ceil(Math.sqrt(numParticles));
      const spacing = (renderWidth * 0.8) / particlesPerRow;
      
      for (let i = 0; i < numParticles; i++) {
        const row = Math.floor(i / particlesPerRow);
        const col = i % particlesPerRow;
        
        const x = (renderWidth * 0.1) + col * spacing + (Math.random() - 0.5) * spacing * 0.5;
        const y = startY + row * spacing + (Math.random() - 0.5) * spacing * 0.5;
        
        if (y < renderHeight - scaledParticleRadius) {
          particles.push(new Particle(x, y));
        }
      }
    }
    
    function updatePhysics() {
      // Update gravity based on device tilt
      gravity.x = smoothTiltX * tiltSensitivity;
      gravity.y = 0.2 + smoothTiltY * tiltSensitivity * 0.5; // Updated base gravity
      
      // Apply separation force every frame to maintain particle spacing
      particles.forEach(p => p.applySeparationForce());
      
      // Run expensive fluid dynamics calculations every other frame for performance
      physicsFrame++;
      if (physicsFrame % 2 === 0) {
        particles.forEach(p => p.calculateDensity());
        particles.forEach(p => p.calculatePressure());
        particles.forEach(p => p.applyPressureForce());
      }
      
      // Update particle positions every frame
      particles.forEach(p => p.update());
      
      // Update bubble physics (but not removal - that happens after liquid rendering)
      bubbles.forEach(bubble => bubble.update());
      
      // Spawn new bubbles if we're below maximum
      while (bubbles.length < maxBubbles && particles.length > 0) {
        const randomParticle = particles[Math.floor(Math.random() * particles.length)];
        bubbles.push(new Bubble(randomParticle));
      }
    }
    
    function renderLiquid() {
      // Calculate border size for meniscus effect (equal to particle mask radius)
      const borderSize = Math.ceil(scaledMaskRadius);
      const extendedWidth = renderWidth + (borderSize * 2);
      const extendedHeight = renderHeight + (borderSize * 2);
      
      // Create temporary extended canvas for meniscus effect
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = extendedWidth;
      tempCanvas.height = extendedHeight;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Fill the entire extended canvas with white (creates the border effect)
      tempCtx.fillStyle = 'white';
      tempCtx.fillRect(0, 0, extendedWidth, extendedHeight);
      
      // Hollow out the interior area, leaving only the border for meniscus
      tempCtx.globalCompositeOperation = 'destination-out';
      tempCtx.fillRect(borderSize, borderSize, renderWidth, renderHeight);
      tempCtx.globalCompositeOperation = 'source-over'; // Reset to normal
      
      // Draw particles on the extended canvas (offset by border size)
      particles.forEach(particle => {
        tempCtx.beginPath();
        tempCtx.arc(
          particle.x + borderSize, 
          particle.y + borderSize, 
          scaledMaskRadius, 
          0, Math.PI * 2
        );
        tempCtx.fill();
      });
      
      // Apply Gaussian blur to create metaball effect with meniscus
      tempCtx.filter = `blur(${scaledBlurRadius}px)`;
      tempCtx.globalCompositeOperation = 'source-over';
      tempCtx.drawImage(tempCanvas, 0, 0);
      tempCtx.filter = 'none';
      
      // Clear the particle canvas and crop the extended result back to original size
      particleCtx.clearRect(0, 0, renderWidth, renderHeight);
      particleCtx.drawImage(
        tempCanvas, 
        borderSize, borderSize, renderWidth, renderHeight, // Source: crop from extended canvas
        0, 0, renderWidth, renderHeight // Destination: original size
      );
      
      // Clear main canvas and create liquid gradient
      ctx.clearRect(0, 0, width, height);
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#ff00ff');
      gradient.addColorStop(0.3, '#8000ff');
      gradient.addColorStop(0.7, '#4000ff');
      gradient.addColorStop(1, '#0080ff');
      
      // Render liquid with scaling from render resolution to display resolution
      ctx.save();
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      ctx.globalCompositeOperation = 'destination-in';
      // Use nearest-neighbor scaling for crisp pixels
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(particleCanvas, 0, 0, renderWidth, renderHeight, 0, 0, width, height);
      ctx.imageSmoothingEnabled = true; // Reset for other operations
      ctx.restore();
    }
    
    function renderInnerGlow() {
      // Clear glow canvas
      glowCtx.clearRect(0, 0, renderWidth, renderHeight);
      
      // Step 1: Create inner mask with higher alpha threshold
      // Draw particles with slightly smaller radius to create inner boundary
      const innerRadius = scaledMaskRadius * 0.7; // Smaller radius for inner shape
      glowCtx.fillStyle = 'white';
      particles.forEach(particle => {
        glowCtx.beginPath();
        glowCtx.arc(particle.x, particle.y, innerRadius, 0, Math.PI * 2);
        glowCtx.fill();
      });
      
      // Step 2: Apply blur to soften the inner mask
      const innerBlur = scaledBlurRadius * 1.5;
      glowCtx.filter = `blur(${innerBlur}px)`;
      glowCtx.globalCompositeOperation = 'source-over';
      glowCtx.drawImage(glowCanvas, 0, 0);
      glowCtx.filter = 'none';
      
      // Step 3: Create inverted alpha channel for glow effect
      // Get the image data to process alpha channel
      const imageData = glowCtx.getImageData(0, 0, renderWidth, renderHeight);
      const data = imageData.data;
      
      // Process pixels: invert alpha and create glow gradient
      for (let i = 0; i < data.length; i += 4) {
        const alpha = data[i + 3];
        if (alpha > 10) { // Only process areas with some content
          // Create inverted glow - stronger where alpha is weaker
          const glowStrength = Math.max(0, 255 - alpha) / 255;
          const glowIntensity = Math.pow(glowStrength, 2) * 0.8; // Quadratic falloff
          
          // UV-like magenta/purple glow colors
          data[i] = Math.floor(255 * glowIntensity);     // Red
          data[i + 1] = Math.floor(100 * glowIntensity); // Green  
          data[i + 2] = Math.floor(255 * glowIntensity); // Blue
          data[i + 3] = Math.floor(180 * glowIntensity); // Alpha
        } else {
          // Clear areas outside the glow
          data[i] = 0;
          data[i + 1] = 0;
          data[i + 2] = 0;
          data[i + 3] = 0;
        }
      }
      
      // Step 4: Put the processed glow back
      glowCtx.clearRect(0, 0, renderWidth, renderHeight);
      glowCtx.putImageData(imageData, 0, 0);
      
      // Step 5: Apply additional blur to the glow for smoothness
      glowCtx.filter = `blur(${scaledBlurRadius * 0.5}px)`;
      glowCtx.globalCompositeOperation = 'source-over';
      glowCtx.drawImage(glowCanvas, 0, 0);
      glowCtx.filter = 'none';
      
      // Step 6: Composite the glow onto the main canvas with scaling
      ctx.globalCompositeOperation = 'screen'; // Additive blending for glow
      // Use nearest-neighbor scaling for crisp pixels
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(glowCanvas, 0, 0, renderWidth, renderHeight, 0, 0, width, height);
      ctx.imageSmoothingEnabled = true; // Reset for other operations
      ctx.globalCompositeOperation = 'source-over'; // Reset to normal blending
    }
    
    function removeBubblesOutsideMask() {
      // Remove bubbles that are outside the liquid mask (after liquid is rendered)
      bubbles = bubbles.filter(bubble => !bubble.isOutsideMask());
    }
    
    function renderBubbles() {
      // Clear the glow canvas and use it for bubble rendering at render resolution
      glowCtx.clearRect(0, 0, renderWidth, renderHeight);
      
      // Calculate line width proportional to render resolution (4x thicker than before)
      const renderLineWidth = Math.max(1, Math.min(renderWidth, renderHeight) * 0.012); // 4x the previous 0.003
      
      // Set up bubble rendering style at render resolution
      glowCtx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; // White with 15% opacity
      glowCtx.lineWidth = renderLineWidth;
      glowCtx.fillStyle = 'transparent'; // No fill
      
      // Render each bubble at render resolution
      bubbles.forEach(bubble => {
        if (bubble.radius > 0.5) { // Only render if bubble has grown enough to be visible
          glowCtx.beginPath();
          glowCtx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
          glowCtx.stroke();
        }
      });
      
      // Now composite the bubble canvas onto the main canvas with pixel-perfect scaling
      ctx.globalCompositeOperation = 'source-over';
      ctx.imageSmoothingEnabled = false; // Pixel-perfect scaling
      ctx.drawImage(glowCanvas, 0, 0, renderWidth, renderHeight, 0, 0, width, height);
      ctx.imageSmoothingEnabled = true; // Reset for other operations
    }
    
    function renderOverlay() {
      overlayCtx.clearRect(0, 0, width, height);
      
      // Calculate scale factor from render to display resolution
      const scaleX = width / renderWidth;
      const scaleY = height / renderHeight;
      
      // Add some magical sparkle effects
      overlayCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      particles.forEach(particle => {
        if (Math.random() < 0.02) { // Random sparkles
          overlayCtx.beginPath();
          overlayCtx.arc(
            (particle.x + (Math.random() - 0.5) * 20 / scaleX) * scaleX,
            (particle.y + (Math.random() - 0.5) * 20 / scaleY) * scaleY,
            Math.random() * 2,
            0, Math.PI * 2
          );
          overlayCtx.fill();
        }
      });
      
      // Removed bottle neck lines - not needed
    }
    
    function updateUI() {
      document.getElementById('particleCount').textContent = particles.length;
      document.getElementById('bubbleCount').textContent = bubbles.length;
      document.getElementById('tiltX').textContent = smoothTiltX.toFixed(1);
      document.getElementById('tiltY').textContent = smoothTiltY.toFixed(1);
      
      // Update tilt indicator
      const dot = document.getElementById('tiltDot');
      const maxOffset = 20;
      const offsetX = (smoothTiltX / maxTilt) * maxOffset;
      const offsetY = (smoothTiltY / maxTilt) * maxOffset;
      dot.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    }
    
    function showUI() {
      uiVisible = true;
      document.querySelector('.ui-panel').classList.add('visible');
      document.querySelector('.tilt-indicator').classList.add('visible');
      
      // Clear existing timeout
      if (uiHideTimeout) {
        clearTimeout(uiHideTimeout);
      }
      
      // Hide UI after 3 seconds of no interaction
      uiHideTimeout = setTimeout(hideUI, 3000);
    }
    
    function hideUI() {
      uiVisible = false;
      document.querySelector('.ui-panel').classList.remove('visible');
      document.querySelector('.tilt-indicator').classList.remove('visible');
      
      if (uiHideTimeout) {
        clearTimeout(uiHideTimeout);
        uiHideTimeout = null;
      }
    }
    
    function requestFullscreen() {
      const element = document.documentElement;
      if (element.requestFullscreen) {
        element.requestFullscreen().catch(err => {
          console.log('Fullscreen request failed:', err);
        });
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      }
    }
    
    function animate() {
      updatePhysics();
      renderLiquid();
      renderInnerGlow(); // Add the inner glow effect
      removeBubblesOutsideMask(); // Check bubbles against liquid mask after rendering
      renderBubbles();
      renderOverlay();
      updateUI();
      requestAnimationFrame(animate);
    }
    
    function handleDeviceMotion(event) {
      if (!motionPermissionGranted) return;
      
      // Get device orientation
      const rawTiltX = event.accelerationIncludingGravity.x || 0;
      const rawTiltY = event.accelerationIncludingGravity.y || 0;
      
      // Convert to degrees and smooth (invert X for mobile)
      tiltX = Math.max(-maxTilt, Math.min(maxTilt, -rawTiltX * 5)); // Inverted X tilt for mobile
      tiltY = Math.max(-maxTilt, Math.min(maxTilt, rawTiltY * 5));
      
      // Smooth the tilt values
      smoothTiltX += (tiltX - smoothTiltX) * 0.1;
      smoothTiltY += (tiltY - smoothTiltY) * 0.1;
    }
    
    async function requestMotionPermission() {
      // Request fullscreen first
      try {
        await requestFullscreen();
      } catch (error) {
        console.log('Fullscreen not available or denied');
      }
      
      if (!('ontouchstart' in window)) {
        // Desktop - go straight to fallback controls
        setupFallbackControls();
        document.getElementById('permissionPrompt').style.display = 'none';
        return;
      }
      
      try {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
          // iOS 13+ permission request
          const permission = await DeviceMotionEvent.requestPermission();
          if (permission === 'granted') {
            motionPermissionGranted = true;
            setupMotionListeners();
          }
        } else {
          // Android or older iOS
          motionPermissionGranted = true;
          setupMotionListeners();
        }
        
        if (motionPermissionGranted) {
          document.getElementById('permissionPrompt').style.display = 'none';
          setupFallbackControls(); // Setup controls but don't show UI yet
        }
      } catch (error) {
        console.warn('Motion permission error:', error);
        // Fallback to mouse/touch controls
        setupFallbackControls();
        document.getElementById('permissionPrompt').style.display = 'none';
      }
    }
    
    function setupMotionListeners() {
      window.addEventListener('devicemotion', handleDeviceMotion);
      
      // Add touch listeners for UI visibility only when interacting with the simulation
      canvas.addEventListener('touchstart', showUI);
    }
    
    function setupFallbackControls() {
      // Mouse/touch fallback
      let isPointerDown = false;
      
      const handlePointerMove = (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (isPointerDown) {
          // Convert mouse position to tilt when dragging
          tiltX = ((x / width) - 0.5) * maxTilt * 2;
          tiltY = ((y / height) - 0.5) * maxTilt * 2;
          
          smoothTiltX += (tiltX - smoothTiltX) * 0.2;
          smoothTiltY += (tiltY - smoothTiltY) * 0.2;
        }
      };
      
      const handleInteraction = (e) => {
        showUI(); // Show UI on canvas interaction
        if (!isPointerDown) {
          isPointerDown = true;
          handlePointerMove(e);
        }
      };
      
      canvas.addEventListener('mousedown', handleInteraction);
      canvas.addEventListener('mouseup', () => isPointerDown = false);
      canvas.addEventListener('mousemove', (e) => {
        if (isPointerDown) {
          showUI(); // Keep UI visible while dragging
          handlePointerMove(e);
        }
      });
      
      canvas.addEventListener('touchstart', (e) => {
        handleInteraction(e.touches[0]);
      });
      canvas.addEventListener('touchend', () => isPointerDown = false);
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (isPointerDown) {
          showUI(); // Keep UI visible while touching
          handlePointerMove(e.touches[0]);
        }
      });
      
      // Only show UI when interacting with the canvas, not the whole document
      canvas.addEventListener('click', showUI);
      
      motionPermissionGranted = true;
    }
    
    // Initialize everything
    function init() {
      initCanvas();
      initParticles();
      animate();
      
      // Request fullscreen on desktop after a short delay to avoid blocking
      if (!('ontouchstart' in window)) {
        setTimeout(() => {
          requestFullscreen();
        }, 1000);
      }
      
      // Don't auto-hide permission prompt - wait for user interaction
      // The permission prompt will be hidden when user clicks "Enable Magic"
    }
    
    // Start when page loads
    window.addEventListener('load', init);
    
    // Prevent scrolling on mobile
    document.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });
    
  </script>
</body>
</html>
