<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Space Scroller</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none; /* Prevent any touch gestures on the page */
      -webkit-user-select: none; /* Prevent text selection */
      user-select: none;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    canvas {
      border: 2px solid #fff;
      background: #000;
      display: block;
      touch-action: none; /* Prevent default touch behaviors */
      max-width: 100vw;
      max-height: 80vh;
    }
    @media (max-width: 768px) {
      canvas {
        width: 100vw;
        height: 75vh;
      }
      .ui {
        font-size: 14px;
      }
    }
    .ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      z-index: 10;
    }
    
    /* Game Over Modal */
    .game-over-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      touch-action: manipulation;
    }
    
    .game-over-content {
      text-align: center;
      color: #fff;
      padding: 2rem;
      max-width: 90%;
    }
    
    .game-over-title {
      font-size: 3rem;
      font-weight: bold;
      color: #ff4444;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    .game-over-score {
      font-size: 2rem;
      margin-bottom: 2rem;
      color: #ffff44;
    }
    
    .game-over-instruction {
      font-size: 1.2rem;
      opacity: 0.8;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 0.4; }
    }
    
    @media (max-width: 768px) {
      .game-over-title {
        font-size: 2rem;
      }
      .game-over-score {
        font-size: 1.5rem;
      }
      .game-over-instruction {
        font-size: 1rem;
      }
    }
    .ui div {
      margin-bottom: 5px;
    }
    .overheat-bar {
      width: 200px;
      height: 20px;
      background: #333;
      border: 1px solid #fff;
      margin-top: 5px;
    }
    .overheat-fill {
      height: 100%;
      background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
      width: 0%;
      transition: width 0.1s;
    }
    .cooldown {
      background: #666 !important;
    }
  </style>
</head>
<body>
  <div class="ui">
    <div>Score: <span id="score">0</span></div>
    <div>Health: <span id="health">100</span></div>
    <div>Bombs: <span id="bombs">0</span></div>
    <div>Overheat:</div>
    <div class="overheat-bar">
      <div class="overheat-fill" id="overheat-fill"></div>
    </div>
    <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">
      Mouse/Touch: Move & Fire<br>
      Spacebar/Quick Tap: Bomb
    </div>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <!-- Game Over Modal -->
  <div id="gameOverModal" class="game-over-modal">
    <div class="game-over-content">
      <div class="game-over-title">GAME OVER</div>
      <div class="game-over-score">Final Score: <span id="finalScore">0</span></div>
      <div class="game-over-instruction">Tap anywhere to restart</div>
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const healthEl = document.getElementById('health');
    const bombsEl = document.getElementById('bombs');
    const overheatFill = document.getElementById('overheat-fill');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');

    // Game variables
    let player = { x: canvas.width / 2, y: canvas.height - 50, width: 30, height: 30, speed: 5 };
    let bullets = [];
    let enemies = [];
    let powerUps = [];
    let missiles = [];
    let bombs = 0;
    let score = 0;
    let health = 100;
    let overheat = 0;
    let maxOverheat = 100;
    let cooldown = false;
    let fireRate = 0; // directions: 0=single, 1=3-way, 2=5-way
    let missileRate = 0; // 0=none, 1=basic missiles

    let mouseX = canvas.width / 2;
    let mouseY = canvas.height - 50;
    let firing = false;
    let lastShot = 0;
    let touchStartTime = 0;
    let touchStartPos = { x: 0, y: 0 };
    let isCurrentlyTouch = false; // Track if current interaction is touch
    let gameRunning = true; // Track if game is running

    // Game Over Modal Functions
    function showGameOver() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      gameOverModal.style.display = 'flex';
    }
    
    function hideGameOver() {
      gameOverModal.style.display = 'none';
      gameRunning = true;
    }
    
    function restartGame() {
      // Reset all game variables
      player = { x: canvas.width / 2, y: canvas.height - 50, width: 30, height: 30, speed: 5 };
      bullets = [];
      enemies = [];
      powerUps = [];
      missiles = [];
      bombs = 0;
      score = 0;
      health = 100;
      overheat = 0;
      cooldown = false;
      fireRate = 0;
      missileRate = 0;
      mouseX = canvas.width / 2;
      mouseY = canvas.height - 50;
      firing = false;
      lastShot = 0;
      
      hideGameOver();
      gameLoop(); // Restart the game loop
    }
    
    // Modal event handlers
    gameOverModal.addEventListener('click', restartGame);
    gameOverModal.addEventListener('touchend', (e) => {
      e.preventDefault();
      restartGame();
    });

    // Event handling functions
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      
      if (e.touches && e.touches.length > 0) {
        // Touch event
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        // Mouse event
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Calculate position relative to canvas bounds
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      
      // Scale coordinates from display size to canvas internal size
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      return {
        x: x * scaleX,
        y: y * scaleY
      };
    }

    function handleMove(e) {
      e.preventDefault(); // Prevent scrolling
      const pos = getEventPos(e);
      mouseX = pos.x;
      mouseY = pos.y;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
    }

    function handleStart(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = true;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
      
      // Update position on touch start
      if (e.touches) {
        const pos = getEventPos(e);
        mouseX = pos.x;
        mouseY = pos.y;
        touchStartTime = Date.now();
        touchStartPos = { x: pos.x, y: pos.y };
      }
    }

    function handleEnd(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = false;
      
      // Check for bomb trigger on touch (tap without much movement)
      if (e.changedTouches) {
        const touchDuration = Date.now() - touchStartTime;
        const pos = getEventPos({ touches: e.changedTouches });
        const distance = Math.sqrt(
          Math.pow(pos.x - touchStartPos.x, 2) + 
          Math.pow(pos.y - touchStartPos.y, 2)
        );
        
        // If it was a short tap (< 200ms) with minimal movement (< 20px), trigger bomb
        if (touchDuration < 200 && distance < 20) {
          useBomb();
        }
        
        // Reset touch tracking when touch ends
        isCurrentlyTouch = false;
      }
    }

    // Mouse event listeners
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mouseup', handleEnd);

    // Touch event listeners
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });

    // Game functions
    function drawPlayer() {
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
    }

    function drawBullets() {
      ctx.fillStyle = '#ffff00';
      bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - 2, bullet.y - 5, 4, 10);
      });
    }

    function drawEnemies() {
      ctx.fillStyle = '#ff0000';
      enemies.forEach(enemy => {
        ctx.fillRect(enemy.x - 15, enemy.y - 15, 30, 30);
      });
    }

    function drawPowerUps() {
      powerUps.forEach(powerUp => {
        ctx.fillStyle = powerUp.type === 'fire' ? '#ff00ff' : powerUp.type === 'missile' ? '#00ffff' : '#ffffff';
        ctx.fillRect(powerUp.x - 10, powerUp.y - 10, 20, 20);
      });
    }

    function drawMissiles() {
      ctx.fillStyle = '#ff8800';
      missiles.forEach(missile => {
        ctx.fillRect(missile.x - 3, missile.y - 8, 6, 16);
      });
    }

    function updatePlayer() {
      if (isCurrentlyTouch) {
        // For touch: offset the ship above the finger to avoid blocking the view
        const shipOffset = 80; // Move ship up by this amount from finger position
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, mouseY - shipOffset));
      } else {
        // For mouse: normal positioning
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, mouseY));
      }
    }

    function updateBullets() {
      bullets = bullets.filter(bullet => bullet.y > 0);
      bullets.forEach(bullet => {
        bullet.y -= 10;
      });
    }

    function updateEnemies() {
      enemies.forEach(enemy => {
        enemy.y += 2;
      });
      enemies = enemies.filter(enemy => enemy.y < canvas.height + 20);
    }

    function updatePowerUps() {
      powerUps.forEach(powerUp => {
        powerUp.y += 1;
      });
      powerUps = powerUps.filter(powerUp => powerUp.y < canvas.height + 20);
    }

    function updateMissiles() {
      missiles.forEach(missile => {
        missile.y -= 8;
      });
      missiles = missiles.filter(missile => missile.y > 0);
    }

    function checkCollisions() {
      // Bullets vs Enemies
      bullets.forEach(bullet => {
        enemies.forEach(enemy => {
          if (Math.abs(bullet.x - enemy.x) < 20 && Math.abs(bullet.y - enemy.y) < 20) {
            bullets.splice(bullets.indexOf(bullet), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 10;
          }
        });
      });

      // Missiles vs Enemies
      missiles.forEach(missile => {
        enemies.forEach(enemy => {
          if (Math.abs(missile.x - enemy.x) < 20 && Math.abs(missile.y - enemy.y) < 20) {
            missiles.splice(missiles.indexOf(missile), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 20;
          }
        });
      });

      // Player vs Enemies
      enemies.forEach(enemy => {
        if (Math.abs(player.x - enemy.x) < 25 && Math.abs(player.y - enemy.y) < 25) {
          enemies.splice(enemies.indexOf(enemy), 1);
          health -= 10;
        }
      });

      // Player vs PowerUps
      powerUps.forEach(powerUp => {
        if (Math.abs(player.x - powerUp.x) < 20 && Math.abs(player.y - powerUp.y) < 20) {
          powerUps.splice(powerUps.indexOf(powerUp), 1);
          if (powerUp.type === 'fire') {
            fireRate = Math.min(fireRate + 1, 2);
          } else if (powerUp.type === 'missile') {
            missileRate = Math.min(missileRate + 1, 1);
          } else if (powerUp.type === 'bomb') {
            bombs++;
          }
        }
      });
    }

    function fireBullet() {
      if (cooldown) return;
      
      const now = Date.now();
      if (now - lastShot < 100) return; // Fire rate limit
      
      lastShot = now;
      
      if (fireRate === 0) {
        bullets.push({ x: player.x, y: player.y - 20 });
      } else if (fireRate === 1) {
        bullets.push({ x: player.x, y: player.y - 20 });
        bullets.push({ x: player.x - 10, y: player.y - 15 });
        bullets.push({ x: player.x + 10, y: player.y - 15 });
      } else if (fireRate === 2) {
        bullets.push({ x: player.x, y: player.y - 20 });
        bullets.push({ x: player.x - 10, y: player.y - 15 });
        bullets.push({ x: player.x + 10, y: player.y - 15 });
        bullets.push({ x: player.x - 20, y: player.y - 10 });
        bullets.push({ x: player.x + 20, y: player.y - 10 });
      }
      
      overheat += 5;
      if (overheat >= maxOverheat) {
        cooldown = true;
        overheat = maxOverheat;
        setTimeout(() => {
          cooldown = false;
          overheat = 0;
        }, 2000);
      }
    }

    function fireMissile() {
      if (missileRate > 0 && Math.random() < 0.1) { // Occasional missile fire
        missiles.push({ x: player.x, y: player.y - 20 });
      }
    }

    function useBomb() {
      if (bombs > 0) {
        enemies = [];
        bombs--;
        score += 100;
      }
    }

    function spawnEnemies() {
      if (Math.random() < 0.02) {
        enemies.push({ x: Math.random() * canvas.width, y: -20 });
      }
    }

    function spawnPowerUps() {
      if (Math.random() < 0.005) {
        const types = ['fire', 'missile', 'bomb'];
        powerUps.push({ x: Math.random() * canvas.width, y: -20, type: types[Math.floor(Math.random() * types.length)] });
      }
    }

    function updateUI() {
      scoreEl.textContent = score;
      healthEl.textContent = health;
      bombsEl.textContent = bombs;
      overheatFill.style.width = `${(overheat / maxOverheat) * 100}%`;
      if (cooldown) {
        overheatFill.classList.add('cooldown');
      } else {
        overheatFill.classList.remove('cooldown');
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      updatePlayer();
      updateBullets();
      updateEnemies();
      updatePowerUps();
      updateMissiles();
      checkCollisions();
      
      if (firing) {
        fireBullet();
      }
      fireMissile();
      
      spawnEnemies();
      spawnPowerUps();
      
      drawPlayer();
      drawBullets();
      drawEnemies();
      drawPowerUps();
      drawMissiles();
      
      updateUI();
      
      if (health <= 0 && gameRunning) {
        showGameOver();
        return; // Stop the game loop
      }
      
      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      }
    }

    // Keyboard for bomb (spacebar)
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        useBomb();
      }
    });

    // Prevent any page scrolling/dragging on mobile
    document.addEventListener('touchstart', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    gameLoop();
  </script>
</body>
</html>
