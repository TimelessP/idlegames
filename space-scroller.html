<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Space Scroller</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none; /* Prevent any touch gestures on the page */
      -webkit-user-select: none; /* Prevent text selection */
      user-select: none;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    canvas {
      outline: 2px solid #fff;
      background: #000;
      display: block;
      touch-action: none; /* Prevent default touch behaviors */
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      max-width: none;
      max-height: none;
    }
    @media (max-width: 768px) {
      .hud { font-size: 14px; }
    }
    /* Heads-up display */
    .hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 150;
      padding: 8px 12px;
      box-sizing: border-box;
      font-size: 18px;
      pointer-events: none; /* let gameplay through, except explicit controls */
    }
    .hud-row { width: 100%; margin-bottom: 6px; }
    .hud-row.stats {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      align-items: center;
      gap: 8px;
    }
    .stat { display: flex; align-items: center; gap: 6px; min-height: 24px; }
    .stat .emoji { filter: drop-shadow(0 1px 1px rgba(0,0,0,0.4)); }
    .dim { opacity: 0.4; }
    
    /* Game Over Modal */
    .game-over-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      touch-action: manipulation;
    }
    
    .game-over-content {
      text-align: center;
      color: #fff;
      padding: 2rem;
      max-width: 90%;
    }
    
    .game-over-title {
      font-size: 3rem;
      font-weight: bold;
      color: #ff4444;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    .game-over-score {
      font-size: 2rem;
      margin-bottom: 2rem;
      color: #ffff44;
    }
    
    .game-over-instruction {
      font-size: 1.2rem;
      opacity: 0.8;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 0.4; }
    }
    
    @media (max-width: 768px) {
      .game-over-title {
        font-size: 2rem;
      }
      .game-over-score {
        font-size: 1.5rem;
      }
      .game-over-instruction {
        font-size: 1rem;
      }
    }
    .ui div {
      margin-bottom: 5px;
    }
    .overheat-bar {
      width: 100%;
      height: 16px;
      background: #333;
      border: 1px solid #fff;
      margin-top: 0;
    }
    .overheat-fill {
      height: 100%;
      background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
      width: 0%;
      transition: width 0.1s;
    }
    .cooldown {
      background: #666 !important;
    }
    /* Fullscreen button */
    .fullscreen-btn {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      color: #fff;
      border: 2px solid #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 200;
      cursor: pointer;
      pointer-events: auto; /* clickable over canvas */
      backdrop-filter: blur(2px);
    }
    .fullscreen-btn:active { transform: scale(0.97); }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hud-row stats">
      <div class="stat"><span class="emoji">🪙</span><span id="score">0</span></div>
      <div class="stat"><span id="hearts"></span></div>
      <div class="stat"><span id="bomb-icons"></span></div>
      <div class="stat"><span id="wingmen"></span></div>
      <div class="stat"><span id="fire-power"></span></div>
      <div class="stat"><span id="missile-power"></span></div>
      <div class="stat"><span id="homing-power"></span></div>
    </div>
    <div class="hud-row">
      <div class="overheat-bar">
        <div class="overheat-fill" id="overheat-fill"></div>
      </div>
    </div>
  </div>
  <button id="fullscreenBtn" class="fullscreen-btn" aria-label="Toggle Fullscreen">⛶</button>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <!-- Game Over Modal -->
  <div id="gameOverModal" class="game-over-modal">
    <div class="game-over-content">
      <div class="game-over-title">GAME OVER</div>
      <div class="game-over-score">Final Score: <span id="finalScore">0</span></div>
      <div class="game-over-instruction">Tap anywhere to restart</div>
    </div>
  </div>
  
  <script>
  const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const heartsEl = document.getElementById('hearts');
  const bombIconsEl = document.getElementById('bomb-icons');
  const wingmenEl = document.getElementById('wingmen');
  const firePowerEl = document.getElementById('fire-power');
  const missilePowerEl = document.getElementById('missile-power');
  const homingPowerEl = document.getElementById('homing-power');
    const overheatFill = document.getElementById('overheat-fill');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');

  // Game variables
  let player = { x: 0, y: 0, width: 30, height: 30, speed: 5 };
    let bullets = [];
    let enemies = [];
    let powerUps = [];
    let missiles = [];
    let bombs = 0;
    let score = 0;
    let health = 100;
    let overheat = 0;
    let maxOverheat = 100;
    let cooldown = false;
    let fireRate = 0; // directions: 0=single, 1=3-way, 2=5-way
  let missileRate = 0; // 0=none, 1=basic missiles
  // Wingmen state
  let wingmenCount = 0; // 0..3
  let wingmenPositions = [];
  const WINGMAN_MAX = 3;
  // Homing missiles power-up state
  let homingActive = false;
  let homingExpire = 0;
  let lastHomingLaunch = 0;
  const HOMING_INTERVAL = 500; // ms
  const HOMING_SPEED = 6; // px per frame
  const HOMING_TURN = 0.12; // radians per frame
  const COOL_RATE = 1; // heat reduced per frame when not firing
  // Power-ups spawn randomly with equal probability per type

  let mouseX = 0;
  let mouseY = 0;
  // Viewport scaling
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let viewW = 0, viewH = 0;
  let scaleUnit = 1; // relative to base 600 min-dimension
  // Scaled metrics
  let shipW = 30, shipH = 30, enemySize = 30, powerUpSize = 20, bulletW = 4, bulletH = 10, missileW = 6, missileH = 16;
  let shipOffsetTouch = 80; // finger offset
  let collBulletEnemy = 20, collPlayerEnemy = 25, collPlayerPower = 20;
  let spread10 = 10, spread20 = 20, wingmanOff = 60;
  
  // Handle canvas/device pixel ratio and scaled metrics
  function resizeCanvas() {
    const rect = document.documentElement.getBoundingClientRect();
    viewW = window.innerWidth || rect.width;
    viewH = window.innerHeight || rect.height;
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(viewW * dpr);
    canvas.height = Math.floor(viewH * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    // scale unit based on smaller dimension vs base 600
    scaleUnit = Math.max(0.5, Math.min(2.5, Math.min(viewW, viewH) / 600));
    // update scaled metrics
    shipW = 30 * scaleUnit; shipH = 30 * scaleUnit;
    enemySize = 30 * scaleUnit; powerUpSize = 20 * scaleUnit;
    bulletW = 4 * scaleUnit; bulletH = 10 * scaleUnit;
    missileW = 6 * scaleUnit; missileH = 16 * scaleUnit;
    shipOffsetTouch = 80 * scaleUnit;
    collBulletEnemy = 20 * scaleUnit; collPlayerEnemy = 25 * scaleUnit; collPlayerPower = 20 * scaleUnit;
    spread10 = 10 * scaleUnit; spread20 = 20 * scaleUnit; wingmanOff = 60 * scaleUnit;
    // sync player size to scaled metrics and clamp position to viewport
    player.width = shipW; player.height = shipH;
    player.x = Math.max(player.width/2, Math.min(viewW - player.width/2, player.x));
    player.y = Math.max(player.height/2, Math.min(viewH - player.height/2, player.y));
  }
  window.addEventListener('resize', resizeCanvas);
  // Initial sizing
  resizeCanvas();
  // initialize position to bottom-center relative to viewport
  player.x = viewW / 2;
  player.y = viewH - shipH;
  mouseX = player.x; mouseY = player.y;
    let firing = false;
    let lastShot = 0;
    let touchStartTime = 0;
    let touchStartPos = { x: 0, y: 0 };
    let isCurrentlyTouch = false; // Track if current interaction is touch
    let gameRunning = true; // Track if game is running

    // Game Over Modal Functions
    function showGameOver() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      gameOverModal.style.display = 'flex';
    }
    
    function hideGameOver() {
      gameOverModal.style.display = 'none';
      gameRunning = true;
    }
    
    function restartGame() {
      // Reset all game variables
      player = { x: viewW / 2, y: viewH - shipH, width: shipW, height: shipH, speed: 5 };
      bullets = [];
      enemies = [];
      powerUps = [];
      missiles = [];
      bombs = 0;
      score = 0;
      health = 100;
      overheat = 0;
      cooldown = false;
      fireRate = 0;
      missileRate = 0;
  wingmenCount = 0;
  wingmenPositions = [];
  homingActive = false;
  homingExpire = 0;
  lastHomingLaunch = 0;
      mouseX = viewW / 2;
      mouseY = viewH - shipH;
      firing = false;
      lastShot = 0;
      
      hideGameOver();
      gameLoop(); // Restart the game loop
    }
    
    // Modal event handlers
    gameOverModal.addEventListener('click', restartGame);
    gameOverModal.addEventListener('touchend', (e) => {
      e.preventDefault();
      restartGame();
    });

    // Event handling functions
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      
      if (e.touches && e.touches.length > 0) {
        // Touch event
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        // Mouse event
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Position in CSS pixels relative to canvas
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      return { x, y };
    }

    function handleMove(e) {
      e.preventDefault(); // Prevent scrolling
      const pos = getEventPos(e);
      mouseX = pos.x;
      mouseY = pos.y;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
    }

    function handleStart(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = true;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
      
      // Update position on touch start
      if (e.touches) {
        const pos = getEventPos(e);
        mouseX = pos.x;
        mouseY = pos.y;
        touchStartTime = Date.now();
        touchStartPos = { x: pos.x, y: pos.y };
      }
    }

    function handleEnd(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = false;
      
      // Check for bomb trigger on touch (tap without much movement)
      if (e.changedTouches) {
        const touchDuration = Date.now() - touchStartTime;
        const pos = getEventPos({ touches: e.changedTouches });
        const distance = Math.sqrt(
          Math.pow(pos.x - touchStartPos.x, 2) + 
          Math.pow(pos.y - touchStartPos.y, 2)
        );
        
        // If it was a short tap (< 200ms) with minimal movement (< 20px), trigger bomb
        if (touchDuration < 200 && distance < 20) {
          useBomb();
        }
        
        // Reset touch tracking when touch ends
        isCurrentlyTouch = false;
      }
    }

    // Mouse event listeners
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mouseup', handleEnd);

    // Touch event listeners
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });

    // Game functions
    function drawPlayer() {
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
    }

    function getWingmanOffsets(count) {
      switch (count) {
        case 1:
          return [{ x: -wingmanOff, y: 0 }];
        case 2:
          return [{ x: -wingmanOff, y: 0 }, { x: wingmanOff, y: 0 }];
        case 3:
          return [{ x: -wingmanOff, y: 0 }, { x: wingmanOff, y: 0 }, { x: 0, y: -wingmanOff }];
        default:
          return [];
      }
    }

    function updateWingmenPositions() {
      const offsets = getWingmanOffsets(wingmenCount);
      wingmenPositions = offsets.map(off => {
        const x = player.x + off.x;
        const y = player.y + off.y;
        return {
          x: Math.max(player.width/2, Math.min(viewW - player.width/2, x)),
          y: Math.max(player.height/2, Math.min(viewH - player.height/2, y))
        };
      });
    }

    function drawWingmen() {
      if (wingmenCount <= 0) return;
      ctx.fillStyle = '#44ff44';
      wingmenPositions.forEach(p => {
        ctx.fillRect(p.x - player.width/2, p.y - player.height/2, player.width, player.height);
      });
    }

    function drawBullets() {
      ctx.fillStyle = '#ffff00';
      bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bulletW/2, bullet.y - bulletH/2, bulletW, bulletH);
      });
    }

    function drawEnemies() {
      ctx.fillStyle = '#ff0000';
      enemies.forEach(enemy => {
        ctx.fillRect(enemy.x - enemySize/2, enemy.y - enemySize/2, enemySize, enemySize);
      });
    }

    function drawPowerUps() {
      powerUps.forEach(powerUp => {
        if (powerUp.type === 'fire') ctx.fillStyle = '#ff00ff';
        else if (powerUp.type === 'missile') ctx.fillStyle = '#00ffff';
        else if (powerUp.type === 'bomb') ctx.fillStyle = '#ffffff';
        else if (powerUp.type === 'wingman') ctx.fillStyle = '#00ff88';
        else if (powerUp.type === 'homing') ctx.fillStyle = '#ffaa00';
        else ctx.fillStyle = '#ffffff';
        ctx.fillRect(powerUp.x - powerUpSize/2, powerUp.y - powerUpSize/2, powerUpSize, powerUpSize);
      });
    }

    function drawMissiles() {
      ctx.fillStyle = '#ff8800';
      missiles.forEach(missile => {
        ctx.fillRect(missile.x - missileW/2, missile.y - missileH/2, missileW, missileH);
      });
    }

    function updatePlayer() {
      if (isCurrentlyTouch) {
        // For touch: offset the ship above the finger to avoid blocking the view
  const shipOffset = shipOffsetTouch; // scaled finger offset
        player.x = Math.max(player.width/2, Math.min(viewW - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(viewH - player.height/2, mouseY - shipOffset));
      } else {
        // For mouse: normal positioning
        player.x = Math.max(player.width/2, Math.min(viewW - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(viewH - player.height/2, mouseY));
      }
    }

    function updateBullets() {
      bullets = bullets.filter(bullet => bullet.y > 0);
      bullets.forEach(bullet => {
        bullet.y -= 10;
      });
    }

    function updateEnemies() {
      enemies.forEach(enemy => {
        enemy.y += 2;
      });
      enemies = enemies.filter(enemy => enemy.y < viewH + enemySize);
    }

    function updatePowerUps() {
      powerUps.forEach(powerUp => {
        powerUp.y += 1;
      });
      powerUps = powerUps.filter(powerUp => powerUp.y < viewH + powerUpSize);
    }

    function updateMissiles() {
      missiles.forEach(missile => {
        if (missile.homing) {
          // Find nearest enemy and steer toward it
          let nearest = null;
          let bestD2 = Infinity;
          for (const e of enemies) {
            const dx = e.x - missile.x;
            const dy = e.y - missile.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestD2) { bestD2 = d2; nearest = e; }
          }
          if (nearest) {
            const desired = Math.atan2(nearest.y - missile.y, nearest.x - missile.x);
            const current = Math.atan2(missile.vy, missile.vx);
            let diff = desired - current;
            while (diff > Math.PI) diff -= 2*Math.PI;
            while (diff < -Math.PI) diff += 2*Math.PI;
            const turn = Math.max(-HOMING_TURN, Math.min(HOMING_TURN, diff));
            const newAngle = current + turn;
            const spd = missile.speed || HOMING_SPEED;
            missile.vx = Math.cos(newAngle) * spd;
            missile.vy = Math.sin(newAngle) * spd;
          }
          missile.x += missile.vx;
          missile.y += missile.vy;
        } else {
          missile.y -= 8;
        }
      });
      missiles = missiles.filter(missile => {
        if (missile.homing) {
          return missile.x > -missileW && missile.x < viewW + missileW && missile.y > -missileH && missile.y < viewH + missileH;
        } else {
          return missile.y > 0;
        }
      });
    }

    function checkCollisions() {
      // Bullets vs Enemies
      bullets.forEach(bullet => {
        enemies.forEach(enemy => {
          if (Math.abs(bullet.x - enemy.x) < collBulletEnemy && Math.abs(bullet.y - enemy.y) < collBulletEnemy) {
            bullets.splice(bullets.indexOf(bullet), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 10;
          }
        });
      });

      // Missiles vs Enemies
      missiles.forEach(missile => {
        enemies.forEach(enemy => {
          if (Math.abs(missile.x - enemy.x) < collBulletEnemy && Math.abs(missile.y - enemy.y) < collBulletEnemy) {
            missiles.splice(missiles.indexOf(missile), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 20;
          }
        });
      });

      // Wingmen vs Enemies: if a wingman hits an enemy, remove both and lose one wingman
      if (wingmenCount > 0 && wingmenPositions.length > 0) {
        enemies.slice().forEach(enemy => {
          for (const w of wingmenPositions) {
            if (Math.abs(w.x - enemy.x) < collPlayerEnemy && Math.abs(w.y - enemy.y) < collPlayerEnemy) {
              const idx = enemies.indexOf(enemy);
              if (idx !== -1) enemies.splice(idx, 1);
              wingmenCount = Math.max(0, wingmenCount - 1);
              break;
            }
          }
        });
      }

      // Player vs Enemies
      enemies.slice().forEach(enemy => {
        if (Math.abs(player.x - enemy.x) < collPlayerEnemy && Math.abs(player.y - enemy.y) < collPlayerEnemy) {
          const idx = enemies.indexOf(enemy);
          if (idx !== -1) enemies.splice(idx, 1);
          if (wingmenCount > 0) {
            wingmenCount = Math.max(0, wingmenCount - 1);
          } else {
            health -= 10;
          }
        }
      });

      // Player vs PowerUps
      powerUps.forEach(powerUp => {
        if (Math.abs(player.x - powerUp.x) < collPlayerPower && Math.abs(player.y - powerUp.y) < collPlayerPower) {
          powerUps.splice(powerUps.indexOf(powerUp), 1);
          if (powerUp.type === 'fire') {
            fireRate = Math.min(fireRate + 1, 2);
          } else if (powerUp.type === 'missile') {
            missileRate = Math.min(missileRate + 1, 1);
          } else if (powerUp.type === 'bomb') {
            bombs++;
          } else if (powerUp.type === 'wingman') {
            wingmenCount = Math.min(WINGMAN_MAX, wingmenCount + 1);
          } else if (powerUp.type === 'homing') {
            const now = Date.now();
            homingActive = true;
            const EXT = 10000; // 10 seconds per pickup
            homingExpire = Math.max(homingExpire, now) + EXT;
          }
        }
      });
    }

    function fireBullet() {
      if (cooldown) return;
      
      const now = Date.now();
      if (now - lastShot < 100) return; // Fire rate limit
      
      lastShot = now;
      
      const shooters = [{ x: player.x, y: player.y }, ...wingmenPositions];
      const addPattern = (sx, sy) => {
        if (fireRate === 0) {
          bullets.push({ x: sx, y: sy - 20 * scaleUnit });
        } else if (fireRate === 1) {
          bullets.push({ x: sx, y: sy - 20 * scaleUnit });
          bullets.push({ x: sx - spread10, y: sy - 15 * scaleUnit });
          bullets.push({ x: sx + spread10, y: sy - 15 * scaleUnit });
        } else if (fireRate === 2) {
          bullets.push({ x: sx, y: sy - 20 * scaleUnit });
          bullets.push({ x: sx - spread10, y: sy - 15 * scaleUnit });
          bullets.push({ x: sx + spread10, y: sy - 15 * scaleUnit });
          bullets.push({ x: sx - spread20, y: sy - 10 * scaleUnit });
          bullets.push({ x: sx + spread20, y: sy - 10 * scaleUnit });
        }
      };
      shooters.forEach(s => addPattern(s.x, s.y));
      
      overheat += 5;
      if (overheat >= maxOverheat) {
        overheat = maxOverheat;
        cooldown = true; // lock firing until cooled below threshold
      }
    }

    function fireMissile() {
      if (missileRate > 0 && Math.random() < 0.1) { // Occasional missile fire
        missiles.push({ x: player.x, y: player.y - 20 * scaleUnit });
      }
    }

    function maybeLaunchHoming() {
      const now = Date.now();
      if (!homingActive) return;
      if (now >= homingExpire) { homingActive = false; return; }
      if (now - lastHomingLaunch >= HOMING_INTERVAL) {
        missiles.push({ x: player.x, y: player.y - 20 * scaleUnit, vx: 0, vy: -HOMING_SPEED, speed: HOMING_SPEED, homing: true });
        lastHomingLaunch = now;
      }
    }

    function useBomb() {
      if (bombs > 0) {
        enemies = [];
        bombs--;
        score += 100;
      }
    }

    function spawnEnemies() {
      if (Math.random() < 0.02) {
        enemies.push({ x: Math.random() * viewW, y: -enemySize });
      }
    }

    function spawnPowerUps() {
      if (Math.random() < 0.005) {
        const types = ['fire', 'missile', 'bomb', 'wingman', 'homing'];
        powerUps.push({ x: Math.random() * viewW, y: -powerUpSize, type: types[Math.floor(Math.random() * types.length)] });
      }
    }


    function updateUI() {
      // Score
      scoreEl.textContent = score;

      // Health as hearts: 10 total, turn black as we lose 10% each
      const totalHearts = 10;
      const filled = Math.max(0, Math.min(totalHearts, Math.ceil((health / 100) * totalHearts)));
      let heartsHTML = '';
      for (let i = 0; i < totalHearts; i++) {
        heartsHTML += i < filled ? '❤️' : '🖤';
      }
      heartsEl.innerHTML = heartsHTML;

      // Bombs as emojis, max 5 shown even if we have more
      const shownBombs = Math.min(5, bombs);
      bombIconsEl.innerHTML = '💣'.repeat(shownBombs) + (bombs > 5 ? ` ×${bombs}` : '');

      // Wingmen as emojis, one per wingman present
      wingmenEl.innerHTML = '🛩️'.repeat(wingmenCount);

  // Fire power: 0..2 → show 1-3 flames to indicate spread levels
  const flames = ['🔥', '🔥🔥', '🔥🔥🔥'];
  firePowerEl.textContent = flames[fireRate] || '';
  firePowerEl.classList.toggle('dim', fireRate === 0);

  // Missile power: 0/1 → show rockets when active
  missilePowerEl.textContent = missileRate > 0 ? '🚀' : '🚀';
  missilePowerEl.classList.toggle('dim', missileRate === 0);

  // Homing power: active window indicator; simple target emoji, dim when inactive
  const nowMs = Date.now();
  const homingActiveNow = homingActive && nowMs < homingExpire;
  homingPowerEl.textContent = '🎯';
  homingPowerEl.classList.toggle('dim', !homingActiveNow);

      // Overheat bar
      overheatFill.style.width = `${(overheat / maxOverheat) * 100}%`;
      if (cooldown) {
        overheatFill.classList.add('cooldown');
      } else {
        overheatFill.classList.remove('cooldown');
      }
    }

    // Fullscreen toggle
    function toggleFullscreen() {
      const elem = document.documentElement;
      if (!document.fullscreenElement) {
        if (elem.requestFullscreen) elem.requestFullscreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
      }
    }
    fullscreenBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); toggleFullscreen(); });

    function gameLoop() {
      ctx.clearRect(0, 0, viewW, viewH);

  updatePlayer();
  updateWingmenPositions();
  updateBullets();
      updateEnemies();
      updatePowerUps();
      updateMissiles();
      checkCollisions();
      // Passive cooling when not firing
      if (!firing && overheat > 0) {
        overheat = Math.max(0, overheat - COOL_RATE);
        if (cooldown && overheat <= maxOverheat * 0.6) {
          cooldown = false; // unlock when sufficiently cooled
        }
      }
      
      if (firing) {
        fireBullet();
      }
  fireMissile();
  maybeLaunchHoming();
      
    spawnEnemies();
    spawnPowerUps();
      
  drawPlayer();
  drawWingmen();
      drawBullets();
      drawEnemies();
      drawPowerUps();
      drawMissiles();
      
      updateUI();
      
      if (health <= 0 && gameRunning) {
        showGameOver();
        return; // Stop the game loop
      }
      
      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      }
    }

    // Keyboard for bomb (spacebar)
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        useBomb();
      }
    });

    // Prevent any page scrolling/dragging on mobile
    document.addEventListener('touchstart', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    gameLoop();
  </script>
</body>
</html>
