<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Space Scroller</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none; /* Prevent any touch gestures on the page */
      -webkit-user-select: none; /* Prevent text selection */
      user-select: none;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    canvas {
      outline: 0.125rem solid #fff;
      background: #000;
      display: block;
      touch-action: none; /* Prevent default touch behaviors */
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      max-width: none;
      max-height: none;
    }
    @media (max-width: 48em) {
      .hud { font-size: var(--hudFont, 0.875rem); }
    }
    /* Heads-up display */
    .hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 150;
      padding: 0.5em 0.75em;
      box-sizing: border-box;
      font-size: var(--hudFont, 1.125rem);
      /* allow selective interactivity per row */
    }
    .hud-row { width: 100%; margin-bottom: 0.375em; pointer-events: none; }
    .hud-row.stats {
      display: grid;
  /* Score reduced, hearts expanded; others unchanged */
  grid-template-columns: 2fr 4fr 3fr 2fr 2fr 2fr 2fr;
      align-items: center;
      gap: 0.5em;
    }
    .stat { display: flex; align-items: center; gap: 0.375em; min-height: 1.5em; }
    .stat .emoji { filter: drop-shadow(0 0.0625em 0.0625em rgba(0,0,0,0.4)); }
    .dim { opacity: 0.4; }
  /* Color pills to match power-up colors */
  .pill { display: inline-flex; align-items: center; justify-content: center; padding: 0 0.375em; border-radius: 0.5em; margin-right: 0.125em; line-height: 1.1; border: 0.0625em solid rgba(255,255,255,0.35); }
  .magenta { background: rgba(255,0,255,0.18); border-color: rgba(255,0,255,0.85); }
  .cyan { background: rgba(0,255,255,0.18); border-color: rgba(0,255,255,0.85); }
  .white { background: rgba(255,255,255,0.18); border-color: rgba(255,255,255,0.85); }
  .green { background: rgba(0,255,136,0.18); border-color: rgba(0,255,136,0.85); }
  .orange { background: rgba(255,170,0,0.18); border-color: rgba(255,170,0,0.85); }
  .red { background: rgba(255,0,0,0.18); border-color: rgba(255,0,0,0.85); }
    
    /* Game Over Modal */
    .game-over-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      touch-action: manipulation;
    }
    
    .game-over-content {
      text-align: center;
      color: #fff;
      padding: 2rem;
      max-width: 90%;
    }
    
    .game-over-title {
      font-size: 3rem;
      font-weight: bold;
      color: #ff4444;
      margin-bottom: 1rem;
      text-shadow: 0.125rem 0.125rem 0.25rem rgba(0,0,0,0.8);
    }
    
    .game-over-score {
      font-size: 2rem;
      margin-bottom: 2rem;
      color: #ffff44;
    }
    
    .game-over-instruction {
      font-size: 1.2rem;
      opacity: 0.8;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 0.4; }
    }
    
    @media (max-width: 48em) {
      .game-over-title {
        font-size: 2rem;
      }
      .game-over-score {
        font-size: 1.5rem;
      }
      .game-over-instruction {
        font-size: 1rem;
      }
    }
    .ui div {
      margin-bottom: 0.3125rem;
    }
    .overheat-bar {
      width: 100%;
      height: 1em;
      background: #333;
      border: 0.0625em solid rgba(255,255,255,0.35);
      border-radius: 0.375em;
      margin-top: 0.625em;
    }
    .overheat-fill {
      height: 100%;
      background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
      width: 0%;
      transition: width 0.1s;
      border-radius: 0.375em;
    }
      /* Controls row below overheat bar */
      .controls-row {
        display: flex;
        justify-content: flex-end;
        gap: 0.5em;
        pointer-events: auto; /* enable interactivity for buttons */
      }
      .fullscreen-btn, .pause-btn {
        position: static;
        width: 2.6em;
        height: 2.6em;
        border-radius: 50%;
        background: rgba(255,255,255,0.1);
        color: #fff;
        border: 0.125rem solid #fff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1em;
        cursor: pointer;
        pointer-events: auto; /* clickable despite parent */
        backdrop-filter: blur(0.125rem);
      }
      .fullscreen-btn:active, .pause-btn:active { transform: scale(0.97); }
    .cooldown {
      background: #666 !important;
    }

    /* Paused overlay */
    .paused-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 900; /* below game-over modal (1000), above canvas */
      pointer-events: none; /* allow clicks to pass through */
    }
    .paused-overlay .paused-text {
      color: #fff;
      font-weight: bold;
      text-shadow: 0.125rem 0.125rem 0.375rem rgba(0,0,0,0.8);
      font-size: clamp(1.5rem, 10vw, 4.5rem);
      letter-spacing: 0.25em;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="hud-row stats">
      <div class="stat"><span class="emoji">ü™ô</span><span id="score">0</span></div>
      <div class="stat"><span id="hearts"></span></div>
      <div class="stat"><span id="bomb-icons"></span></div>
      <div class="stat"><span id="wingmen"></span></div>
      <div class="stat"><span id="fire-power"></span></div>
      <div class="stat"><span id="missile-power"></span></div>
      <div class="stat"><span id="homing-power"></span></div>
    </div>
    <div class="hud-row">
      <div class="overheat-bar">
        <div class="overheat-fill" id="overheat-fill"></div>
      </div>
    </div>
    <div class="hud-row controls-row">
      <button id="pauseBtn" class="pause-btn" aria-label="Pause">‚è∏</button>
      <button id="fullscreenBtn" class="fullscreen-btn" aria-label="Toggle Fullscreen">‚õ∂</button>
    </div>
  </div>
  
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <!-- Paused Overlay -->
  <div id="pausedOverlay" class="paused-overlay"><div class="paused-text">PAUSED</div></div>
  
  <!-- Game Over Modal -->
  <div id="gameOverModal" class="game-over-modal">
    <div class="game-over-content">
      <div class="game-over-title">GAME OVER</div>
      <div class="game-over-score">Final Score: <span id="finalScore">0</span></div>
      <div class="game-over-instruction">Tap anywhere to restart</div>
    </div>
  </div>
  
  <script>
  const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const heartsEl = document.getElementById('hearts');
  const bombIconsEl = document.getElementById('bomb-icons');
  const wingmenEl = document.getElementById('wingmen');
  const firePowerEl = document.getElementById('fire-power');
  const missilePowerEl = document.getElementById('missile-power');
  const homingPowerEl = document.getElementById('homing-power');
  const overheatFill = document.getElementById('overheat-fill');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');
  const pausedOverlay = document.getElementById('pausedOverlay');

  // Game variables
  let player = { x: 0, y: 0, width: 30, height: 30, speed: 5 };
    let bullets = [];
    let enemies = [];
    let powerUps = [];
    let missiles = [];
    let bombs = 0;
    let score = 0;
    let health = 100;
    let overheat = 0;
    let maxOverheat = 100;
    let cooldown = false;
    let fireRate = 0; // directions: 0=single, 1=3-way, 2=5-way
  let missileRate = 0; // 0=none, 1=up, 2=¬±15¬∞, 3=up + ¬±15¬∞
  // Wingmen state
  let wingmenCount = 0; // 0..3
  let wingmenPositions = [];
  const WINGMAN_MAX = 3;
  // Homing missiles power-up state (stacked)
  let homingActive = false; // derived from stacks > 0
  let homingStacks = 0; // 0..3 stacks queued
  let homingNextExpiry = 0; // timestamp when current stack expires
  let lastHomingLaunch = 0;
  const HOMING_INTERVAL = 500; // ms
  const HOMING_SPEED = 6; // px per frame
  const HOMING_TURN = 0.12; // radians per frame
  const COOL_RATE = 1; // heat reduced per frame when not firing
  let overheatPenaltyApplied = false; // ensure penalty applies once per life until power is minimal
  // Power-ups spawn randomly with equal probability per type

  let mouseX = 0;
  let mouseY = 0;
  // Viewport scaling
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let viewW = 0, viewH = 0;
  let scaleUnit = 1; // relative to base 600 min-dimension
  // Scaled metrics
  let shipW = 30, shipH = 30, enemySize = 30, powerUpSize = 20, bulletW = 4, bulletH = 10, missileW = 6, missileH = 16;
  let shipOffsetTouch = 80; // finger offset
  let collBulletEnemy = 20, collPlayerEnemy = 25, collPlayerPower = 20;
  let spread10 = 10, spread20 = 20, wingmanOff = 60;
  
  // Handle canvas/device pixel ratio and scaled metrics
  function resizeCanvas() {
    const rect = document.documentElement.getBoundingClientRect();
    viewW = window.innerWidth || rect.width;
    viewH = window.innerHeight || rect.height;
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(viewW * dpr);
    canvas.height = Math.floor(viewH * dpr);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    // scale unit based on smaller dimension vs base 600
    scaleUnit = Math.max(0.5, Math.min(2.5, Math.min(viewW, viewH) / 600));
    // update scaled metrics
    shipW = 30 * scaleUnit; shipH = 30 * scaleUnit;
    enemySize = 30 * scaleUnit; powerUpSize = 20 * scaleUnit;
    bulletW = 4 * scaleUnit; bulletH = 10 * scaleUnit;
    missileW = 6 * scaleUnit; missileH = 16 * scaleUnit;
    shipOffsetTouch = 80 * scaleUnit;
    collBulletEnemy = 20 * scaleUnit; collPlayerEnemy = 25 * scaleUnit; collPlayerPower = 20 * scaleUnit;
    spread10 = 10 * scaleUnit; spread20 = 20 * scaleUnit; wingmanOff = 60 * scaleUnit;
    // sync player size to scaled metrics and clamp position to viewport
    player.width = shipW; player.height = shipH;
    player.x = Math.max(player.width/2, Math.min(viewW - player.width/2, player.x));
    player.y = Math.max(player.height/2, Math.min(viewH - player.height/2, player.y));
    // scale HUD font proportional to scaleUnit, clamped to a readable range
  const hudFont = Math.round(16 * scaleUnit);
  const hudPx = Math.max(12, Math.min(24, hudFont));
  document.documentElement.style.setProperty('--hudFont', (hudPx / 16).toFixed(3) + 'rem');
  }
  window.addEventListener('resize', resizeCanvas);
  // Initial sizing
  resizeCanvas();
  // initialize position to bottom-center relative to viewport
  player.x = viewW / 2;
  player.y = viewH - shipH;
  mouseX = player.x; mouseY = player.y;
    let firing = false;
    let lastShot = 0;
    let touchStartTime = 0;
    let touchStartPos = { x: 0, y: 0 };
  let isCurrentlyTouch = false; // Track if current interaction is touch
  let gameRunning = true; // Track if game is running
  let isPaused = false; // Track pause state

    // Game Over Modal Functions
    function showGameOver() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      gameOverModal.style.display = 'flex';
    }
    
    function hideGameOver() {
      gameOverModal.style.display = 'none';
      gameRunning = true;
    }
    
    function restartGame() {
      // Reset all game variables
      player = { x: viewW / 2, y: viewH - shipH, width: shipW, height: shipH, speed: 5 };
      bullets = [];
      enemies = [];
      powerUps = [];
      missiles = [];
      bombs = 0;
      score = 0;
      health = 100;
      overheat = 0;
      cooldown = false;
      fireRate = 0;
      missileRate = 0;
  wingmenCount = 0;
  wingmenPositions = [];
  homingActive = false;
  homingStacks = 0;
  homingNextExpiry = 0;
  lastHomingLaunch = 0;
    overheatPenaltyApplied = false;
      mouseX = viewW / 2;
      mouseY = viewH - shipH;
      firing = false;
      lastShot = 0;
      // Clear pause state on restart
      isPaused = false;
      gameRunning = true;
      if (pauseBtn) {
        pauseBtn.textContent = '‚è∏';
        pauseBtn.setAttribute('aria-label', 'Pause');
      }
      
      hideGameOver();
      gameLoop(); // Restart the game loop
    }
    
    // Modal event handlers
    gameOverModal.addEventListener('click', restartGame);
    gameOverModal.addEventListener('touchend', (e) => {
      e.preventDefault();
      restartGame();
    });

    // --- Floating Emoji Animations ---
    const floatAnims = [];
    function getElementCenter(el) {
      if (!el) return { x: viewW/2, y: 0 };
      const r = el.getBoundingClientRect();
      const c = canvas.getBoundingClientRect();
      return { x: r.left + r.width/2 - c.left, y: r.top + r.height/2 - c.top };
    }
    function addEmojiFloat(fromX, fromY, toX, toY, emoji, options = {}) {
      const start = Date.now();
      const speed = 1 + 0.7 * (Math.random() - 0.5);
      const duration = (options.duration || 700) * speed;
      const angle = (-1.2 + 2.4 * Math.random());
      const ampX = (options.ampX || 120) * (options.scaleAmpWithUnit ? scaleUnit : 1);
      const ampY = (options.ampY || 60) * (options.scaleAmpWithUnit ? scaleUnit : 1);
      const size = options.size || Math.max(16, Math.floor(viewH / 24));
      floatAnims.push({ start, duration, fromX, fromY, toX, toY, angle, ampX, ampY, emoji, size });
    }
    function addEmojiFloatToElement(fromX, fromY, toEl, emoji, options = {}) {
      const { x, y } = getElementCenter(toEl);
      addEmojiFloat(fromX, fromY, x, y, emoji, options);
    }
    function addEmojiFloatFromElement(fromEl, toX, toY, emoji, options = {}) {
      const { x, y } = getElementCenter(fromEl);
      addEmojiFloat(x, y, toX, toY, emoji, options);
    }
    function renderEmojiAnims() {
      if (!floatAnims.length) return false;
      const now = Date.now();
      let still = false;
      for (const anim of floatAnims) {
        const t = Math.min(1, (now - anim.start) / anim.duration);
        if (t < 1) still = true;
        const ease = 1 - Math.pow(1 - t, 3);
        const x = anim.fromX + (anim.toX - anim.fromX) * ease + Math.sin(anim.angle) * anim.ampX * (1 - t);
        const y = anim.fromY + (anim.toY - anim.fromY) * ease + Math.sin(anim.angle) * anim.ampY * (1 - t);
        ctx.save();
        ctx.font = `${anim.size}px serif`;
        ctx.globalAlpha = 0.7 + 0.3 * (1 - t);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(anim.emoji, x, y);
        ctx.restore();
      }
      // Purge finished
      for (let i = floatAnims.length - 1; i >= 0; i--) {
        const anim = floatAnims[i];
        if (now - anim.start >= anim.duration) floatAnims.splice(i, 1);
      }
      return still;
    }

    // Event handling functions
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      
      if (e.touches && e.touches.length > 0) {
        // Touch event
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        // Mouse event
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Position in CSS pixels relative to canvas
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      return { x, y };
    }

    function handleMove(e) {
      e.preventDefault(); // Prevent scrolling
      const pos = getEventPos(e);
      mouseX = pos.x;
      mouseY = pos.y;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
    }

    function handleStart(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = true;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
      
      // Update position on touch start
      if (e.touches) {
        const pos = getEventPos(e);
        mouseX = pos.x;
        mouseY = pos.y;
        touchStartTime = Date.now();
        touchStartPos = { x: pos.x, y: pos.y };
      }
    }

    function handleEnd(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = false;
      
      // Check for bomb trigger on touch (tap without much movement)
      if (e.changedTouches) {
        const touchDuration = Date.now() - touchStartTime;
        const pos = getEventPos({ touches: e.changedTouches });
        const distance = Math.sqrt(
          Math.pow(pos.x - touchStartPos.x, 2) + 
          Math.pow(pos.y - touchStartPos.y, 2)
        );
        
        // If it was a short tap (< 200ms) with minimal movement (< 20px), trigger bomb
        if (touchDuration < 200 && distance < 20) {
          useBomb();
        }
        
        // Reset touch tracking when touch ends
        isCurrentlyTouch = false;
      }
    }

    // Mouse event listeners
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mouseup', handleEnd);

    // Touch event listeners
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });

    // Game functions
    function drawPlayer() {
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
    }

    function getWingmanOffsets(count) {
      switch (count) {
        case 1:
          return [{ x: -wingmanOff, y: 0 }];
        case 2:
          return [{ x: -wingmanOff, y: 0 }, { x: wingmanOff, y: 0 }];
        case 3:
          return [{ x: -wingmanOff, y: 0 }, { x: wingmanOff, y: 0 }, { x: 0, y: -wingmanOff }];
        default:
          return [];
      }
    }

    function updateWingmenPositions() {
      const offsets = getWingmanOffsets(wingmenCount);
      wingmenPositions = offsets.map(off => {
        const x = player.x + off.x;
        const y = player.y + off.y;
        return {
          x: Math.max(player.width/2, Math.min(viewW - player.width/2, x)),
          y: Math.max(player.height/2, Math.min(viewH - player.height/2, y))
        };
      });
    }

    function drawWingmen() {
      if (wingmenCount <= 0) return;
      ctx.fillStyle = '#44ff44';
      wingmenPositions.forEach(p => {
        ctx.fillRect(p.x - player.width/2, p.y - player.height/2, player.width, player.height);
      });
    }

    function drawBullets() {
      ctx.fillStyle = '#ffff00';
      bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bulletW/2, bullet.y - bulletH/2, bulletW, bulletH);
      });
    }

    function drawEnemies() {
      ctx.fillStyle = '#ff0000';
      enemies.forEach(enemy => {
        ctx.fillRect(enemy.x - enemySize/2, enemy.y - enemySize/2, enemySize, enemySize);
      });
    }

    function drawPowerUps() {
      powerUps.forEach(powerUp => {
        if (powerUp.type === 'fire') ctx.fillStyle = '#ff00ff';
        else if (powerUp.type === 'missile') ctx.fillStyle = '#00ffff';
        else if (powerUp.type === 'bomb') ctx.fillStyle = '#ffffff';
        else if (powerUp.type === 'wingman') ctx.fillStyle = '#00ff88';
        else if (powerUp.type === 'homing') ctx.fillStyle = '#ffaa00';
        else ctx.fillStyle = '#ffffff';
        ctx.fillRect(powerUp.x - powerUpSize/2, powerUp.y - powerUpSize/2, powerUpSize, powerUpSize);
      });
    }

    function drawMissiles() {
      missiles.forEach(missile => {
        if (missile.homing) {
          // Light grey and rotated to face current velocity
          const angle = Math.atan2(missile.vy || 0, missile.vx || 0) + Math.PI / 2;
          ctx.save();
          ctx.translate(missile.x, missile.y);
          ctx.rotate(angle);
          ctx.fillStyle = '#d0d0d0';
          ctx.fillRect(-missileW / 2, -missileH / 2, missileW, missileH);
          ctx.restore();
        } else {
          // Regular missiles: straight up, orange
          ctx.fillStyle = '#ff8800';
          ctx.fillRect(missile.x - missileW / 2, missile.y - missileH / 2, missileW, missileH);
        }
      });
    }

    function updatePlayer() {
      if (isCurrentlyTouch) {
        // For touch: offset the ship above the finger to avoid blocking the view
  const shipOffset = shipOffsetTouch; // scaled finger offset
        player.x = Math.max(player.width/2, Math.min(viewW - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(viewH - player.height/2, mouseY - shipOffset));
      } else {
        // For mouse: normal positioning
        player.x = Math.max(player.width/2, Math.min(viewW - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(viewH - player.height/2, mouseY));
      }
    }

    function updateBullets() {
      bullets = bullets.filter(bullet => bullet.y > 0);
      bullets.forEach(bullet => {
        bullet.y -= 10;
      });
    }

    function updateEnemies() {
      enemies.forEach(enemy => {
        enemy.y += 2;
      });
      enemies = enemies.filter(enemy => enemy.y < viewH + enemySize);
    }

    function updatePowerUps() {
      powerUps.forEach(powerUp => {
        powerUp.y += 1;
      });
      powerUps = powerUps.filter(powerUp => powerUp.y < viewH + powerUpSize);
    }

    function updateMissiles() {
      missiles.forEach(missile => {
        if (missile.homing) {
          // Find nearest enemy and steer toward it
          let nearest = null;
          let bestD2 = Infinity;
          for (const e of enemies) {
            const dx = e.x - missile.x;
            const dy = e.y - missile.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestD2) { bestD2 = d2; nearest = e; }
          }
          if (nearest) {
            const desired = Math.atan2(nearest.y - missile.y, nearest.x - missile.x);
            const current = Math.atan2(missile.vy, missile.vx);
            let diff = desired - current;
            while (diff > Math.PI) diff -= 2*Math.PI;
            while (diff < -Math.PI) diff += 2*Math.PI;
            const turn = Math.max(-HOMING_TURN, Math.min(HOMING_TURN, diff));
            const newAngle = current + turn;
            const spd = missile.speed || HOMING_SPEED;
            missile.vx = Math.cos(newAngle) * spd;
            missile.vy = Math.sin(newAngle) * spd;
          }
          missile.x += missile.vx;
          missile.y += missile.vy;
        } else {
          if (typeof missile.vx === 'number' && typeof missile.vy === 'number') {
            missile.x += missile.vx;
            missile.y += missile.vy;
          } else {
            missile.y -= 8;
          }
        }
      });
      missiles = missiles.filter(missile => {
        if (missile.homing) {
          return missile.x > -missileW && missile.x < viewW + missileW && missile.y > -missileH && missile.y < viewH + missileH;
        } else {
          return missile.x > -missileW && missile.x < viewW + missileW && missile.y > -missileH && missile.y < viewH + missileH;
        }
      });
    }

    function checkCollisions() {
      // Bullets vs Enemies
      bullets.forEach(bullet => {
        enemies.forEach(enemy => {
          if (Math.abs(bullet.x - enemy.x) < collBulletEnemy && Math.abs(bullet.y - enemy.y) < collBulletEnemy) {
            bullets.splice(bullets.indexOf(bullet), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 10;
          }
        });
      });

      // Missiles vs Enemies
      missiles.forEach(missile => {
        enemies.forEach(enemy => {
          if (Math.abs(missile.x - enemy.x) < collBulletEnemy && Math.abs(missile.y - enemy.y) < collBulletEnemy) {
            missiles.splice(missiles.indexOf(missile), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 20;
          }
        });
      });

      // Wingmen vs Enemies: if a wingman hits an enemy, remove both and lose one wingman
      if (wingmenCount > 0 && wingmenPositions.length > 0) {
        enemies.slice().forEach(enemy => {
          for (const w of wingmenPositions) {
            if (Math.abs(w.x - enemy.x) < collPlayerEnemy && Math.abs(w.y - enemy.y) < collPlayerEnemy) {
              const idx = enemies.indexOf(enemy);
              if (idx !== -1) { enemies.splice(idx, 1); }
              wingmenCount = Math.max(0, wingmenCount - 1);
              break;
            }
          }
        });
      }

      // Player vs Enemies
      enemies.slice().forEach(enemy => {
        if (Math.abs(player.x - enemy.x) < collPlayerEnemy && Math.abs(player.y - enemy.y) < collPlayerEnemy) {
          const idx = enemies.indexOf(enemy);
          if (idx !== -1) { enemies.splice(idx, 1); }
          if (wingmenCount > 0) {
            wingmenCount = Math.max(0, wingmenCount - 1);
          } else {
            health -= 10;
            // Animate heart from hearts HUD to player ship
            addEmojiFloatFromElement(heartsEl, player.x, player.y, '‚ù§Ô∏è', { scaleAmpWithUnit: true });
          }
        }
      });

      // Player vs PowerUps
      powerUps.forEach(powerUp => {
        if (Math.abs(player.x - powerUp.x) < collPlayerPower && Math.abs(player.y - powerUp.y) < collPlayerPower) {
          powerUps.splice(powerUps.indexOf(powerUp), 1);
          if (powerUp.type === 'fire') {
            fireRate = Math.min(fireRate + 1, 2);
            addEmojiFloatToElement(powerUp.x, powerUp.y, firePowerEl, 'üî•', { scaleAmpWithUnit: true });
          } else if (powerUp.type === 'missile') {
            // Accumulate up to 3 missile levels
            missileRate = Math.min(missileRate + 1, 3);
            addEmojiFloatToElement(powerUp.x, powerUp.y, missilePowerEl, 'üöÄ', { scaleAmpWithUnit: true });
          } else if (powerUp.type === 'bomb') {
            bombs++;
            addEmojiFloatToElement(powerUp.x, powerUp.y, bombIconsEl, 'üí£', { scaleAmpWithUnit: true });
          } else if (powerUp.type === 'wingman') {
            wingmenCount = Math.min(WINGMAN_MAX, wingmenCount + 1);
            addEmojiFloatToElement(powerUp.x, powerUp.y, wingmenEl, 'üõ©Ô∏è', { scaleAmpWithUnit: true });
          } else if (powerUp.type === 'homing') {
            const now = Date.now();
            const EXT = 20000; // 10 seconds per stack
            if (homingStacks === 0) {
              homingStacks = 1;
              homingNextExpiry = now + EXT;
              homingActive = true;
            } else if (homingStacks < 3) {
              homingStacks += 1;
            } else {
              // Already at max stacks: top-up current timer
              homingNextExpiry = now + EXT;
            }
            addEmojiFloatToElement(powerUp.x, powerUp.y, homingPowerEl, 'üéØ', { scaleAmpWithUnit: true });
          }
        }
      });
    }

    function fireBullet() {
      if (cooldown) return;
      
      const now = Date.now();
      if (now - lastShot < 100) return; // Fire rate limit
      
      lastShot = now;
      
      const shooters = [{ x: player.x, y: player.y }, ...wingmenPositions];
      const addPattern = (sx, sy) => {
        if (fireRate === 0) {
          bullets.push({ x: sx, y: sy - 20 * scaleUnit });
        } else if (fireRate === 1) {
          bullets.push({ x: sx, y: sy - 20 * scaleUnit });
          bullets.push({ x: sx - spread10, y: sy - 15 * scaleUnit });
          bullets.push({ x: sx + spread10, y: sy - 15 * scaleUnit });
        } else if (fireRate === 2) {
          bullets.push({ x: sx, y: sy - 20 * scaleUnit });
          bullets.push({ x: sx - spread10, y: sy - 15 * scaleUnit });
          bullets.push({ x: sx + spread10, y: sy - 15 * scaleUnit });
          bullets.push({ x: sx - spread20, y: sy - 10 * scaleUnit });
          bullets.push({ x: sx + spread20, y: sy - 10 * scaleUnit });
        }
      };
      shooters.forEach(s => addPattern(s.x, s.y));
      
      overheat += 5;
      if (overheat >= maxOverheat) {
        overheat = maxOverheat;
        cooldown = true; // lock firing until cooled below threshold
        // Apply one-time downgrade on reaching overheat
        if (!overheatPenaltyApplied) {
          // Priority: homing (one stack) -> missiles -> spread
          if (homingStacks > 0) {
            homingStacks = Math.max(0, homingStacks - 1);
            if (homingStacks === 0) { homingActive = false; homingNextExpiry = 0; }
          } else if (missileRate > 0) {
            missileRate = Math.max(0, missileRate - 1);
          } else if (fireRate > 0) {
            fireRate = Math.max(0, fireRate - 1);
          }
          // If everything already minimal, further overheats do nothing.
          overheatPenaltyApplied = true;
        }
      }
    }

    function fireMissile() {
      if (missileRate <= 0) return;
      if (Math.random() >= 0.1) return; // Occasional missile fire
      const speed = 8;
      const origin = { x: player.x, y: player.y - 20 * scaleUnit };
      const up = -Math.PI / 2;
      const ang = Math.PI / 12; // 15 degrees
      const spawnAt = (theta) => {
        missiles.push({ x: origin.x, y: origin.y, vx: Math.cos(theta) * speed, vy: Math.sin(theta) * speed });
      };
      if (missileRate === 1) {
        spawnAt(up);
      } else if (missileRate === 2) {
        spawnAt(up - ang);
        spawnAt(up + ang);
      } else {
        spawnAt(up);
        spawnAt(up - ang);
        spawnAt(up + ang);
      }
    }

    function maybeLaunchHoming() {
      const now = Date.now();
      if (homingStacks <= 0) { homingActive = false; return; }
      // Handle expiry of the current stack
      if (now >= homingNextExpiry) {
        const EXT = 10000;
        if (homingStacks > 1) {
          homingStacks -= 1;
          homingNextExpiry += EXT; // immediately begin next stack
        } else {
          homingStacks = 0;
          homingActive = false;
          return;
        }
      }
      homingActive = true;
      if (now - lastHomingLaunch >= HOMING_INTERVAL) {
        missiles.push({ x: player.x, y: player.y - 20 * scaleUnit, vx: 0, vy: -HOMING_SPEED, speed: HOMING_SPEED, homing: true });
        lastHomingLaunch = now;
      }
    }

    function useBomb() {
      if (bombs > 0) {
        enemies = [];
        bombs--;
        score += 100;
      }
    }

    function spawnEnemies() {
      if (Math.random() < 0.02) {
        enemies.push({ x: Math.random() * viewW, y: -enemySize });
      }
    }

    function spawnPowerUps() {
      if (Math.random() < 0.005) {
        const types = ['fire', 'missile', 'bomb', 'wingman', 'homing'];
        powerUps.push({ x: Math.random() * viewW, y: -powerUpSize, type: types[Math.floor(Math.random() * types.length)] });
      }
    }


    function updateUI() {
      // Score
      scoreEl.textContent = score;

      // Health as hearts: 10 total, turn black as we lose 10% each
      const totalHearts = 10;
      const filled = Math.max(0, Math.min(totalHearts, Math.ceil((health / 100) * totalHearts)));
      let heartsHTML = '';
      for (let i = 0; i < totalHearts; i++) {
        heartsHTML += i < filled ? '‚ù§Ô∏è' : 'üñ§';
      }
      heartsEl.innerHTML = `<span class="pill red">${heartsHTML}</span>`;

  // Bombs as emojis, wrapped in white pill; max 5 shown with total count indicated when >5
  const shownBombs = Math.min(5, bombs);
  bombIconsEl.innerHTML = `<span class="pill white">${'üí£'.repeat(shownBombs)}${bombs > 5 ? ` √ó${bombs}` : ''}</span>`;

    // Wingmen as emojis, one per wingman present
  wingmenEl.innerHTML = `<span class="pill green">${'üõ©Ô∏è'.repeat(wingmenCount)}</span>`;
  wingmenEl.classList.toggle('dim', wingmenCount === 0);

    // Fire power: 0..2 ‚Üí show 1-3 flames to indicate spread levels, with magenta pill
    const flames = ['üî•', 'üî•üî•', 'üî•üî•üî•'];
    if (fireRate > 0) {
      firePowerEl.innerHTML = `<span class="pill magenta">${flames[fireRate]}</span>`;
    } else {
      firePowerEl.innerHTML = '';
    }

    // Missile power: 0..3 ‚Üí show 1‚Äì3 rockets in cyan pill when active
    if (missileRate > 0) {
      missilePowerEl.innerHTML = `<span class="pill cyan">${'üöÄ'.repeat(Math.min(3, missileRate))}</span>`;
    } else {
      missilePowerEl.innerHTML = '';
    }

    // Homing power: show 1‚Äì3 targets based on stacks
    if (homingStacks > 0) {
      homingPowerEl.innerHTML = `<span class="pill orange">${'üéØ'.repeat(Math.min(3, homingStacks))}</span>`;
    } else {
      homingPowerEl.innerHTML = '';
    }

      // Overheat bar
      overheatFill.style.width = `${(overheat / maxOverheat) * 100}%`;
      if (cooldown) {
        overheatFill.classList.add('cooldown');
      } else {
        overheatFill.classList.remove('cooldown');
      }
    }

    // Fullscreen toggle
    function toggleFullscreen() {
      const elem = document.documentElement;
      if (!document.fullscreenElement) {
        if (elem.requestFullscreen) elem.requestFullscreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
      }
    }
  fullscreenBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); toggleFullscreen(); });
  // Touch support for fullscreen
  fullscreenBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); }, { passive: false });
  fullscreenBtn.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); toggleFullscreen(); }, { passive: false });

    // Pause/Play toggle
    function togglePause() {
      // Prevent pause/resume while Game Over is visible
      if (gameOverModal.style.display === 'flex') return;
      isPaused = !isPaused;
      if (isPaused) {
        gameRunning = false; // stop the loop
        firing = false; // stop firing while paused
        pauseBtn.textContent = '‚ñ∂';
        pauseBtn.setAttribute('aria-label', 'Play');
        pausedOverlay.style.display = 'flex';
      } else {
        gameRunning = true; // resume
        pauseBtn.textContent = '‚è∏';
        pauseBtn.setAttribute('aria-label', 'Pause');
        pausedOverlay.style.display = 'none';
        requestAnimationFrame(gameLoop);
      }
    }
  pauseBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); togglePause(); });
  // Touch support for pause
  pauseBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); }, { passive: false });
  pauseBtn.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); togglePause(); }, { passive: false });

    function gameLoop() {
      ctx.clearRect(0, 0, viewW, viewH);

  updatePlayer();
  updateWingmenPositions();
  updateBullets();
      updateEnemies();
      updatePowerUps();
      updateMissiles();
      checkCollisions();
      // Passive cooling when not firing
      if (!firing && overheat > 0) {
        overheat = Math.max(0, overheat - COOL_RATE);
        if (cooldown && overheat <= maxOverheat * 0.6) {
          cooldown = false; // unlock when sufficiently cooled
          overheatPenaltyApplied = false; // allow next overheat to apply next downgrade
        }
      }
      
      if (firing) {
        fireBullet();
      }
  fireMissile();
  maybeLaunchHoming();
      
    spawnEnemies();
    spawnPowerUps();
      
  drawPlayer();
  drawWingmen();
      drawBullets();
      drawEnemies();
      drawPowerUps();
      drawMissiles();
  // Render floating emoji animations (coins, pickups, hearts)
  renderEmojiAnims();
      
      updateUI();
      
      if (health <= 0 && gameRunning) {
        // Ensure paused overlay is hidden on game over
        pausedOverlay.style.display = 'none';
        showGameOver();
        return; // Stop the game loop
      }
      
      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      }
    }

    // Keyboard for bomb (spacebar)
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        useBomb();
      } else if (e.code === 'KeyP') {
        e.preventDefault();
        togglePause();
      }
    });

    // Prevent page scroll/drag on mobile, but allow HUD controls and modal
    function isInteractiveTouch(el) {
      return !!(el && (el.closest('.controls-row') || el.closest('.game-over-modal')));
    }
    document.addEventListener('touchstart', (e) => {
      if (e.target === canvas || isInteractiveTouch(e.target)) return;
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (e.target === canvas || isInteractiveTouch(e.target)) return;
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (e.target === canvas || isInteractiveTouch(e.target)) return;
      e.preventDefault();
    }, { passive: false });

    gameLoop();
  </script>
</body>
</html>
