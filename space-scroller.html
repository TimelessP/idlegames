<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Space Scroller</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none; /* Prevent any touch gestures on the page */
      -webkit-user-select: none; /* Prevent text selection */
      user-select: none;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    canvas {
      border: 2px solid #fff;
      background: #000;
      display: block;
      touch-action: none; /* Prevent default touch behaviors */
      max-width: 100vw;
      max-height: 80vh;
    }
    @media (max-width: 768px) {
      canvas {
        width: 100vw;
        height: 75vh;
      }
      .ui {
        font-size: 14px;
      }
    }
    .ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      z-index: 10;
    }
    
    /* Game Over Modal */
    .game-over-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      touch-action: manipulation;
    }
    
    .game-over-content {
      text-align: center;
      color: #fff;
      padding: 2rem;
      max-width: 90%;
    }
    
    .game-over-title {
      font-size: 3rem;
      font-weight: bold;
      color: #ff4444;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    .game-over-score {
      font-size: 2rem;
      margin-bottom: 2rem;
      color: #ffff44;
    }
    
    .game-over-instruction {
      font-size: 1.2rem;
      opacity: 0.8;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 0.4; }
    }
    
    @media (max-width: 768px) {
      .game-over-title {
        font-size: 2rem;
      }
      .game-over-score {
        font-size: 1.5rem;
      }
      .game-over-instruction {
        font-size: 1rem;
      }
    }
    .ui div {
      margin-bottom: 5px;
    }
    .overheat-bar {
      width: 200px;
      height: 20px;
      background: #333;
      border: 1px solid #fff;
      margin-top: 5px;
    }
    .overheat-fill {
      height: 100%;
      background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
      width: 0%;
      transition: width 0.1s;
    }
    .cooldown {
      background: #666 !important;
    }
  </style>
</head>
<body>
  <div class="ui">
    <div>Score: <span id="score">0</span></div>
    <div>Health: <span id="health">100</span></div>
    <div>Bombs: <span id="bombs">0</span></div>
  <div>Wingmen: <span id="wingmen">0</span></div>
    <div>Overheat:</div>
    <div class="overheat-bar">
      <div class="overheat-fill" id="overheat-fill"></div>
    </div>
    <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">
      Mouse/Touch: Move & Fire<br>
      Spacebar/Quick Tap: Bomb
    </div>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <!-- Game Over Modal -->
  <div id="gameOverModal" class="game-over-modal">
    <div class="game-over-content">
      <div class="game-over-title">GAME OVER</div>
      <div class="game-over-score">Final Score: <span id="finalScore">0</span></div>
      <div class="game-over-instruction">Tap anywhere to restart</div>
    </div>
  </div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const healthEl = document.getElementById('health');
  const bombsEl = document.getElementById('bombs');
  const wingmenEl = document.getElementById('wingmen');
    const overheatFill = document.getElementById('overheat-fill');
    const gameOverModal = document.getElementById('gameOverModal');
    const finalScoreEl = document.getElementById('finalScore');

    // Game variables
    let player = { x: canvas.width / 2, y: canvas.height - 50, width: 30, height: 30, speed: 5 };
    let bullets = [];
    let enemies = [];
    let powerUps = [];
    let missiles = [];
    let bombs = 0;
    let score = 0;
    let health = 100;
    let overheat = 0;
    let maxOverheat = 100;
    let cooldown = false;
    let fireRate = 0; // directions: 0=single, 1=3-way, 2=5-way
  let missileRate = 0; // 0=none, 1=basic missiles
  // Wingmen state
  let wingmenCount = 0; // 0..3
  let wingmenPositions = [];
  const WINGMAN_MAX = 3;
  // Homing missiles power-up state
  let homingActive = false;
  let homingExpire = 0;
  let lastHomingLaunch = 0;
  const HOMING_INTERVAL = 500; // ms
  const HOMING_SPEED = 6; // px per frame
  const HOMING_TURN = 0.12; // radians per frame
  const COOL_RATE = 1; // heat reduced per frame when not firing
  // Power-ups spawn randomly with equal probability per type

    let mouseX = canvas.width / 2;
    let mouseY = canvas.height - 50;
    let firing = false;
    let lastShot = 0;
    let touchStartTime = 0;
    let touchStartPos = { x: 0, y: 0 };
    let isCurrentlyTouch = false; // Track if current interaction is touch
    let gameRunning = true; // Track if game is running

    // Game Over Modal Functions
    function showGameOver() {
      gameRunning = false;
      finalScoreEl.textContent = score;
      gameOverModal.style.display = 'flex';
    }
    
    function hideGameOver() {
      gameOverModal.style.display = 'none';
      gameRunning = true;
    }
    
    function restartGame() {
      // Reset all game variables
      player = { x: canvas.width / 2, y: canvas.height - 50, width: 30, height: 30, speed: 5 };
      bullets = [];
      enemies = [];
      powerUps = [];
      missiles = [];
      bombs = 0;
      score = 0;
      health = 100;
      overheat = 0;
      cooldown = false;
      fireRate = 0;
      missileRate = 0;
  wingmenCount = 0;
  wingmenPositions = [];
  homingActive = false;
  homingExpire = 0;
  lastHomingLaunch = 0;
      mouseX = canvas.width / 2;
      mouseY = canvas.height - 50;
      firing = false;
      lastShot = 0;
      
      hideGameOver();
      gameLoop(); // Restart the game loop
    }
    
    // Modal event handlers
    gameOverModal.addEventListener('click', restartGame);
    gameOverModal.addEventListener('touchend', (e) => {
      e.preventDefault();
      restartGame();
    });

    // Event handling functions
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      
      if (e.touches && e.touches.length > 0) {
        // Touch event
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        // Mouse event
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      // Calculate position relative to canvas bounds
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      
      // Scale coordinates from display size to canvas internal size
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      return {
        x: x * scaleX,
        y: y * scaleY
      };
    }

    function handleMove(e) {
      e.preventDefault(); // Prevent scrolling
      const pos = getEventPos(e);
      mouseX = pos.x;
      mouseY = pos.y;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
    }

    function handleStart(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = true;
      
      // Track if this is a touch interaction
      isCurrentlyTouch = !!(e.touches && e.touches.length > 0);
      
      // Update position on touch start
      if (e.touches) {
        const pos = getEventPos(e);
        mouseX = pos.x;
        mouseY = pos.y;
        touchStartTime = Date.now();
        touchStartPos = { x: pos.x, y: pos.y };
      }
    }

    function handleEnd(e) {
      e.preventDefault(); // Prevent default behaviors
      firing = false;
      
      // Check for bomb trigger on touch (tap without much movement)
      if (e.changedTouches) {
        const touchDuration = Date.now() - touchStartTime;
        const pos = getEventPos({ touches: e.changedTouches });
        const distance = Math.sqrt(
          Math.pow(pos.x - touchStartPos.x, 2) + 
          Math.pow(pos.y - touchStartPos.y, 2)
        );
        
        // If it was a short tap (< 200ms) with minimal movement (< 20px), trigger bomb
        if (touchDuration < 200 && distance < 20) {
          useBomb();
        }
        
        // Reset touch tracking when touch ends
        isCurrentlyTouch = false;
      }
    }

    // Mouse event listeners
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mouseup', handleEnd);

    // Touch event listeners
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });

    // Game functions
    function drawPlayer() {
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
    }

    function getWingmanOffsets(count) {
      switch (count) {
        case 1:
          return [{ x: -60, y: 0 }];
        case 2:
          return [{ x: -60, y: 0 }, { x: 60, y: 0 }];
        case 3:
          return [{ x: -60, y: 0 }, { x: 60, y: 0 }, { x: 0, y: -60 }];
        default:
          return [];
      }
    }

    function updateWingmenPositions() {
      const offsets = getWingmanOffsets(wingmenCount);
      wingmenPositions = offsets.map(off => {
        const x = player.x + off.x;
        const y = player.y + off.y;
        return {
          x: Math.max(player.width/2, Math.min(canvas.width - player.width/2, x)),
          y: Math.max(player.height/2, Math.min(canvas.height - player.height/2, y))
        };
      });
    }

    function drawWingmen() {
      if (wingmenCount <= 0) return;
      ctx.fillStyle = '#44ff44';
      wingmenPositions.forEach(p => {
        ctx.fillRect(p.x - player.width/2, p.y - player.height/2, player.width, player.height);
      });
    }

    function drawBullets() {
      ctx.fillStyle = '#ffff00';
      bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - 2, bullet.y - 5, 4, 10);
      });
    }

    function drawEnemies() {
      ctx.fillStyle = '#ff0000';
      enemies.forEach(enemy => {
        ctx.fillRect(enemy.x - 15, enemy.y - 15, 30, 30);
      });
    }

    function drawPowerUps() {
      powerUps.forEach(powerUp => {
        if (powerUp.type === 'fire') ctx.fillStyle = '#ff00ff';
        else if (powerUp.type === 'missile') ctx.fillStyle = '#00ffff';
        else if (powerUp.type === 'bomb') ctx.fillStyle = '#ffffff';
        else if (powerUp.type === 'wingman') ctx.fillStyle = '#00ff88';
        else if (powerUp.type === 'homing') ctx.fillStyle = '#ffaa00';
        else ctx.fillStyle = '#ffffff';
        ctx.fillRect(powerUp.x - 10, powerUp.y - 10, 20, 20);
      });
    }

    function drawMissiles() {
      ctx.fillStyle = '#ff8800';
      missiles.forEach(missile => {
        ctx.fillRect(missile.x - 3, missile.y - 8, 6, 16);
      });
    }

    function updatePlayer() {
      if (isCurrentlyTouch) {
        // For touch: offset the ship above the finger to avoid blocking the view
        const shipOffset = 80; // Move ship up by this amount from finger position
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, mouseY - shipOffset));
      } else {
        // For mouse: normal positioning
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, mouseX));
        player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, mouseY));
      }
    }

    function updateBullets() {
      bullets = bullets.filter(bullet => bullet.y > 0);
      bullets.forEach(bullet => {
        bullet.y -= 10;
      });
    }

    function updateEnemies() {
      enemies.forEach(enemy => {
        enemy.y += 2;
      });
      enemies = enemies.filter(enemy => enemy.y < canvas.height + 20);
    }

    function updatePowerUps() {
      powerUps.forEach(powerUp => {
        powerUp.y += 1;
      });
      powerUps = powerUps.filter(powerUp => powerUp.y < canvas.height + 20);
    }

    function updateMissiles() {
      missiles.forEach(missile => {
        if (missile.homing) {
          // Find nearest enemy and steer toward it
          let nearest = null;
          let bestD2 = Infinity;
          for (const e of enemies) {
            const dx = e.x - missile.x;
            const dy = e.y - missile.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestD2) { bestD2 = d2; nearest = e; }
          }
          if (nearest) {
            const desired = Math.atan2(nearest.y - missile.y, nearest.x - missile.x);
            const current = Math.atan2(missile.vy, missile.vx);
            let diff = desired - current;
            while (diff > Math.PI) diff -= 2*Math.PI;
            while (diff < -Math.PI) diff += 2*Math.PI;
            const turn = Math.max(-HOMING_TURN, Math.min(HOMING_TURN, diff));
            const newAngle = current + turn;
            const spd = missile.speed || HOMING_SPEED;
            missile.vx = Math.cos(newAngle) * spd;
            missile.vy = Math.sin(newAngle) * spd;
          }
          missile.x += missile.vx;
          missile.y += missile.vy;
        } else {
          missile.y -= 8;
        }
      });
      missiles = missiles.filter(missile => {
        if (missile.homing) {
          return missile.x > -20 && missile.x < canvas.width + 20 && missile.y > -20 && missile.y < canvas.height + 20;
        } else {
          return missile.y > 0;
        }
      });
    }

    function checkCollisions() {
      // Bullets vs Enemies
      bullets.forEach(bullet => {
        enemies.forEach(enemy => {
          if (Math.abs(bullet.x - enemy.x) < 20 && Math.abs(bullet.y - enemy.y) < 20) {
            bullets.splice(bullets.indexOf(bullet), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 10;
          }
        });
      });

      // Missiles vs Enemies
      missiles.forEach(missile => {
        enemies.forEach(enemy => {
          if (Math.abs(missile.x - enemy.x) < 20 && Math.abs(missile.y - enemy.y) < 20) {
            missiles.splice(missiles.indexOf(missile), 1);
            enemies.splice(enemies.indexOf(enemy), 1);
            score += 20;
          }
        });
      });

      // Wingmen vs Enemies: if a wingman hits an enemy, remove both and lose one wingman
      if (wingmenCount > 0 && wingmenPositions.length > 0) {
        enemies.slice().forEach(enemy => {
          for (const w of wingmenPositions) {
            if (Math.abs(w.x - enemy.x) < 25 && Math.abs(w.y - enemy.y) < 25) {
              const idx = enemies.indexOf(enemy);
              if (idx !== -1) enemies.splice(idx, 1);
              wingmenCount = Math.max(0, wingmenCount - 1);
              break;
            }
          }
        });
      }

      // Player vs Enemies
      enemies.slice().forEach(enemy => {
        if (Math.abs(player.x - enemy.x) < 25 && Math.abs(player.y - enemy.y) < 25) {
          const idx = enemies.indexOf(enemy);
          if (idx !== -1) enemies.splice(idx, 1);
          if (wingmenCount > 0) {
            wingmenCount = Math.max(0, wingmenCount - 1);
          } else {
            health -= 10;
          }
        }
      });

      // Player vs PowerUps
      powerUps.forEach(powerUp => {
        if (Math.abs(player.x - powerUp.x) < 20 && Math.abs(player.y - powerUp.y) < 20) {
          powerUps.splice(powerUps.indexOf(powerUp), 1);
          if (powerUp.type === 'fire') {
            fireRate = Math.min(fireRate + 1, 2);
          } else if (powerUp.type === 'missile') {
            missileRate = Math.min(missileRate + 1, 1);
          } else if (powerUp.type === 'bomb') {
            bombs++;
          } else if (powerUp.type === 'wingman') {
            wingmenCount = Math.min(WINGMAN_MAX, wingmenCount + 1);
          } else if (powerUp.type === 'homing') {
            const now = Date.now();
            homingActive = true;
            const EXT = 10000; // 10 seconds per pickup
            homingExpire = Math.max(homingExpire, now) + EXT;
          }
        }
      });
    }

    function fireBullet() {
      if (cooldown) return;
      
      const now = Date.now();
      if (now - lastShot < 100) return; // Fire rate limit
      
      lastShot = now;
      
      const shooters = [{ x: player.x, y: player.y }, ...wingmenPositions];
      const addPattern = (sx, sy) => {
        if (fireRate === 0) {
          bullets.push({ x: sx, y: sy - 20 });
        } else if (fireRate === 1) {
          bullets.push({ x: sx, y: sy - 20 });
          bullets.push({ x: sx - 10, y: sy - 15 });
          bullets.push({ x: sx + 10, y: sy - 15 });
        } else if (fireRate === 2) {
          bullets.push({ x: sx, y: sy - 20 });
          bullets.push({ x: sx - 10, y: sy - 15 });
          bullets.push({ x: sx + 10, y: sy - 15 });
          bullets.push({ x: sx - 20, y: sy - 10 });
          bullets.push({ x: sx + 20, y: sy - 10 });
        }
      };
      shooters.forEach(s => addPattern(s.x, s.y));
      
      overheat += 5;
      if (overheat >= maxOverheat) {
        overheat = maxOverheat;
        cooldown = true; // lock firing until cooled below threshold
      }
    }

    function fireMissile() {
      if (missileRate > 0 && Math.random() < 0.1) { // Occasional missile fire
        missiles.push({ x: player.x, y: player.y - 20 });
      }
    }

    function maybeLaunchHoming() {
      const now = Date.now();
      if (!homingActive) return;
      if (now >= homingExpire) { homingActive = false; return; }
      if (now - lastHomingLaunch >= HOMING_INTERVAL) {
        missiles.push({ x: player.x, y: player.y - 20, vx: 0, vy: -HOMING_SPEED, speed: HOMING_SPEED, homing: true });
        lastHomingLaunch = now;
      }
    }

    function useBomb() {
      if (bombs > 0) {
        enemies = [];
        bombs--;
        score += 100;
      }
    }

    function spawnEnemies() {
      if (Math.random() < 0.02) {
        enemies.push({ x: Math.random() * canvas.width, y: -20 });
      }
    }

    function spawnPowerUps() {
      if (Math.random() < 0.005) {
        const types = ['fire', 'missile', 'bomb', 'wingman', 'homing'];
        powerUps.push({ x: Math.random() * canvas.width, y: -20, type: types[Math.floor(Math.random() * types.length)] });
      }
    }


    function updateUI() {
      scoreEl.textContent = score;
      healthEl.textContent = health;
      bombsEl.textContent = bombs;
      wingmenEl.textContent = wingmenCount;
      overheatFill.style.width = `${(overheat / maxOverheat) * 100}%`;
      if (cooldown) {
        overheatFill.classList.add('cooldown');
      } else {
        overheatFill.classList.remove('cooldown');
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
  updatePlayer();
  updateWingmenPositions();
  updateBullets();
      updateEnemies();
      updatePowerUps();
      updateMissiles();
      checkCollisions();
      // Passive cooling when not firing
      if (!firing && overheat > 0) {
        overheat = Math.max(0, overheat - COOL_RATE);
        if (cooldown && overheat <= maxOverheat * 0.6) {
          cooldown = false; // unlock when sufficiently cooled
        }
      }
      
      if (firing) {
        fireBullet();
      }
  fireMissile();
  maybeLaunchHoming();
      
    spawnEnemies();
    spawnPowerUps();
      
  drawPlayer();
  drawWingmen();
      drawBullets();
      drawEnemies();
      drawPowerUps();
      drawMissiles();
      
      updateUI();
      
      if (health <= 0 && gameRunning) {
        showGameOver();
        return; // Stop the game loop
      }
      
      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      }
    }

    // Keyboard for bomb (spacebar)
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        useBomb();
      }
    });

    // Prevent any page scrolling/dragging on mobile
    document.addEventListener('touchstart', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (e.target !== canvas) {
        e.preventDefault();
      }
    }, { passive: false });

    gameLoop();
  </script>
</body>
</html>
