<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hands Ping Pong - Idle Games</title>
    <link rel="icon" type="image/png" sizes="512x512" href="assets/appicons/idle-games-512x512px.png">
    <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512px.png">
    <style>
        :root {
            --bg: #0a0a1a;
            --surface: #12122a;
            --text: #e0e0ff;
            --highlight: #6366f1;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --player1: #3b82f6;
            --player2: #ec4899;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Video backdrop - always visible */
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.4;
            /* Blur + green lawn effect: sepia converts to brown, hue-rotate shifts to green,
               saturate enhances green, contrast reduces blacks/whites toward grey-green */
            filter: 
                blur(var(--video-blur, 20px))
                sepia(100%)
                hue-rotate(70deg)
                saturate(60%)
                contrast(0.6)
                brightness(0.7);
            will-change: filter;
        }

        #webcam.active {
            opacity: 0.6;
        }

        /* Procedural lawn texture overlay */
        #lawn-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.5;
            filter: blur(var(--lawn-blur, 3px));
            pointer-events: none;
        }

        /* Game canvas overlay */
        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        /* UI Overlay */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Title Screen */
        #title-screen {
            text-align: center;
            padding: 2rem;
            background: rgba(10, 10, 26, 0.85);
            border-radius: 20px;
            border: 2px solid var(--highlight);
            max-width: 500px;
        }

        #title-screen h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--player1), var(--player2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #title-screen .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0.5rem;
        }

        .btn-primary {
            background: var(--highlight);
            color: white;
        }

        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--highlight);
        }

        .btn-start {
            background: linear-gradient(135deg, var(--player1), var(--player2));
            color: white;
            font-size: 1.5rem;
            padding: 1.2rem 3rem;
        }

        .btn-start:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px var(--highlight);
        }

        .btn-start:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #camera-status {
            margin: 1rem 0;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        #camera-status.waiting {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }

        #camera-status.ready {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }

        .instructions {
            margin-top: 1.5rem;
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 10px;
            font-size: 0.9rem;
        }

        .instructions h3 {
            margin-bottom: 0.5rem;
            color: var(--highlight);
        }

        .instructions ul {
            margin-left: 1.2rem;
        }

        .instructions li {
            margin: 0.3rem 0;
        }

        /* Game Screen */
        #game-screen {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(10, 10, 26, 0.9), transparent);
            z-index: 10;
        }

        .player-score {
            font-size: 1.5rem;
            font-weight: bold;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            text-align: center;
            white-space: nowrap;
        }

        #player1-score {
            background: rgba(59, 130, 246, 0.3);
            border: 2px solid var(--player1);
        }

        #player2-score {
            background: rgba(236, 72, 153, 0.3);
            border: 2px solid var(--player2);
        }

        #player2-score.wall-mode {
            background: rgba(100, 100, 100, 0.3);
            border: 2px solid #666;
        }

        #game-status {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            background: rgba(10, 10, 26, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 10px;
            white-space: nowrap;
        }

        /* Game Over Screen */
        #game-over-screen {
            text-align: center;
            padding: 2rem;
            background: rgba(10, 10, 26, 0.95);
            border-radius: 20px;
            border: 2px solid var(--highlight);
            min-width: 350px;
        }

        #game-over-screen h2 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }

        #game-over-screen h2.winner-p1 {
            color: var(--player1);
        }

        #game-over-screen h2.winner-p2 {
            color: var(--player2);
        }

        #game-over-screen h2.game-over-1p {
            color: var(--highlight);
        }

        #game-over-screen .final-score {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .winner {
            color: var(--success);
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        .game-over-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn-menu {
            background: linear-gradient(135deg, #6b7280, #4b5563);
        }

        /* Hand-activated button */
        .hand-btn {
            position: relative;
            overflow: hidden;
        }

        .hand-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            transition: width 0.1s linear;
        }

        .hand-btn.pressing::after {
            width: var(--press-progress, 0%);
        }

        .hand-btn.hovered {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--highlight);
        }

        /* Mode selection buttons */
        .mode-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }

        .mode-btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .mode-btn.btn-1p {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .mode-btn.btn-2p {
            background: linear-gradient(135deg, #ec4899, #be185d);
            color: white;
        }

        .mode-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mode-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            transition: width 0.1s linear;
        }

        .mode-btn.pressing::after {
            width: var(--press-progress, 0%);
        }

        .mode-btn.hovered {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        /* Hidden */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Video Backdrop -->
    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <!-- Procedural Lawn Texture -->
    <canvas id="lawn-texture"></canvas>

    <!-- Game Canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-overlay">
        <!-- Title Screen -->
        <div id="title-screen">
            <h1>üèì Hands Ping Pong</h1>
            <p class="subtitle">Control with your hands!</p>
            
            <div id="camera-status" class="waiting">
                üëÜ Click anywhere to start camera
            </div>
            
            <div class="mode-buttons">
                <button id="btn-1p" class="mode-btn btn-1p hand-btn" disabled>
                    üë§ 1 Player
                </button>
                <button id="btn-2p" class="mode-btn btn-2p hand-btn" disabled>
                    üë• 2 Players
                </button>
            </div>
            
            <div class="instructions">
                <h3>How to Play</h3>
                <ul>
                    <li>üñêÔ∏è Move hand on <strong>left side</strong> = Player 1 paddle</li>
                    <li>üñêÔ∏è Move hand on <strong>right side</strong> = Player 2 paddle</li>
                    <li>‚úä Make a fist to grab &amp; move paddle freely</li>
                    <li>üë§ <strong>1 Player:</strong> Rally against the wall - 3 misses ends game</li>
                    <li>üë• <strong>2 Players:</strong> First to 11 points wins (win by 2)</li>
                </ul>
            </div>
        </div>

        <!-- Game Screen (HUD is separate) -->
        <div id="game-screen">
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden">
            <h2 id="game-over-title">Game Over!</h2>
            <div class="final-score">
                <div id="final-score-text"></div>
            </div>
            <div class="game-over-buttons">
                <button id="restart-btn" class="btn btn-start hand-btn">
                    üîÑ Play Again
                </button>
                <button id="menu-btn" class="btn btn-menu hand-btn">
                    üè† Main Menu
                </button>
            </div>
        </div>
    </div>

    <!-- HUD (always on top during game) -->
    <div id="hud" class="hidden">
        <div id="player1-score" class="player-score">P1: 0</div>
        <div id="game-status">Get Ready...</div>
        <div id="player2-score" class="player-score wall-mode">Wall</div>
    </div>

    <!-- MediaPipe Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

    <script>
        // ============================================
        // Game Constants (canvas-relative: % of canvas height per second)
        // ============================================
        const PADDLE_WIDTH_RATIO = 0.025;  // 2.5% of canvas width
        const PADDLE_HEIGHT_RATIO = 0.15;  // 15% of canvas height
        const BALL_SIZE_RATIO = 0.025;     // 2.5% of canvas height
        
        // Speeds as % of canvas height per second
        const BALL_SPEED_RATIO = 0.7;      // 70% of canvas height/sec base speed
        const BALL_SPEED_INCREMENT_RATIO = 0.03; // +3% per rally hit
        const MAX_BALL_SPEED_RATIO = 1.5;  // 150% of canvas height/sec max
        const MIN_BALL_SPEED_RATIO = 0.25; // 25% of canvas height/sec min
        
        // Scoring constants
        const POINTS_TO_WIN = 11;    // 2-player: first to 11 (win by 2)
        const MAX_MISSES_1P = 3;     // 1-player: 3 misses and game over
        const SERVE_SWITCH_POINTS = 2; // Switch serve every 2 points
        
        // Frame rate settings
        const HAND_TRACKING_FPS = 10;  // Hand detection rate
        const PHYSICS_FPS = 30;        // Game physics and UI update rate
        const HAND_TRACKING_INTERVAL = 1000 / HAND_TRACKING_FPS; // ~100ms
        const PHYSICS_INTERVAL = 1000 / PHYSICS_FPS; // ~33ms
        
        const COUNTDOWN_DURATION = 3; // seconds
        const PADDLE_SPEED_RATIO = 2.0; // 200% of canvas height/sec - max paddle travel speed
        
        // Hit boost: initial burst of speed when bat connects
        // Creates the satisfying "thwack" effect of a real paddle hit
        const HIT_SPEED_MULTIPLIER = 1.8; // 80% faster burst on hit
        
        // Air friction calibration (per unit of canvas height traveled):
        // Higher friction means more dramatic speed contrast between hit and arrival
        const AIR_FRICTION = 0.15; // friction per canvas-height of travel
        
        // Helper to get pixel values from ratios
        function getPixelSizes() {
            const canvas = elements.canvas;
            return {
                paddleWidth: canvas.width * PADDLE_WIDTH_RATIO,
                paddleHeight: canvas.height * PADDLE_HEIGHT_RATIO,
                ballSize: canvas.height * BALL_SIZE_RATIO,
                ballSpeed: canvas.height * BALL_SPEED_RATIO,
                ballSpeedIncrement: canvas.height * BALL_SPEED_INCREMENT_RATIO,
                maxBallSpeed: canvas.height * MAX_BALL_SPEED_RATIO,
                minBallSpeed: canvas.height * MIN_BALL_SPEED_RATIO,
                paddleSpeed: canvas.height * PADDLE_SPEED_RATIO
            };
        }

        // ============================================
        // Game State
        // ============================================
        const HAND_STABILITY_FRAMES = 5; // Frames a hand must be present before appearing
        
        const game = {
            state: 'title', // title, playing, countdown, waiting, gameover
            gameMode: null,  // '1p' or '2p' - set at game start, doesn't change
            cameraReady: false,
            handsReady: false,
            lastPhysicsTime: 0,      // Last physics/UI update
            lastHandTrackingTime: 0, // Last hand tracking frame sent
            
            // Raw hand tracking (before stability filter)
            // Now tracked by court position: 'left' and 'right' instead of handedness
            rawHands: [],        // Hands detected this frame (before filtering)
            handFrameCounts: { left: 0, right: 0 }, // Track consecutive frames per court side
            
            // Countdown
            countdown: 0,
            countdownStartTime: 0,
            lastServePlayer: null, // 'player1' or 'player2' - who lost the point
            waitingForBat: false,  // countdown paused waiting for hand
            countdownPausedAt: 0,  // where countdown was when bat disappeared
            
            // Players
            player1: {
                x: 20,  // Default X position (left side)
                y: 0,
                targetX: 20,    // Where paddle wants to go
                targetY: 0,
                points: 0,      // Points scored (opponent misses)
                active: false,
                wasActive: false, // track if bat was there before
                isGrabbing: false // when true, can move horizontally
            },
            player2: {
                x: 0,   // Will be set based on canvas width
                y: 0,
                targetX: 0,
                targetY: 0,
                points: 0,
                active: false,
                wasActive: false,
                isGrabbing: false
            },
            
            // Rally tracking (for 1P mode)
            rally: 0,           // Current rally count
            bestRally: 0,       // Best rally this game
            missCount: 0,       // Misses in 1P mode
            
            // Serve tracking
            servingPlayer: 'player1',
            totalPoints: 0,     // For serve rotation
            
            // Ball (speed will be set on game start based on canvas size)
            ball: {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                speed: 0,
                visible: true
            },
            
            // Hands tracking
            hands: [],
            
            // UI interaction
            hoveredButton: null,
            pressedButton: null,
            pressStartTime: 0,
            pressThreshold: 500 // ms to activate button
        };

        // ============================================
        // DOM Elements
        // ============================================
        const elements = {
            video: document.getElementById('webcam'),
            canvas: document.getElementById('game-canvas'),
            lawnTexture: document.getElementById('lawn-texture'),
            titleScreen: document.getElementById('title-screen'),
            gameScreen: document.getElementById('game-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            gameOverTitle: document.getElementById('game-over-title'),
            hud: document.getElementById('hud'),
            btn1P: document.getElementById('btn-1p'),
            btn2P: document.getElementById('btn-2p'),
            restartBtn: document.getElementById('restart-btn'),
            menuBtn: document.getElementById('menu-btn'),
            cameraStatus: document.getElementById('camera-status'),
            player1Score: document.getElementById('player1-score'),
            player2Score: document.getElementById('player2-score'),
            gameStatus: document.getElementById('game-status'),
            finalScoreText: document.getElementById('final-score-text')
        };

        const ctx = elements.canvas.getContext('2d');
        const lawnCtx = elements.lawnTexture.getContext('2d');

        // ============================================
        // Hand Tracking Setup
        // ============================================
        const LANDMARKS = {
            WRIST: 0,
            THUMB_TIP: 4, THUMB_IP: 3, THUMB_MCP: 2,
            INDEX_TIP: 8, INDEX_PIP: 6, INDEX_MCP: 5,
            MIDDLE_TIP: 12, MIDDLE_PIP: 10, MIDDLE_MCP: 9,
            RING_TIP: 16, RING_PIP: 14, RING_MCP: 13,
            PINKY_TIP: 20, PINKY_PIP: 18, PINKY_MCP: 17
        };
        
        // Center line margin - how close to center paddles can go
        const CENTER_MARGIN = 50;

        let handsDetector;
        let camera;
        let lastHandTrackingSent = 0; // Track when we last sent a frame for hand detection

        function initHandTracking() {
            handsDetector = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                }
            });

            handsDetector.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            handsDetector.onResults(onHandsResults);

            camera = new Camera(elements.video, {
                onFrame: async () => {
                    // Throttle hand tracking to HAND_TRACKING_FPS
                    const now = performance.now();
                    if (now - lastHandTrackingSent >= HAND_TRACKING_INTERVAL) {
                        lastHandTrackingSent = now;
                        await handsDetector.send({ image: elements.video });
                    }
                },
                width: 1280,
                height: 720
            });
        }
        
        // Gesture detection helpers
        function isFingerExtended(landmarks, tipIdx, pipIdx, mcpIdx) {
            const tip = landmarks[tipIdx];
            const pip = landmarks[pipIdx];
            const mcp = landmarks[mcpIdx];
            // Finger is extended if tip is further from wrist than PIP
            return tip.y < pip.y && pip.y < mcp.y;
        }
        
        function detectGrabGesture(landmarks) {
            // Check if fingers are curled (grab gesture)
            const indexExtended = isFingerExtended(landmarks, LANDMARKS.INDEX_TIP, LANDMARKS.INDEX_PIP, LANDMARKS.INDEX_MCP);
            const middleExtended = isFingerExtended(landmarks, LANDMARKS.MIDDLE_TIP, LANDMARKS.MIDDLE_PIP, LANDMARKS.MIDDLE_MCP);
            const ringExtended = isFingerExtended(landmarks, LANDMARKS.RING_TIP, LANDMARKS.RING_PIP, LANDMARKS.RING_MCP);
            const pinkyExtended = isFingerExtended(landmarks, LANDMARKS.PINKY_TIP, LANDMARKS.PINKY_PIP, LANDMARKS.PINKY_MCP);
            
            const extendedCount = [indexExtended, middleExtended, ringExtended, pinkyExtended].filter(Boolean).length;
            
            // Grab = at most 1 finger extended, and specifically index+middle must be curled
            return extendedCount <= 1 && !indexExtended && !middleExtended;
        }

        async function startCamera() {
            try {
                await camera.start();
                elements.video.classList.add('active');
                elements.cameraStatus.textContent = '‚úÖ Camera ready! Show your hand';
                elements.cameraStatus.className = 'ready';
                game.cameraReady = true;
                game.handsReady = true;
                elements.btn1P.disabled = false;
                elements.btn2P.disabled = false;
            } catch (err) {
                console.error('Camera error:', err);
                elements.cameraStatus.textContent = '‚ùå Camera access denied';
                elements.cameraStatus.className = 'waiting';
            }
        }

        function onHandsResults(results) {
            // Collect all detected hands this frame
            const rawHands = [];
            const canvas = elements.canvas;
            const centerX = canvas.width / 2;
            
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    
                    // Calculate palm center
                    const wrist = landmarks[LANDMARKS.WRIST];
                    const indexMcp = landmarks[LANDMARKS.INDEX_MCP];
                    const middleMcp = landmarks[LANDMARKS.MIDDLE_MCP];
                    const ringMcp = landmarks[LANDMARKS.RING_MCP];
                    const pinkyMcp = landmarks[LANDMARKS.PINKY_MCP];
                    
                    const palmX = (wrist.x + indexMcp.x + middleMcp.x + ringMcp.x + pinkyMcp.x) / 5;
                    const palmY = (wrist.y + indexMcp.y + middleMcp.y + ringMcp.y + pinkyMcp.y) / 5;
                    
                    // Detect grab gesture (fingers curled)
                    const isGrabbing = detectGrabGesture(landmarks);
                    
                    // Calculate video-to-canvas mapping for object-fit: cover
                    const video = elements.video;
                    const videoWidth = video.videoWidth || 640;
                    const videoHeight = video.videoHeight || 480;
                    const videoAspect = videoWidth / videoHeight;
                    const canvasAspect = canvas.width / canvas.height;
                    
                    let offsetX = 0, offsetY = 0, scale = 1;
                    
                    if (videoAspect > canvasAspect) {
                        scale = canvas.height / videoHeight;
                        const scaledVideoWidth = videoWidth * scale;
                        offsetX = (scaledVideoWidth - canvas.width) / 2;
                    } else {
                        scale = canvas.width / videoWidth;
                        const scaledVideoHeight = videoHeight * scale;
                        offsetY = (scaledVideoHeight - canvas.height) / 2;
                    }
                    
                    // Map palm position (0-1) to canvas coordinates
                    // Flip X because video is mirrored
                    const videoX = (1 - palmX) * videoWidth;
                    const videoY = palmY * videoHeight;
                    const screenX = videoX * scale - offsetX;
                    const screenY = videoY * scale - offsetY;
                    
                    // Clamp to canvas bounds
                    const clampedX = Math.max(0, Math.min(canvas.width, screenX));
                    const clampedY = Math.max(0, Math.min(canvas.height, screenY));
                    
                    // Determine court side based on position
                    const courtSide = clampedX < centerX ? 'left' : 'right';
                    
                    rawHands.push({
                        x: clampedX,
                        y: clampedY,
                        courtSide: courtSide,
                        isGrabbing: isGrabbing
                    });
                }
            }
            
            // Track which court sides have hands this frame
            const sidesDetected = { left: false, right: false };
            for (const hand of rawHands) {
                sidesDetected[hand.courtSide] = true;
            }
            
            // Update stability frame counts per court side
            for (const side of ['left', 'right']) {
                if (sidesDetected[side]) {
                    game.handFrameCounts[side] = (game.handFrameCounts[side] || 0) + 1;
                } else {
                    game.handFrameCounts[side] = 0;
                }
            }
            
            // Build stable hands list - one hand per court side, only if stable
            game.hands = [];
            
            // Find best hand for each side (if multiple hands on same side, use first)
            const leftHands = rawHands.filter(h => h.courtSide === 'left');
            const rightHands = rawHands.filter(h => h.courtSide === 'right');
            
            if (leftHands.length > 0 && game.handFrameCounts.left >= HAND_STABILITY_FRAMES) {
                game.hands.push({ ...leftHands[0], player: 'player1' });
            }
            if (rightHands.length > 0 && game.handFrameCounts.right >= HAND_STABILITY_FRAMES) {
                game.hands.push({ ...rightHands[0], player: 'player2' });
            }
            
            // Update game based on state
            if (game.state === 'title' || game.state === 'gameover') {
                updateUIInteraction();
            }
        }

        // ============================================
        // UI Interaction (Hand-based buttons)
        // ============================================
        function updateUIInteraction() {
            const buttons = game.state === 'title' 
                ? [elements.btn1P, elements.btn2P] 
                : [elements.restartBtn, elements.menuBtn];
            
            // Reset all buttons
            buttons.forEach(btn => {
                if (btn) {
                    btn.classList.remove('hovered', 'pressing');
                    btn.style.setProperty('--press-progress', '0%');
                }
            });
            
            if (game.hands.length === 0) {
                game.hoveredButton = null;
                game.pressedButton = null;
                return;
            }
            
            // Use any hand for UI interaction
            const hand = game.hands[0];
            
            // Check button hover
            let hoveredBtn = null;
            buttons.forEach(btn => {
                if (!btn || btn.disabled) return;
                const rect = btn.getBoundingClientRect();
                if (hand.x >= rect.left && hand.x <= rect.right &&
                    hand.y >= rect.top && hand.y <= rect.bottom) {
                    hoveredBtn = btn;
                }
            });
            
            if (hoveredBtn) {
                hoveredBtn.classList.add('hovered');
                
                if (game.hoveredButton !== hoveredBtn) {
                    // Started hovering new button
                    game.hoveredButton = hoveredBtn;
                    game.pressStartTime = Date.now();
                    game.pressedButton = hoveredBtn;
                }
                
                // Update press progress
                const elapsed = Date.now() - game.pressStartTime;
                const progress = Math.min(100, (elapsed / game.pressThreshold) * 100);
                hoveredBtn.classList.add('pressing');
                hoveredBtn.style.setProperty('--press-progress', `${progress}%`);
                
                // Activate if held long enough
                if (elapsed >= game.pressThreshold) {
                    activateButton(hoveredBtn);
                    game.pressedButton = null;
                    game.pressStartTime = 0;
                }
            } else {
                game.hoveredButton = null;
                game.pressedButton = null;
            }
        }

        function activateButton(btn) {
            if (btn === elements.btn1P) {
                startGame('1p');
            } else if (btn === elements.btn2P) {
                startGame('2p');
            } else if (btn === elements.restartBtn) {
                restartGame();
            } else if (btn === elements.menuBtn) {
                goToMainMenu();
            }
        }

        function goToMainMenu() {
            game.state = 'title';
            game.gameMode = null;
            
            // Hide game over, show title
            elements.gameOverScreen.classList.add('hidden');
            elements.hud.classList.add('hidden');
            elements.titleScreen.classList.remove('hidden');
            
            // Restart title screen render loop
            requestAnimationFrame(renderTitleScreen);
        }

        // ============================================
        // Game Logic
        // ============================================
        function startGame(mode) {
            game.gameMode = mode; // '1p' or '2p' - locked for this game
            game.state = 'waiting'; // Wait for hand to appear
            game.lastPhysicsTime = performance.now();
            
            const canvas = elements.canvas;
            
            // Get canvas-relative sizes
            const sizes = getPixelSizes();
            
            // Reset players with x positions and targets
            game.player1 = { 
                x: 20,
                y: canvas.height / 2,
                targetX: 20,
                targetY: canvas.height / 2,
                points: 0,
                active: false, 
                wasActive: false,
                isGrabbing: false
            };
            game.player2 = { 
                x: canvas.width - sizes.paddleWidth - 20,
                y: canvas.height / 2,
                targetX: canvas.width - sizes.paddleWidth - 20,
                targetY: canvas.height / 2,
                points: 0,
                active: false, 
                wasActive: false, 
                isGrabbing: false
            };
            
            // Reset rally/scoring
            game.rally = 0;
            game.bestRally = 0;
            game.missCount = 0;
            game.servingPlayer = 'player1';
            game.totalPoints = 0;
            
            // Hide ball until ready
            game.ball.visible = false;
            game.ball.speed = sizes.ballSpeed;
            game.lastServePlayer = null;
            
            // Update UI
            elements.titleScreen.classList.add('hidden');
            elements.gameOverScreen.classList.add('hidden');
            elements.hud.classList.remove('hidden');
            
            updateScoreDisplay();
            elements.gameStatus.textContent = game.gameMode === '1p' 
                ? 'Show your hand on the LEFT!'
                : 'Both players show hands!';
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            startGame(game.gameMode); // Keep same mode
        }

        function startCountdown(serveFrom) {
            game.state = 'countdown';
            game.countdown = COUNTDOWN_DURATION;
            game.countdownStartTime = performance.now();
            game.lastServePlayer = serveFrom;
            game.waitingForBat = false;
            game.countdownPausedAt = 0;
            game.ball.visible = false;
            elements.gameStatus.textContent = '3';
        }

        function serveBall(fromPlayer) {
            const canvas = elements.canvas;
            const sizes = getPixelSizes();
            
            // Position ball at the serving player's paddle
            if (fromPlayer === 'player1') {
                game.ball.x = sizes.paddleWidth + 40 + sizes.ballSize;
                game.ball.y = game.player1.active ? game.player1.y : canvas.height / 2;
            } else {
                game.ball.x = canvas.width - sizes.paddleWidth - 40 - sizes.ballSize;
                game.ball.y = game.player2.active ? game.player2.y : canvas.height / 2;
            }
            
            // Random angle as if hit from paddle
            const angle = (Math.random() - 0.5) * Math.PI / 3; // -30 to +30 degrees
            const direction = fromPlayer === 'player1' ? 1 : -1;
            
            // Reset ball speed to initial value for new round
            game.ball.speed = sizes.ballSpeed;
            game.ball.vx = Math.cos(angle) * game.ball.speed * direction;
            game.ball.vy = Math.sin(angle) * game.ball.speed;
            game.ball.visible = true;
            
            game.state = 'playing';
            elements.gameStatus.textContent = 'Game On!';
        }

        function resetBall() {
            // This is now just used internally - actual reset uses countdown
            const canvas = elements.canvas;
            const sizes = getPixelSizes();
            game.ball.x = canvas.width / 2;
            game.ball.y = canvas.height / 2;
            game.ball.speed = sizes.ballSpeed;
            
            // Random direction, but always toward a player
            const angle = (Math.random() - 0.5) * Math.PI / 2; // -45 to +45 degrees
            const direction = Math.random() < 0.5 ? -1 : 1;
            game.ball.vx = Math.cos(angle) * game.ball.speed * direction;
            game.ball.vy = Math.sin(angle) * game.ball.speed;
        }

        function updateScoreDisplay() {
            if (game.gameMode === '1p') {
                // 1-Player mode: Rally count and best rally
                elements.player1Score.textContent = `Rally: ${game.rally}`;
                elements.player2Score.textContent = `Best: ${game.bestRally} | ‚ùå${game.missCount}/${MAX_MISSES_1P}`;
                elements.player2Score.classList.add('wall-mode');
            } else {
                // 2-Player mode: Points like table tennis
                const serveIndicator1 = game.servingPlayer === 'player1' ? 'üèì ' : '';
                const serveIndicator2 = game.servingPlayer === 'player2' ? 'üèì ' : '';
                elements.player1Score.textContent = `${serveIndicator1}P1: ${game.player1.points}`;
                elements.player2Score.textContent = `${serveIndicator2}P2: ${game.player2.points}`;
                elements.player2Score.classList.remove('wall-mode');
            }
        }
        
        function scorePoint(scorer) {
            // Someone scored a point (opponent missed)
            if (game.gameMode === '1p') {
                // 1-Player mode: player missed
                game.missCount++;
                game.bestRally = Math.max(game.bestRally, game.rally);
                game.rally = 0;
                
                if (game.missCount >= MAX_MISSES_1P) {
                    endGame(null); // No winner in 1P, just game over
                    return true;
                }
            } else {
                // 2-Player mode
                if (scorer === 'player1') {
                    game.player1.points++;
                } else {
                    game.player2.points++;
                }
                game.totalPoints++;
                
                // Check for win (first to 11, win by 2)
                const p1 = game.player1.points;
                const p2 = game.player2.points;
                if ((p1 >= POINTS_TO_WIN || p2 >= POINTS_TO_WIN) && Math.abs(p1 - p2) >= 2) {
                    endGame(p1 > p2 ? 'player1' : 'player2');
                    return true;
                }
                
                // Switch serve every 2 points (or every point after 10-10)
                const switchEvery = (p1 >= POINTS_TO_WIN - 1 && p2 >= POINTS_TO_WIN - 1) ? 1 : SERVE_SWITCH_POINTS;
                if (game.totalPoints % switchEvery === 0) {
                    game.servingPlayer = game.servingPlayer === 'player1' ? 'player2' : 'player1';
                }
            }
            
            updateScoreDisplay();
            return false; // Game continues
        }
        
        function incrementRally() {
            // Called when ball successfully hits a paddle (1P mode)
            if (game.gameMode === '1p') {
                game.rally++;
                game.bestRally = Math.max(game.bestRally, game.rally);
                updateScoreDisplay();
            }
        }

        function gameLoop(timestamp) {
            if (game.state === 'gameover' || game.state === 'title') return;
            
            // Frame rate limiting for physics/UI at 30 FPS
            const elapsed = timestamp - game.lastPhysicsTime;
            if (elapsed < PHYSICS_INTERVAL) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Calculate delta time in seconds (capped to prevent huge jumps)
            const deltaTime = Math.min(elapsed / 1000, 0.1);
            game.lastPhysicsTime = timestamp;
            
            resizeCanvas();
            updatePlayers();
            movePaddlesTowardTarget(deltaTime);  // Smooth paddle movement
            
            // Handle different game states
            if (game.state === 'waiting') {
                // Waiting for hand to appear/reappear
                if (game.player1.active && !game.player1.wasActive) {
                    // Hand just appeared - start countdown
                    startCountdown('player1');
                }
                // Update wasActive AFTER checking transitions
                game.player1.wasActive = game.player1.active;
                game.player2.wasActive = game.player2.active;
            } else if (game.state === 'countdown') {
                // Check if the serving player's bat is present
                // In 1P mode, always ready since wall is always there
                const playerActive = game.lastServePlayer === 'player1' ? game.player1.active : 
                                    (game.gameMode === '1p' || game.player2.active);
                
                if (!playerActive && !game.waitingForBat) {
                    // Bat disappeared - pause countdown
                    game.waitingForBat = true;
                    game.countdownPausedAt = game.countdown;
                    elements.gameStatus.textContent = 'Show hand!';
                } else if (playerActive && game.waitingForBat) {
                    // Bat returned - resume countdown
                    game.waitingForBat = false;
                    game.countdownStartTime = timestamp - (COUNTDOWN_DURATION - game.countdownPausedAt) * 1000;
                }
                
                if (!game.waitingForBat) {
                    // Update countdown
                    const countdownElapsed = (timestamp - game.countdownStartTime) / 1000;
                    const remaining = Math.ceil(COUNTDOWN_DURATION - countdownElapsed);
                    
                    if (remaining > 0) {
                        game.countdown = remaining;
                        elements.gameStatus.textContent = remaining.toString();
                    } else {
                        // Countdown finished - serve the ball
                        serveBall(game.lastServePlayer || 'player1');
                    }
                }
                // Update wasActive for countdown state too
                game.player1.wasActive = game.player1.active;
                game.player2.wasActive = game.player2.active;
            } else if (game.state === 'playing') {
                updateBall(deltaTime);
                // Update wasActive for playing state
                game.player1.wasActive = game.player1.active;
                game.player2.wasActive = game.player2.active;
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        function updatePlayers() {
            const canvas = elements.canvas;
            const centerX = canvas.width / 2;
            const sizes = getPixelSizes();
            
            // Find hands for each player based on court position
            const p1Hand = game.hands.find(h => h.player === 'player1');
            const p2Hand = game.hands.find(h => h.player === 'player2');
            
            // Player 1 (left side) - controlled by hand on left side of court
            if (p1Hand) {
                game.player1.active = true;
                game.player1.targetY = p1Hand.y;
                game.player1.isGrabbing = p1Hand.isGrabbing;
                
                // When grabbing, allow horizontal movement (but stay on left side)
                if (p1Hand.isGrabbing) {
                    const maxX = centerX - CENTER_MARGIN - sizes.paddleWidth;
                    game.player1.targetX = Math.max(0, Math.min(maxX, p1Hand.x));
                } else {
                    game.player1.targetX = 20;
                }
            } else {
                game.player1.active = false;
                game.player1.isGrabbing = false;
            }
            
            // Player 2 (right side) - in 2P mode, controlled by hand on right side
            // In 1P mode, player2 is always the wall (no hand control)
            if (game.gameMode === '2p' && p2Hand) {
                game.player2.active = true;
                game.player2.targetY = p2Hand.y;
                game.player2.isGrabbing = p2Hand.isGrabbing;
                
                // When grabbing, allow horizontal movement (but stay on right side)
                if (p2Hand.isGrabbing) {
                    const minX = centerX + CENTER_MARGIN;
                    const maxX = canvas.width - sizes.paddleWidth;
                    game.player2.targetX = Math.max(minX, Math.min(maxX, p2Hand.x - sizes.paddleWidth));
                } else {
                    game.player2.targetX = canvas.width - sizes.paddleWidth - 20;
                }
            } else if (game.gameMode === '2p') {
                // 2P mode but no hand on right - paddle inactive but still shows
                game.player2.active = false;
                game.player2.isGrabbing = false;
            }
            // In 1P mode, player2 state doesn't matter - wall is drawn instead
            
            // Check if player1 just appeared during waiting state (to start game)
            if (game.state === 'waiting') {
                if (game.player1.active && !game.player1.wasActive) {
                    startCountdown('player1');
                }
            }
            
            updateScoreDisplay();
        }
        
        function movePaddlesTowardTarget(deltaTime) {
            // Move each paddle smoothly toward its target position
            const sizes = getPixelSizes();
            const maxMove = sizes.paddleSpeed * deltaTime;
            
            // Player 1
            if (game.player1.active) {
                const dx1 = game.player1.targetX - game.player1.x;
                const dy1 = game.player1.targetY - game.player1.y;
                const dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                
                if (dist1 > 0) {
                    if (dist1 <= maxMove) {
                        // Close enough - snap to target
                        game.player1.x = game.player1.targetX;
                        game.player1.y = game.player1.targetY;
                    } else {
                        // Move toward target at max speed
                        const ratio = maxMove / dist1;
                        game.player1.x += dx1 * ratio;
                        game.player1.y += dy1 * ratio;
                    }
                }
            }
            
            // Player 2 (only in 2P mode)
            if (game.gameMode === '2p' && game.player2.active) {
                const dx2 = game.player2.targetX - game.player2.x;
                const dy2 = game.player2.targetY - game.player2.y;
                const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                
                if (dist2 > 0) {
                    if (dist2 <= maxMove) {
                        // Close enough - snap to target
                        game.player2.x = game.player2.targetX;
                        game.player2.y = game.player2.targetY;
                    } else {
                        // Move toward target at max speed
                        const ratio = maxMove / dist2;
                        game.player2.x += dx2 * ratio;
                        game.player2.y += dy2 * ratio;
                    }
                }
            }
        }

        function updateBall(deltaTime) {
            const canvas = elements.canvas;
            const ball = game.ball;
            const sizes = getPixelSizes();
            
            // Move ball using deltaTime for consistent physics
            const moveX = ball.vx * deltaTime;
            const moveY = ball.vy * deltaTime;
            ball.x += moveX;
            ball.y += moveY;
            
            // Apply air friction based on distance traveled (normalized to canvas height)
            const distanceRatio = Math.sqrt(moveX * moveX + moveY * moveY) / canvas.height;
            const frictionDecay = Math.exp(-AIR_FRICTION * distanceRatio);
            ball.speed = Math.max(sizes.minBallSpeed, ball.speed * frictionDecay);
            
            // Update velocity magnitude to match new speed (preserve direction)
            const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (currentSpeed > 0) {
                const speedRatio = ball.speed / currentSpeed;
                ball.vx *= speedRatio;
                ball.vy *= speedRatio;
            }
            
            // Top/bottom wall bounce
            if (ball.y - sizes.ballSize / 2 <= 0 || ball.y + sizes.ballSize / 2 >= canvas.height) {
                ball.vy *= -1;
                ball.y = Math.max(sizes.ballSize / 2, Math.min(canvas.height - sizes.ballSize / 2, ball.y));
            }
            
            // Player 1 paddle collision (left side)
            const p1Right = game.player1.x + sizes.paddleWidth;
            if (game.player1.active && ball.x - sizes.ballSize / 2 <= p1Right && ball.x + sizes.ballSize / 2 >= game.player1.x) {
                const paddleTop = game.player1.y - sizes.paddleHeight / 2;
                const paddleBottom = game.player1.y + sizes.paddleHeight / 2;
                
                if (ball.y >= paddleTop && ball.y <= paddleBottom && ball.vx < 0) {
                    // Calculate hit position: -1 (top) to +1 (bottom)
                    const hitPos = (ball.y - game.player1.y) / (sizes.paddleHeight / 2);
                    
                    // Convert to angle: -45¬∞ (top) to +45¬∞ (bottom), 0¬∞ in middle
                    const maxAngle = Math.PI / 4; // 45 degrees
                    const angle = hitPos * maxAngle;
                    
                    // Reset to initial speed - paddle always hits with full force
                    ball.speed = sizes.ballSpeed;
                    
                    // Apply hit boost for satisfying "thwack" effect
                    const hitSpeed = ball.speed * HIT_SPEED_MULTIPLIER;
                    
                    // Set new velocity based on angle (ball goes right from player 1)
                    ball.vx = Math.cos(angle) * hitSpeed;
                    ball.vy = Math.sin(angle) * hitSpeed;
                    
                    // Push ball out of paddle
                    ball.x = p1Right + sizes.ballSize / 2;
                    
                    // Track rally in 1P mode
                    incrementRally();
                }
            }
            
            // Ball passed left edge - Player 1 missed!
            if (ball.x < -sizes.ballSize) {
                ball.visible = false;
                
                // Score point for player 2 (or count miss in 1P mode)
                const gameEnded = scorePoint('player2');
                
                if (!gameEnded) {
                    // Start countdown - server depends on mode
                    startCountdown(game.gameMode === '1p' ? 'player1' : game.servingPlayer);
                }
            }
            
            // Player 2 paddle or wall collision (right side)
            const p2Left = game.player2.x;
            const p2Right = game.player2.x + sizes.paddleWidth;
            
            if (game.gameMode === '1p') {
                // Wall acts like a stationary bat - always returns at full speed
                const wallX = canvas.width - 20;
                if (ball.x + sizes.ballSize / 2 >= wallX) {
                    // Reset to initial speed - wall returns with full force
                    ball.speed = sizes.ballSpeed;
                    
                    // Apply hit boost (wall "hits" the ball back)
                    const hitSpeed = ball.speed * HIT_SPEED_MULTIPLIER;
                    
                    // Reflect with boosted speed, preserve Y velocity ratio
                    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    const vyRatio = currentSpeed > 0 ? ball.vy / currentSpeed : 0;
                    const vxRatio = currentSpeed > 0 ? Math.abs(ball.vx) / currentSpeed : 1;
                    
                    ball.vx = -vxRatio * hitSpeed;
                    ball.vy = vyRatio * hitSpeed;
                    ball.x = wallX - sizes.ballSize / 2;
                    
                    // Wall bounce counts as a rally hit too
                    incrementRally();
                }
            } else if (game.gameMode === '2p' && game.player2.active && ball.x + sizes.ballSize / 2 >= p2Left && ball.x - sizes.ballSize / 2 <= p2Right) {
                const paddleTop = game.player2.y - sizes.paddleHeight / 2;
                const paddleBottom = game.player2.y + sizes.paddleHeight / 2;
                
                if (ball.y >= paddleTop && ball.y <= paddleBottom && ball.vx > 0) {
                    // Calculate hit position: -1 (top) to +1 (bottom)
                    const hitPos = (ball.y - game.player2.y) / (sizes.paddleHeight / 2);
                    
                    // Convert to angle: -45¬∞ (top) to +45¬∞ (bottom), 0¬∞ in middle
                    const maxAngle = Math.PI / 4; // 45 degrees
                    const angle = hitPos * maxAngle;
                    
                    // Reset to initial speed - paddle always hits with full force
                    ball.speed = sizes.ballSpeed;
                    
                    // Apply hit boost for satisfying "thwack" effect
                    const hitSpeed = ball.speed * HIT_SPEED_MULTIPLIER;
                    
                    // Set new velocity based on angle (ball goes left from player 2)
                    ball.vx = -Math.cos(angle) * hitSpeed;
                    ball.vy = Math.sin(angle) * hitSpeed;
                    
                    // Push ball out of paddle
                    ball.x = p2Left - sizes.ballSize / 2;
                }
            }
            
            // Ball passed right edge - Player 2 missed! (only in 2P mode)
            if (game.gameMode === '2p' && ball.x > canvas.width + sizes.ballSize) {
                ball.visible = false;
                
                // Score point for player 1
                const gameEnded = scorePoint('player1');
                
                if (!gameEnded) {
                    // Start countdown - server continues
                    startCountdown(game.servingPlayer);
                }
            }
        }

        function endGame(winner) {
            game.state = 'gameover';
            
            elements.hud.classList.add('hidden');
            elements.gameOverScreen.classList.remove('hidden');
            
            // Reset title styling
            elements.gameOverTitle.className = '';
            
            if (game.gameMode === '1p') {
                // 1-Player mode - show best rally
                elements.gameOverTitle.textContent = 'Game Over!';
                elements.gameOverTitle.classList.add('game-over-1p');
                elements.finalScoreText.innerHTML = `
                    <div class="winner">üèì Best Rally: ${game.bestRally}</div>
                    <div>Keep practicing!</div>
                `;
            } else {
                // 2-Player mode - show winner with appropriate color
                if (winner === 'player1') {
                    elements.gameOverTitle.textContent = 'üèÜ Player 1 Wins!';
                    elements.gameOverTitle.classList.add('winner-p1');
                } else {
                    elements.gameOverTitle.textContent = 'üèÜ Player 2 Wins!';
                    elements.gameOverTitle.classList.add('winner-p2');
                }
                elements.finalScoreText.innerHTML = `
                    <div>Final Score</div>
                    <div class="winner">${game.player1.points} - ${game.player2.points}</div>
                `;
            }
            
            // Restart title screen render loop for game over screen
            requestAnimationFrame(renderTitleScreen);
        }

        // ============================================
        // Rendering
        // ============================================
        const VIDEO_BLUR_RATIO = 0.03; // 3% of screen height (doubled for softer look)
        const LAWN_BLUR_RATIO = 0.003; // 0.3% of screen height (subtle blur)
        const LAWN_STRIPE_RATIO = 0.04; // 4% of screen height per stripe
        
        function updateVideoBlur() {
            // Update video blur based on screen height (CSS custom property for GPU acceleration)
            const blurPx = Math.round(window.innerHeight * VIDEO_BLUR_RATIO);
            document.documentElement.style.setProperty('--video-blur', `${blurPx}px`);
            
            // Update lawn blur (much smaller)
            const lawnBlurPx = Math.max(1, Math.round(window.innerHeight * LAWN_BLUR_RATIO));
            document.documentElement.style.setProperty('--lawn-blur', `${lawnBlurPx}px`);
        }
        
        function generateLawnTexture() {
            const canvas = elements.lawnTexture;
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            canvas.width = width;
            canvas.height = height;
            
            const stripeHeight = Math.round(height * LAWN_STRIPE_RATIO);
            
            // Tennis lawn green colors - alternating light/dark stripes
            const lightGreen = '#2d5a2d';  // Lighter grass stripe
            const darkGreen = '#1e4a1e';   // Darker grass stripe
            
            // Draw alternating horizontal stripes (like mowed lawn)
            for (let y = 0; y < height; y += stripeHeight) {
                const isLight = Math.floor(y / stripeHeight) % 2 === 0;
                lawnCtx.fillStyle = isLight ? lightGreen : darkGreen;
                lawnCtx.fillRect(0, y, width, stripeHeight);
            }
            
            // Add subtle noise/grain for grass texture
            const imageData = lawnCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                // Add random variation to green channel primarily
                const noise = (Math.random() - 0.5) * 20;
                data[i] = Math.max(0, Math.min(255, data[i] + noise * 0.3));     // R
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));   // G (more variation)
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise * 0.3)); // B
            }
            
            lawnCtx.putImageData(imageData, 0, 0);
        }
        
        function resizeCanvas() {
            if (elements.canvas.width !== window.innerWidth || 
                elements.canvas.height !== window.innerHeight) {
                elements.canvas.width = window.innerWidth;
                elements.canvas.height = window.innerHeight;
                updateVideoBlur();
                generateLawnTexture();
            }
        }

        function render() {
            const canvas = elements.canvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw center line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw paddles using player x positions
            drawPaddle(game.player1.x, game.player1.y, 'player1', game.player1.active, game.player1.isGrabbing);
            
            if (game.gameMode === '1p') {
                drawWall(canvas.width - 20);
            } else {
                drawPaddle(game.player2.x, game.player2.y, 'player2', game.player2.active, game.player2.isGrabbing);
            }
            
            // Draw ball
            drawBall();
            
            // Draw countdown if active
            if (game.state === 'countdown') {
                drawCountdown();
            } else if (game.state === 'waiting') {
                drawWaitingForHand();
            }
            
            // Draw hand indicators based on which player each hand is assigned to
            game.hands.forEach((hand) => {
                drawHandIndicator(hand.x, hand.y, hand.player);
            });
        }
        
        function drawCountdown() {
            const canvas = elements.canvas;
            ctx.save();
            
            if (game.waitingForBat) {
                // Show "waiting for hand" message
                ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';
                ctx.font = 'bold 60px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#ffcc66';
                ctx.shadowBlur = 20;
                ctx.fillText('üëã', canvas.width / 2, canvas.height / 2);
            } else {
                // Large countdown number in center
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 200px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 30;
                ctx.fillText(game.countdown.toString(), canvas.width / 2, canvas.height / 2);
            }
            
            ctx.restore();
        }
        
        function drawWaitingForHand() {
            const canvas = elements.canvas;
            ctx.save();
            
            // Pulsing hand emoji
            const pulse = Math.sin(Date.now() / 300) * 0.2 + 0.8;
            ctx.globalAlpha = pulse;
            ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
            ctx.font = 'bold 120px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#66ccff';
            ctx.shadowBlur = 30;
            ctx.fillText('‚úã', canvas.width / 2, canvas.height / 2);
            
            ctx.restore();
        }

        function drawPaddle(x, y, player, active, isGrabbing = false) {
            const alpha = active ? 1 : 0.3;
            
            // Different color when grabbing (brighter/white glow)
            if (isGrabbing && active) {
                ctx.fillStyle = player === 'player1' 
                    ? `rgba(100, 180, 255, ${alpha})` 
                    : `rgba(255, 120, 200, ${alpha})`;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 30;
            } else {
                ctx.fillStyle = player === 'player1' 
                    ? `rgba(59, 130, 246, ${alpha})` 
                    : `rgba(236, 72, 153, ${alpha})`;
                
                // Normal glow effect
                if (active) {
                    ctx.shadowColor = player === 'player1' ? '#3b82f6' : '#ec4899';
                    ctx.shadowBlur = 20;
                }
            }
            
            // Rounded paddle
            const sizes = getPixelSizes();
            const radius = sizes.paddleWidth / 2;
            ctx.beginPath();
            ctx.roundRect(x, y - sizes.paddleHeight / 2, sizes.paddleWidth, sizes.paddleHeight, radius);
            ctx.fill();
            
            ctx.shadowBlur = 0;
        }

        function drawWall(x) {
            ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.fillRect(x - 10, 0, 20, elements.canvas.height);
            
            // Wall pattern
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
            ctx.lineWidth = 2;
            for (let y = 0; y < elements.canvas.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(x - 10, y);
                ctx.lineTo(x + 10, y);
                ctx.stroke();
            }
        }

        function drawBall() {
            const ball = game.ball;
            const sizes = getPixelSizes();
            
            // Don't draw if ball is hidden (during countdown)
            if (!ball.visible) return;
            
            // Main ball
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, sizes.ballSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawHandIndicator(x, y, player) {
            const color = player === 'player1' ? 'rgba(59, 130, 246, 0.6)' : 'rgba(236, 72, 153, 0.6)';
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Crosshair
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 25, y);
            ctx.lineTo(x + 25, y);
            ctx.moveTo(x, y - 25);
            ctx.lineTo(x, y + 25);
            ctx.stroke();
        }

        // ============================================
        // Title Screen Rendering
        // ============================================
        function renderTitleScreen() {
            if (game.state !== 'title' && game.state !== 'gameover') return;
            
            resizeCanvas();
            ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            
            // Draw hand indicators on title/game over screen
            game.hands.forEach((hand) => {
                drawHandIndicator(hand.x, hand.y, hand.player);
            });
            
            requestAnimationFrame(renderTitleScreen);
        }

        // ============================================
        // Initialization
        // ============================================
        function init() {
            updateVideoBlur(); // Set initial blur before canvas resize
            generateLawnTexture(); // Generate lawn texture
            resizeCanvas();
            initHandTracking();
            
            // Click to start camera
            document.addEventListener('click', () => {
                if (!game.cameraReady) {
                    elements.cameraStatus.textContent = '‚è≥ Starting camera...';
                    startCamera();
                }
            }, { once: false });
            
            // Keyboard/mouse fallback for mode buttons
            elements.btn1P.addEventListener('click', () => {
                if (!elements.btn1P.disabled) {
                    startGame('1p');
                }
            });
            
            elements.btn2P.addEventListener('click', () => {
                if (!elements.btn2P.disabled) {
                    startGame('2p');
                }
            });
            
            elements.restartBtn.addEventListener('click', () => {
                restartGame();
            });
            
            elements.menuBtn.addEventListener('click', () => {
                goToMainMenu();
            });
            
            // Start title screen render loop
            renderTitleScreen();
        }

        // Start
        init();
    </script>

    <script src="parental.js" defer></script>
    <script src="assets/js/pwa.js" defer></script>
</body>
</html>
