<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Badge Generator - Realistic Embroidered Patches</title>
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --accent: #e94560;
      --accent-hover: #ff6b6b;
      --text-primary: #eaeaea;
      --text-secondary: #a0a0a0;
      --border: #2a2a4a;
      --success: #4ade80;
      --input-bg: #0d1b2a;
      --shadow: rgba(0, 0, 0, 0.3);
    }

    html {
      font-size: 16px;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
    }

    h1 {
      margin: 0;
      font-size: 1.75rem;
      font-weight: 600;
    }

    .app {
      display: grid;
      grid-template-columns: minmax(320px, 400px) 1fr;
      min-height: 100vh;
      gap: 0;
    }

    @media (max-width: 900px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
    }

    .controls {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      padding: 1.5rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .header svg {
      width: 32px;
      height: 32px;
      fill: var(--accent);
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: fit-content;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    label {
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    input,
    select,
    button {
      font-family: inherit;
      font-size: 1rem;
      padding: 0.625rem 0.875rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--input-bg);
      color: var(--text-primary);
      transition: border-color 0.2s, box-shadow 0.2s;
      width: 100%;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(233, 69, 96, 0.2);
    }

    input[type="file"] {
      padding: 0.5rem;
      cursor: pointer;
    }

    input[type="file"]::file-selector-button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      margin-right: 0.75rem;
      transition: background 0.2s;
    }

    input[type="file"]::file-selector-button:hover {
      background: var(--accent-hover);
    }

    input[type="range"] {
      padding: 0;
      height: 6px;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255, 255, 255, 0.05);
      border: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px var(--shadow);
    }

    select {
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23a0a0a0'%3E%3Cpath d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 2.5rem;
    }

    .range-value {
      display: inline-block;
      min-width: 2.5rem;
      text-align: right;
      font-weight: 600;
      color: var(--accent);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.75rem 1.25rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-primary:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-group {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .preview-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      background: var(--bg-primary);
      background-image: radial-gradient(circle at 1px 1px, var(--border) 1px, transparent 0);
      background-size: 24px 24px;
      position: relative;
      overflow: hidden;
    }

    .preview-container {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 8px 32px var(--shadow);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      max-width: 100%;
      max-height: 100%;
    }

    #previewCanvas {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow);
    }

    .status {
      font-size: 0.875rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status.rendering {
      color: var(--accent);
    }

    .status.ready {
      color: var(--success);
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--accent);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .polygon-sides {
      display: none;
    }

    .polygon-sides.visible {
      display: block;
    }

    .dimension-toggle {
      display: flex;
      background: var(--input-bg);
      border-radius: 8px;
      padding: 4px;
      gap: 4px;
    }

    .dimension-toggle button {
      flex: 1;
      padding: 0.5rem;
      font-size: 0.875rem;
      background: transparent;
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .dimension-toggle button.active {
      background: var(--accent);
      color: white;
    }

    .dimension-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .dimension-inputs.scale-mode {
      grid-template-columns: 1fr;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .empty-state {
      text-align: center;
      color: var(--text-secondary);
      padding: 2rem;
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      opacity: 0.5;
      margin-bottom: 1rem;
    }
  </style>
</head>

<body>
  <div class="app" role="main">
    <aside class="controls" role="form" aria-label="Badge configuration">
      <header class="header">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path
            d="M12 2L2 7v10l10 5 10-5V7L12 2zm0 2.18l6.9 3.45L12 11.09 5.1 7.63 12 4.18zM4 8.82l7 3.5v7.36l-7-3.5V8.82zm9 10.86v-7.36l7-3.5v7.36l-7 3.5z" />
        </svg>
        <h1>Badge Generator</h1>
      </header>

      <div class="form-group">
        <label for="imageInput">Source Image</label>
        <input type="file" id="imageInput" accept=".png,.jpg,.jpeg,.webp,image/png,image/jpeg,image/webp"
          aria-describedby="imageHelp">
        <small id="imageHelp" class="status">PNG, JPG, or WebP supported</small>
      </div>

      <div class="form-group">
        <label for="shapeSelect">Badge Shape</label>
        <select id="shapeSelect" aria-describedby="shapeHelp">
          <option value="horizontal-lozenge">Horizontal Lozenge</option>
          <option value="vertical-lozenge">Vertical Lozenge</option>
          <option value="circle">Circle</option>
          <option value="diamond">Diamond</option>
          <option value="square">Square</option>
          <option value="rectangle">Rectangle</option>
          <option value="polygon">Custom Polygon</option>
        </select>
        <div class="polygon-sides" id="polygonSidesGroup">
          <label for="polygonSides">Number of Sides</label>
          <input type="number" id="polygonSides" min="3" max="12" value="6" aria-label="Polygon sides">
        </div>
      </div>

      <div class="form-group">
        <label for="title1">Top Title</label>
        <input type="text" id="title1" placeholder="e.g., NASA" maxlength="30" aria-describedby="title1Help">
        <small id="title1Help" class="sr-only">Text displayed on top arc of badge</small>
      </div>

      <div class="form-group">
        <label for="title2">Bottom Title</label>
        <input type="text" id="title2" placeholder="e.g., SPACE PROGRAM" maxlength="30" aria-describedby="title2Help">
        <small id="title2Help" class="sr-only">Text displayed on bottom arc of badge</small>
      </div>

      <div class="form-group">
        <label for="textScale">
          Text Size: <span class="range-value" id="textScaleValue">100%</span>
        </label>
        <input type="range" id="textScale" min="50" max="300" value="100" step="10" aria-describedby="textScaleHelp">
        <small id="textScaleHelp" class="sr-only">Scale size of badge text</small>
      </div>

      <div class="form-group">
        <label for="colorCount">
          Posterize Colors: <span class="range-value" id="colorCountValue">6</span>
        </label>
        <input type="range" id="colorCount" min="2" max="16" value="6" aria-describedby="colorHelp">
        <small id="colorHelp" class="sr-only">Number of colors to reduce image to</small>
      </div>

      <div class="form-group">
        <label id="dimensionLabel">Output Size</label>
        <div class="dimension-toggle" role="tablist" aria-label="Dimension mode">
          <button type="button" role="tab" id="tabPixels" class="active" aria-selected="true"
            aria-controls="pixelInputs">Pixels</button>
          <button type="button" role="tab" id="tabScale" aria-selected="false" aria-controls="scaleInputs">Scale
            %</button>
        </div>
        <div class="dimension-inputs" id="dimensionInputs" role="tabpanel" aria-labelledby="dimensionLabel">
          <div class="form-group">
            <label for="outputWidth" class="sr-only">Width</label>
            <input type="number" id="outputWidth" min="50" max="2000" value="400" placeholder="Width"
              aria-label="Output width in pixels">
          </div>
          <div class="form-group">
            <label for="outputHeight" class="sr-only">Height</label>
            <input type="number" id="outputHeight" min="50" max="2000" value="400" placeholder="Height"
              aria-label="Output height in pixels">
          </div>
          <div class="form-group" style="display:none;">
            <label for="outputScale" class="sr-only">Scale percentage</label>
            <input type="number" id="outputScale" min="10" max="500" value="100" placeholder="Scale %">
          </div>
        </div>
      </div>

      <div class="form-group" style="margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--border);">
        <button type="button" id="renderBtn" class="btn btn-primary" disabled aria-live="polite">
          <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true">
            <path d="M8 3a5 5 0 100 10A5 5 0 008 3zm0 1a4 4 0 110 8 4 4 0 010-8z" />
          </svg>
          Generate Badge
        </button>
        <div class="btn-group" style="margin-top: 0.75rem;">
          <button type="button" id="copyBtn" class="btn btn-secondary" disabled>
            <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true">
              <path
                d="M4 2a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2V4a2 2 0 00-2-2H4zm0 1h8a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4a1 1 0 011-1z" />
            </svg>
            Copy
          </button>
          <button type="button" id="saveBtn" class="btn btn-secondary" disabled>
            <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true">
              <path d="M8 12l-4-4h2.5V4h3v4H12L8 12z" />
              <path d="M14 14H2v-3h1v2h10v-2h1v3z" />
            </svg>
            Save PNG
          </button>
        </div>
      </div>
    </aside>

    <section class="preview-area" aria-label="Badge preview">
      <div class="preview-container">
        <div id="emptyState" class="empty-state">
          <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <path
              d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14zm-5-7l-3 3.72L9 13l-3 4h12l-4-5z" />
          </svg>
          <p>Upload an image to get started</p>
        </div>
        <canvas id="previewCanvas" width="400" height="400" style="display:none;"
          aria-label="Generated badge preview"></canvas>
        <div id="statusText" class="status" aria-live="polite"></div>
      </div>
    </section>
  </div>

  <script>
    // ============================================
    // IMAGE PROCESSOR - Load and posterize images
    // ============================================
    class ImageProcessor {
      static loadImage(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      static getImageData(img, width, height, centerCrop = false) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        if (centerCrop) {
          // Center-crop: crop the source image to match target aspect ratio
          const targetAspect = width / height;
          const srcAspect = img.width / img.height;

          let srcX = 0, srcY = 0, srcW = img.width, srcH = img.height;

          if (srcAspect > targetAspect) {
            // Source is wider - crop horizontally
            srcW = img.height * targetAspect;
            srcX = (img.width - srcW) / 2;
          } else {
            // Source is taller - crop vertically
            srcH = img.width / targetAspect;
            srcY = (img.height - srcH) / 2;
          }

          ctx.drawImage(img, srcX, srcY, srcW, srcH, 0, 0, width, height);
        } else {
          // Stretch to fit
          ctx.drawImage(img, 0, 0, width, height);
        }

        return ctx.getImageData(0, 0, width, height);
      }

      static posterize(imageData, colorCount) {
        const data = imageData.data;
        const totalPixels = data.length / 4;

        // Sample pixels to avoid stack overflow (max 10000 for palette extraction)
        const maxSamples = 10000;
        const step = Math.max(1, Math.floor(totalPixels / maxSamples));
        const sampledPixels = [];
        for (let i = 0; i < data.length; i += 4 * step) {
          sampledPixels.push([data[i], data[i + 1], data[i + 2]]);
        }

        const palette = this.medianCutIterative(sampledPixels, colorCount);
        const result = new ImageData(imageData.width, imageData.height);

        for (let i = 0; i < totalPixels; i++) {
          const pixel = [data[i * 4], data[i * 4 + 1], data[i * 4 + 2]];
          const nearest = this.findNearest(pixel, palette);
          result.data[i * 4] = nearest[0];
          result.data[i * 4 + 1] = nearest[1];
          result.data[i * 4 + 2] = nearest[2];
          result.data[i * 4 + 3] = data[i * 4 + 3]; // Preserve alpha
        }
        return { imageData: result, palette };
      }

      static medianCutIterative(pixels, count) {
        if (pixels.length === 0) return [[128, 128, 128]];

        // Use iterative approach with a queue instead of recursion
        let buckets = [pixels];

        while (buckets.length < count) {
          // Find the bucket with the largest color range
          let maxRange = -1;
          let maxIndex = 0;

          for (let i = 0; i < buckets.length; i++) {
            const bucket = buckets[i];
            if (bucket.length < 2) continue;

            const range = this.getMaxColorRange(bucket);
            if (range.maxRange > maxRange) {
              maxRange = range.maxRange;
              maxIndex = i;
            }
          }

          // Split the bucket with the largest range
          const bucketToSplit = buckets[maxIndex];
          if (bucketToSplit.length < 2) break;

          const { channel } = this.getMaxColorRange(bucketToSplit);
          bucketToSplit.sort((a, b) => a[channel] - b[channel]);

          const mid = Math.floor(bucketToSplit.length / 2);
          const left = bucketToSplit.slice(0, mid);
          const right = bucketToSplit.slice(mid);

          buckets.splice(maxIndex, 1, left, right);
        }

        // Calculate average color for each bucket
        return buckets.map(bucket => this.averageColor(bucket));
      }

      static getMaxColorRange(pixels) {
        if (pixels.length === 0) return { channel: 0, maxRange: 0 };

        let minR = 255, maxR = 0, minG = 255, maxG = 0, minB = 255, maxB = 0;
        for (const p of pixels) {
          if (p[0] < minR) minR = p[0]; if (p[0] > maxR) maxR = p[0];
          if (p[1] < minG) minG = p[1]; if (p[1] > maxG) maxG = p[1];
          if (p[2] < minB) minB = p[2]; if (p[2] > maxB) maxB = p[2];
        }

        const rangeR = maxR - minR;
        const rangeG = maxG - minG;
        const rangeB = maxB - minB;

        if (rangeR >= rangeG && rangeR >= rangeB) return { channel: 0, maxRange: rangeR };
        if (rangeG >= rangeR && rangeG >= rangeB) return { channel: 1, maxRange: rangeG };
        return { channel: 2, maxRange: rangeB };
      }

      static averageColor(pixels) {
        if (pixels.length === 0) return [128, 128, 128];
        const sum = pixels.reduce((acc, p) => [acc[0] + p[0], acc[1] + p[1], acc[2] + p[2]], [0, 0, 0]);
        return sum.map(v => Math.round(v / pixels.length));
      }

      static findNearest(pixel, palette) {
        let minDist = Infinity, nearest = palette[0];
        for (const color of palette) {
          const dist = (pixel[0] - color[0]) ** 2 + (pixel[1] - color[1]) ** 2 + (pixel[2] - color[2]) ** 2;
          if (dist < minDist) { minDist = dist; nearest = color; }
        }
        return nearest;
      }

      static extractRegions(imageData, palette) {
        const { width, height, data } = imageData;
        const regions = new Map();
        palette.forEach(c => regions.set(c.join(','), []));
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            // Skip transparent pixels
            if (data[i + 3] < 50) continue;

            const pixel = [data[i], data[i + 1], data[i + 2]];
            const key = pixel.join(',');
            if (regions.has(key)) {
              regions.get(key).push({ x, y });
            }
          }
        }
        return regions;
      }
    }

    // ============================================
    // SHAPE GENERATOR - Create badge boundary paths
    // ============================================
    class ShapeGenerator {
      static generatePath(type, width, height, sides = 6) {
        const cx = width / 2, cy = height / 2;
        const path = new Path2D();
        switch (type) {
          case 'horizontal-lozenge': {
            // Enforce at least 10% flat width to maintain lozenge shape
            // flatW = width - 2*outerRadius. we want flatW >= 0.1*width
            // 2*outerRadius <= 0.9*width => outerRadius <= 0.45*width
            const outerR = Math.min(height / 2, width * 0.45);
            const r = outerR * 0.9; // Margin
            const flatW = width - 2 * outerR; // Use full width distribution

            path.moveTo(cx - flatW / 2, cy - r);
            path.lineTo(cx + flatW / 2, cy - r);
            path.arc(cx + flatW / 2, cy, r, -Math.PI / 2, Math.PI / 2);
            path.lineTo(cx - flatW / 2, cy + r);
            path.arc(cx - flatW / 2, cy, r, Math.PI / 2, -Math.PI / 2);
            break;
          }
          case 'vertical-lozenge': {
            // Enforce at least 10% flat height
            // flatH = height - 2*outerRadius. we want flatH >= 0.1*height
            // 2*outerRadius <= 0.9*height => outerRadius <= 0.45*height
            const outerR = Math.min(width / 2, height * 0.45);
            const r = outerR * 0.9;
            const flatH = height - 2 * outerR;

            path.moveTo(cx + r, cy - flatH / 2);
            path.lineTo(cx + r, cy + flatH / 2);
            path.arc(cx, cy + flatH / 2, r, 0, Math.PI);
            path.lineTo(cx - r, cy - flatH / 2);
            path.arc(cx, cy - flatH / 2, r, Math.PI, 0);
            break;
          }
          case 'circle': {
            const r = Math.min(width, height) / 2 * 0.95;
            path.arc(cx, cy, r, 0, Math.PI * 2);
            break;
          }
          case 'diamond': {
            const rx = width / 2 * 0.9, ry = height / 2 * 0.9;
            path.moveTo(cx, cy - ry);
            path.lineTo(cx + rx, cy);
            path.lineTo(cx, cy + ry);
            path.lineTo(cx - rx, cy);
            path.closePath();
            break;
          }
          case 'square': {
            const size = Math.min(width, height) * 0.9;
            const r = size * 0.08;
            const x = cx - size / 2, y = cy - size / 2;
            path.roundRect(x, y, size, size, r);
            break;
          }
          case 'rectangle': {
            const w = width * 0.92, h = height * 0.92;
            const r = Math.min(w, h) * 0.06;
            path.roundRect(cx - w / 2, cy - h / 2, w, h, r);
            break;
          }
          case 'polygon': {
            const r = Math.min(width, height) / 2 * 0.9;
            for (let i = 0; i < sides; i++) {
              const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
              const x = cx + r * Math.cos(angle);
              const y = cy + r * Math.sin(angle);
              i === 0 ? path.moveTo(x, y) : path.lineTo(x, y);
            }
            path.closePath();
            break;
          }
        }
        return path;
      }

      static getPathBounds(type, width, height, sides = 6) {
        const cx = width / 2, cy = height / 2;
        let bounds = { cx, cy, innerRadius: 0, textRadius: 0 };

        if (type === 'horizontal-lozenge') {
          // Match logic in generatePath: enforce 10% flat
          const outerR = Math.min(height / 2, width * 0.45);
          const r = outerR * 0.9;
          const flatW = width - 2 * outerR;

          bounds.innerRadius = r;
          // For horizontal lozenge, text radius is simpler (along the curve)
          bounds.textRadius = r * 0.85;

          // Define centers for the two semicircles
          bounds.topTextCenter = { x: cx - flatW / 2, y: cy };
          bounds.bottomTextCenter = { x: cx + flatW / 2, y: cy };
          bounds.isHorizontalLozenge = true;
        } else if (type === 'vertical-lozenge') {
          // Match logic in generatePath
          const outerR = Math.min(width / 2, height * 0.45);
          const r = outerR * 0.9;
          const flatH = height - 2 * outerR;

          bounds.innerRadius = r;
          bounds.textRadius = r * 0.85;

          bounds.topTextCenter = { x: cx, y: cy - flatH / 2 };
          bounds.bottomTextCenter = { x: cx, y: cy + flatH / 2 };
          bounds.isVerticalLozenge = true;
        } else {
          const minDim = Math.min(width, height);
          bounds.innerRadius = (minDim / 2) * 0.8;
          bounds.outerRadius = (minDim / 2) * 0.95;
          bounds.textRadius = bounds.innerRadius * 0.85;
        }

        return bounds;
      }
    }

    // ============================================
    // STITCH ENGINE - Generate embroidery stitches
    // ============================================
    class StitchEngine {
      constructor(scale = 1) {
        this.scale = scale;
        this.stitchLen = 4 * scale;   // Longer stitches
        this.stitchGap = 0.8 * scale; // Tighter gap for denser fill
        this.satinWidth = 6 * scale;  // Wider satin stitches
      }

      generateFillStitches(points, color, angle = 45) {
        if (points.length === 0) return [];

        const stitches = [];
        const rad = angle * Math.PI / 180;
        const cos = Math.cos(rad), sin = Math.sin(rad);

        // Build a bitmap of the region for fast lookup
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const p of points) {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        }

        const width = Math.ceil(maxX - minX) + 1;
        const height = Math.ceil(maxY - minY) + 1;

        // Create lookup set for faster point checking
        const pointSet = new Set();
        for (const p of points) {
          const key = `${Math.floor(p.x - minX)},${Math.floor(p.y - minY)}`;
          pointSet.add(key);
        }

        // Scan lines at the given angle across the region
        const diagonal = Math.sqrt(width * width + height * height);
        const cx = minX + width / 2;
        const cy = minY + height / 2;

        // Generate parallel scanlines
        const gap = this.stitchGap;

        for (let offset = -diagonal / 2; offset <= diagonal / 2; offset += gap) {
          // Line perpendicular to angle at this offset
          const lineX = cx + offset * Math.cos(rad + Math.PI / 2);
          const lineY = cy + offset * Math.sin(rad + Math.PI / 2);

          // Find all intersections with the region along this scanline
          const intersections = [];

          for (let t = -diagonal; t <= diagonal; t += 1) {
            const px = lineX + t * cos;
            const py = lineY + t * sin;
            const ix = Math.floor(px - minX);
            const iy = Math.floor(py - minY);

            if (ix >= 0 && ix < width && iy >= 0 && iy < height) {
              const key = `${ix},${iy}`;
              if (pointSet.has(key)) {
                intersections.push({ x: px, y: py, t });
              }
            }
          }

          if (intersections.length < 2) continue;

          // Find runs (continuous segments)
          let runStart = null;
          for (let i = 0; i < intersections.length; i++) {
            const curr = intersections[i];
            const next = intersections[i + 1];

            if (runStart === null) {
              runStart = curr;
            }

            // End of run if gap or end of intersections
            if (!next || next.t - curr.t > 2) {
              // Create stitches for this run
              let x = runStart.x, y = runStart.y;
              const endX = curr.x, endY = curr.y;
              const runLen = Math.sqrt((endX - x) ** 2 + (endY - y) ** 2);

              if (runLen > this.stitchLen * 0.5) {
                let traveled = 0;
                while (traveled < runLen) {
                  const segLen = Math.min(this.stitchLen, runLen - traveled);
                  const x2 = x + segLen * cos;
                  const y2 = y + segLen * sin;

                  stitches.push({
                    x1: x, y1: y, x2: x2, y2: y2,
                    color, type: 'fill', angle
                  });

                  x = x2;
                  y = y2;
                  traveled += segLen + gap * 0.2;
                }
              }
              runStart = null;
            }
          }
        }

        return stitches;
      }

      generateSatinStitches(pathPoints, color, width = null) {
        const stitches = [];
        const w = width || this.satinWidth;
        for (let i = 0; i < pathPoints.length - 1; i++) {
          const p1 = pathPoints[i], p2 = pathPoints[i + 1];
          const dx = p2.x - p1.x, dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          if (len < 0.5) continue;
          const nx = -dy / len, ny = dx / len;
          const numStitches = Math.ceil(len / (this.stitchGap * 0.8));
          for (let j = 0; j <= numStitches; j++) {
            const t = j / numStitches;
            const cx = p1.x + dx * t;
            const cy = p1.y + dy * t;
            stitches.push({
              x1: cx - nx * w / 2, y1: cy - ny * w / 2,
              x2: cx + nx * w / 2, y2: cy + ny * w / 2,
              color, type: 'satin', angle: Math.atan2(ny, nx)
            });
          }
        }
        return stitches;
      }

      generateBorderStitches(shapePath, width, height, color, borderWidth = null) {
        const bw = borderWidth || this.satinWidth * 2;
        const points = this.samplePath(shapePath, width, height, this.stitchGap * 0.5);
        return this.generateSatinStitches(points, color, bw);
      }

      samplePath(path, width, height, step) {
        const canvas = document.createElement('canvas');
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        const points = [];

        // Sample many angles from center
        const cx = width / 2, cy = height / 2;
        for (let a = 0; a < 360; a += 1) {
          const rad = a * Math.PI / 180;
          for (let r = 0; r < Math.max(width, height); r += step) {
            const x = cx + r * Math.cos(rad);
            const y = cy + r * Math.sin(rad);
            if (ctx.isPointInPath(path, x, y)) {
              continue;
            } else if (r > 0) {
              points.push({ x: cx + (r - step) * Math.cos(rad), y: cy + (r - step) * Math.sin(rad), angle: a });
              break;
            }
          }
        }
        // Sort by angle and remove duplicates
        points.sort((a, b) => a.angle - b.angle);
        return points;
      }

      // General Text Generation with Auto-Scaling and Readable Rotation
      generateTextStitches(text, cx, cy, radius, startAngle, endAngle, color, fontSize, isBottom = false) {
        const stitches = [];
        if (!text) return stitches;

        const chars = text.split('');
        const charWidth = fontSize * 0.6; // Approx width
        const totalTextLength = chars.length * charWidth;

        // Direction-aware calculations
        const rawSpan = endAngle - startAngle;
        const isNegative = rawSpan < 0;
        let angleSpan = Math.abs(rawSpan);
        const availableArcLen = angleSpan * radius;

        let actualStart = startAngle;
        let actualEnd = endAngle;

        // Auto-expand angles if text bunched
        if (totalTextLength > availableArcLen) {
          const requiredAngle = totalTextLength / radius;
          const centerAngle = (startAngle + endAngle) / 2;
          const halfAngle = requiredAngle / 2;

          if (isNegative) {
            actualStart = centerAngle + halfAngle;
            actualEnd = centerAngle - halfAngle;
          } else {
            actualStart = centerAngle - halfAngle;
            actualEnd = centerAngle + halfAngle;
          }
        }

        const totalAngle = actualEnd - actualStart;
        const charAngle = totalAngle / chars.length;

        chars.forEach((char, i) => {
          // Center the characters in their slots
          const angle = actualStart + charAngle * (i + 0.5);
          const x = cx + radius * Math.cos(angle);
          const y = cy + radius * Math.sin(angle);

          // Rotation:
          // Top text: Perpendicular to radius, pointing up. Rot = angle + PI/2
          // Bottom text (readable): Perpendicular to radius, pointing up (inward). Rot = angle - PI/2
          const rotation = isBottom ? angle - Math.PI / 2 : angle + Math.PI / 2;

          const charStitches = this.generateCharStitches(char, x, y, fontSize, rotation, color);
          stitches.push(...charStitches);
        });
        return stitches;
      }

      // Adaptive text layout for horizontal lozenge
      generateHorizontalLozengeText(text, bounds, isTop, color, fontSize) {
        const stitches = [];
        if (!text) return stitches;

        const chars = text.split('');
        const charWidth = fontSize * 0.6;
        const totalTextWidth = chars.length * charWidth;

        // Dimensions
        const r = bounds.textRadius;
        const flatW = bounds.bottomTextCenter.x - bounds.topTextCenter.x;
        const yPos = isTop ? bounds.cy - r : bounds.cy + r;

        // Check if fits on flat section
        if (totalTextWidth <= flatW * 0.9) {
          // Render straight
          const startX = bounds.cx - totalTextWidth / 2;
          const rotation = 0; // Upright
          chars.forEach((char, i) => {
            const x = startX + i * charWidth + charWidth / 2;
            const charStitches = this.generateCharStitches(char, x, yPos, fontSize, rotation, color);
            stitches.push(...charStitches);
          });
        } else {
          // Wrap around
          const centerAngle = isTop ? -Math.PI / 2 : Math.PI / 2;
          const spread = totalTextWidth / r; // Approximate angle coverage effectively

          // Use improved arc generation
          // Top center: -PI/2. Bottom center: PI/2.
          const start = centerAngle - spread / 2;
          const end = centerAngle + spread / 2;

          // Simple Arc fallback implies circular path, but Lozenge is Flat+Arc.
          // Precise Path placement:
          // Path: Left Arc -> Flat -> Right Arc.
          // Let's trace the path properly.
          this.renderTracePathText(stitches, text, bounds, isTop, color, fontSize, charWidth);
        }
        return stitches;
      }

      // Helper to trace text along the Lozenge Top or Bottom path
      renderTracePathText(stitches, text, bounds, isTop, color, fontSize, charWidth) {
        const r = bounds.textRadius;
        const flatW = bounds.bottomTextCenter.x - bounds.topTextCenter.x;
        const totalTextWidth = text.length * charWidth;

        // Construct Path Definition:
        // Top: Left Arc (PI -> 0) -> Flat -> Right Arc (PI -> 0)? 
        // No, Top Path: Left Center(PI->0?? No).
        // Top Path runs Left to Right.
        // Left Arc part: Starts at Angle PI (leftmost) -> Ends at Angle -PI/2 (top of LeftCenter)?
        // Wait, ShapeGenerator: arc(cx-flatW/2, cy, r, Math.PI, -PI/2) ??

        // Visualizing Horizontal Lozenge:
        //      ___
        //    /     \
        //   |       |

        // Top Edge: Starts Left (Angle PI relative to LeftCenter), goes to -PI/2 (Top of LeftCenter).
        // Then Flat: LeftCenter.x to RightCenter.x
        // Then Right Arc: -PI/2 (Top of RightCenter) to 0 (Rightmost).

        // Total Path Length calculation
        const arcLen = (Math.PI / 2) * r; // Quarter circle
        const totalPathLen = arcLen + flatW + arcLen; // Quarter + Flat + Quarter = Half Perimeter

        const startDist = (totalPathLen - totalTextWidth) / 2;

        const leftCx = bounds.topTextCenter.x;
        const rightCx = bounds.bottomTextCenter.x;
        const cy = bounds.cy;

        text.split('').forEach((char, i) => {
          const dist = startDist + i * charWidth + charWidth / 2;
          let x, y, rotation;

          if (isTop) {
            // Top Edge Path (Left to Right)
            if (dist < arcLen) {
              // On Left Top Arc (PI -> -PI/2)
              const fraction = dist / arcLen; // 0..1
              const angle = Math.PI - fraction * (Math.PI / 2); // PI -> PI/2 (Wait, -PI/2 is 3PI/2)
              // Let's use standard angles. Top is -PI/2. Left is -PI or PI.
              // Start at PI. Go to -PI/2 is ambiguous.
              // Start at PI. Go CW to 3*PI/2? No CCW.
              // Start at PI. Go CW (decrease) to PI/2? No.
              // Screen coords: Right=0, Down=PI/2, Left=PI, Up=-PI/2 (or 3PI/2).
              // Left Arc Top Quadrant: PI -> -PI/2? No. PI -> 3PI/2 works? No.
              // Left Arc Top Quadrant is between Left(-1,0) and Top(0,-1).
              // Angle goes from PI to 3*PI/2 (if 3PI/2 is top? No -PI/2 is top).
              // Let's use negative angles. Left is -PI. Top is -PI/2.
              // So angle goes from -PI to -PI/2.
              const ang = -Math.PI + fraction * (Math.PI / 2);
              x = leftCx + r * Math.cos(ang);
              y = cy + r * Math.sin(ang);
              rotation = ang + Math.PI / 2;
            } else if (dist < arcLen + flatW) {
              // On Flat Top
              const flatDist = dist - arcLen;
              x = leftCx + flatDist;
              y = cy - r;
              rotation = 0;
            } else {
              // On Right Top Arc (-PI/2 -> 0)
              const fraction = (dist - arcLen - flatW) / arcLen;
              const ang = -Math.PI / 2 + fraction * (Math.PI / 2);
              x = rightCx + r * Math.cos(ang);
              y = cy + r * Math.sin(ang);
              rotation = ang + Math.PI / 2;
            }
          } else {
            // Bottom Edge Path (Left to Right)
            // Left Bottom Arc (PI -> PI/2? No. Left(PI) -> Bottom(PI/2) -> Right(0)??)
            // Bottom is PI/2. Left is PI.  Order Left->Right implies PI -> PI/2.
            // Wait, Left(PI) is higher than Bottom(PI/2)? No.
            // Order: Left (-PI or PI) -> Bottom (PI/2) ?
            // Left Arc Bottom Quadrant: PI -> PI/2 ?? (Counter-Clockwise?)
            // No, Left to Right implies x increases.
            // Start Leftmost (PI). Go to Bottom (PI/2)? No, PI/2 is > 0.
            // Angle PI -> Angle PI/2 IS CW.
            // But we usually define angles CCW.
            // Let's stick to X/Y.
            // Path: Leftmost -> BottomLeft -> BottomRight -> Rightmost.
            // Left Arc: Left(PI) -> Bottom(PI/2).

            if (dist < arcLen) {
              // Left Bottom Arc (PI -> PI/2)?
              // Angle PI -> PI/2 ?
              // fraction 0 -> PI. fraction 1 -> PI/2.
              // angle = PI - fraction * (PI/2).
              const fraction = dist / arcLen;
              const ang = Math.PI - fraction * (Math.PI / 2); // PI -> PI/2
              x = leftCx + r * Math.cos(ang);
              y = cy + r * Math.sin(ang);
              rotation = ang - Math.PI / 2; // Readable bottom
            } else if (dist < arcLen + flatW) {
              // Flat Bottom
              const flatDist = dist - arcLen;
              x = leftCx + flatDist;
              y = cy + r;
              rotation = 0; // Upright readable
            } else {
              // Right Bottom Arc (PI/2 -> 0)
              const fraction = (dist - arcLen - flatW) / arcLen;
              const ang = Math.PI / 2 - fraction * (Math.PI / 2); // PI/2 -> 0
              x = rightCx + r * Math.cos(ang);
              y = cy + r * Math.sin(ang);
              rotation = ang - Math.PI / 2;
            }
          }

          const charStitches = this.generateCharStitches(char, x, y, fontSize, rotation, color);
          stitches.push(...charStitches);
        });
      }

      // Adaptive text layout for vertical lozenge
      generateVerticalLozengeText(text, bounds, isTop, color, fontSize) {
        if (!text) return [];
        const chars = text.split('');
        const charWidth = fontSize * 0.6;
        const totalTextWidth = chars.length * charWidth;
        const r = bounds.textRadius;

        // Use tracing logic for vertical as well
        const stitches = [];
        const flatH = bounds.bottomTextCenter.y - bounds.topTextCenter.y;
        const arcLen = Math.PI * r; // A full semi-circle at top/bottom
        // Vertical Lozenge:
        // Top: Left Vertical -> Top SemiCircle -> Right Vertical
        // Bottom: Left Vertical -> Bottom SemiCircle -> Right Vertical

        // Max side extension
        const sideLen = Math.min(flatH * 0.4, totalTextWidth * 0.4);
        const totalPathLen = sideLen + arcLen + sideLen;
        const startDist = Math.max(0, (totalPathLen - totalTextWidth) / 2);
        const cx = bounds.cx;
        const topCy = bounds.topTextCenter.y;
        const botCy = bounds.bottomTextCenter.y;

        chars.forEach((char, i) => {
          const dist = startDist + i * charWidth + charWidth / 2;
          let x, y, rotation;

          if (isTop) {
            // Top Path: Left Side Up -> Top Arc -> Right Side Down
            if (dist < sideLen) {
              // Left Side Up
              x = cx - r;
              y = topCy + sideLen - dist;
              rotation = -Math.PI / 2; // Point Left (Read Up)
            } else if (dist < sideLen + arcLen) {
              // Top Arc (Left to Right)
              // Angle: Left(PI) -> Top(-PI/2) -> Right(0).
              // Start angle PI. End angle 0. (Goes 'negative' or CCW? PI->0 via top is -PI range)
              // Or PI -> -PI/2 -> 0 (Angle decreases?)
              // Standard: PI (left) -> 0 (right) is top half? No 0..PI is bottom.
              // PI -> 2PI is top. (or -PI -> 0).
              const fraction = (dist - sideLen) / arcLen;
              const ang = -Math.PI + fraction * Math.PI; // -PI -> 0
              x = cx + r * Math.cos(ang);
              y = topCy + r * Math.sin(ang);
              rotation = ang + Math.PI / 2;
            } else {
              // Right Side Down
              const d = dist - sideLen - arcLen;
              x = cx + r;
              y = topCy + d;
              rotation = Math.PI / 2; // Point Right (Read Down)
            }
          } else {
            // Bottom Path: Left Side Down -> Bottom Arc -> Right Side Up
            if (dist < sideLen) {
              // Left Side Down (starts high, goes down)
              x = cx - r;
              y = botCy - sideLen + dist;
              rotation = Math.PI / 2; // Point Right? No.
              // "Readable" bottom text:
              // Usually Bottom Title reads Left-to-Right.
              // On a badge, bottom text is upright and reads L-to-R.
              // Left vertical part: Should read Down? Or Up?
              // If it wraps around the bottom, it starts Left-Low, goes Right-Low.
              // Standard Bottom path: Angle PI -> PI/2 -> 0.
              // Extends up the sides?
              // Left side: Starts at y = botCy - sideLen. Goes down to botCy.
              // Text reading Down on left side?
              // Yes, if following the clockwise perimeter.
              // Rotation: Point Right (PI/2). Top of char points Right. Text flow Down.
              rotation = Math.PI / 2;
            } else if (dist < sideLen + arcLen) {
              // Bottom Arc (Left to Right)
              // Angle PI -> 0. (+PI range)
              const fraction = (dist - sideLen) / arcLen;
              const ang = Math.PI - fraction * Math.PI; // PI -> 0
              x = cx + r * Math.cos(ang);
              y = botCy + r * Math.sin(ang);
              rotation = ang - Math.PI / 2; // Readable (inward)
            } else {
              // Right Side Up
              const d = dist - sideLen - arcLen;
              x = cx + r;
              y = botCy - d;
              rotation = -Math.PI / 2; // Point Left (Read Up)
            }
          }

          const charStitches = this.generateCharStitches(char, x, y, fontSize, rotation, color);
          stitches.push(...charStitches);
        });
        return stitches;
      }

      generateCharStitches(char, cx, cy, size, rotation, color) {
        const stitches = [];
        const paths = this.getCharPaths(char, size);
        const cos = Math.cos(rotation), sin = Math.sin(rotation);

        paths.forEach(p => {
          p.forEach((seg, i) => {
            if (i === 0) return;
            const prev = p[i - 1];
            // Rotate and translate
            const x1 = cx + (prev.x * cos - prev.y * sin);
            const y1 = cy + (prev.x * sin + prev.y * cos);
            const x2 = cx + (seg.x * cos - seg.y * sin);
            const y2 = cy + (seg.x * sin + seg.y * cos);
            stitches.push({ x1, y1, x2, y2, color, type: 'satin' });
          });
        });
        return stitches;
      }

      getCharPaths(char, size) {
        // Simplified vector paths for common characters
        const s = size / 10;
        const paths = {
          'A': [[{ x: -3 * s, y: 4 * s }, { x: 0, y: -4 * s }, { x: 3 * s, y: 4 * s }], [{ x: -1.5 * s, y: 1 * s }, { x: 1.5 * s, y: 1 * s }]],
          'B': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: -2 * s, y: -4 * s }, { x: 1 * s, y: -4 * s }, { x: 2 * s, y: -3 * s }, { x: 2 * s, y: -1 * s }, { x: 1 * s, y: 0 }, { x: -2 * s, y: 0 }], [{ x: -2 * s, y: 0 }, { x: 1 * s, y: 0 }, { x: 2 * s, y: 1 * s }, { x: 2 * s, y: 3 * s }, { x: 1 * s, y: 4 * s }, { x: -2 * s, y: 4 * s }]],
          'C': [[{ x: 2 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: -2 * s, y: -2 * s }, { x: -2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 3 * s }]],
          'D': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: -2 * s, y: -4 * s }, { x: 0, y: -4 * s }, { x: 2 * s, y: -2 * s }, { x: 2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: -2 * s, y: 4 * s }]],
          'E': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: -2 * s, y: -4 * s }, { x: 2 * s, y: -4 * s }], [{ x: -2 * s, y: 0 }, { x: 1 * s, y: 0 }], [{ x: -2 * s, y: 4 * s }, { x: 2 * s, y: 4 * s }]],
          'F': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: -2 * s, y: -4 * s }, { x: 2 * s, y: -4 * s }], [{ x: -2 * s, y: 0 }, { x: 1 * s, y: 0 }]],
          'G': [[{ x: 2 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: -2 * s, y: -2 * s }, { x: -2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 3 * s }, { x: 2 * s, y: 0 }, { x: 0.5 * s, y: 0 }]],
          'H': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: 2 * s, y: -4 * s }, { x: 2 * s, y: 4 * s }], [{ x: -2 * s, y: 0 }, { x: 2 * s, y: 0 }]],
          'I': [[{ x: 0, y: -4 * s }, { x: 0, y: 4 * s }], [{ x: -1.5 * s, y: -4 * s }, { x: 1.5 * s, y: -4 * s }], [{ x: -1.5 * s, y: 4 * s }, { x: 1.5 * s, y: 4 * s }]],
          'J': [[{ x: 2 * s, y: -4 * s }, { x: 2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: -2 * s, y: 2 * s }]],
          'K': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: 2 * s, y: -4 * s }, { x: -2 * s, y: 0 }, { x: 2 * s, y: 4 * s }]],
          'L': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }, { x: 2 * s, y: 4 * s }]],
          'M': [[{ x: -3 * s, y: 4 * s }, { x: -3 * s, y: -4 * s }, { x: 0, y: 0 }, { x: 3 * s, y: -4 * s }, { x: 3 * s, y: 4 * s }]],
          'N': [[{ x: -2 * s, y: 4 * s }, { x: -2 * s, y: -4 * s }, { x: 2 * s, y: 4 * s }, { x: 2 * s, y: -4 * s }]],
          'O': [[{ x: 0, y: -4 * s }, { x: -2 * s, y: -2 * s }, { x: -2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 2 * s }, { x: 2 * s, y: -2 * s }, { x: 0, y: -4 * s }]],
          'P': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: -2 * s, y: -4 * s }, { x: 1 * s, y: -4 * s }, { x: 2 * s, y: -3 * s }, { x: 2 * s, y: -1 * s }, { x: 1 * s, y: 0 }, { x: -2 * s, y: 0 }]],
          'Q': [[{ x: 0, y: -4 * s }, { x: -2 * s, y: -2 * s }, { x: -2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 2 * s }, { x: 2 * s, y: -2 * s }, { x: 0, y: -4 * s }], [{ x: 1 * s, y: 2 * s }, { x: 3 * s, y: 5 * s }]],
          'R': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }], [{ x: -2 * s, y: -4 * s }, { x: 1 * s, y: -4 * s }, { x: 2 * s, y: -3 * s }, { x: 2 * s, y: -1 * s }, { x: 1 * s, y: 0 }, { x: -2 * s, y: 0 }], [{ x: 0, y: 0 }, { x: 2 * s, y: 4 * s }]],
          'S': [[{ x: 2 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: -2 * s, y: -3 * s }, { x: -2 * s, y: -1 * s }, { x: 2 * s, y: 1 * s }, { x: 2 * s, y: 3 * s }, { x: 0, y: 4 * s }, { x: -2 * s, y: 3 * s }]],
          'T': [[{ x: 0, y: -4 * s }, { x: 0, y: 4 * s }], [{ x: -2.5 * s, y: -4 * s }, { x: 2.5 * s, y: -4 * s }]],
          'U': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 2 * s }, { x: 2 * s, y: -4 * s }]],
          'V': [[{ x: -2.5 * s, y: -4 * s }, { x: 0, y: 4 * s }, { x: 2.5 * s, y: -4 * s }]],
          'W': [[{ x: -3 * s, y: -4 * s }, { x: -1.5 * s, y: 4 * s }, { x: 0, y: 0 }, { x: 1.5 * s, y: 4 * s }, { x: 3 * s, y: -4 * s }]],
          'X': [[{ x: -2 * s, y: -4 * s }, { x: 2 * s, y: 4 * s }], [{ x: 2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }]],
          'Y': [[{ x: -2 * s, y: -4 * s }, { x: 0, y: 0 }, { x: 2 * s, y: -4 * s }], [{ x: 0, y: 0 }, { x: 0, y: 4 * s }]],
          'Z': [[{ x: -2 * s, y: -4 * s }, { x: 2 * s, y: -4 * s }, { x: -2 * s, y: 4 * s }, { x: 2 * s, y: 4 * s }]],
          ' ': [],
          '0': [[{ x: 0, y: -4 * s }, { x: -2 * s, y: -2 * s }, { x: -2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 2 * s }, { x: 2 * s, y: -2 * s }, { x: 0, y: -4 * s }]],
          '1': [[{ x: -1 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: 0, y: 4 * s }], [{ x: -1.5 * s, y: 4 * s }, { x: 1.5 * s, y: 4 * s }]],
          '2': [[{ x: -2 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: 2 * s, y: -3 * s }, { x: 2 * s, y: -1 * s }, { x: -2 * s, y: 4 * s }, { x: 2 * s, y: 4 * s }]],
          '3': [[{ x: -2 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: 2 * s, y: -3 * s }, { x: 2 * s, y: -1 * s }, { x: 0, y: 0 }, { x: 2 * s, y: 1 * s }, { x: 2 * s, y: 3 * s }, { x: 0, y: 4 * s }, { x: -2 * s, y: 3 * s }]],
          '4': [[{ x: -2 * s, y: -4 * s }, { x: -2 * s, y: 0 }, { x: 2 * s, y: 0 }], [{ x: 2 * s, y: -4 * s }, { x: 2 * s, y: 4 * s }]],
          '5': [[{ x: 2 * s, y: -4 * s }, { x: -2 * s, y: -4 * s }, { x: -2 * s, y: 0 }, { x: 1 * s, y: 0 }, { x: 2 * s, y: 1 * s }, { x: 2 * s, y: 3 * s }, { x: 0, y: 4 * s }, { x: -2 * s, y: 3 * s }]],
          '6': [[{ x: 2 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: -2 * s, y: -2 * s }, { x: -2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 2 * s }, { x: 2 * s, y: 1 * s }, { x: 0, y: 0 }, { x: -2 * s, y: 1 * s }]],
          '7': [[{ x: -2 * s, y: -4 * s }, { x: 2 * s, y: -4 * s }, { x: 0, y: 4 * s }]],
          '8': [[{ x: 0, y: -4 * s }, { x: -2 * s, y: -3 * s }, { x: -2 * s, y: -1 * s }, { x: 0, y: 0 }, { x: 2 * s, y: -1 * s }, { x: 2 * s, y: -3 * s }, { x: 0, y: -4 * s }], [{ x: 0, y: 0 }, { x: -2 * s, y: 1 * s }, { x: -2 * s, y: 3 * s }, { x: 0, y: 4 * s }, { x: 2 * s, y: 3 * s }, { x: 2 * s, y: 1 * s }, { x: 0, y: 0 }]],
          '9': [[{ x: 2 * s, y: 1 * s }, { x: 0, y: 0 }, { x: -2 * s, y: -1 * s }, { x: -2 * s, y: -3 * s }, { x: 0, y: -4 * s }, { x: 2 * s, y: -3 * s }, { x: 2 * s, y: 2 * s }, { x: 0, y: 4 * s }, { x: -2 * s, y: 3 * s }]],
        };
        return paths[char.toUpperCase()] || [[{ x: -1 * s, y: -2 * s }, { x: 1 * s, y: -2 * s }, { x: 1 * s, y: 2 * s }, { x: -1 * s, y: 2 * s }, { x: -1 * s, y: -2 * s }]];
      }
    }

    // ============================================
    // THREAD RENDERER - Draw realistic 3D threads
    // ============================================
    class ThreadRenderer {
      constructor(lightAngle = -45, lightIntensity = 0.7) {
        this.lightAngle = lightAngle * Math.PI / 180;
        this.lightIntensity = lightIntensity;
        this.lightX = Math.cos(this.lightAngle);
        this.lightY = Math.sin(this.lightAngle);
      }

      renderStitch(ctx, stitch, baseWidth = 1.5) {
        const { x1, y1, x2, y2, color } = stitch;
        const dx = x2 - x1, dy = y2 - y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len < 0.5) return;

        const nx = -dy / len, ny = dx / len; // Normal perpendicular to stitch
        const stitchAngle = Math.atan2(dy, dx);

        // Calculate lighting based on stitch angle
        const lightDot = nx * this.lightX + ny * this.lightY;
        const highlight = Math.max(0, lightDot) * this.lightIntensity;
        const shadow = Math.max(0, -lightDot) * this.lightIntensity * 0.6;

        // Parse color
        const r = color[0], g = color[1], b = color[2];

        // Thread width with slight variation
        const width = baseWidth * (0.9 + Math.random() * 0.2);

        ctx.save();
        ctx.translate(x1, y1);
        ctx.rotate(stitchAngle);

        // Draw shadow layer (offset away from light)
        ctx.fillStyle = `rgba(0,0,0,${0.15 + shadow * 0.15})`;
        ctx.beginPath();
        ctx.ellipse(len / 2 - this.lightX * 0.5, -this.lightY * 0.5 + width * 0.3,
          len / 2 + 0.5, width * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Main thread body with gradient
        const grad = ctx.createLinearGradient(0, -width / 2, 0, width / 2);
        const darkR = Math.max(0, r - 40 - shadow * 50);
        const darkG = Math.max(0, g - 40 - shadow * 50);
        const darkB = Math.max(0, b - 40 - shadow * 50);
        const lightR = Math.min(255, r + highlight * 60);
        const lightG = Math.min(255, g + highlight * 60);
        const lightB = Math.min(255, b + highlight * 60);

        if (lightDot > 0) {
          grad.addColorStop(0, `rgb(${lightR},${lightG},${lightB})`);
          grad.addColorStop(0.5, `rgb(${r},${g},${b})`);
          grad.addColorStop(1, `rgb(${darkR},${darkG},${darkB})`);
        } else {
          grad.addColorStop(0, `rgb(${darkR},${darkG},${darkB})`);
          grad.addColorStop(0.5, `rgb(${r},${g},${b})`);
          grad.addColorStop(1, `rgb(${lightR},${lightG},${lightB})`);
        }

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(0, -width / 2, len, width, width / 2);
        ctx.fill();

        // Specular highlight
        if (highlight > 0.3) {
          ctx.fillStyle = `rgba(255,255,255,${(highlight - 0.3) * 0.3})`;
          ctx.beginPath();
          ctx.ellipse(len / 2, -width * 0.2, len * 0.4, width * 0.15, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Thread twist texture (subtle lines)
        ctx.strokeStyle = `rgba(0,0,0,0.08)`;
        ctx.lineWidth = 0.3;
        const twistSpacing = width * 1.5;
        for (let t = twistSpacing; t < len - twistSpacing / 2; t += twistSpacing) {
          ctx.beginPath();
          ctx.moveTo(t, -width / 2 + 0.5);
          ctx.lineTo(t + width * 0.3, width / 2 - 0.5);
          ctx.stroke();
        }

        ctx.restore();
      }

      renderAllStitches(ctx, stitches, baseWidth = 1.5) {
        stitches.forEach(s => this.renderStitch(ctx, s, baseWidth));
      }
    }

    // ============================================
    // FABRIC RENDERER - Draw canvas/twill backing
    // ============================================
    class FabricRenderer {
      static render(ctx, width, height, baseColor = [45, 45, 55]) {
        // Base color
        ctx.fillStyle = `rgb(${baseColor[0]},${baseColor[1]},${baseColor[2]})`;
        ctx.fillRect(0, 0, width, height);

        // Canvas weave pattern
        const weaveSize = 3;
        ctx.globalAlpha = 0.15;

        for (let y = 0; y < height; y += weaveSize) {
          for (let x = 0; x < width; x += weaveSize) {
            const isLight = (Math.floor(x / weaveSize) + Math.floor(y / weaveSize)) % 2 === 0;
            ctx.fillStyle = isLight ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            ctx.fillRect(x, y, weaveSize, weaveSize);
          }
        }

        // Add noise for texture
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const noise = (Math.random() - 0.5) * 15;
          data[i] = Math.max(0, Math.min(255, data[i] + noise));
          data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
          data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
        }
        ctx.putImageData(imageData, 0, 0);
        ctx.globalAlpha = 1;
      }
    }

    // ============================================
    // BADGE RENDERER - Main orchestrator
    // ============================================
    class BadgeRenderer {
      constructor() {
        this.superScale = 3; // Render at 3x then downscale
      }

      async render(config) {
        const { image, shape, sides, title1, title2, colorCount, textScale = 100, width, height } = config;
        const sw = width * this.superScale;
        const sh = height * this.superScale;

        // Create high-res canvas
        const canvas = document.createElement('canvas');
        canvas.width = sw;
        canvas.height = sh;
        const ctx = canvas.getContext('2d');

        // 2. Create shape path and clip
        const shapePath = ShapeGenerator.generatePath(shape, sw, sh, sides);
        ctx.save();
        ctx.clip(shapePath);

        // 1. Draw fabric background (now clipped)
        FabricRenderer.render(ctx, sw, sh);

        // 3. Process image - use center-crop for lozenges to handle aspect ratio mismatch
        const useCenterCrop = shape.includes('lozenge');
        const imgData = ImageProcessor.getImageData(image, sw, sh, useCenterCrop);
        const { imageData: posterized, palette } = ImageProcessor.posterize(imgData, colorCount);
        const regions = ImageProcessor.extractRegions(posterized, palette);

        // 4. Generate and render fill stitches for each color region
        const stitchEngine = new StitchEngine(this.superScale);
        const threadRenderer = new ThreadRenderer(-45, 0.7);

        let allStitches = [];
        let angleOffset = 0;

        // Track color frequencies to find least-common for border
        let minCount = Infinity;
        let leastCommonColor = null;

        regions.forEach((points, colorKey) => {
          const color = colorKey.split(',').map(Number);
          const angle = 45 + angleOffset;
          angleOffset += 15; // Vary angle per color for visual interest
          const stitches = stitchEngine.generateFillStitches(points, color, angle);
          allStitches.push(...stitches);

          // Track least common color
          if (points.length < minCount) {
            minCount = points.length;
            leastCommonColor = color;
          }
        });

        // Shuffle stitches slightly for natural overlap
        allStitches.sort(() => Math.random() - 0.5);
        threadRenderer.renderAllStitches(ctx, allStitches, 2.5 * this.superScale);

        ctx.restore();

        // 5. Render border - use least common color for contrast (or fallback to gold)
        const borderColor = leastCommonColor || [220, 180, 80];
        const borderStitches = stitchEngine.generateBorderStitches(
          shapePath, sw, sh, borderColor, 12 * this.superScale
        );
        threadRenderer.renderAllStitches(ctx, borderStitches, 4 * this.superScale);

        // 6. Render text - positioned along edge with proper margins
        const bounds = ShapeGenerator.getPathBounds(shape, sw, sh, sides);
        const textColor = [255, 255, 255];
        // Apply text scaling (default 100%)
        const fontSize = Math.min(sw, sh) * 0.06 * (textScale / 100);

        if (title1) {
          let topStitches;
          if (bounds.isHorizontalLozenge) {
            // Use adaptive horizontal lozenge text layout
            topStitches = stitchEngine.generateHorizontalLozengeText(
              title1.toUpperCase(), bounds, true, textColor, fontSize
            );
          } else if (bounds.isVerticalLozenge) {
            // Use adaptive vertical lozenge text layout
            topStitches = stitchEngine.generateVerticalLozengeText(
              title1.toUpperCase(), bounds, true, textColor, fontSize
            );
          } else {
            // Standard arc text for other shapes
            topStitches = stitchEngine.generateTextStitches(
              title1.toUpperCase(), bounds.cx, bounds.cy,
              bounds.textRadius, -Math.PI * 0.75, -Math.PI * 0.25,
              textColor, fontSize
            );
          }
          threadRenderer.renderAllStitches(ctx, topStitches, 3 * this.superScale);
        }

        if (title2) {
          let bottomStitches;
          if (bounds.isHorizontalLozenge) {
            // Use adaptive horizontal lozenge text layout
            bottomStitches = stitchEngine.generateHorizontalLozengeText(
              title2.toUpperCase(), bounds, false, textColor, fontSize
            );
          } else if (bounds.isVerticalLozenge) {
            // Use adaptive vertical lozenge text layout
            bottomStitches = stitchEngine.generateVerticalLozengeText(
              title2.toUpperCase(), bounds, false, textColor, fontSize
            );
          } else {
            // Standard arc text for other shapes
            // Swap angles (0.75 PI -> 0.25 PI) to ensure Left-to-Right reading direction
            // Stitchengine now handles negative direction correctly
            bottomStitches = stitchEngine.generateTextStitches(
              title2.toUpperCase(), bounds.cx, bounds.cy,
              bounds.textRadius, Math.PI * 0.75, Math.PI * 0.25,
              textColor, fontSize, true // isBottom = true for readable text
            );
          }
          threadRenderer.renderAllStitches(ctx, bottomStitches, 3 * this.superScale);
        }

        // 7. Downscale with anti-aliasing
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = width;
        finalCanvas.height = height;
        const fCtx = finalCanvas.getContext('2d');
        fCtx.imageSmoothingEnabled = true;
        fCtx.imageSmoothingQuality = 'high';
        fCtx.drawImage(canvas, 0, 0, width, height);

        return finalCanvas;
      }
    }

    // ============================================
    // UI CONTROLLER - Handle user interactions
    // ============================================
    class BadgeApp {
      constructor() {
        this.image = null;
        this.renderer = new BadgeRenderer();
        this.resultCanvas = null;
        this.init();
      }

      init() {
        // DOM elements
        this.imageInput = document.getElementById('imageInput');
        this.shapeSelect = document.getElementById('shapeSelect');
        this.polygonSidesGroup = document.getElementById('polygonSidesGroup');
        this.polygonSides = document.getElementById('polygonSides');
        this.title1 = document.getElementById('title1');
        this.title2 = document.getElementById('title2');
        this.colorCount = document.getElementById('colorCount');
        this.colorCountValue = document.getElementById('colorCountValue');
        this.tabPixels = document.getElementById('tabPixels');
        this.tabScale = document.getElementById('tabScale');
        this.dimensionInputs = document.getElementById('dimensionInputs');
        this.outputWidth = document.getElementById('outputWidth');
        this.outputHeight = document.getElementById('outputHeight');
        this.outputScale = document.getElementById('outputScale');
        this.textScale = document.getElementById('textScale');
        this.textScaleValue = document.getElementById('textScaleValue');
        this.renderBtn = document.getElementById('renderBtn');
        this.copyBtn = document.getElementById('copyBtn');
        this.saveBtn = document.getElementById('saveBtn');
        this.previewCanvas = document.getElementById('previewCanvas');
        this.emptyState = document.getElementById('emptyState');
        this.statusText = document.getElementById('statusText');

        this.isScaleMode = false;
        this.originalWidth = 400;
        this.originalHeight = 400;

        // Event listeners
        this.imageInput.addEventListener('change', (e) => this.handleImageUpload(e));
        this.shapeSelect.addEventListener('change', () => this.handleShapeChange());
        this.colorCount.addEventListener('input', () => {
          this.colorCountValue.textContent = this.colorCount.value;
        });
        this.textScale.addEventListener('input', () => {
          this.textScaleValue.textContent = this.textScale.value + '%';
        });

        this.tabPixels.addEventListener('click', () => this.setDimensionMode(false));
        this.tabScale.addEventListener('click', () => this.setDimensionMode(true));

        this.renderBtn.addEventListener('click', () => this.render());
        this.copyBtn.addEventListener('click', () => this.copyToClipboard());
        this.saveBtn.addEventListener('click', () => this.saveAsPng());

        // Keyboard support
        [this.tabPixels, this.tabScale].forEach(btn => {
          btn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              btn.click();
            }
          });
        });
      }

      async handleImageUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        try {
          this.image = await ImageProcessor.loadImage(file);
          this.originalWidth = this.image.width;
          this.originalHeight = this.image.height;

          // Set default output size maintaining aspect ratio
          const maxSize = 400;
          if (this.image.width > this.image.height) {
            this.outputWidth.value = maxSize;
            this.outputHeight.value = Math.round(maxSize * this.image.height / this.image.width);
          } else {
            this.outputHeight.value = maxSize;
            this.outputWidth.value = Math.round(maxSize * this.image.width / this.image.height);
          }

          this.renderBtn.disabled = false;
          this.setStatus('Image loaded - ready to generate', 'ready');
        } catch (err) {
          this.setStatus('Error loading image', '');
          console.error(err);
        }
      }

      handleShapeChange() {
        const isPolygon = this.shapeSelect.value === 'polygon';
        this.polygonSidesGroup.classList.toggle('visible', isPolygon);
      }

      setDimensionMode(isScale) {
        this.isScaleMode = isScale;
        this.tabPixels.classList.toggle('active', !isScale);
        this.tabScale.classList.toggle('active', isScale);
        this.tabPixels.setAttribute('aria-selected', !isScale);
        this.tabScale.setAttribute('aria-selected', isScale);

        this.dimensionInputs.classList.toggle('scale-mode', isScale);
        this.outputWidth.parentElement.style.display = isScale ? 'none' : '';
        this.outputHeight.parentElement.style.display = isScale ? 'none' : '';
        this.outputScale.parentElement.style.display = isScale ? '' : 'none';
      }

      getOutputDimensions() {
        if (this.isScaleMode) {
          const scale = parseInt(this.outputScale.value) / 100;
          return {
            width: Math.round(this.originalWidth * scale),
            height: Math.round(this.originalHeight * scale)
          };
        }
        return {
          width: parseInt(this.outputWidth.value) || 400,
          height: parseInt(this.outputHeight.value) || 400
        };
      }

      setStatus(text, type = '') {
        this.statusText.className = 'status ' + type;
        if (type === 'rendering') {
          this.statusText.innerHTML = '<span class="spinner"></span> ' + text;
        } else {
          this.statusText.textContent = text;
        }
      }

      async render() {
        if (!this.image) return;

        this.renderBtn.disabled = true;
        this.setStatus('Generating embroidered badge...', 'rendering');

        // Use requestAnimationFrame to allow UI update
        await new Promise(r => requestAnimationFrame(r));
        await new Promise(r => setTimeout(r, 50));

        try {
          const { width, height } = this.getOutputDimensions();
          const config = {
            image: this.image,
            shape: this.shapeSelect.value,
            sides: parseInt(this.polygonSides.value),
            title1: this.title1.value,
            title2: this.title2.value,
            colorCount: parseInt(this.colorCount.value),
            textScale: parseInt(this.textScale.value) || 100,
            width, height
          };

          this.resultCanvas = await this.renderer.render(config);

          // Display result
          this.previewCanvas.width = width;
          this.previewCanvas.height = height;
          const ctx = this.previewCanvas.getContext('2d');
          ctx.drawImage(this.resultCanvas, 0, 0);

          this.emptyState.style.display = 'none';
          this.previewCanvas.style.display = 'block';

          this.copyBtn.disabled = false;
          this.saveBtn.disabled = false;
          this.setStatus('Badge generated successfully!', 'ready');
        } catch (err) {
          this.setStatus('Error generating badge: ' + err.message, '');
          console.error(err);
        } finally {
          this.renderBtn.disabled = false;
        }
      }

      async copyToClipboard() {
        if (!this.resultCanvas) return;
        try {
          const blob = await new Promise(r => this.resultCanvas.toBlob(r, 'image/png'));
          await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
          this.setStatus('Copied to clipboard!', 'ready');
        } catch (err) {
          this.setStatus('Failed to copy: ' + err.message, '');
        }
      }

      saveAsPng() {
        if (!this.resultCanvas) return;
        const link = document.createElement('a');
        // Use title if available (sanitized), otherwise 'badge'
        const name = this.title1.value.trim().replace(/[^a-z0-9]/gi, '_') || 'badge';
        // Explicitly add .png extension which addresses user request
        link.download = `${name}.png`;
        link.href = this.resultCanvas.toDataURL('image/png');
        link.click();
        this.setStatus('Badge saved!', 'ready');
      }
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => new BadgeApp());
  </script>
  <script src="parental.js"></script>
</body>

</html>