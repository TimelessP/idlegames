<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Match & Clear - Idle Game</title>
  <meta name="description" content="A clean, mobile-friendly match-3 idle game with theme support.">
  <style>
    :root {
      --bg: #f5f5f5;
      --fg: #222;
      --accent: #e91e63;
      --tile-bg: #fff;
      --tile-fg: #222;
      --font: 'Segoe UI', 'Arial', 'sans-serif';
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #181818;
        --fg: #eee;
        --accent: #ff4081;
        --tile-bg: #222;
        --tile-fg: #eee;
      }
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: var(--font);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      justify-content: center;
    }
    h1 {
      margin-top: 0.5em;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
  gap: 6px;
  width: min(90vw, 90vh, 400px);
  height: min(90vw, 90vh, 400px);
  background: var(--accent);
  border-radius: 16px;
  box-shadow: 0 2px 16px rgba(0,0,0,0.08);
  margin: 1em auto;
  padding: 12px;
    }
    .tile {
      background: var(--tile-bg);
      color: var(--tile-fg);
      font-size: 1.5em;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
      box-shadow: 0 1px 4px rgba(0,0,0,0.04);
      border: 2px solid transparent;
    }
    .tile.selected {
      border: 2px solid var(--accent);
    }
    .controls {
      margin: 1em 0;
      display: flex;
      gap: 1em;
      justify-content: center;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.5em 1.2em;
      font-size: 1em;
      font-family: var(--font);
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #ad1457;
    }
    .score {
      font-weight: 600;
      color: var(--accent);
      margin-top: 0.5em;
    }
  </style>
</head>
<body>
  <h1>Match & Clear</h1>
  <div class="board" id="board"></div>
  <div class="controls">
    <button onclick="resetBoard()">Reset</button>
    <button onclick="toggleTheme()">Theme</button>
  </div>
  <div class="score" id="score"></div>
  <script>
    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    let board = [];
    let selected = null;
    let score = 0;
    let theme = localStorage.getItem('theme2') || 'system';
    const size = 8;
    const shapes = [
      {color: '#e91e63', char: '●'},
      {color: '#2196f3', char: '■'},
      {color: '#ffeb3b', char: '▲'},
      {color: '#4caf50', char: '◆'},
      {color: '#ff9800', char: '⬟'}
    ];

    function setTheme(mode) {
      if (mode === 'light') {
        document.documentElement.style.setProperty('--bg', '#f5f5f5');
        document.documentElement.style.setProperty('--fg', '#222');
        document.documentElement.style.setProperty('--accent', '#e91e63');
        document.documentElement.style.setProperty('--tile-bg', '#fff');
        document.documentElement.style.setProperty('--tile-fg', '#222');
      } else if (mode === 'dark') {
        document.documentElement.style.setProperty('--bg', '#181818');
        document.documentElement.style.setProperty('--fg', '#eee');
        document.documentElement.style.setProperty('--accent', '#ff4081');
        document.documentElement.style.setProperty('--tile-bg', '#222');
        document.documentElement.style.setProperty('--tile-fg', '#eee');
      } else {
        document.documentElement.removeAttribute('style');
      }
      theme = mode;
      localStorage.setItem('theme2', mode);
    }
    function toggleTheme() {
      if (theme === 'system') setTheme('light');
      else if (theme === 'light') setTheme('dark');
      else setTheme('system');
    }
    setTheme(theme);

    function randomShape() {
      return Math.floor(Math.random()*shapes.length);
    }
    function createBoard() {
      let arr = [];
      for (let i = 0; i < size*size; i++) {
        arr.push(randomShape());
      }
      return arr;
    }
    function renderBoard() {
      boardEl.innerHTML = '';
      for (let i = 0; i < size*size; i++) {
        const idx = board[i];
        const tile = document.createElement('div');
        tile.className = 'tile' + (selected === i ? ' selected' : '');
        if (idx !== null) {
          tile.style.color = shapes[idx].color;
          tile.textContent = shapes[idx].char;
          tile.onclick = () => selectTile(i);
        } else {
          tile.textContent = '';
          tile.style.background = 'transparent';
          tile.style.cursor = 'default';
        }
        boardEl.appendChild(tile);
      }
      scoreEl.textContent = 'Score: ' + score;
    }
    function selectTile(i) {
      if (selected === null) {
        selected = i;
        renderBoard();
      } else if (selected === i) {
        selected = null;
        renderBoard();
      } else if (isAdjacent(selected, i)) {
        swapTiles(selected, i);
        selected = null;
        setTimeout(() => {
          let cleared = clearMatches();
          if (cleared > 0) {
            score += cleared;
            dropTiles();
            fillTiles();
            renderBoard();
          } else {
            renderBoard();
          }
        }, 100);
      } else {
        selected = i;
        renderBoard();
      }
    }
    function isAdjacent(a, b) {
      const ax = a % size, ay = Math.floor(a/size);
      const bx = b % size, by = Math.floor(b/size);
      return (Math.abs(ax-bx) + Math.abs(ay-by)) === 1;
    }
    function swapTiles(a, b) {
      [board[a], board[b]] = [board[b], board[a]];
    }
    function clearMatches() {
      let cleared = 0;
      let toClear = Array(size*size).fill(false);
      // Check all shapes with sides touching (not just lines)
      for (let i = 0; i < size*size; i++) {
        let group = [i];
        let color = board[i];
        let visited = Array(size*size).fill(false);
        visited[i] = true;
        for (let j = 0; j < group.length; j++) {
          let idx = group[j];
          let neighbors = [idx-size, idx+size, idx-1, idx+1].filter(n =>
            n >= 0 && n < size*size &&
            ((Math.abs(n-idx) === 1 && Math.floor(n/size) === Math.floor(idx/size)) ||
             Math.abs(n-idx) === size)
          );
          for (let n of neighbors) {
            if (!visited[n] && board[n] === color) {
              visited[n] = true;
              group.push(n);
            }
          }
        }
        if (group.length >= 3) {
          for (let idx of group) toClear[idx] = true;
        }
      }
      for (let i = 0; i < size*size; i++) {
        if (toClear[i]) {
          board[i] = null;
          cleared++;
        }
      }
      return cleared;
    }
    function dropTiles() {
      // Drop tiles down
      for (let x = 0; x < size; x++) {
        for (let y = size-1; y >= 0; y--) {
          let idx = y*size + x;
          if (board[idx] === null) {
            for (let k = y-1; k >= 0; k--) {
              let above = k*size + x;
              if (board[above] !== null) {
                board[idx] = board[above];
                board[above] = null;
                break;
              }
            }
          }
        }
      }
      // Shift columns left if entire column is empty
      for (let x = 0; x < size; x++) {
        let emptyCol = true;
        for (let y = 0; y < size; y++) {
          if (board[y*size + x] !== null) {
            emptyCol = false;
            break;
          }
        }
        if (emptyCol) {
          // Shift all columns right of x left by one
          for (let xx = x+1; xx < size; xx++) {
            for (let y = 0; y < size; y++) {
              board[y*size + (xx-1)] = board[y*size + xx];
            }
          }
          // Set rightmost column to null
          for (let y = 0; y < size; y++) {
            board[y*size + (size-1)] = null;
          }
        }
      }
    }
    function fillTiles() {
  // Do not refill tiles; leave cleared spaces as null
  // Board can eventually be cleared
    }
    function resetBoard() {
      board = createBoard();
      score = 0;
      selected = null;
      renderBoard();
    }
    // Init
    resetBoard();
  </script>
</html>
