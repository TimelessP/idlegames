<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pipes - IdleGames</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#667eea">
    <style>
        :root {
            --bg-light: #e8d4b8;
            --bg-dark: #2a2520;
            --soil-light: #c9a66b;
            --soil-dark: #3d3020;
            --pipe-light: #a08060;
            --pipe-dark: #6a5a4a;
            --water: #4a90c2;
            --water-deep: #2a6090;
            --highlight: rgba(255, 250, 240, 0.4);
            --shadow: rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] {
            --bg-light: #2a2520;
            --soil-light: #3d3020;
            --pipe-light: #6a5a4a;
            --highlight: rgba(255, 250, 240, 0.15);
            --shadow: rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-light);
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            transition: background 0.3s;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: min(calc(100vw - 2rem), calc(100vh - 8rem), calc(100dvh - 8rem));
            height: min(calc(100vw - 2rem), calc(100vh - 8rem), calc(100dvh - 8rem));
            max-width: 800px;
            max-height: 800px;
        }

        #caustics-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            pointer-events: none;
            mix-blend-mode: overlay;
            opacity: 0.6;
        }

        #water-mask-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
        }

        #game-svg {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        #status-bar {
            margin-top: 1rem;
            display: flex;
            gap: 2rem;
            font-size: 1.1rem;
            color: #665544;
        }

        [data-theme="dark"] #status-bar {
            color: #aa9988;
        }

        #menu-btn {
            position: fixed;
            top: 1rem;
            right: 1rem;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background: rgba(255,255,255,0.9);
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 100;
        }

        [data-theme="dark"] #menu-btn {
            background: rgba(60,50,40,0.9);
            color: #ddd;
        }

        #menu-dropdown {
            position: fixed;
            top: 4rem;
            right: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            display: none;
            flex-direction: column;
            overflow: hidden;
            z-index: 100;
        }

        #menu-dropdown.open {
            display: flex;
        }

        [data-theme="dark"] #menu-dropdown {
            background: #3d3020;
        }

        .menu-item {
            padding: 12px 20px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 1rem;
            color: #333;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: rgba(0,0,0,0.05);
        }

        [data-theme="dark"] .menu-item {
            color: #ddd;
        }

        [data-theme="dark"] .menu-item:hover {
            background: rgba(255,255,255,0.05);
        }

        .menu-divider {
            height: 1px;
            background: rgba(0,0,0,0.1);
        }

        /* Win animation */
        @keyframes pulse-win {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .pipe-tile {
            cursor: pointer;
            transition: transform 0.15s ease-out;
        }

        .pipe-tile:hover {
            filter: brightness(1.05);
        }

        /* Drain pulse animation */
        @keyframes drain-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .drain-glow {
            animation: drain-pulse 2s ease-in-out infinite;
        }

        /* Water shimmer */
        @keyframes water-shimmer {
            0% { opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }

        .water-highlight {
            animation: water-shimmer 1.5s ease-in-out infinite;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            max-width: 90%;
            width: 360px;
            text-align: center;
        }

        [data-theme="dark"] .modal {
            background: #3d3020;
            color: #ddd;
        }

        .modal h2 {
            margin-bottom: 1rem;
        }

        .modal p {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        .modal-btn {
            margin-top: 1rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .modal-btn:active {
            transform: scale(0.98);
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        #win-modal h2 {
            font-size: 2rem;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <svg id="game-svg" viewBox="0 0 400 400"></svg>
        <canvas id="caustics-canvas"></canvas>
        <svg id="water-mask-svg" viewBox="0 0 400 400"></svg>
    </div>

    <div id="status-bar">
        <span>Level: <span id="level-num">1</span></span>
        <span>Moves: <span id="move-count">0</span></span>
    </div>

    <button id="menu-btn">â˜°</button>

    <div id="menu-dropdown">
        <button class="menu-item" id="new-game-btn">ğŸ® New Game</button>
        <div class="menu-divider"></div>
        <button class="menu-item" id="sound-toggle">ğŸ”Š Sound: On</button>
        <div class="menu-divider"></div>
        <button class="menu-item" id="theme-toggle">ğŸŒ™ Dark Mode</button>
        <div class="menu-divider"></div>
        <button class="menu-item" id="help-btn">â“ How to Play</button>
    </div>

    <div class="modal-overlay" id="help-modal">
        <div class="modal">
            <h2>â“ How to Play</h2>
            <p>ğŸ”„ Tap pipes to rotate them clockwise.</p>
            <p>ğŸ’§ Connect water from the source (filled pipe) to the drain (pulsing pipe).</p>
            <p>ğŸ¯ Complete each level to progress!</p>
            <button class="modal-btn primary" id="close-help">Got it!</button>
        </div>
    </div>

    <div class="modal-overlay" id="win-modal">
        <div class="modal">
            <h2>ğŸ‰ Level Complete!</h2>
            <p>Moves: <span id="win-moves">0</span></p>
            <button class="modal-btn primary" id="next-level-btn">Next Level</button>
        </div>
    </div>

    <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIPES - Low-poly SVG puzzle game
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const svg = document.getElementById('game-svg');
    const waterMaskSvg = document.getElementById('water-mask-svg');
    const causticsCanvas = document.getElementById('caustics-canvas');
    const causticsCtx = causticsCanvas.getContext('2d');
    const NS = 'http://www.w3.org/2000/svg';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const state = {
        level: 1,
        gridSize: 3,
        grid: [],
        source: { x: 0, y: 0 },
        drain: { x: 0, y: 0 },
        moves: 0,
        won: false,
        sound: true,
        darkMode: window.matchMedia('(prefers-color-scheme: dark)').matches,
        causticsTime: 0,
        lastCausticsFrame: 0,
        animationId: null
    };

    // Pipe types: connections as [N, E, S, W] booleans
    const PIPE_TYPES = {
        straight: { connections: [1, 0, 1, 0], symbol: 'â”‚' },
        corner: { connections: [1, 1, 0, 0], symbol: 'â””' },
        tee: { connections: [1, 1, 0, 1], symbol: 'â”´' },
        cross: { connections: [1, 1, 1, 1], symbol: 'â”¼' }
    };

    // Direction vectors: N=0, E=1, S=2, W=3
    const DIR_VECTORS = [
        { x: 0, y: -1 }, // N
        { x: 1, y: 0 },  // E
        { x: 0, y: 1 },  // S
        { x: -1, y: 0 }  // W
    ];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SEEDED RANDOM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let rngSeed = Date.now();
    let rngState = rngSeed;

    function seedRandom(seed) {
        rngSeed = seed;
        rngState = seed;
    }

    function random() {
        rngState = (rngState * 1103515245 + 12345) & 0x7fffffff;
        return rngState / 0x7fffffff;
    }

    function randomInt(min, max) {
        return Math.floor(random() * (max - min + 1)) + min;
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PIPE CLASS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class Pipe {
        constructor(type, rotation = 0) {
            this.type = type;
            this.rotation = rotation; // 0-3 (number of 90Â° clockwise rotations)
            this.hasWater = false;
            this.isSource = false;
            this.isDrain = false;
        }

        getConnections() {
            // Return which directions this pipe connects to after rotation
            const base = PIPE_TYPES[this.type].connections;
            const rotated = [];
            for (let i = 0; i < 4; i++) {
                rotated[i] = base[(i - this.rotation + 4) % 4];
            }
            return rotated;
        }

        connectsTo(dir) {
            return this.getConnections()[dir] === 1;
        }

        rotate() {
            this.rotation = (this.rotation + 1) % 4;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PUZZLE GENERATION (GUARANTEED SOLVABLE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function generatePuzzle(size) {
        // Initialize empty grid
        const grid = [];
        for (let y = 0; y < size; y++) {
            grid[y] = [];
            for (let x = 0; x < size; x++) {
                grid[y][x] = null;
            }
        }

        // Place source and drain on opposite sides
        const sourceY = randomInt(0, size - 1);
        const drainY = randomInt(0, size - 1);
        state.source = { x: 0, y: sourceY };
        state.drain = { x: size - 1, y: drainY };

        // Generate a valid path from source to drain using random walk
        const path = generatePath(size, state.source, state.drain);

        // Place pipes along the path with correct connections
        for (let i = 0; i < path.length; i++) {
            const pos = path[i];
            const prevDir = i > 0 ? getDirection(path[i - 1], pos) : null;
            const nextDir = i < path.length - 1 ? getDirection(pos, path[i + 1]) : null;

            // Determine required connections
            const connections = [0, 0, 0, 0];
            if (prevDir !== null) connections[(prevDir + 2) % 4] = 1; // incoming
            if (nextDir !== null) connections[nextDir] = 1; // outgoing

            // Find matching pipe type and rotation
            const { type, rotation } = findPipeForConnections(connections);
            grid[pos.y][pos.x] = new Pipe(type, rotation);
        }

        // Mark source and drain
        grid[state.source.y][state.source.x].isSource = true;
        grid[state.drain.y][state.drain.x].isDrain = true;

        // Fill empty tiles with random pipes
        const types = Object.keys(PIPE_TYPES);
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                if (!grid[y][x]) {
                    const type = types[randomInt(0, types.length - 1)];
                    grid[y][x] = new Pipe(type, randomInt(0, 3));
                }
            }
        }

        // Store solution rotations
        const solution = grid.map(row => row.map(pipe => pipe.rotation));

        // Randomize all rotations (but ensure still solvable by keeping solution)
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Random rotation that's different from solution (usually)
                const randomRotations = randomInt(1, 3);
                for (let r = 0; r < randomRotations; r++) {
                    grid[y][x].rotate();
                }
            }
        }

        return { grid, solution };
    }

    function generatePath(size, source, drain) {
        // BFS to find a path, with some randomization
        const visited = new Set();
        const queue = [{ pos: source, path: [source] }];
        visited.add(`${source.x},${source.y}`);

        while (queue.length > 0) {
            // Randomly pick from queue for more interesting paths
            const idx = randomInt(0, Math.min(queue.length - 1, 2));
            const { pos, path } = queue.splice(idx, 1)[0];

            if (pos.x === drain.x && pos.y === drain.y) {
                return path;
            }

            // Get neighbors in random order
            const neighbors = shuffle([0, 1, 2, 3]).map(dir => ({
                dir,
                x: pos.x + DIR_VECTORS[dir].x,
                y: pos.y + DIR_VECTORS[dir].y
            })).filter(n =>
                n.x >= 0 && n.x < size &&
                n.y >= 0 && n.y < size &&
                !visited.has(`${n.x},${n.y}`)
            );

            for (const n of neighbors) {
                visited.add(`${n.x},${n.y}`);
                queue.push({
                    pos: { x: n.x, y: n.y },
                    path: [...path, { x: n.x, y: n.y }]
                });
            }
        }

        // Fallback: straight line (shouldn't happen)
        return [source, drain];
    }

    function getDirection(from, to) {
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        if (dy < 0) return 0; // N
        if (dx > 0) return 1; // E
        if (dy > 0) return 2; // S
        if (dx < 0) return 3; // W
        return 0;
    }

    function findPipeForConnections(required) {
        // Find a pipe type and rotation that provides at least the required connections
        for (const [type, data] of Object.entries(PIPE_TYPES)) {
            for (let rot = 0; rot < 4; rot++) {
                const rotated = [];
                for (let i = 0; i < 4; i++) {
                    rotated[i] = data.connections[(i - rot + 4) % 4];
                }
                // Check if this provides required connections
                let matches = true;
                for (let i = 0; i < 4; i++) {
                    if (required[i] === 1 && rotated[i] !== 1) {
                        matches = false;
                        break;
                    }
                }
                if (matches) {
                    return { type, rotation: rot };
                }
            }
        }
        return { type: 'cross', rotation: 0 }; // Fallback
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WATER FLOW
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function updateWaterFlow() {
        // Reset water state
        for (const row of state.grid) {
            for (const pipe of row) {
                pipe.hasWater = false;
            }
        }

        // BFS from source
        const queue = [state.source];
        const visited = new Set();
        visited.add(`${state.source.x},${state.source.y}`);
        state.grid[state.source.y][state.source.x].hasWater = true;

        while (queue.length > 0) {
            const pos = queue.shift();
            const pipe = state.grid[pos.y][pos.x];

            for (let dir = 0; dir < 4; dir++) {
                if (!pipe.connectsTo(dir)) continue;

                const nx = pos.x + DIR_VECTORS[dir].x;
                const ny = pos.y + DIR_VECTORS[dir].y;
                const key = `${nx},${ny}`;

                if (nx < 0 || nx >= state.gridSize ||
                    ny < 0 || ny >= state.gridSize ||
                    visited.has(key)) continue;

                const neighbor = state.grid[ny][nx];
                const oppositeDir = (dir + 2) % 4;

                if (neighbor.connectsTo(oppositeDir)) {
                    visited.add(key);
                    neighbor.hasWater = true;
                    queue.push({ x: nx, y: ny });
                }
            }
        }

        // Check win condition
        const drainPipe = state.grid[state.drain.y][state.drain.x];
        if (drainPipe.hasWater && !state.won) {
            state.won = true;
            setTimeout(showWinModal, 300);
        }

        // Update caustics mask to follow water
        updateWaterMask();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SVG RENDERING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function render() {
        svg.innerHTML = '';
        const size = state.gridSize;
        const tileSize = 400 / size;

        // Create defs for gradients and filters
        const defs = document.createElementNS(NS, 'defs');

        // Sunlight gradient (top-left to bottom-right)
        const sunGrad = document.createElementNS(NS, 'linearGradient');
        sunGrad.id = 'sunlight';
        sunGrad.setAttribute('x1', '0%');
        sunGrad.setAttribute('y1', '0%');
        sunGrad.setAttribute('x2', '100%');
        sunGrad.setAttribute('y2', '100%');
        sunGrad.innerHTML = `
            <stop offset="0%" style="stop-color:rgba(255,250,230,0.3)"/>
            <stop offset="100%" style="stop-color:rgba(0,0,0,0.1)"/>
        `;
        defs.appendChild(sunGrad);

        // Water gradient
        const waterGrad = document.createElementNS(NS, 'linearGradient');
        waterGrad.id = 'water';
        waterGrad.setAttribute('x1', '0%');
        waterGrad.setAttribute('y1', '0%');
        waterGrad.setAttribute('x2', '100%');
        waterGrad.setAttribute('y2', '100%');
        waterGrad.innerHTML = `
            <stop offset="0%" style="stop-color:#6ab4e8"/>
            <stop offset="50%" style="stop-color:#4a90c2"/>
            <stop offset="100%" style="stop-color:#2a6090"/>
        `;
        defs.appendChild(waterGrad);

        svg.appendChild(defs);

        // Render each tile
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                renderTile(x, y, tileSize);
            }
        }
    }

    function renderTile(x, y, ts) {
        const px = x * ts;
        const py = y * ts;
        const pipe = state.grid[y][x];
        const isDark = state.darkMode;

        const group = document.createElementNS(NS, 'g');
        group.classList.add('pipe-tile');
        group.setAttribute('data-x', x);
        group.setAttribute('data-y', y);

        // Background soil
        const soil = document.createElementNS(NS, 'rect');
        soil.setAttribute('x', px);
        soil.setAttribute('y', py);
        soil.setAttribute('width', ts);
        soil.setAttribute('height', ts);
        soil.setAttribute('fill', isDark ? '#3d3020' : '#c9a66b');
        group.appendChild(soil);

        // Soil texture gradient
        const soilOverlay = document.createElementNS(NS, 'rect');
        soilOverlay.setAttribute('x', px);
        soilOverlay.setAttribute('y', py);
        soilOverlay.setAttribute('width', ts);
        soilOverlay.setAttribute('height', ts);
        soilOverlay.setAttribute('fill', 'url(#sunlight)');
        group.appendChild(soilOverlay);

        // Pebbles
        renderPebbles(group, px, py, ts, x, y, isDark);

        // Pipe
        if (pipe) {
            renderPipe(group, pipe, px, py, ts, isDark);
        }

        // Click handler
        group.addEventListener('click', () => handleClick(x, y));

        svg.appendChild(group);
    }

    function renderPebbles(group, px, py, ts, tileX, tileY, isDark) {
        // Deterministic pebbles based on tile position
        const seed = tileX * 1000 + tileY;
        const count = 3 + (seed % 4);

        for (let i = 0; i < count; i++) {
            const pebbleSeed = seed * 100 + i;
            const cx = px + (((pebbleSeed * 7) % 80) + 10) / 100 * ts;
            const cy = py + (((pebbleSeed * 13) % 80) + 10) / 100 * ts;
            const size = ts * (0.04 + (pebbleSeed % 30) / 1000);
            const shade = (pebbleSeed % 40) - 20;

            // Pebble shadow
            const shadow = document.createElementNS(NS, 'ellipse');
            shadow.setAttribute('cx', cx + size * 0.3);
            shadow.setAttribute('cy', cy + size * 0.3);
            shadow.setAttribute('rx', size * 1.1);
            shadow.setAttribute('ry', size * 0.7);
            shadow.setAttribute('fill', 'rgba(0,0,0,0.2)');
            group.appendChild(shadow);

            // Pebble body
            const pebble = document.createElementNS(NS, 'ellipse');
            pebble.setAttribute('cx', cx);
            pebble.setAttribute('cy', cy);
            pebble.setAttribute('rx', size);
            pebble.setAttribute('ry', size * 0.7);
            const baseColor = isDark ? 50 + shade : 130 + shade;
            pebble.setAttribute('fill', `rgb(${baseColor + 20}, ${baseColor + 10}, ${baseColor - 10})`);
            group.appendChild(pebble);

            // Pebble highlight
            const highlight = document.createElementNS(NS, 'ellipse');
            highlight.setAttribute('cx', cx - size * 0.3);
            highlight.setAttribute('cy', cy - size * 0.2);
            highlight.setAttribute('rx', size * 0.4);
            highlight.setAttribute('ry', size * 0.25);
            highlight.setAttribute('fill', 'rgba(255,255,255,0.3)');
            group.appendChild(highlight);
        }
    }

    function renderPipe(group, pipe, px, py, ts, isDark) {
        const cx = px + ts / 2;
        const cy = py + ts / 2;
        const connections = pipe.getConnections();
        const pipeWidth = ts * 0.35;
        const wallWidth = ts * 0.08;
        const channelWidth = pipeWidth - wallWidth * 2;

        const pipeGroup = document.createElementNS(NS, 'g');

        // Colors
        const wallColor = isDark ? '#6a5a4a' : '#a08060';
        const wallDark = isDark ? '#4a3a2a' : '#806040';
        const wallLight = isDark ? '#8a7a6a' : '#c0a080';
        const waterColor = pipe.hasWater ? (isDark ? '#4a90c2' : '#5aa0d8') : 'transparent';

        // Draw pipe segments for each connection
        const dirs = [];
        for (let dir = 0; dir < 4; dir++) {
            if (connections[dir]) dirs.push(dir);
        }

        // Draw channel/water first (bottom layer)
        for (const dir of dirs) {
            drawPipeChannel(pipeGroup, cx, cy, dir, ts, channelWidth, waterColor, pipe.hasWater);
        }

        // Draw center channel
        if (dirs.length > 0) {
            const centerSize = channelWidth;
            if (pipe.hasWater) {
                const centerWater = document.createElementNS(NS, 'rect');
                centerWater.setAttribute('x', cx - centerSize / 2);
                centerWater.setAttribute('y', cy - centerSize / 2);
                centerWater.setAttribute('width', centerSize);
                centerWater.setAttribute('height', centerSize);
                centerWater.setAttribute('fill', waterColor);
                pipeGroup.appendChild(centerWater);
            }
        }

        // Draw walls (top layer)
        for (const dir of dirs) {
            drawPipeWalls(pipeGroup, cx, cy, dir, ts, pipeWidth, wallWidth, wallColor, wallDark, wallLight, isDark);
        }

        // Draw center junction walls
        drawCenterJunction(pipeGroup, cx, cy, dirs, pipeWidth, wallWidth, wallColor, wallDark, wallLight, isDark);

        // Draw end caps for non-connected directions
        for (let dir = 0; dir < 4; dir++) {
            if (!connections[dir]) {
                drawEndCap(pipeGroup, cx, cy, dir, pipeWidth, wallWidth, wallColor, wallDark, isDark);
            }
        }

        // Source indicator
        if (pipe.isSource) {
            const sourceGlow = document.createElementNS(NS, 'circle');
            sourceGlow.setAttribute('cx', cx);
            sourceGlow.setAttribute('cy', cy);
            sourceGlow.setAttribute('r', pipeWidth * 0.3);
            sourceGlow.setAttribute('fill', '#4a90c2');
            sourceGlow.setAttribute('opacity', '0.8');
            pipeGroup.appendChild(sourceGlow);
        }

        // Drain indicator (pulsing)
        if (pipe.isDrain) {
            const drainGlow = document.createElementNS(NS, 'circle');
            drainGlow.setAttribute('cx', cx);
            drainGlow.setAttribute('cy', cy);
            drainGlow.setAttribute('r', pipeWidth * 0.35);
            drainGlow.setAttribute('fill', pipe.hasWater ? '#4adc4a' : '#dc4a4a');
            drainGlow.classList.add('drain-glow');
            pipeGroup.appendChild(drainGlow);
        }

        // Water shimmer effect
        if (pipe.hasWater && !pipe.isDrain) {
            const shimmer = document.createElementNS(NS, 'circle');
            shimmer.setAttribute('cx', cx);
            shimmer.setAttribute('cy', cy);
            shimmer.setAttribute('r', channelWidth * 0.3);
            shimmer.setAttribute('fill', 'rgba(255,255,255,0.4)');
            shimmer.classList.add('water-highlight');
            pipeGroup.appendChild(shimmer);
        }

        group.appendChild(pipeGroup);
    }

    function drawPipeChannel(group, cx, cy, dir, ts, width, color, hasWater) {
        if (!hasWater) return;

        const halfTs = ts / 2;
        const halfWidth = width / 2;
        const bevel = width * 0.15; // Subtle channel bevel

        // Channel polygon from center to edge with slight bevels
        const channel = document.createElementNS(NS, 'polygon');
        let points;

        switch (dir) {
            case 0: // N
                points = [
                    [cx - halfWidth + bevel, cy - halfTs],
                    [cx + halfWidth - bevel, cy - halfTs],
                    [cx + halfWidth, cy],
                    [cx - halfWidth, cy]
                ];
                break;
            case 1: // E
                points = [
                    [cx, cy - halfWidth],
                    [cx + halfTs, cy - halfWidth + bevel],
                    [cx + halfTs, cy + halfWidth - bevel],
                    [cx, cy + halfWidth]
                ];
                break;
            case 2: // S
                points = [
                    [cx - halfWidth, cy],
                    [cx + halfWidth, cy],
                    [cx + halfWidth - bevel, cy + halfTs],
                    [cx - halfWidth + bevel, cy + halfTs]
                ];
                break;
            case 3: // W
                points = [
                    [cx - halfTs, cy - halfWidth + bevel],
                    [cx, cy - halfWidth],
                    [cx, cy + halfWidth],
                    [cx - halfTs, cy + halfWidth - bevel]
                ];
                break;
        }

        channel.setAttribute('points', points.map(p => p.join(',')).join(' '));
        channel.setAttribute('fill', color);
        group.appendChild(channel);
    }

    function drawPipeWalls(group, cx, cy, dir, ts, pipeWidth, wallWidth, wallColor, wallDark, wallLight, isDark) {
        const halfTs = ts / 2;
        const halfPipe = pipeWidth / 2;
        const bevel = wallWidth * 0.6; // Low-poly bevel amount

        // Each wall is a chunky stone block with beveled faces
        switch (dir) {
            case 0: // N - walls on left and right of vertical channel
                drawStoneWall(group, 'v-left', cx - halfPipe, cy - halfTs, cx - halfPipe + wallWidth, cy + wallWidth, wallWidth, bevel, isDark);
                drawStoneWall(group, 'v-right', cx + halfPipe - wallWidth, cy - halfTs, cx + halfPipe, cy + wallWidth, wallWidth, bevel, isDark);
                break;
            case 1: // E - walls on top and bottom of horizontal channel
                drawStoneWall(group, 'h-top', cx - wallWidth, cy - halfPipe, cx + halfTs, cy - halfPipe + wallWidth, wallWidth, bevel, isDark);
                drawStoneWall(group, 'h-bottom', cx - wallWidth, cy + halfPipe - wallWidth, cx + halfTs, cy + halfPipe, wallWidth, bevel, isDark);
                break;
            case 2: // S
                drawStoneWall(group, 'v-left', cx - halfPipe, cy - wallWidth, cx - halfPipe + wallWidth, cy + halfTs, wallWidth, bevel, isDark);
                drawStoneWall(group, 'v-right', cx + halfPipe - wallWidth, cy - wallWidth, cx + halfPipe, cy + halfTs, wallWidth, bevel, isDark);
                break;
            case 3: // W
                drawStoneWall(group, 'h-top', cx - halfTs, cy - halfPipe, cx + wallWidth, cy - halfPipe + wallWidth, wallWidth, bevel, isDark);
                drawStoneWall(group, 'h-bottom', cx - halfTs, cy + halfPipe - wallWidth, cx + wallWidth, cy + halfPipe, wallWidth, bevel, isDark);
                break;
        }
    }

    function drawStoneWall(group, type, x1, y1, x2, y2, wallWidth, bevel, isDark) {
        // Low-poly stone block with beveled top face
        const baseColor = isDark ? '#5a4a3a' : '#a08060';
        const lightColor = isDark ? '#7a6a5a' : '#c0a080';
        const darkColor = isDark ? '#3a2a1a' : '#705030';
        const midColor = isDark ? '#4a3a2a' : '#907050';

        const w = x2 - x1;
        const h = y2 - y1;
        const b = Math.min(bevel, w * 0.4, h * 0.15);

        if (type.startsWith('v')) {
            // Vertical wall - beveled on outer edge
            const isLeft = type === 'v-left';

            // Main face (base)
            const main = document.createElementNS(NS, 'polygon');
            main.setAttribute('points', [
                [x1, y1 + b],
                [x2, y1 + b],
                [x2, y2 - b],
                [x1, y2 - b]
            ].map(p => p.join(',')).join(' '));
            main.setAttribute('fill', baseColor);
            group.appendChild(main);

            // Top bevel (catches light)
            const topBevel = document.createElementNS(NS, 'polygon');
            topBevel.setAttribute('points', [
                [x1, y1],
                [x2, y1],
                [x2, y1 + b],
                [x1, y1 + b]
            ].map(p => p.join(',')).join(' '));
            topBevel.setAttribute('fill', lightColor);
            group.appendChild(topBevel);

            // Bottom bevel (shadow)
            const bottomBevel = document.createElementNS(NS, 'polygon');
            bottomBevel.setAttribute('points', [
                [x1, y2 - b],
                [x2, y2 - b],
                [x2, y2],
                [x1, y2]
            ].map(p => p.join(',')).join(' '));
            bottomBevel.setAttribute('fill', darkColor);
            group.appendChild(bottomBevel);

            // Inner edge highlight/shadow (the channel-facing side)
            const innerEdge = document.createElementNS(NS, 'polygon');
            if (isLeft) {
                // Right edge catches light
                innerEdge.setAttribute('points', [
                    [x2 - b * 0.5, y1 + b],
                    [x2, y1 + b],
                    [x2, y2 - b],
                    [x2 - b * 0.5, y2 - b]
                ].map(p => p.join(',')).join(' '));
                innerEdge.setAttribute('fill', lightColor);
            } else {
                // Left edge in shadow
                innerEdge.setAttribute('points', [
                    [x1, y1 + b],
                    [x1 + b * 0.5, y1 + b],
                    [x1 + b * 0.5, y2 - b],
                    [x1, y2 - b]
                ].map(p => p.join(',')).join(' '));
                innerEdge.setAttribute('fill', darkColor);
            }
            innerEdge.setAttribute('opacity', '0.6');
            group.appendChild(innerEdge);

        } else {
            // Horizontal wall
            const isTop = type === 'h-top';

            // Main face
            const main = document.createElementNS(NS, 'polygon');
            main.setAttribute('points', [
                [x1 + b, y1],
                [x2 - b, y1],
                [x2 - b, y2],
                [x1 + b, y2]
            ].map(p => p.join(',')).join(' '));
            main.setAttribute('fill', baseColor);
            group.appendChild(main);

            // Left bevel (catches light from top-left sun)
            const leftBevel = document.createElementNS(NS, 'polygon');
            leftBevel.setAttribute('points', [
                [x1, y1],
                [x1 + b, y1],
                [x1 + b, y2],
                [x1, y2]
            ].map(p => p.join(',')).join(' '));
            leftBevel.setAttribute('fill', lightColor);
            group.appendChild(leftBevel);

            // Right bevel (shadow)
            const rightBevel = document.createElementNS(NS, 'polygon');
            rightBevel.setAttribute('points', [
                [x2 - b, y1],
                [x2, y1],
                [x2, y2],
                [x2 - b, y2]
            ].map(p => p.join(',')).join(' '));
            rightBevel.setAttribute('fill', darkColor);
            group.appendChild(rightBevel);

            // Inner edge (channel-facing side)
            const innerEdge = document.createElementNS(NS, 'polygon');
            if (isTop) {
                // Bottom edge catches light
                innerEdge.setAttribute('points', [
                    [x1 + b, y2 - b * 0.5],
                    [x2 - b, y2 - b * 0.5],
                    [x2 - b, y2],
                    [x1 + b, y2]
                ].map(p => p.join(',')).join(' '));
                innerEdge.setAttribute('fill', lightColor);
            } else {
                // Top edge in shadow
                innerEdge.setAttribute('points', [
                    [x1 + b, y1],
                    [x2 - b, y1],
                    [x2 - b, y1 + b * 0.5],
                    [x1 + b, y1 + b * 0.5]
                ].map(p => p.join(',')).join(' '));
                innerEdge.setAttribute('fill', darkColor);
            }
            innerEdge.setAttribute('opacity', '0.6');
            group.appendChild(innerEdge);
        }
    }

    function drawCenterJunction(group, cx, cy, dirs, pipeWidth, wallWidth, wallColor, wallDark, wallLight, isDark) {
        // Draw corner blocks where walls meet - these are the chunky joint stones
        const halfPipe = pipeWidth / 2;
        const hasN = dirs.includes(0);
        const hasE = dirs.includes(1);
        const hasS = dirs.includes(2);
        const hasW = dirs.includes(3);
        const bevel = wallWidth * 0.4;

        const baseColor = isDark ? '#5a4a3a' : '#a08060';
        const lightColor = isDark ? '#7a6a5a' : '#c0a080';
        const darkColor = isDark ? '#3a2a1a' : '#705030';

        // Corner stones fill the gaps where perpendicular walls meet
        // NW corner
        if (!hasN && !hasW) {
            drawCornerStone(group, cx - halfPipe, cy - halfPipe, wallWidth, bevel, 'nw', baseColor, lightColor, darkColor);
        }
        // NE corner
        if (!hasN && !hasE) {
            drawCornerStone(group, cx + halfPipe - wallWidth, cy - halfPipe, wallWidth, bevel, 'ne', baseColor, lightColor, darkColor);
        }
        // SE corner
        if (!hasS && !hasE) {
            drawCornerStone(group, cx + halfPipe - wallWidth, cy + halfPipe - wallWidth, wallWidth, bevel, 'se', baseColor, lightColor, darkColor);
        }
        // SW corner
        if (!hasS && !hasW) {
            drawCornerStone(group, cx - halfPipe, cy + halfPipe - wallWidth, wallWidth, bevel, 'sw', baseColor, lightColor, darkColor);
        }
    }

    function drawCornerStone(group, x, y, size, bevel, corner, baseColor, lightColor, darkColor) {
        const b = Math.min(bevel, size * 0.3);

        // Main stone body
        const main = document.createElementNS(NS, 'rect');
        main.setAttribute('x', x);
        main.setAttribute('y', y);
        main.setAttribute('width', size);
        main.setAttribute('height', size);
        main.setAttribute('fill', baseColor);
        group.appendChild(main);

        // Beveled highlight (top-left facing corners get more light)
        if (corner === 'nw' || corner === 'ne' || corner === 'sw') {
            const highlight = document.createElementNS(NS, 'polygon');
            if (corner === 'nw') {
                highlight.setAttribute('points', [
                    [x, y], [x + size, y], [x + size - b, y + b], [x + b, y + b], [x + b, y + size - b], [x, y + size]
                ].map(p => p.join(',')).join(' '));
            } else if (corner === 'ne') {
                highlight.setAttribute('points', [
                    [x, y], [x + size, y], [x + size, y + b], [x + b, y + b]
                ].map(p => p.join(',')).join(' '));
            } else {
                highlight.setAttribute('points', [
                    [x, y], [x + b, y], [x + b, y + size - b], [x, y + size]
                ].map(p => p.join(',')).join(' '));
            }
            highlight.setAttribute('fill', lightColor);
            highlight.setAttribute('opacity', '0.7');
            group.appendChild(highlight);
        }

        // Shadow (bottom-right facing)
        if (corner === 'se' || corner === 'ne' || corner === 'sw') {
            const shadow = document.createElementNS(NS, 'polygon');
            if (corner === 'se') {
                shadow.setAttribute('points', [
                    [x + size, y], [x + size, y + size], [x, y + size], [x + b, y + size - b], [x + size - b, y + size - b], [x + size - b, y + b]
                ].map(p => p.join(',')).join(' '));
            } else if (corner === 'ne') {
                shadow.setAttribute('points', [
                    [x + size, y + b], [x + size, y + size], [x + size - b, y + size - b], [x + size - b, y + b]
                ].map(p => p.join(',')).join(' '));
            } else {
                shadow.setAttribute('points', [
                    [x + b, y + size - b], [x + size, y + size - b], [x + size, y + size], [x, y + size]
                ].map(p => p.join(',')).join(' '));
            }
            shadow.setAttribute('fill', darkColor);
            shadow.setAttribute('opacity', '0.7');
            group.appendChild(shadow);
        }
    }

    function drawEndCap(group, cx, cy, dir, pipeWidth, wallWidth, wallColor, wallDark, isDark) {
        const halfPipe = pipeWidth / 2;
        const bevel = wallWidth * 0.5;

        const baseColor = isDark ? '#5a4a3a' : '#a08060';
        const lightColor = isDark ? '#7a6a5a' : '#c0a080';
        const darkColor = isDark ? '#3a2a1a' : '#705030';

        // End cap is a chunky stone that closes off the channel
        let x, y, w, h;

        switch (dir) {
            case 0: // N - cap at top
                x = cx - halfPipe;
                y = cy - halfPipe;
                w = pipeWidth;
                h = wallWidth;
                break;
            case 1: // E - cap at right
                x = cx + halfPipe - wallWidth;
                y = cy - halfPipe;
                w = wallWidth;
                h = pipeWidth;
                break;
            case 2: // S - cap at bottom
                x = cx - halfPipe;
                y = cy + halfPipe - wallWidth;
                w = pipeWidth;
                h = wallWidth;
                break;
            case 3: // W - cap at left
                x = cx - halfPipe;
                y = cy - halfPipe;
                w = wallWidth;
                h = pipeWidth;
                break;
        }

        const b = Math.min(bevel, w * 0.2, h * 0.2);

        // Main cap body
        const cap = document.createElementNS(NS, 'polygon');
        cap.setAttribute('points', [
            [x + b, y + b],
            [x + w - b, y + b],
            [x + w - b, y + h - b],
            [x + b, y + h - b]
        ].map(p => p.join(',')).join(' '));
        cap.setAttribute('fill', baseColor);
        group.appendChild(cap);

        // Top bevel (light)
        const topBevel = document.createElementNS(NS, 'polygon');
        topBevel.setAttribute('points', [
            [x, y],
            [x + w, y],
            [x + w - b, y + b],
            [x + b, y + b]
        ].map(p => p.join(',')).join(' '));
        topBevel.setAttribute('fill', lightColor);
        group.appendChild(topBevel);

        // Left bevel (light)
        const leftBevel = document.createElementNS(NS, 'polygon');
        leftBevel.setAttribute('points', [
            [x, y],
            [x + b, y + b],
            [x + b, y + h - b],
            [x, y + h]
        ].map(p => p.join(',')).join(' '));
        leftBevel.setAttribute('fill', lightColor);
        leftBevel.setAttribute('opacity', '0.8');
        group.appendChild(leftBevel);

        // Bottom bevel (shadow)
        const bottomBevel = document.createElementNS(NS, 'polygon');
        bottomBevel.setAttribute('points', [
            [x + b, y + h - b],
            [x + w - b, y + h - b],
            [x + w, y + h],
            [x, y + h]
        ].map(p => p.join(',')).join(' '));
        bottomBevel.setAttribute('fill', darkColor);
        group.appendChild(bottomBevel);

        // Right bevel (shadow)
        const rightBevel = document.createElementNS(NS, 'polygon');
        rightBevel.setAttribute('points', [
            [x + w - b, y + b],
            [x + w, y],
            [x + w, y + h],
            [x + w - b, y + h - b]
        ].map(p => p.join(',')).join(' '));
        rightBevel.setAttribute('fill', darkColor);
        rightBevel.setAttribute('opacity', '0.8');
        group.appendChild(rightBevel);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INPUT HANDLING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function handleClick(x, y) {
        if (state.won) return;

        const pipe = state.grid[y][x];
        pipe.rotate();
        state.moves++;

        // Play sound
        if (state.sound) {
            playClickSound();
        }

        updateWaterFlow();
        render();
        updateUI();
    }

    function playClickSound() {
        try {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = 400 + Math.random() * 100;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        } catch (e) {}
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CAUSTICS ANIMATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function initCaustics() {
        // Size canvas to match SVG viewBox
        causticsCanvas.width = 400;
        causticsCanvas.height = 400;
    }

    function updateWaterMask() {
        // Create SVG mask shapes for where water is
        waterMaskSvg.innerHTML = '';
        const size = state.gridSize;
        const tileSize = 400 / size;
        const channelWidth = tileSize * 0.35 - tileSize * 0.08 * 2;

        // Build clip path from water shapes
        const defs = document.createElementNS(NS, 'defs');
        const clipPath = document.createElementNS(NS, 'clipPath');
        clipPath.id = 'water-clip';

        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const pipe = state.grid[y][x];
                if (!pipe || !pipe.hasWater) continue;

                const px = x * tileSize;
                const py = y * tileSize;
                const cx = px + tileSize / 2;
                const cy = py + tileSize / 2;
                const connections = pipe.getConnections();
                const halfTs = tileSize / 2;
                const halfWidth = channelWidth / 2;

                // Center square for junction
                const center = document.createElementNS(NS, 'rect');
                center.setAttribute('x', cx - halfWidth);
                center.setAttribute('y', cy - halfWidth);
                center.setAttribute('width', channelWidth);
                center.setAttribute('height', channelWidth);
                clipPath.appendChild(center);

                // Channel extensions in each connected direction
                for (let dir = 0; dir < 4; dir++) {
                    if (!connections[dir]) continue;
                    const channel = document.createElementNS(NS, 'rect');
                    switch (dir) {
                        case 0: // N
                            channel.setAttribute('x', cx - halfWidth);
                            channel.setAttribute('y', py);
                            channel.setAttribute('width', channelWidth);
                            channel.setAttribute('height', halfTs);
                            break;
                        case 1: // E
                            channel.setAttribute('x', cx);
                            channel.setAttribute('y', cy - halfWidth);
                            channel.setAttribute('width', halfTs);
                            channel.setAttribute('height', channelWidth);
                            break;
                        case 2: // S
                            channel.setAttribute('x', cx - halfWidth);
                            channel.setAttribute('y', cy);
                            channel.setAttribute('width', channelWidth);
                            channel.setAttribute('height', halfTs);
                            break;
                        case 3: // W
                            channel.setAttribute('x', px);
                            channel.setAttribute('y', cy - halfWidth);
                            channel.setAttribute('width', halfTs);
                            channel.setAttribute('height', channelWidth);
                            break;
                    }
                    clipPath.appendChild(channel);
                }
            }
        }

        defs.appendChild(clipPath);
        waterMaskSvg.appendChild(defs);

        // Background rect clipped to water shape
        const maskRect = document.createElementNS(NS, 'rect');
        maskRect.setAttribute('width', '400');
        maskRect.setAttribute('height', '400');
        maskRect.setAttribute('fill', 'white');
        maskRect.setAttribute('clip-path', 'url(#water-clip)');
        waterMaskSvg.appendChild(maskRect);

        // Convert SVG to data URL for CSS mask
        const svgData = new XMLSerializer().serializeToString(waterMaskSvg);
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(svgBlob);

        causticsCanvas.style.webkitMaskImage = `url(${url})`;
        causticsCanvas.style.maskImage = `url(${url})`;
        causticsCanvas.style.webkitMaskSize = '100% 100%';
        causticsCanvas.style.maskSize = '100% 100%';
    }

    function renderCaustics(dt) {
        state.causticsTime += dt;
        const time = state.causticsTime * 2.5;

        const width = causticsCanvas.width;
        const height = causticsCanvas.height;
        const imageData = causticsCtx.createImageData(width, height);
        const data = imageData.data;

        const isDark = state.darkMode;
        const baseIntensity = isDark ? 0.12 : 0.2;

        for (let py = 0; py < height; py++) {
            for (let px = 0; px < width; px++) {
                // Layer 1: Large slow-moving cells
                const n1 = Math.sin(px * 0.04 + time * 0.5) *
                           Math.sin(py * 0.05 + time * 0.4) *
                           Math.sin((px + py) * 0.03 - time * 0.3);

                // Layer 2: Medium faster cells
                const n2 = Math.sin(px * 0.06 - time * 0.7) *
                           Math.sin(py * 0.04 + time * 0.6) *
                           Math.cos((px - py) * 0.04 + time * 0.5);

                // Layer 3: Small quick shimmer
                const n3 = Math.sin(px * 0.1 + time * 1.2) *
                           Math.sin(py * 0.08 - time * 0.9);

                // Combine layers
                const cellValue = n1 * 0.5 + n2 * 0.35 + n3 * 0.15;

                // Bright at edges (where value crosses zero)
                let brightness = 1 - Math.abs(cellValue) * 2.5;
                brightness = Math.max(0, brightness);
                brightness = brightness * brightness;
                brightness *= baseIntensity;

                const idx = (py * width + px) * 4;
                const b = Math.min(255, brightness * 255);

                if (isDark) {
                    data[idx] = 200;     // R
                    data[idx + 1] = 230; // G
                    data[idx + 2] = 255; // B
                } else {
                    data[idx] = 255;     // R
                    data[idx + 1] = 252; // G
                    data[idx + 2] = 230; // B
                }
                data[idx + 3] = b;   // A
            }
        }

        causticsCtx.putImageData(imageData, 0, 0);

        // Soft blur
        causticsCtx.filter = 'blur(2px)';
        causticsCtx.drawImage(causticsCanvas, 0, 0);
        causticsCtx.filter = 'none';
    }

    function animationLoop(timestamp) {
        const elapsed = timestamp - state.lastCausticsFrame;
        if (elapsed >= 50) { // ~20 FPS
            const dt = elapsed / 1000;
            state.lastCausticsFrame = timestamp;
            renderCaustics(dt);
        }
        state.animationId = requestAnimationFrame(animationLoop);
    }

    function startCausticsAnimation() {
        if (state.animationId) cancelAnimationFrame(state.animationId);
        initCaustics();
        state.lastCausticsFrame = performance.now();
        state.animationId = requestAnimationFrame(animationLoop);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function updateUI() {
        document.getElementById('level-num').textContent = state.level;
        document.getElementById('move-count').textContent = state.moves;
    }

    function showWinModal() {
        document.getElementById('win-moves').textContent = state.moves;
        document.getElementById('win-modal').classList.add('open');
    }

    function hideWinModal() {
        document.getElementById('win-modal').classList.remove('open');
    }

    function nextLevel() {
        hideWinModal();
        state.level++;
        state.gridSize = Math.min(3 + Math.floor(state.level / 2), 8);
        state.moves = 0;
        state.won = false;
        startLevel();
    }

    function startLevel() {
        seedRandom(Date.now());
        state.won = false; // Ensure clean state
        
        const { grid, solution } = generatePuzzle(state.gridSize);
        state.grid = grid;
        state.solution = solution;
        
        // Initial water flow check (without win detection)
        updateWaterFlowSilent();

        // Ensure puzzle isn't already solved
        ensurePuzzleNeedsSolving();
        
        // Rotate drain to least-connected orientation for extra insurance
        rotateDrainToLeastConnected();
        
        // Final water flow update (still silent during setup)
        updateWaterFlowSilent();
        
        // Now we're ready - any future water flow checks can trigger win
        state.won = false;
        
        render();
        updateUI();
    }
    
    function updateWaterFlowSilent() {
        // Reset water state
        for (const row of state.grid) {
            for (const pipe of row) {
                pipe.hasWater = false;
            }
        }

        // BFS from source
        const queue = [state.source];
        const visited = new Set();
        visited.add(`${state.source.x},${state.source.y}`);
        state.grid[state.source.y][state.source.x].hasWater = true;

        while (queue.length > 0) {
            const pos = queue.shift();
            const pipe = state.grid[pos.y][pos.x];

            for (let dir = 0; dir < 4; dir++) {
                if (!pipe.connectsTo(dir)) continue;

                const nx = pos.x + DIR_VECTORS[dir].x;
                const ny = pos.y + DIR_VECTORS[dir].y;
                const key = `${nx},${ny}`;

                if (nx < 0 || nx >= state.gridSize ||
                    ny < 0 || ny >= state.gridSize ||
                    visited.has(key)) continue;

                const neighbor = state.grid[ny][nx];
                const oppositeDir = (dir + 2) % 4;

                if (neighbor.connectsTo(oppositeDir)) {
                    visited.add(key);
                    neighbor.hasWater = true;
                    queue.push({ x: nx, y: ny });
                }
            }
        }
        
        // Update caustics mask
        updateWaterMask();
    }
    
    function rotateDrainToLeastConnected() {
        const drainPipe = state.grid[state.drain.y][state.drain.x];
        if (drainPipe.type === 'cross') return; // Can't help crosses
        
        // Find rotation with fewest connections to neighbors that have water
        let bestRotation = drainPipe.rotation;
        let minConnections = 999;
        
        const originalRotation = drainPipe.rotation;
        
        for (let r = 0; r < 4; r++) {
            drainPipe.rotation = r;
            const connections = drainPipe.getConnections();
            
            // Count how many directions connect to water-carrying neighbors
            let waterConnections = 0;
            for (let dir = 0; dir < 4; dir++) {
                if (!connections[dir]) continue;
                
                const nx = state.drain.x + DIR_VECTORS[dir].x;
                const ny = state.drain.y + DIR_VECTORS[dir].y;
                
                if (nx >= 0 && nx < state.gridSize && ny >= 0 && ny < state.gridSize) {
                    const neighbor = state.grid[ny][nx];
                    const oppositeDir = (dir + 2) % 4;
                    if (neighbor.hasWater && neighbor.connectsTo(oppositeDir)) {
                        waterConnections++;
                    }
                }
            }
            
            if (waterConnections < minConnections) {
                minConnections = waterConnections;
                bestRotation = r;
            }
        }
        
        drainPipe.rotation = bestRotation;
    }

    function ensurePuzzleNeedsSolving() {
        // If water already reaches the drain, rotate pipes to break the flow
        const drainPipe = state.grid[state.drain.y][state.drain.x];
        if (!drainPipe.hasWater) return; // Already broken, nothing to do

        // Find pipes on the solution path that we can rotate to break flow
        // Skip cross pipes - rotating them does nothing (4 exits)
        const candidates = [];

        // Add source pipe (if not a cross)
        const sourcePipe = state.grid[state.source.y][state.source.x];
        if (sourcePipe.type !== 'cross') {
            candidates.push({ x: state.source.x, y: state.source.y });
        }

        // Add neighbors of source that have water (if not crosses)
        for (let dir = 0; dir < 4; dir++) {
            const nx = state.source.x + DIR_VECTORS[dir].x;
            const ny = state.source.y + DIR_VECTORS[dir].y;
            if (nx >= 0 && nx < state.gridSize && ny >= 0 && ny < state.gridSize) {
                const neighbor = state.grid[ny][nx];
                if (neighbor && neighbor.hasWater && !neighbor.isDrain && neighbor.type !== 'cross') {
                    candidates.push({ x: nx, y: ny });
                }
            }
        }

        // Try rotating each candidate until flow breaks
        for (const pos of candidates) {
            const pipe = state.grid[pos.y][pos.x];
            const originalRotation = pipe.rotation;

            // Try each rotation
            for (let r = 1; r <= 3; r++) {
                pipe.rotate();
                updateWaterFlowSilent();

                if (!state.grid[state.drain.y][state.drain.x].hasWater) {
                    // Successfully broken! Flow doesn't reach drain
                    return;
                }
            }

            // Restore original rotation if none worked
            pipe.rotation = originalRotation;
        }

        // If we still haven't broken it, try all water-carrying pipes (except crosses)
        for (let y = 0; y < state.gridSize; y++) {
            for (let x = 0; x < state.gridSize; x++) {
                const pipe = state.grid[y][x];
                if (!pipe.hasWater || pipe.isSource || pipe.isDrain || pipe.type === 'cross') continue;

                const originalRotation = pipe.rotation;
                for (let r = 1; r <= 3; r++) {
                    pipe.rotate();
                    updateWaterFlowSilent();

                    if (!state.grid[state.drain.y][state.drain.x].hasWater) {
                        return;
                    }
                }
                pipe.rotation = originalRotation;
            }
        }

        // Reset water flow state after all attempts
        updateWaterFlowSilent();
    }

    function newGame() {
        state.level = 1;
        state.gridSize = 3;
        state.moves = 0;
        state.won = false;
        hideWinModal();
        startLevel();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MENU & SETTINGS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    document.getElementById('menu-btn').addEventListener('click', () => {
        document.getElementById('menu-dropdown').classList.toggle('open');
    });

    document.addEventListener('click', (e) => {
        if (!e.target.closest('#menu-btn') && !e.target.closest('#menu-dropdown')) {
            document.getElementById('menu-dropdown').classList.remove('open');
        }
    });

    document.getElementById('new-game-btn').addEventListener('click', () => {
        document.getElementById('menu-dropdown').classList.remove('open');
        newGame();
    });

    document.getElementById('sound-toggle').addEventListener('click', () => {
        state.sound = !state.sound;
        document.getElementById('sound-toggle').textContent = state.sound ? 'ğŸ”Š Sound: On' : 'ğŸ”‡ Sound: Off';
    });

    document.getElementById('theme-toggle').addEventListener('click', () => {
        state.darkMode = !state.darkMode;
        document.documentElement.setAttribute('data-theme', state.darkMode ? 'dark' : '');
        document.getElementById('theme-toggle').textContent = state.darkMode ? 'â˜€ï¸ Light Mode' : 'ğŸŒ™ Dark Mode';
        render();
    });

    document.getElementById('help-btn').addEventListener('click', () => {
        document.getElementById('menu-dropdown').classList.remove('open');
        document.getElementById('help-modal').classList.add('open');
    });

    document.getElementById('close-help').addEventListener('click', () => {
        document.getElementById('help-modal').classList.remove('open');
    });

    document.getElementById('next-level-btn').addEventListener('click', nextLevel);
    
    // Any click/touch/keypress advances from win modal
    document.getElementById('win-modal').addEventListener('click', (e) => {
        if (document.getElementById('win-modal').classList.contains('open')) {
            nextLevel();
        }
    });
    
    document.addEventListener('keydown', (e) => {
        if (document.getElementById('win-modal').classList.contains('open')) {
            e.preventDefault();
            nextLevel();
        }
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INITIALIZATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Apply saved theme
    if (state.darkMode) {
        document.documentElement.setAttribute('data-theme', 'dark');
        document.getElementById('theme-toggle').textContent = 'â˜€ï¸ Light Mode';
    }

    // Start game and caustics
    startLevel();
    startCausticsAnimation();

    </script>
    <script src="parental.js" defer></script>
    <script type="module" src="assets/js/pwa.js"></script>
</body>
</html>
