<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Cyber Deck</title>
  <style>
    :root {
      /* Base colors */
      --bg-color: #0a0a0a;
      --text-color: #00ff00;
      --panel-bg: #1a1a1a;
      --panel-border: #333;
      --button-bg: #222;
      --button-text: #00ff00;
      --button-hover: #333;
      --shadow-color: rgba(0,255,0,0.2);
      --warning-color: #ffaa00;
      --danger-color: #ff0000;
      --success-color: #00ff00;
      --accent-color: #00ffff;
      
      /* Terminal themes */
      --terminal-bg: #000;
      --terminal-text: #00ff00;
      --terminal-cursor: #00ff00;
      
      /* Sticky layout variables - will be updated dynamically */
      --stats-height: auto;
      --terminal-height: auto;
      --terminal-content-height: calc(8 * 1.4em + 16px + 8px); /* content + padding */
      --terminal-header-height: calc(1.2em + 24px + 8px); /* header + padding */
      --terminal-total-height: calc(var(--terminal-content-height) + var(--terminal-header-height) + 24px); /* content + header + panel padding */
      --status-bar-height: calc(1.1em + 32px + 4px + 32px); /* font + padding + border + extra spacing */
      --scroll-offset: 0px;
    }
    
    [data-theme="green"] {
      --terminal-bg: #000;
      --terminal-text: #00ff00;
      --terminal-cursor: #00ff00;
      --text-color: #00ff00;
      --button-text: #00ff00;
      --shadow-color: rgba(0,255,0,0.2);
      --accent-color: #00ff00;
      --success-color: #00ff00;
      --warning-color: #ffff00;
      --danger-color: #ff0000;
    }
    
    [data-theme="amber"] {
      --terminal-bg: #1a0a00;
      --terminal-text: #ffaa00;
      --terminal-cursor: #ffaa00;
      --text-color: #ffaa00;
      --button-text: #ffaa00;
      --shadow-color: rgba(255,170,0,0.2);
      --accent-color: #ffaa00;
      --success-color: #ffaa00;
      --warning-color: #ff8800;
      --danger-color: #ff0000;
    }
    
    [data-theme="white"] {
      --terminal-bg: #f8f8f8;
      --terminal-text: #333;
      --terminal-cursor: #333;
      --text-color: #333;
      --button-text: #333;
      --shadow-color: rgba(0,0,0,0.2);
      --panel-bg: #f0f0f0;
      --panel-border: #ccc;
      --button-bg: #e0e0e0;
      --button-hover: #d0d0d0;
      --accent-color: #666;
      --success-color: #2e7d2e;
      --warning-color: #cc8800;
      --danger-color: #cc3333;
    }
    
    [data-theme="light"] {
      --bg-color: #f5f5f5;
      --text-color: #333;
      --panel-bg: #fff;
      --panel-border: #ddd;
      --button-bg: #f0f0f0;
      --button-text: #333;
      --button-hover: #e0e0e0;
      --shadow-color: rgba(0,0,0,0.1);
      --terminal-bg: #fff;
      --terminal-text: #333;
      --terminal-cursor: #333;
      --accent-color: #555;
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --danger-color: #f44336;
    }
    
    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #eee;
      --panel-bg: #2a2a2a;
      --panel-border: #555;
      --button-bg: #333;
      --button-text: #eee;
      --button-hover: #444;
      --shadow-color: rgba(255,255,255,0.1);
      --terminal-bg: #1a1a1a;
      --terminal-text: #eee;
      --terminal-cursor: #eee;
      --accent-color: #ccc;
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --danger-color: #f44336;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: var(--bg-color);
      color: var(--text-color);
      overflow-x: auto;
      overflow-y: auto;
      min-height: 100vh;
      transition: all 0.3s ease;
      padding: 0;
      margin: 0;
      position: relative;
    }

    /* === STICKY SCROLL LAYOUT === */
    .scroll-container {
      position: relative;
      min-height: 100vh;
    }

    .terminal-section {
      position: relative;
      z-index: 1;
      height: var(--terminal-total-height);
      min-height: var(--terminal-total-height);
      padding: 8px;
      background: var(--bg-color);
    }

    .stats-section {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--bg-color);
      border-bottom: 2px solid var(--panel-border);
      box-shadow: 0 2px 8px rgba(0,0,0,0.8);
      transition: all 0.3s ease;
      padding: 8px;
      height: auto;
      min-height: var(--status-bar-height);
    }
    
    .stats-section.scrolled {
      background: var(--panel-bg);
      box-shadow: 0 4px 16px rgba(0,0,0,0.9);
      border-bottom-color: var(--accent-color);
    }
    
    .stats-section .status-bar {
      margin: 0;
    }

    .content-section {
      position: relative;
      z-index: 5;
      background: var(--bg-color);
      min-height: calc(100vh - var(--status-bar-height));
      padding: 8px;
    }

    /* === RESPONSIVE LAYOUT === */
    @media (orientation: portrait) and (max-width: 768px) {
      /* Mobile portrait - full sticky behavior */
      .stats-section {
        position: sticky;
        top: 0;
      }
      
      .terminal-section {
        height: auto; /* Let it size naturally on mobile */
        min-height: auto;
        padding: 8px 4px; /* Reduce horizontal padding for mobile */
      }
      
      .terminal {
        min-width: 250px; /* Reduce min-width for mobile */
      }
      
      .content-section {
        padding-top: 0;
        padding: 4px; /* Reduce padding for mobile */
      }
      
      .main-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .top-section, .bottom-section {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      /* Override panel padding on mobile */
      .panel {
        padding: 8px;
      }
      
      /* Optimize terminal for mobile */
      .terminal-content {
        font-size: 12px; /* Smaller font on mobile */
        height: calc(6.5 * 1.4em + 20px); /* 6.5 lines + generous padding for mobile */
        min-height: calc(6.5 * 1.4em + 20px);
        max-height: calc(6.5 * 1.4em + 20px);
        padding: 10px 6px; /* More generous padding for mobile */
        box-sizing: border-box;
      }
      
      .terminal-header h2 {
        font-size: 1em;
      }
      
      .theme-btn {
        padding: 4px 8px;
        font-size: 0.7em;
      }
      
      /* Mobile cursor adjustments */
      .cursor {
        width: 0.5em;
        height: 0.9em;
        top: -0.02em;
      }
    }

    @media (orientation: landscape) and (max-width: 1024px), (min-width: 769px) {
      /* Landscape mobile or desktop - modified layout */
      .scroll-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto 1fr;
        grid-template-areas: 
          "terminal terminal"
          "stats stats"
          "content content";
        gap: 8px;
        padding: 8px;
        min-height: 100vh;
      }
      
      .terminal-section {
        grid-area: terminal;
        position: static;
        height: auto;
        padding: 0;
      }
      
      .stats-section {
        grid-area: stats;
        position: sticky;
        top: 0;
        z-index: 10;
        border-bottom: 2px solid var(--panel-border);
        box-shadow: 0 2px 8px rgba(0,0,0,0.8);
        padding: 0;
      }
      
      .content-section {
        grid-area: content;
        min-height: auto;
        padding: 0;
      }
      
      .main-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        height: 100%;
      }
      
      .top-section {
        display: contents;
      }
      
      .bottom-section {
        display: contents;
      }
    }

    @media (min-width: 1200px) {
      /* Large desktop - three column layout */
      .scroll-container {
        grid-template-columns: 350px 1fr 1fr;
        grid-template-areas: 
          "terminal stats stats"
          "content content content";
      }
      
      .main-container {
        grid-template-columns: 1fr 1fr 1fr;
      }
    }

    .main-container {
      /* Legacy container - now handled by scroll-container */
      display: contents;
    }

    .top-section {
      /* Legacy - now handled by grid areas */
      display: contents;
    }

    .bottom-section {
      /* Legacy - now handled by grid areas */
      display: contents;
    }    .panel {
      background: var(--panel-bg);
      border: 2px solid var(--panel-border);
      border-radius: 8px;
      padding: 12px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 20px var(--shadow-color);
      transition: all 0.3s ease;
    }
    
    .panel h2 {
      font-size: 1.2em;
      margin-bottom: 12px;
      color: var(--accent-color);
      text-transform: uppercase;
      letter-spacing: 2px;
      border-bottom: 1px solid var(--panel-border);
      padding-bottom: 8px;
    }
    
    /* Terminal */
    .terminal {
      flex: 1;
      min-width: 300px;
      background: var(--terminal-bg);
      color: var(--terminal-text);
      font-family: 'Courier New', monospace;
      position: relative;
    }
    
    .terminal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .terminal-controls {
      display: flex;
      gap: 8px;
    }
    
    .theme-btn {
      background: var(--button-bg);
      border: none;
      color: var(--button-text);
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8em;
      transition: all 0.2s ease;
    }
    
    .theme-btn:hover {
      background: var(--button-hover);
    }
    
    .terminal-content {
      height: calc(8.5 * 1.4em + 24px); /* 8.5 lines to ensure no clipping + generous padding */
      min-height: calc(8.5 * 1.4em + 24px);
      max-height: calc(8.5 * 1.4em + 24px);
      overflow: hidden;
      padding: 12px 8px; /* More generous top/bottom padding */
      line-height: 1.4;
      white-space: pre-wrap;
      font-size: 14px;
      position: relative;
      
      /* Prevent sub-pixel rendering issues that cause clipping */
      transform: translateZ(0);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeSpeed;
      box-sizing: border-box;
    }
    
    .cursor {
      background: var(--terminal-cursor);
      animation: blink 1s infinite;
      width: 0.6em; /* Use em units to scale with font */
      height: 1em; /* Match font height, not line height */
      display: inline-block;
      vertical-align: text-bottom; /* Align with text bottom */
      margin: 0;
      position: relative;
      top: -0.05em; /* Slight adjustment to align with baseline */
    }
    
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    
    /* Computer Case */
    .case {
      flex: 1;
      min-width: 300px;
    }
    
    .case-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      height: calc(100% - 40px);
    }
    
    .component-slot {
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      position: relative;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .component-slot .label {
      font-size: 0.9em;
      opacity: 0.7;
      margin-bottom: 8px;
    }
    
    .component {
      background: var(--button-bg);
      border: 1px solid var(--button-text);
      border-radius: 4px;
      padding: 8px;
      text-align: center;
      cursor: default;
      transition: all 0.3s ease;
    }
    
    .component:hover {
      background: var(--button-hover);
      box-shadow: 0 2px 8px var(--shadow-color);
    }
    
    .component.warning {
      border-color: var(--warning-color);
      box-shadow: 0 0 10px rgba(255,170,0,0.3);
      animation: pulse-warning 2s infinite;
    }
    
    .component.danger {
      border-color: var(--danger-color);
      box-shadow: 0 0 10px rgba(255,0,0,0.5);
      animation: pulse-danger 1s infinite;
    }
    
    @keyframes pulse-warning {
      0%, 100% { box-shadow: 0 0 10px rgba(255,170,0,0.3); }
      50% { box-shadow: 0 0 20px rgba(255,170,0,0.6); }
    }
    
    @keyframes pulse-danger {
      0%, 100% { box-shadow: 0 0 10px rgba(255,0,0,0.5); }
      50% { box-shadow: 0 0 25px rgba(255,0,0,0.8); }
    }
    
    /* Shop */
    .shop {
      width: 100%;
    }
    
    .shop-content {
      height: calc(100% - 40px);
      overflow-y: auto;
    }
    
    .shop-category {
      margin-bottom: 16px;
    }
    
    .shop-category h3 {
      font-size: 1em;
      margin-bottom: 8px;
      color: var(--accent-color);
      opacity: 0.8;
    }
    
    .shop-items {
      display: grid;
      gap: 8px;
    }
    
    .shop-item {
      background: var(--button-bg);
      border: 1px solid var(--button-text);
      border-radius: 4px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .shop-item:hover {
      background: var(--button-hover);
      box-shadow: 0 2px 8px var(--shadow-color);
    }
    
    .shop-item.unaffordable {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .shop-item.unaffordable:hover {
      background: var(--panel-bg); /* Reset background for unaffordable items */
      box-shadow: none; /* Remove shadow for unaffordable items */
    }
    
    .shop-item:active {
      transform: scale(0.98);
    }
    
    .shop-item .name {
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    .shop-item .price {
      color: var(--success-color);
      font-size: 0.9em;
    }
    
    .shop-item .stats {
      font-size: 0.8em;
      opacity: 0.8;
      margin-top: 4px;
    }

    .shop-item .type-indicator {
      font-size: 0.7em;
      font-weight: bold;
      text-transform: uppercase;
      margin-bottom: 2px;
      padding: 2px 6px;
      border-radius: 4px;
      display: inline-block;
    }

    .shop-item.upgrade {
      border-color: var(--success-color);
      background: var(--panel-bg);
    }

    .shop-item.upgrade .type-indicator {
      background: var(--success-color);
      color: var(--bg-color);
    }

    .shop-item.upgrade .price {
      color: var(--success-color);
    }

    .shop-item.downgrade {
      border-color: var(--warning-color);
      background: var(--panel-bg);
    }

    .shop-item.downgrade .type-indicator {
      background: var(--warning-color);
      color: var(--bg-color);
    }

    .shop-item.downgrade .price {
      color: var(--warning-color);
    }

    .shop-item.current {
      border-color: var(--accent-color);
      background: var(--panel-bg);
      opacity: 0.7;
    }

    .shop-item.current .type-indicator {
      background: var(--accent-color);
      color: var(--bg-color);
    }

    .shop-item.current .price {
      color: var(--accent-color);
    }
    
    /* Status Bar */
    .status-bar {
      background: var(--panel-bg);
      border: 2px solid var(--panel-border);
      border-radius: 8px;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      font-size: 1.1em;
      align-items: center;
    }
    
    .status-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0; /* Allow items to shrink */
    }
    
    .status-item.credits-item {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }
    
    .status-label {
      font-weight: bold;
      color: var(--text-color);
      font-size: 0.9em;
      opacity: 0.9;
    }
    
    .status-value {
      color: var(--accent-color);
      font-weight: bold;
      font-size: 1em;
      white-space: nowrap;
    }
    
    .progress-container {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    
    .progress-bar {
      flex: 1;
      min-width: 80px;
      height: 14px;
      background: var(--button-bg);
      border-radius: 7px;
      overflow: hidden;
      border: 1px solid var(--panel-border);
      position: relative;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--success-color);
      transition: all 0.3s ease;
      min-width: 2px;
    }
    
    .progress-fill.warning {
      background: var(--warning-color);
    }
    
    .progress-fill.danger {
      background: var(--danger-color);
    }

    /* Missions */
    .missions {
      width: 100%;
    }

    .missions-content {
      height: calc(100% - 40px);
      overflow-y: auto;
    }

    .active-mission {
      margin-bottom: 20px;
    }

    .active-mission h3, .available-missions h3 {
      font-size: 1em;
      margin-bottom: 8px;
      color: var(--accent-color);
      opacity: 0.8;
    }

    .mission-card {
      background: var(--button-bg);
      border: 1px solid var(--button-text);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .mission-card:hover {
      background: var(--button-hover);
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    .mission-card.active {
      border-color: var(--accent-color);
      background: var(--panel-bg);
      cursor: default;
      box-shadow: 0 0 10px var(--shadow-color);
    }

    .mission-card.active:hover {
      background: var(--panel-bg);
    }

    .mission-name {
      font-weight: bold;
      color: var(--accent-color);
      margin-bottom: 4px;
    }

    .mission-description {
      font-size: 0.9em;
      margin-bottom: 8px;
      opacity: 0.8;
    }

    .mission-requirements {
      font-size: 0.8em;
      color: var(--warning-color);
      margin-bottom: 4px;
    }

    .mission-reward {
      font-size: 0.8em;
      color: var(--success-color);
      font-weight: bold;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      body {
        padding: 6px;
      }
      
      .top-section {
        flex-direction: column;
      }
      
      .terminal, .case {
        min-width: unset;
      }
      
      .panel {
        padding: 8px;
      }
      
      .panel h2 {
        font-size: 1em;
        margin-bottom: 8px;
      }
      
      .terminal-content {
        font-size: 12px;
        height: calc(8 * 1.2em + 16px); /* Adjust for smaller font size */
        min-height: calc(8 * 1.2em + 16px);
        max-height: calc(8 * 1.2em + 16px);
      }
      
      .case-grid {
        grid-template-columns: 1fr;
        gap: 8px;
      }
      
      .component-slot {
        min-height: 50px;
        padding: 8px;
      }
      
      .shop-item {
        padding: 6px;
      }
      
      .status-bar {
        padding: 8px 12px;
        font-size: 1em;
        flex-wrap: wrap;
        justify-content: center;
        gap: 12px;
      }
      
      .status-item {
        flex-shrink: 0;
      }
      
      .progress-bar {
        width: 80px;
        height: 10px;
      }
    }
    
    @media (max-width: 768px) {
      .status-bar {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
        padding: 12px;
      }
      
      .progress-bar {
        min-width: 60px;
      }
      
      .status-value {
        font-size: 0.9em;
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding: 4px;
      }
      
      .main-container {
        gap: 4px;
      }
      
      .panel {
        padding: 6px;
      }
      
      .terminal-content {
        font-size: 11px;
        height: calc(8 * 1.1em + 12px); /* Adjust for even smaller font size */
        min-height: calc(8 * 1.1em + 12px);
        max-height: calc(8 * 1.1em + 12px);
      }
      
      .status-bar {
        grid-template-columns: 1fr 1fr;
        padding: 8px;
        font-size: 0.9em;
        gap: 8px;
      }
      
      .status-item {
        gap: 4px;
      }
      
      .status-label {
        font-size: 0.8em;
      }
      
      .status-value {
        font-size: 0.85em;
      }
      
      .progress-container {
        gap: 6px;
      }
      
      .progress-bar {
        height: 12px;
        min-width: 50px;
      }
      
      .status-item {
        font-size: 1em;
      }
    }
    
    /* Game Over Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .modal.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    .modal-content {
      background: var(--panel-bg);
      border: 2px solid var(--panel-border);
      border-radius: 12px;
      padding: 24px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 0 30px var(--shadow-color);
    }
    
    .modal-content h2 {
      color: var(--danger-color);
      margin-bottom: 16px;
    }
    
    .modal-content p {
      margin-bottom: 16px;
      line-height: 1.4;
    }
    
    .modal-content button {
      background: var(--button-bg);
      border: 1px solid var(--button-text);
      color: var(--button-text);
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 1em;
      transition: all 0.2s ease;
    }
    
    .modal-content button:hover {
      background: var(--button-hover);
    }
  </style>
</head>
<body>
  <div class="scroll-container">
    <!-- Terminal Section (scrolls off first) -->
    <div class="terminal-section">
      <div class="panel terminal">
        <div class="terminal-header">
          <h2>Terminal</h2>
          <div class="terminal-controls">
            <button class="theme-btn" onclick="toggleFullscreen()">Fullscreen</button>
            <button class="theme-btn" id="theme-btn">Green</button>
          </div>
        </div>
        <div class="terminal-content" id="terminal-content">
          <div>$ cyber-deck --init</div>
          <div>Initializing Cyber Deck OS...</div>
          <div>System ready. Type to earn credits.</div>
          <div>$ <span class="cursor"></span></div>
        </div>
      </div>
    </div>

    <!-- Critical Stats Section (sticky) -->
    <div class="stats-section">
      <div class="status-bar">
        <div class="status-item credits-item">
          <span class="status-label">Credits:</span>
          <span class="status-value">$<span id="credits">0</span></span>
        </div>
        <div class="status-item">
          <span class="status-label">Memory:</span>
          <div class="progress-container">
            <div class="progress-bar">
              <div class="progress-fill" id="memory-progress"></div>
            </div>
            <span class="status-value" id="memory-text">0/4GB</span>
          </div>
        </div>
        <div class="status-item">
          <span class="status-label">Storage:</span>
          <div class="progress-container">
            <div class="progress-bar">
              <div class="progress-fill" id="storage-progress"></div>
            </div>
            <span class="status-value" id="storage-text">0/500GB</span>
          </div>
        </div>
        <div class="status-item">
          <span class="status-label">CPU Temp:</span>
          <div class="progress-container">
            <div class="progress-bar">
              <div class="progress-fill" id="cpu-progress"></div>
            </div>
            <span class="status-value" id="cpu-temp">25°C</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Content Section (scrolls under stats) -->
    <div class="content-section">
      <div class="main-container">
        <div class="top-section">
          <!-- Computer Case -->
          <div class="panel case">
            <h2>System</h2>
            <div class="case-grid">
        <div class="component-slot" data-slot="cpu">
          <div class="label">CPU</div>
          <div class="component" id="cpu-component">
            <div>Basic CPU v1.0</div>
            <div style="font-size: 0.8em; opacity: 0.7;">1 GHz</div>
          </div>
        </div>
        <div class="component-slot" data-slot="memory">
          <div class="label">Memory</div>
          <div class="component" id="memory-component">
            <div>4GB RAM</div>
            <div style="font-size: 0.8em; opacity: 0.7;">DDR3</div>
          </div>
        </div>
        <div class="component-slot" data-slot="storage">
          <div class="label">Storage</div>
          <div class="component" id="storage-component">
            <div>500GB HDD</div>
            <div style="font-size: 0.8em; opacity: 0.7;">5400 RPM</div>
          </div>
        </div>
        <div class="component-slot" data-slot="software">
          <div class="label">Software</div>
          <div class="component" id="software-component">
            <div>Basic OS v1.0</div>
            <div style="font-size: 0.8em; opacity: 0.7;">1x efficiency</div>
          </div>
        </div>
      </div>
    </div>
    </div>

        <div class="bottom-section">
          <!-- Missions -->
          <div class="panel missions">
            <h2>Missions</h2>
            <div class="missions-content">
              <div class="active-mission" id="active-mission">
                <h3>Active Mission</h3>
                <div class="mission-card active" id="active-mission-card">
                  <!-- Active mission will be displayed here -->
                </div>
              </div>
              <div class="available-missions" id="available-missions">
                <h3>Available Missions</h3>
                <div class="mission-list" id="mission-list">
                  <!-- Available missions will be generated by JavaScript -->
                </div>
              </div>
            </div>
          </div>

          <!-- Shop -->
          <div class="panel shop">
            <h2>Shop</h2>
            <div class="shop-content" id="shop-content">
              <!-- Shop items will be generated by JavaScript -->
            </div>
          </div>
        </div>
      </div> <!-- end main-container -->
    </div> <!-- end content-section -->
  </div> <!-- end scroll-container -->
  
  <!-- Game Over Modal -->
  <div class="modal" id="game-over-modal">
    <div class="modal-content">
      <h2>System Failure</h2>
      <p id="failure-reason">Your system has failed!</p>
      <p>Final Score: $<span id="final-score">0</span></p>
      <p style="margin-top: 16px; font-style: italic; opacity: 0.8;">Touch anywhere to restart</p>
    </div>
  </div>

  <script>
    // --- THEME MANAGEMENT ---
    const THEMES = ['system', 'green', 'amber', 'white', 'light', 'dark'];
    let currentThemeIndex = 0;
    
    function getSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    
    function applyTheme(theme) {
      if (theme === 'system') {
        const systemTheme = getSystemTheme();
        // Map system themes to terminal themes
        const terminalTheme = systemTheme === 'dark' ? 'green' : 'white';
        document.documentElement.setAttribute('data-theme', terminalTheme);
      } else {
        document.documentElement.setAttribute('data-theme', theme);
      }
    }
    
    function cycleTheme() {
      currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
      const theme = THEMES[currentThemeIndex];
      applyTheme(theme);
      updateThemeButtonText(theme);
      localStorage.setItem('cyber-deck-theme', theme);
    }
    
    function updateThemeButtonText(theme) {
      const displayNames = {
        'system': 'System',
        'green': 'Green',
        'amber': 'Amber', 
        'white': 'White',
        'light': 'Light',
        'dark': 'Dark'
      };
      document.getElementById('theme-btn').textContent = displayNames[theme] || theme;
    }
    
    function initTheme() {
      const savedTheme = localStorage.getItem('cyber-deck-theme');
      if (savedTheme && THEMES.includes(savedTheme)) {
        currentThemeIndex = THEMES.indexOf(savedTheme);
      }
      const theme = THEMES[currentThemeIndex];
      applyTheme(theme);
      updateThemeButtonText(theme);
      
      // Listen for system theme changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        if (THEMES[currentThemeIndex] === 'system') {
          applyTheme('system');
        }
      });
    }
    
    // --- GAME STATE ---
    let gameState = {
      credits: 0,
      memoryUsed: 0,
      storageUsed: 0,
      cpuTemp: 25,
      baseTemp: 25,
      system: {
        cpu: { name: 'Basic CPU v1.0', version: 1.0, speed: 1, temp: 25 },
        memory: { name: '4GB RAM', capacity: 4096, type: 'DDR3' },
        storage: { name: '500GB HDD', capacity: 500000, type: 'HDD', speed: 5400 }
      },
      software: {
        version: 1.0,
        efficiency: 1.0
      },
      typing: {
        active: false,
        speed: 50, // characters per second
        efficiency: 1.0
      },
      missions: {
        active: 'hello-world',
        available: ['web-scraping', 'api-development', 'password-crack'],
        completed: [],
        progress: {
          currentEarned: 0, // How much earned from current mission
          totalRequired: 0  // Total payout needed to complete mission
        }
      },
      gameRunning: true
    };
    
    let rngSeed = Date.now();
    
    // --- SEEDED RANDOM ---
    function seededRandom() {
      rngSeed = (rngSeed * 9301 + 49297) % 233280;
      return rngSeed / 233280;
    }
    
    // --- SHOP DATA ---
    const shopData = {
      cpu: [
        { name: 'Fast CPU v2.0', version: 2.0, speed: 2, temp: 30, price: 500 },
        { name: 'Ultra CPU v3.0', version: 3.0, speed: 4, temp: 35, price: 1500 },
        { name: 'Quantum CPU v4.0', version: 4.0, speed: 8, temp: 40, price: 5000 },
        { name: 'Neural CPU v5.0', version: 5.0, speed: 16, temp: 45, price: 15000 }
      ],
      memory: [
        { name: '8GB RAM', capacity: 8192, type: 'DDR3', price: 200 },
        { name: '16GB RAM', capacity: 16384, type: 'DDR4', price: 600 },
        { name: '32GB RAM', capacity: 32768, type: 'DDR4', price: 1800 },
        { name: '64GB RAM', capacity: 65536, type: 'DDR5', price: 5000 }
      ],
      storage: [
        { name: '1TB SSD', capacity: 1000000, type: 'SSD', speed: 550, price: 300 },
        { name: '2TB NVMe', capacity: 2000000, type: 'NVMe', speed: 3500, price: 800 },
        { name: '4TB NVMe', capacity: 4000000, type: 'NVMe', speed: 7000, price: 2500 },
        { name: '8TB Quantum', capacity: 8000000, type: 'Quantum', speed: 15000, price: 8000 }
      ],
      software: [
        { name: 'Code Optimizer v2.0', version: 2.0, efficiency: 1.5, price: 400 },
        { name: 'AI Assistant v3.0', version: 3.0, efficiency: 2.0, price: 1200 },
        { name: 'Neural Compiler v4.0', version: 4.0, efficiency: 3.0, price: 3500 },
        { name: 'Quantum IDE v5.0', version: 5.0, efficiency: 5.0, price: 10000 }
      ]
    };

    // --- MISSIONS DATA ---
    const missionsData = [
      {
        id: 'hello-world',
        name: 'Hello, World!',
        description: 'Basic coding tutorial. Learn the fundamentals.',
        requirements: { cpu: 1.0, memory: 2048, storage: 10000 },
        usage: { memory: 15, storage: 30, cpu: 0.5 },
        demandMultipliers: { cpu: 1.0, memory: 1.0, storage: 1.0, heat: 1.0 },
        baseReward: 12,
        totalPayout: 240,
        duration: 5000,
        type: 'tutorial',
        isIdle: false
      },
      {
        id: 'web-scraping',
        name: 'Web Scraping',
        description: 'Extract data from websites using automated scripts.',
        requirements: { cpu: 1.4, memory: 3072, storage: 25000 },
        usage: { memory: 45, storage: 100, cpu: 0.8 },
        demandMultipliers: { cpu: 1.1, memory: 1.3, storage: 1.2, heat: 1.1 },
        baseReward: 18,
        totalPayout: 450,
        duration: 8000,
        type: 'automation',
        isIdle: false
      },
      {
        id: 'api-development',
        name: 'API Development',
        description: 'Build REST APIs for client applications.',
        requirements: { cpu: 1.8, memory: 6144, storage: 75000 },
        usage: { memory: 80, storage: 200, cpu: 1.2 },
        demandMultipliers: { cpu: 1.2, memory: 1.5, storage: 1.3, heat: 1.2 },
        baseReward: 28,
        totalPayout: 700,
        duration: 10000,
        type: 'development',
        isIdle: false
      },
      {
        id: 'password-crack',
        name: 'Password Cracking',
        description: 'Penetration testing - crack encrypted passwords.',
        requirements: { cpu: 2.5, memory: 4096, storage: 15000 },
        usage: { memory: 35, storage: 60, cpu: 2.2 },
        demandMultipliers: { cpu: 2.2, memory: 1.1, storage: 1.0, heat: 2.5 },
        baseReward: 42,
        totalPayout: 1050,
        duration: 7000,
        type: 'pentest',
        isIdle: false
      },
      {
        id: 'machine-learning',
        name: 'ML Model Training',
        description: 'Train neural networks on large datasets.',
        requirements: { cpu: 2.2, memory: 12288, storage: 300000 },
        usage: { memory: 180, storage: 450, cpu: 1.8 },
        demandMultipliers: { cpu: 1.8, memory: 2.2, storage: 1.6, heat: 2.0 },
        baseReward: 55,
        totalPayout: 1375,
        duration: 12000,
        type: 'ai',
        isIdle: false
      },
      {
        id: 'blockchain-mining',
        name: 'Crypto Mining',
        description: 'Mine cryptocurrency using computational power.',
        requirements: { cpu: 3.5, memory: 6144, storage: 40000 },
        usage: { memory: 60, storage: 100, cpu: 3.2 },
        demandMultipliers: { cpu: 2.8, memory: 1.2, storage: 1.1, heat: 3.2 },
        baseReward: 70,
        totalPayout: 1750,
        duration: 9000,
        type: 'mining',
        isIdle: false
      },
      {
        id: 'quantum-simulation',
        name: 'Quantum Simulation',
        description: 'Simulate quantum computing algorithms.',
        requirements: { cpu: 4.5, memory: 24576, storage: 600000 },
        usage: { memory: 320, storage: 800, cpu: 4.0 },
        demandMultipliers: { cpu: 3.2, memory: 2.8, storage: 1.8, heat: 3.8 },
        baseReward: 95,
        totalPayout: 2375,
        duration: 15000,
        type: 'research',
        isIdle: false
      },
      // Idle missions for downtime
      {
        id: 'social-media',
        name: 'Scrolling Social Media',
        description: 'Browse social feeds and memes. Very relaxing.',
        requirements: { cpu: 0.5, memory: 1024, storage: 5000 },
        usage: { memory: 8, storage: 15, cpu: 0.2 },
        demandMultipliers: { cpu: 0.3, memory: 0.5, storage: 0.4, heat: 0.2 },
        baseReward: 2,
        totalPayout: 80,
        duration: 4000,
        type: 'idle',
        isIdle: true
      },
      {
        id: 'email-check',
        name: 'Checking Email',
        description: 'Respond to emails and manage inbox.',
        requirements: { cpu: 0.6, memory: 1024, storage: 5000 },
        usage: { memory: 10, storage: 20, cpu: 0.3 },
        demandMultipliers: { cpu: 0.4, memory: 0.6, storage: 0.5, heat: 0.3 },
        baseReward: 3,
        totalPayout: 120,
        duration: 5000,
        type: 'idle',
        isIdle: true
      },
      {
        id: 'system-maintenance',
        name: 'System Maintenance',
        description: 'Clean temp files and optimize system performance.',
        requirements: { cpu: 0.8, memory: 1536, storage: 8000 },
        usage: { memory: 12, storage: 25, cpu: 0.4 },
        demandMultipliers: { cpu: 0.5, memory: 0.7, storage: 0.6, heat: 0.4 },
        baseReward: 4,
        totalPayout: 160,
        duration: 6000,
        type: 'idle',
        isIdle: true
      },
      // Additional missions with varied resource requirements
      {
        id: 'code-review',
        name: 'Code Review',
        description: 'Review and optimize existing codebases.',
        requirements: { cpu: 1.2, memory: 3072, storage: 30000 },
        usage: { memory: 35, storage: 70, cpu: 0.8 },
        demandMultipliers: { cpu: 1.1, memory: 1.2, storage: 1.1, heat: 1.0 },
        baseReward: 22,
        totalPayout: 550,
        duration: 7000,
        type: 'development',
        isIdle: false
      },
      {
        id: 'database-query',
        name: 'Database Optimization',
        description: 'Optimize database queries and indexing.',
        requirements: { cpu: 1.8, memory: 6144, storage: 180000 },
        usage: { memory: 90, storage: 320, cpu: 1.2 },
        demandMultipliers: { cpu: 1.2, memory: 1.8, storage: 1.6, heat: 1.1 },
        baseReward: 38,
        totalPayout: 950,
        duration: 9000,
        type: 'database',
        isIdle: false
      },
      {
        id: 'network-scan',
        name: 'Network Vulnerability Scan',
        description: 'Scan networks for security vulnerabilities.',
        requirements: { cpu: 2.2, memory: 3072, storage: 25000 },
        usage: { memory: 50, storage: 90, cpu: 2.0 },
        demandMultipliers: { cpu: 1.8, memory: 1.1, storage: 1.0, heat: 1.6 },
        baseReward: 48,
        totalPayout: 1200,
        duration: 8000,
        type: 'pentest',
        isIdle: false
      },
      {
        id: 'image-processing',
        name: 'Image Processing',
        description: 'Process and enhance digital images with AI.',
        requirements: { cpu: 2.8, memory: 12288, storage: 280000 },
        usage: { memory: 160, storage: 480, cpu: 2.2 },
        demandMultipliers: { cpu: 1.7, memory: 2.0, storage: 1.8, heat: 1.5 },
        baseReward: 62,
        totalPayout: 1550,
        duration: 11000,
        type: 'ai',
        isIdle: false
      },
      {
        id: 'compiler-build',
        name: 'Software Compilation',
        description: 'Compile large software projects from source.',
        requirements: { cpu: 3.2, memory: 8192, storage: 700000 },
        usage: { memory: 120, storage: 850, cpu: 2.8 },
        demandMultipliers: { cpu: 2.4, memory: 1.3, storage: 2.2, heat: 2.2 },
        baseReward: 72,
        totalPayout: 1800,
        duration: 12000,
        type: 'development',
        isIdle: false
      },
      {
        id: 'data-analysis',
        name: 'Big Data Analysis',
        description: 'Analyze massive datasets for insights.',
        requirements: { cpu: 2.0, memory: 18432, storage: 500000 },
        usage: { memory: 280, storage: 750, cpu: 1.5 },
        demandMultipliers: { cpu: 1.3, memory: 2.6, storage: 2.0, heat: 1.4 },
        baseReward: 82,
        totalPayout: 2050,
        duration: 14000,
        type: 'analysis',
        isIdle: false
      },
      {
        id: 'game-engine',
        name: 'Game Engine Development',
        description: 'Develop high-performance game rendering engine.',
        requirements: { cpu: 4.2, memory: 16384, storage: 500000 },
        usage: { memory: 240, storage: 650, cpu: 3.8 },
        demandMultipliers: { cpu: 3.0, memory: 1.9, storage: 1.5, heat: 2.8 },
        baseReward: 110,
        totalPayout: 2750,
        duration: 16000,
        type: 'development',
        isIdle: false
      },
      {
        id: 'crypto-analysis',
        name: 'Cryptographic Analysis',
        description: 'Break encryption algorithms and ciphers.',
        requirements: { cpu: 4.8, memory: 6144, storage: 35000 },
        usage: { memory: 65, storage: 150, cpu: 4.5 },
        demandMultipliers: { cpu: 3.6, memory: 1.2, storage: 1.1, heat: 3.8 },
        baseReward: 125,
        totalPayout: 3125,
        duration: 13000,
        type: 'pentest',
        isIdle: false
      }
    ];

    // --- MISSION GENERATOR ---
    const missionTemplates = {
      tutorial: {
        names: ['Basic Scripting', 'Hello World', 'Code Fundamentals', 'Syntax Learning'],
        descriptions: ['Learn basic programming concepts', 'Write your first program', 'Master fundamental syntax', 'Build coding foundation'],
        demandMultipliers: { cpu: 1.0, memory: 1.0, storage: 1.0, heat: 1.0 },
        rewardRange: [10, 20]
      },
      automation: {
        names: ['Web Scraping', 'Data Mining', 'Bot Development', 'API Automation'],
        descriptions: ['Extract data from websites', 'Mine valuable information', 'Create automated bots', 'Integrate multiple APIs'],
        demandMultipliers: { cpu: 1.2, memory: 1.4, storage: 1.3, heat: 1.1 },
        rewardRange: [20, 35]
      },
      pentest: {
        names: ['Password Cracking', 'Network Penetration', 'Vulnerability Scan', 'Security Audit'],
        descriptions: ['Crack encrypted passwords', 'Test network defenses', 'Find system weaknesses', 'Audit security protocols'],
        demandMultipliers: { cpu: 2.5, memory: 1.2, storage: 1.1, heat: 2.8 },
        rewardRange: [50, 80]
      },
      mining: {
        names: ['Crypto Mining', 'Hash Cracking', 'Blockchain Validation', 'Proof of Work'],
        descriptions: ['Mine cryptocurrency', 'Crack cryptographic hashes', 'Validate blockchain transactions', 'Solve computational puzzles'],
        demandMultipliers: { cpu: 3.0, memory: 1.5, storage: 1.2, heat: 3.5 },
        rewardRange: [80, 120]
      },
      ai: {
        names: ['Neural Training', 'Deep Learning', 'AI Research', 'Model Optimization'],
        descriptions: ['Train neural networks', 'Develop deep learning models', 'Research AI algorithms', 'Optimize machine learning'],
        demandMultipliers: { cpu: 2.2, memory: 2.5, storage: 1.8, heat: 2.3 },
        rewardRange: [60, 100]
      },
      research: {
        names: ['Quantum Simulation', 'Physics Modeling', 'Scientific Computing', 'Advanced Research'],
        descriptions: ['Simulate quantum systems', 'Model complex physics', 'Perform scientific calculations', 'Conduct advanced research'],
        demandMultipliers: { cpu: 3.5, memory: 3.0, storage: 2.0, heat: 4.0 },
        rewardRange: [120, 200]
      },
      idle: {
        names: ['Social Media', 'Email Check', 'System Cleanup', 'File Organization', 'News Reading'],
        descriptions: ['Browse social networks', 'Manage inbox', 'Clean temporary files', 'Organize documents', 'Read tech news'],
        demandMultipliers: { cpu: 0.3, memory: 0.5, storage: 0.4, heat: 0.2 },
        rewardRange: [2, 8]
      }
    };

    function generateMission(type, difficulty = 1.0) {
      const template = missionTemplates[type];
      if (!template) return null;

      const nameIndex = Math.floor(seededRandom() * template.names.length);
      const descIndex = Math.floor(seededRandom() * template.descriptions.length);
      
      const difficultyMultiplier = 0.5 + (difficulty * 1.5); // 0.5x to 2.0x based on difficulty
      
      const mission = {
        id: `${type}-${Date.now()}-${Math.floor(seededRandom() * 1000)}`,
        name: template.names[nameIndex],
        description: template.descriptions[descIndex],
        type: type,
        requirements: {
          cpu: Math.round((1.0 + difficulty * 2.0) * 10) / 10,
          memory: Math.floor((2048 + difficulty * 8192) * difficultyMultiplier),
          storage: Math.floor((10000 + difficulty * 200000) * difficultyMultiplier)
        },
        usage: {
          cpu: Math.round((0.5 + difficulty * 2.0) * 10) / 10,
          memory: Math.floor((20 + difficulty * 200) * difficultyMultiplier),
          storage: Math.floor((50 + difficulty * 500) * difficultyMultiplier)
        },
        demandMultipliers: {
          cpu: template.demandMultipliers.cpu * (0.8 + seededRandom() * 0.4), // ±20% variation
          memory: template.demandMultipliers.memory * (0.8 + seededRandom() * 0.4),
          storage: template.demandMultipliers.storage * (0.8 + seededRandom() * 0.4),
          heat: template.demandMultipliers.heat * (0.8 + seededRandom() * 0.4)
        },
        baseReward: Math.floor(template.rewardRange[0] + (template.rewardRange[1] - template.rewardRange[0]) * seededRandom() * difficulty),
        totalPayout: Math.floor((template.rewardRange[0] + template.rewardRange[1]) / 2 * difficulty * (15 + seededRandom() * 10)), // 15-25 cycles worth
        duration: Math.floor((5000 + difficulty * 10000) * (0.8 + seededRandom() * 0.4)),
        isIdle: type === 'idle'
      };

      return mission;
    }

    // --- TERMINAL ---
    let terminalLines = [
      '$ cyber-deck --init',
      'Initializing Cyber Deck OS...',
      'System ready. Type to earn credits.'
    ];
    const terminalCommands = [
      'compiling neural network...',
      'processing data streams...',
      'optimizing algorithms...',
      'encrypting secure channels...',
      'analyzing quantum patterns...',
      'executing cyber protocols...',
      'scanning digital matrices...',
      'parsing binary structures...',
      'calculating probability fields...',
      'synthesizing code fragments...'
    ];
    
    function addTerminalLine(text) {
      terminalLines.push(text);
      if (terminalLines.length > 8) {
        terminalLines.shift();
      }
      updateTerminalDisplay();
    }

    function clearTerminal() {
      terminalLines = [];
      updateTerminalDisplay();
    }
    
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        // Enter fullscreen
        document.documentElement.requestFullscreen().catch(err => {
          console.log(`Error attempting to enable fullscreen: ${err.message}`);
        });
      } else {
        // Exit fullscreen
        document.exitFullscreen();
      }
    }
    
    function updateTerminalDisplay() {
      const content = document.getElementById('terminal-content');
      content.innerHTML = terminalLines.join('\n') + '\n$ <span class="cursor"></span>';
      
      // Simpler approach - let it scroll naturally and add enough padding
      setTimeout(() => {
        content.scrollTop = content.scrollHeight;
      }, 0);
    }
    
    // --- KEYBOARD ---
    function simulateKeyPress(key, keyElement = null) {
      const activeMission = getActiveMission();
      if (!activeMission) return;

      // Calculate system inadequacy multipliers (how under-spec we are)
      const cpuRatio = gameState.system.cpu.speed / activeMission.requirements.cpu;
      const memoryRatio = gameState.system.memory.capacity / activeMission.requirements.memory;
      const storageRatio = gameState.system.storage.capacity / activeMission.requirements.storage;
      
      // Calculate penalty multipliers (worse when under-spec)
      const cpuPenalty = cpuRatio < 1 ? (1 / cpuRatio) : 1; // 2x penalty if half the required CPU
      const memoryPenalty = memoryRatio < 1 ? (1 / memoryRatio) : 1;
      const storagePenalty = storageRatio < 1 ? (1 / storageRatio) : 1;
      
      // Add warning for severely under-spec systems
      if (cpuPenalty > 2 || memoryPenalty > 2 || storagePenalty > 2) {
        if (Math.random() < 0.2) { // 20% chance per cycle
          addTerminalLine(`WARNING: System severely under-spec for "${activeMission.name}". Expect failures.`);
        }
      }

      // Add typing effects with mission-specific commands
      const command = getMissionCommand(activeMission);
      addTerminalLine(`$ ${command}`);
      
      // Use mission-specific resource usage with demand multipliers
      const baseMemoryUsage = Math.floor(seededRandom() * activeMission.usage.memory) + activeMission.usage.memory * 0.5;
      const baseStorageUsage = Math.floor(seededRandom() * activeMission.usage.storage) + activeMission.usage.storage * 0.5;
      // Apply penalty multipliers for under-spec systems
      let memoryUsage = Math.floor(baseMemoryUsage * activeMission.demandMultipliers.memory * memoryPenalty);
      const storageUsage = Math.floor(baseStorageUsage * activeMission.demandMultipliers.storage * storagePenalty);
      const cpuDemand = activeMission.usage.cpu * activeMission.demandMultipliers.cpu * cpuPenalty;
      
      // Idle missions gradually leak memory over time (memory fragmentation/bloat)
      if (activeMission.isIdle) {
        const memoryLeak = Math.floor(1 + seededRandom() * 3); // 1-4 MB per cycle
        memoryUsage += memoryLeak;
      }
      
      gameState.memoryUsed += memoryUsage;
      gameState.storageUsed += storageUsage;
      
      // Earn credits based on mission reward and software efficiency (reduced if under-spec)
      const efficiencyPenalty = Math.min(cpuPenalty, memoryPenalty, storagePenalty); // Use worst penalty
      const earnings = Math.floor(activeMission.baseReward * gameState.software.efficiency / Math.sqrt(efficiencyPenalty));
      gameState.credits += earnings;

      // Track mission progress
      if (gameState.missions && gameState.missions.progress) {
        gameState.missions.progress.currentEarned += earnings;

        // Check for mission completion
        if (gameState.missions.progress.currentEarned >= gameState.missions.progress.totalRequired) {
          completeMission(activeMission);
        }
      }
      
      // Mission-specific CPU temperature increase with demand multiplier AND penalty
      const heatPenalty = Math.max(cpuPenalty, 1); // Heat is primarily CPU-dependent
      const tempIncrease = cpuDemand * 0.5 * activeMission.demandMultipliers.heat * heatPenalty;
      gameState.cpuTemp += tempIncrease;

      // Additional heat if software version is too high for CPU
      const versionDiff = gameState.software.version - gameState.system.cpu.version;
      if (versionDiff > 0) {
        gameState.cpuTemp += versionDiff * 1.5;
      }

      // Warning system for mission stress
      if (activeMission.demandMultipliers.heat > 2.0 && gameState.cpuTemp > 70) {
        if (Math.random() < 0.1) { // 10% chance per cycle
          addTerminalLine(`WARNING: High CPU stress detected. Mission "${activeMission.name}" pushing system limits.`);
        }
      }
      if (activeMission.demandMultipliers.cpu > 2.5 && gameState.system.cpu.speed < activeMission.requirements.cpu) {
        if (Math.random() < 0.05) { // 5% chance per cycle
          addTerminalLine(`ALERT: CPU underspec for current mission. Overheating risk elevated.`);
        }
      }

      // System failure mechanics for severely over-taxed systems
      if (cpuPenalty > 3) { // CPU less than 1/3 required speed
        if (Math.random() < 0.02) { // 2% chance per cycle
          addTerminalLine(`SYSTEM CRASH: CPU overloaded. Process terminated.`);
          gameState.memoryUsed = Math.max(0, gameState.memoryUsed - 500); // Lose some progress
          gameState.cpuTemp += 15; // Spike temperature
        }
      }
      if (memoryPenalty > 2) { // Memory less than 1/2 required
        if (Math.random() < 0.03) { // 3% chance per cycle
          addTerminalLine(`MEMORY ERROR: Out of memory. Data corruption detected.`);
          gameState.storageUsed = Math.max(0, gameState.storageUsed - 200); // Lose data
        }
      }
      if (gameState.cpuTemp > 95 && heatPenalty > 2) { // Extreme heat + under-spec
        if (Math.random() < 0.05) { // 5% chance per cycle
          addTerminalLine(`THERMAL THROTTLING: CPU performance degraded.`);
          // Temporarily reduce efficiency for next few cycles
          gameState.software.efficiency = Math.max(0.1, gameState.software.efficiency * 0.9);
        }
      }
      
      updateDisplay();
      updateShopAffordability();
      updateMissions(); // Update mission requirements without recreating DOM
      checkGameOver();
    }

    function getMissionCommand(mission) {
      const commands = {
        'hello-world': [
          'echo "Hello, World!"',
          'print("Learning basics...")',
          'console.log("Tutorial step complete")'
        ],
        'web-scraping': [
          'python scraper.py --target=site.com',
          'curl -s https://api.target.com/data',
          'scrapy crawl data_spider'
        ],
        'api-development': [
          'npm run build:api',
          'docker-compose up backend',
          'curl -X POST /api/v1/endpoints'
        ],
        'password-crack': [
          'hashcat -m 0 hashes.txt wordlist.txt',
          'john --wordlist=rockyou.txt shadow',
          'hydra -l admin -P pass.txt target'
        ],
        'machine-learning': [
          'python train_model.py --epochs=100',
          'tensorboard --logdir=./logs',
          'nvidia-smi | grep python'
        ],
        'blockchain-mining': [
          'eth-miner --gpu --intensity=8',
          'cgminer --scrypt -o pool:port',
          'xmrig --donate-level=1'
        ],
        'quantum-simulation': [
          'qiskit-run quantum_algorithm.py',
          'cirq-simulate --qubits=16',
          'quantum-gate-optimize --depth=50'
        ],
        'social-media': [
          'firefox reddit.com/r/programming',
          'scroll --endless --mindless',
          'cat /dev/memes > /tmp/procrastination'
        ],
        'email-check': [
          'thunderbird --check-mail',
          'mutt -y | grep "New mail"',
          'gmail-sync --inbox-zero-attempt'
        ],
        'system-maintenance': [
          'sudo apt update && apt upgrade',
          'rm -rf /tmp/* ~/.cache/*',
          'defrag /C: --optimize'
        ]
      };

      const missionCommands = commands[mission.id] || commands['hello-world'];
      return missionCommands[Math.floor(seededRandom() * missionCommands.length)];
    }
    
    // --- SHOP ---
    function createShop() {
      const content = document.getElementById('shop-content');
      content.innerHTML = '';
      
      Object.entries(shopData).forEach(([category, items]) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'shop-category';
        
        const title = document.createElement('h3');
        title.textContent = category.toUpperCase();
        categoryDiv.appendChild(title);
        
        const itemsDiv = document.createElement('div');
        itemsDiv.className = 'shop-items';
        
        items.forEach((item, index) => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'shop-item';
          itemDiv.dataset.category = category;
          itemDiv.dataset.index = index;
          itemDiv.dataset.price = item.price;

          // Calculate effective cost/refund
          let currentItem = category === 'software' ? gameState.software : gameState.system[category];
          let currentPrice = getCurrentItemPrice(category, currentItem);
          let isItemUpgrade = isUpgrade(category, item);
          let effectiveCost = item.price - currentPrice;
          
          let priceDisplay;
          let typeIndicator;
          
          if (isItemUpgrade) {
            typeIndicator = 'UPGRADE';
            priceDisplay = effectiveCost > 0 ? `Cost: $${effectiveCost}` : 'Cost: FREE';
            itemDiv.classList.add('upgrade');
            // Set affordability based on effective cost
            if (gameState.credits < effectiveCost) {
              itemDiv.classList.add('unaffordable');
            }
          } else if (!isItemUpgrade && !isCurrent(category, item)) {
            typeIndicator = 'DOWNGRADE';
            let refund = Math.floor((currentPrice - item.price) * 0.6);
            priceDisplay = `Refund: $${refund}`;
            itemDiv.classList.add('downgrade');
          } else {
            typeIndicator = 'CURRENT';
            priceDisplay = 'Equipped';
            itemDiv.classList.add('current');
          }
          
          itemDiv.innerHTML = `
            <div class="name">${item.name}</div>
            <div class="type-indicator">${typeIndicator}</div>
            <div class="price">${priceDisplay}</div>
            <div class="stats">${getItemStats(category, item)}</div>
          `;
          
          itemDiv.addEventListener('click', (e) => handleShopItemClick(category, index, item, e));
          itemsDiv.appendChild(itemDiv);
        });
        
        categoryDiv.appendChild(itemsDiv);
        content.appendChild(categoryDiv);
      });
    }
    
    function getItemStats(category, item) {
      switch (category) {
        case 'cpu':
          return `${item.speed}GHz, v${item.version}`;
        case 'memory':
          return `${item.capacity / 1024}GB ${item.type}`;
        case 'storage':
          return `${item.capacity / 1000}GB ${item.type}`;
        case 'software':
          return `${item.efficiency}x efficiency, v${item.version}`;
        default:
          return '';
      }
    }
    
    function updateShopAffordability() {
      const shopItems = document.querySelectorAll('.shop-item');
      shopItems.forEach(itemElement => {
        const category = itemElement.dataset.category;
        const index = parseInt(itemElement.dataset.index);
        const item = shopData[category][index];
        
        // Calculate effective cost for affordability check
        let currentItem = category === 'software' ? gameState.software : gameState.system[category];
        let currentPrice = getCurrentItemPrice(category, currentItem);
        let isItemUpgrade = isUpgrade(category, item);
        let effectiveCost = item.price - currentPrice;
        
        const wasAffordable = !itemElement.classList.contains('unaffordable');
        
        // Only upgrades need affordability check, downgrades are always "affordable"
        const isAffordable = !isItemUpgrade || gameState.credits >= effectiveCost;
        
        if (wasAffordable !== isAffordable) {
          if (isAffordable) {
            // Make affordable
            itemElement.classList.remove('unaffordable');
          } else {
            // Make unaffordable  
            itemElement.classList.add('unaffordable');
          }
        }
      });
    }
    
    function isUpgrade(category, item) {
      switch (category) {
        case 'cpu':
          return item.version > gameState.system.cpu.version;
        case 'memory':
          return item.capacity > gameState.system.memory.capacity;
        case 'storage':
          return item.capacity > gameState.system.storage.capacity;
        case 'software':
          return item.version > gameState.software.version;
        default:
          return true;
      }
    }
    
    function isCurrent(category, item) {
      switch (category) {
        case 'cpu':
          return item.version === gameState.system.cpu.version && item.speed === gameState.system.cpu.speed;
        case 'memory':
          return item.capacity === gameState.system.memory.capacity && item.name === gameState.system.memory.name;
        case 'storage':
          return item.capacity === gameState.system.storage.capacity && item.name === gameState.system.storage.name;
        case 'software':
          return item.version === gameState.software.version && item.name === gameState.software.name;
        default:
          return false;
      }
    }
    
    // --- DRAG AND DROP ---
    
    function handleShopItemClick(category, index, item, event) {
      // Get current item to check if this is an upgrade or downgrade
      let currentItem = category === 'software' ? gameState.software : gameState.system[category];
      let currentPrice = getCurrentItemPrice(category, currentItem);
      
      let isItemUpgrade = isUpgrade(category, item);
      let effectiveCost = item.price - currentPrice;
      
      if (isItemUpgrade) {
        // Standard upgrade logic
        if (gameState.credits < effectiveCost) {
          // Provide visual feedback for unaffordable items
          const itemElement = event.target.closest('.shop-item');
          if (itemElement) {
            itemElement.style.background = 'rgba(255, 0, 0, 0.2)';
            setTimeout(() => {
              itemElement.style.background = '';
            }, 200);
          }
          return;
        }
        gameState.credits -= effectiveCost;
      } else if (!isCurrent(category, item)) {
        // Downgrade: give back 60% of the price difference
        let refund = Math.floor((currentPrice - item.price) * 0.6);
        gameState.credits += refund;
        addTerminalLine(`Downgraded ${category}. Refund: $${refund} (60% of difference)`);
      } else {
        // Current item - do nothing
        return;
      }
      
      // Apply the new component
      if (category === 'software') {
        gameState.software = { ...item };
      } else {
        gameState.system[category] = { ...item };
      }
      
      updateComponents();
      createShop(); // Recreate shop to update upgrade/downgrade states
      updateDisplay();
    }

    function getCurrentItemPrice(category, currentItem) {
      // Find the price of the currently equipped item
      const categoryData = shopData[category];
      const matchingItem = categoryData.find(shopItem => 
        shopItem.name === currentItem.name || 
        (shopItem.version && shopItem.version === currentItem.version) ||
        (shopItem.speed && shopItem.speed === currentItem.speed) ||
        (shopItem.capacity && shopItem.capacity === currentItem.capacity)
      );
      return matchingItem ? matchingItem.price : 0;
    }

    // --- MISSIONS ---
    function createMissions() {
      createActiveMission();
      createAvailableMissions();
    }

    function createActiveMission() {
      if (!gameState || !gameState.missions || !gameState.missions.active) {
        return;
      }
      
      const activeMission = missionsData.find(m => m.id === gameState.missions.active);
      if (!activeMission) return;

      const progress = gameState.missions.progress || { currentEarned: 0, totalRequired: 1 };
      const progressPercent = Math.min(100, (progress.currentEarned / progress.totalRequired) * 100);
      
      const activeCard = document.getElementById('active-mission-card');
      activeCard.innerHTML = `
        <div class="mission-name">${activeMission.name}</div>
        <div class="mission-description">${activeMission.description}</div>
        <div class="mission-requirements">Recommended: CPU ${activeMission.requirements.cpu}GHz+, ${Math.floor(activeMission.requirements.memory/1024)}GB+ RAM, ${Math.floor(activeMission.requirements.storage/1000)}GB+ Storage</div>
        <div class="mission-progress" style="margin: 8px 0;">
          <div class="mission-progress-text" style="font-size: 0.8em; margin-bottom: 4px;">Progress: $${progress.currentEarned} / $${progress.totalRequired} (${progressPercent.toFixed(1)}%)</div>
          <div class="mission-progress-bar" style="background: var(--panel-bg); border: 1px solid var(--button-text); border-radius: 2px; height: 8px; overflow: hidden;">
            <div class="mission-progress-fill" style="background: var(--accent-color); height: 100%; width: ${progressPercent}%; transition: width 0.3s ease;"></div>
          </div>
        </div>
        <div class="mission-reward">Reward: $${activeMission.baseReward}/cycle</div>
      `;

      // Show system stress level with visual indicators
      const meetsRequirements = checkMissionRequirements(activeMission);
      if (!meetsRequirements) {
        activeCard.style.opacity = '1'; // Keep fully visible since mission will run
        activeCard.style.borderColor = 'var(--danger-color)';
        activeCard.style.boxShadow = '0 0 10px var(--danger-color)'; // Add warning glow
      } else {
        activeCard.style.opacity = '1';
        activeCard.style.borderColor = 'var(--accent-color)';
        activeCard.style.boxShadow = '0 0 10px var(--shadow-color)';
      }
    }

    function createAvailableMissions() {
      const missionList = document.getElementById('mission-list');
      missionList.innerHTML = '';

      if (!gameState || !gameState.missions || !gameState.missions.available) {
        return;
      }

      gameState.missions.available.forEach((missionId, index) => {
        const mission = missionsData.find(m => m.id === missionId);
        if (!mission) return;

        const missionCard = document.createElement('div');
        missionCard.className = 'mission-card';
        missionCard.setAttribute('data-mission-id', missionId);
        missionCard.innerHTML = `
          <div class="mission-name">${mission.name}</div>
          <div class="mission-description">${mission.description}</div>
          <div class="mission-requirements">Recommended: CPU ${mission.requirements.cpu}GHz+, ${Math.floor(mission.requirements.memory/1024)}GB+ RAM, ${Math.floor(mission.requirements.storage/1000)}GB+ Storage</div>
          <div class="mission-demand" style="font-size: 0.8em; opacity: 0.8; color: ${mission.demandMultipliers.heat > 2.5 ? 'var(--danger-color)' : mission.demandMultipliers.heat > 1.5 ? 'var(--warning-color)' : 'var(--text-color)'};">
            Stress: CPU ${mission.demandMultipliers.cpu.toFixed(1)}x, Heat ${mission.demandMultipliers.heat.toFixed(1)}x, RAM ${mission.demandMultipliers.memory.toFixed(1)}x
          </div>
          <div class="mission-reward">Reward: $${mission.baseReward}/cycle | Total: $${mission.totalPayout}</div>
        `;

        // Always allow mission selection - let players decide if they're ready!
        missionCard.addEventListener('click', () => {
          selectMission(missionId);
        });

        missionList.appendChild(missionCard);
      });
    }

    function checkMissionRequirements(mission) {
      const cpu = gameState.system.cpu;
      const memory = gameState.system.memory;
      const storage = gameState.system.storage;

      return cpu.speed >= mission.requirements.cpu &&
             memory.capacity >= mission.requirements.memory &&
             storage.capacity >= mission.requirements.storage;
    }

    function calculateMissionDifficulty(mission) {
      if (!gameState || mission.isIdle) {
        return mission.isIdle ? 0 : 5; // Idle = 0, unknown = medium
      }

      const cpu = gameState.system.cpu;
      const memory = gameState.system.memory;
      const storage = gameState.system.storage;
      const software = gameState.software;

      // Calculate how well equipped the player is for this mission
      const cpuRatio = cpu.speed / mission.requirements.cpu;
      const memoryRatio = memory.capacity / mission.requirements.memory;
      const storageRatio = storage.capacity / mission.requirements.storage;

      // Factor in software efficiency
      const efficiencyBonus = software.efficiency / 2.0; // Software helps with all missions
      const effectiveCpuRatio = cpuRatio * efficiencyBonus;
      const effectiveMemoryRatio = memoryRatio * efficiencyBonus;
      const effectiveStorageRatio = storageRatio * efficiencyBonus;

      // Find the most limiting factor (bottleneck)
      const limitingRatio = Math.min(effectiveCpuRatio, effectiveMemoryRatio, effectiveStorageRatio);

      // Convert ratio to difficulty score (0-10, lower = easier for player)
      if (limitingRatio >= 2.0) return 1;      // Very easy - overpowered
      if (limitingRatio >= 1.5) return 2;      // Easy - comfortable margin
      if (limitingRatio >= 1.2) return 3;      // Doable - some margin
      if (limitingRatio >= 1.0) return 4;      // Just meets requirements
      if (limitingRatio >= 0.8) return 5;      // Challenging - slightly under-spec
      if (limitingRatio >= 0.6) return 6;      // Hard - notably under-spec
      if (limitingRatio >= 0.4) return 7;      // Very hard - significantly under-spec
      if (limitingRatio >= 0.2) return 8;      // Extreme - severely under-spec
      return 9;                                 // Nearly impossible
    }

    function selectMission(missionId) {
      if (!gameState || !gameState.missions) {
        return;
      }
      
      // Handle current active mission when switching
      if (gameState.missions.active !== 'hello-world') {
        const currentMission = missionsData.find(m => m.id === gameState.missions.active);
        
        // Only add idle missions back to available (to maintain 1 idle mission max)
        // Non-idle missions are dismissed/cycled out, giving players control over difficulty
        if (currentMission && currentMission.isIdle) {
          const hasIdleMission = gameState.missions.available.some(missionId => {
            const mission = missionsData.find(m => m.id === missionId);
            return mission && mission.isIdle === true;
          });
          
          // Add idle mission back only if we don't already have one
          if (!hasIdleMission) {
            gameState.missions.available.push(gameState.missions.active);
          }
        }
        // Non-idle missions are intentionally NOT added back - they get dismissed
      }

      // Remove selected mission from available
      gameState.missions.available = gameState.missions.available.filter(id => id !== missionId);

      // Set new active mission
      gameState.missions.active = missionId;

      // Initialize mission progress
      const mission = missionsData.find(m => m.id === missionId);
      if (mission) {
        gameState.missions.progress.currentEarned = 0;
        gameState.missions.progress.totalRequired = mission.totalPayout;
      }

      // Generate new random missions to keep 3 available
      generateNewMissions();

      // Update displays
      createMissions();
      
      // Provide feedback about mission cycling
      const abandonedMission = missionsData.find(m => m.id === gameState.missions.active);
      if (abandonedMission && !abandonedMission.isIdle) {
        addTerminalLine(`Mission selected: ${mission.name} (Target: $${mission.totalPayout})`);
      } else {
        addTerminalLine(`Mission selected: ${mission.name} (Target: $${mission.totalPayout})`);
      }
    }

    function generateNewMissions() {
      if (!gameState || !gameState.missions) {
        return;
      }
      
      // Clean up any excess idle missions first
      const idleMissionIds = gameState.missions.available.filter(missionId => {
        const mission = missionsData.find(m => m.id === missionId);
        return mission && mission.isIdle === true;
      });
      
      // If we have more than 1 idle mission, remove the extras
      if (idleMissionIds.length > 1) {
        const excessIdle = idleMissionIds.slice(1); // Keep first, remove rest
        gameState.missions.available = gameState.missions.available.filter(id => !excessIdle.includes(id));
      }
      
      // Intelligent mission selection: 1 idle + 1 doable + 1 challenging
      const hasIdleMission = gameState.missions.available.some(missionId => {
        const mission = missionsData.find(m => m.id === missionId);
        return mission && mission.isIdle === true;
      });
      
      // Get all available missions not already selected or active
      const candidateMissions = missionsData.filter(mission => 
        mission.id !== gameState.missions.active &&
        !gameState.missions.available.includes(mission.id) &&
        !gameState.missions.completed.includes(mission.id)
      );
      
      // Categorize missions by difficulty
      const missionsByDifficulty = {};
      candidateMissions.forEach(mission => {
        const difficulty = calculateMissionDifficulty(mission);
        if (!missionsByDifficulty[difficulty]) {
          missionsByDifficulty[difficulty] = [];
        }
        missionsByDifficulty[difficulty].push(mission);
      });
      
      // Fill to 3 missions total with intelligent selection
      while (gameState.missions.available.length < 3) {
        let selectedMission = null;
        
        // Priority 1: Ensure we have one idle mission
        if (!hasIdleMission) {
          const idleMissions = candidateMissions.filter(m => m.isIdle);
          if (idleMissions.length > 0) {
            selectedMission = idleMissions[Math.floor(seededRandom() * idleMissions.length)];
          }
        }
        
        // Priority 2: Add a doable mission (difficulty 2-4)
        if (!selectedMission) {
          const doableMissions = candidateMissions.filter(m => {
            const diff = calculateMissionDifficulty(m);
            return !m.isIdle && diff >= 2 && diff <= 4;
          });
          if (doableMissions.length > 0) {
            selectedMission = doableMissions[Math.floor(seededRandom() * doableMissions.length)];
          }
        }
        
        // Priority 3: Add a challenging mission (difficulty 5-7)
        if (!selectedMission) {
          const challengingMissions = candidateMissions.filter(m => {
            const diff = calculateMissionDifficulty(m);
            return !m.isIdle && diff >= 5 && diff <= 7;
          });
          if (challengingMissions.length > 0) {
            selectedMission = challengingMissions[Math.floor(seededRandom() * challengingMissions.length)];
          }
        }
        
        // Fallback: Pick any available mission
        if (!selectedMission && candidateMissions.length > 0) {
          selectedMission = candidateMissions[Math.floor(seededRandom() * candidateMissions.length)];
        }
        
        // If still no mission, generate a procedural one
        if (!selectedMission) {
          const missionTypes = hasIdleMission ? 
            ['tutorial', 'automation', 'development', 'pentest', 'mining', 'ai', 'research', 'database', 'analysis'] :
            ['tutorial', 'automation', 'development', 'pentest', 'mining', 'ai', 'research', 'database', 'analysis', 'idle'];
          
          const randomType = missionTypes[Math.floor(seededRandom() * missionTypes.length)];
          const difficulty = 0.3 + seededRandom() * 1.2; // 0.3 to 1.5 range
          
          selectedMission = generateMission(randomType, difficulty);
          if (selectedMission) {
            missionsData.push(selectedMission);
          }
        }
        
        if (selectedMission) {
          gameState.missions.available.push(selectedMission.id);
          // Remove from candidates to avoid duplicates
          const index = candidateMissions.indexOf(selectedMission);
          if (index > -1) candidateMissions.splice(index, 1);
          
          // Update idle mission tracking
          if (selectedMission.isIdle) {
            hasIdleMission = true;
          }
        } else {
          break; // No more missions available
        }
      }
    }

    function getActiveMission() {
      if (!gameState || !gameState.missions || !gameState.missions.active) {
        return null;
      }
      return missionsData.find(m => m.id === gameState.missions.active);
    }

    function completeMission(mission) {
      if (!gameState || !gameState.missions) {
        return;
      }
      
      // Mark mission as completed
      gameState.missions.completed.push(mission.id);
      
      // Calculate completion bonus (10% of total payout)
      const completionBonus = Math.floor(mission.totalPayout * 0.1);
      gameState.credits += completionBonus;
      
      // Clear memory usage as mission completion benefit (only for non-idle missions)
      const memoryCleared = gameState.memoryUsed;
      let memoryWasCleared = false;
      
      if (!mission.isIdle) {
        gameState.memoryUsed = 0;
        memoryWasCleared = true;
      }
      
      addTerminalLine(`MISSION COMPLETE: ${mission.name}`);
      addTerminalLine(`Completion bonus: $${completionBonus}`);
      if (memoryWasCleared && memoryCleared > 0) {
        addTerminalLine(`Memory cleared: ${memoryCleared}MB freed`);
      } else if (mission.isIdle && memoryCleared > 0) {
        addTerminalLine(`Memory remains at ${memoryCleared}MB (idle missions don't clear memory)`);
      }
      
      // Automatically assign idle mission for cooldown
      assignIdleMission();
    }

    function assignIdleMission() {
      if (!gameState || !gameState.missions) {
        return;
      }
      
      const idleMissions = missionsData.filter(m => m.isIdle === true);
      const randomIdle = idleMissions[Math.floor(seededRandom() * idleMissions.length)];
      
      if (randomIdle) {
        gameState.missions.active = randomIdle.id;
        gameState.missions.progress.currentEarned = 0;
        gameState.missions.progress.totalRequired = randomIdle.totalPayout;
        
        addTerminalLine(`Auto-assigned: ${randomIdle.name} (cooling down system)`);
        createMissions(); // Update displays
      }
    }

    function updateMissions() {
      if (!gameState || !gameState.missions) {
        return;
      }

      // Update active mission requirements display and progress
      const activeMission = missionsData.find(m => m.id === gameState.missions.active);
      if (activeMission) {
        const activeCard = document.getElementById('active-mission-card');
        if (activeCard) {
          // Update progress bar and text
          const progress = gameState.missions.progress || { currentEarned: 0, totalRequired: 1 };
          const progressPercent = Math.min(100, (progress.currentEarned / progress.totalRequired) * 100);
          
          // Find existing progress elements and update them
          const progressText = activeCard.querySelector('.mission-progress-text');
          const progressBar = activeCard.querySelector('.mission-progress-fill');
          
          if (progressText) {
            progressText.textContent = `Progress: $${progress.currentEarned} / $${progress.totalRequired} (${progressPercent.toFixed(1)}%)`;
          }
          
          if (progressBar) {
            progressBar.style.width = `${progressPercent}%`;
          }

          // Update border styling based on requirements
          const meetsRequirements = checkMissionRequirements(activeMission);
          if (!meetsRequirements) {
            activeCard.style.opacity = '1'; // Keep fully visible since mission will run
            activeCard.style.borderColor = 'var(--danger-color)';
            activeCard.style.boxShadow = '0 0 10px var(--danger-color)'; // Add warning glow
          } else {
            activeCard.style.opacity = '1';
            activeCard.style.borderColor = 'var(--accent-color)';
            activeCard.style.boxShadow = '0 0 10px var(--shadow-color)';
          }
        }
      }

      // Update available missions - all missions are always selectable
      const missionCards = document.querySelectorAll('#mission-list .mission-card');
      missionCards.forEach((card) => {
        const missionId = card.getAttribute('data-mission-id');
        if (gameState.missions.available.includes(missionId)) {
          // Always show as fully selectable
          card.style.opacity = '1';
          card.style.cursor = 'pointer';
        }
      });
    }

    // --- COMPONENT UPDATES ---
    function updateComponents() {
      // Update CPU component
      const cpuComponent = document.getElementById('cpu-component');
      const cpu = gameState.system.cpu;
      cpuComponent.innerHTML = `
        <div>${cpu.name}</div>
        <div style="font-size: 0.8em; opacity: 0.7;">${cpu.speed}GHz</div>
      `;
      
      // Update Memory component
      const memoryComponent = document.getElementById('memory-component');
      const memory = gameState.system.memory;
      memoryComponent.innerHTML = `
        <div>${memory.name}</div>
        <div style="font-size: 0.8em; opacity: 0.7;">${memory.type}</div>
      `;
      
      // Update Storage component
      const storageComponent = document.getElementById('storage-component');
      const storage = gameState.system.storage;
      storageComponent.innerHTML = `
        <div>${storage.name}</div>
        <div style="font-size: 0.8em; opacity: 0.7;">${storage.type}</div>
      `;
      
      // Update Software component
      const softwareComponent = document.getElementById('software-component');
      const software = gameState.software;
      softwareComponent.innerHTML = `
        <div>${software.name || `Basic OS v${software.version}`}</div>
        <div style="font-size: 0.8em; opacity: 0.7;">${software.efficiency}x efficiency</div>
      `;
    }
    
    // --- GAME LOGIC ---
    function updateDisplay() {
      // Update credits
      document.getElementById('credits').textContent = gameState.credits;
      
      // Update memory progress
      const memoryPercent = (gameState.memoryUsed / gameState.system.memory.capacity) * 100;
      const memoryProgress = document.getElementById('memory-progress');
      memoryProgress.style.width = Math.min(memoryPercent, 100) + '%';
      
      if (memoryPercent > 90) {
        memoryProgress.className = 'progress-fill danger';
        document.getElementById('memory-component').className = 'component danger';
      } else if (memoryPercent > 75) {
        memoryProgress.className = 'progress-fill warning';
        document.getElementById('memory-component').className = 'component warning';
      } else {
        memoryProgress.className = 'progress-fill';
        document.getElementById('memory-component').className = 'component';
      }
      
      document.getElementById('memory-text').textContent = 
        `${Math.floor(gameState.memoryUsed / 1024)}/${Math.floor(gameState.system.memory.capacity / 1024)}GB`;
      
      // Update storage progress
      const storagePercent = (gameState.storageUsed / gameState.system.storage.capacity) * 100;
      const storageProgress = document.getElementById('storage-progress');
      storageProgress.style.width = Math.min(storagePercent, 100) + '%';
      
      if (storagePercent > 90) {
        storageProgress.className = 'progress-fill danger';
        document.getElementById('storage-component').className = 'component danger';
      } else if (storagePercent > 75) {
        storageProgress.className = 'progress-fill warning';
        document.getElementById('storage-component').className = 'component warning';
      } else {
        storageProgress.className = 'progress-fill';
        document.getElementById('storage-component').className = 'component';
      }
      
      document.getElementById('storage-text').textContent = 
        `${Math.floor(gameState.storageUsed / 1000)}/${Math.floor(gameState.system.storage.capacity / 1000)}GB`;
      
      // Update CPU temperature
      const cpuTemp = Math.floor(gameState.cpuTemp);
      const maxTemp = 100; // Maximum safe operating temperature
      const cpuPercent = Math.min((cpuTemp / maxTemp) * 100, 100);
      
      document.getElementById('cpu-temp').textContent = `${cpuTemp}°C`;
      
      // Update CPU progress bar
      const cpuProgress = document.getElementById('cpu-progress');
      cpuProgress.style.width = cpuPercent + '%';
      
      if (cpuTemp > 85) {
        cpuProgress.className = 'progress-fill danger';
        document.getElementById('cpu-component').className = 'component danger';
      } else if (cpuTemp > 70) {
        cpuProgress.className = 'progress-fill warning';
        document.getElementById('cpu-component').className = 'component warning';
      } else {
        cpuProgress.className = 'progress-fill';
        document.getElementById('cpu-component').className = 'component';
      }
    }
    
    function checkGameOver() {
      let gameOver = false;
      let reason = '';
      
      if (gameState.memoryUsed >= gameState.system.memory.capacity) {
        gameOver = true;
        reason = 'Memory overflow! Your system ran out of RAM.';
      } else if (gameState.storageUsed >= gameState.system.storage.capacity) {
        gameOver = true;
        reason = 'Storage full! No more space for data.';
      } else if (gameState.cpuTemp > 100) {
        gameOver = true;
        reason = 'CPU overheated! Your processor burned out.';
      }
      
      if (gameOver) {
        gameState.gameRunning = false;
        showGameOver(reason);
      }
    }
    
    function showGameOver(reason) {
      document.getElementById('failure-reason').textContent = reason;
      document.getElementById('final-score').textContent = gameState.credits;
      document.getElementById('game-over-modal').classList.add('show');
    }
    
    function restartGame() {
      // Reset game state
      gameState = {
        credits: Math.floor(seededRandom() * 100) + 50, // Random starting credits
        memoryUsed: 0,
        storageUsed: 0,
        cpuTemp: 25,
        baseTemp: 25,
        system: {
          cpu: { name: 'Basic CPU v1.0', version: 1.0, speed: 1, temp: 25 },
          memory: { name: '4GB RAM', capacity: 4096, type: 'DDR3' },
          storage: { name: '500GB HDD', capacity: 500000, type: 'HDD', speed: 5400 }
        },
        software: {
          version: 1.0,
          efficiency: 1.0
        },
        typing: {
          active: false,
          speed: 50,
          efficiency: 1.0
        },
        missions: {
          active: 'hello-world',
          available: ['web-scraping', 'api-development', 'password-crack'],
          completed: [],
          progress: {
            currentEarned: 0,
            totalRequired: 0
          }
        },
        gameRunning: true
      };
      
      // Reset displays
      terminalLines = [
        '$ cyber-deck --init',
        'Initializing Cyber Deck OS...',
        'System ready. Type to earn credits.'
      ];
      
      updateTerminalDisplay();
      updateComponents();
      createShop();
      
      // Initialize mission progress for starting mission
      const startingMission = missionsData.find(m => m.id === gameState.missions.active);
      if (startingMission) {
        gameState.missions.progress.currentEarned = 0;
        gameState.missions.progress.totalRequired = startingMission.totalPayout;
      }
      
      createMissions();
      updateDisplay();
      
      document.getElementById('game-over-modal').classList.remove('show');
    }
    
    // --- AUTO TYPING ---
    function startAutoTyping() {
      setInterval(() => {
        if (gameState.gameRunning && seededRandom() < 0.3) { // 30% chance per interval
          const randomKey = String.fromCharCode(65 + Math.floor(seededRandom() * 26));
          simulateKeyPress(randomKey);
        }
        
        // Gradual CPU cooling
        if (gameState.cpuTemp > gameState.baseTemp) {
          gameState.cpuTemp -= 0.5;
        }
      }, 200); // Every 200ms
    }
    
    // --- KEYBOARD INPUT ---
    function setupKeyboardInput() {
      document.addEventListener('keydown', (e) => {
        if (!gameState.gameRunning) return;
        
        const key = e.key.toUpperCase();
        if (key.match(/^[A-Z0-9]$/)) {
          e.preventDefault();
          simulateKeyPress(key);
        }
      });
    }
    
    // --- INITIALIZATION ---
    function init() {
      initTheme();
      createShop();
      
      // Initialize mission progress for starting mission
      const startingMission = missionsData.find(m => m.id === gameState.missions.active);
      if (startingMission) {
        gameState.missions.progress.currentEarned = 0;
        gameState.missions.progress.totalRequired = startingMission.totalPayout;
      }
      
      createMissions();
      setupKeyboardInput();
      updateComponents();
      updateDisplay();
      startAutoTyping();
      
      // Theme button
      document.getElementById('theme-btn').addEventListener('click', cycleTheme);
      
      // Game over modal click handler
      document.getElementById('game-over-modal').addEventListener('click', restartGame);
      
      // Add initial terminal content
      terminalLines = [
        '$ cyber-deck --init',
        'Initializing Cyber Deck OS...',
        'System ready. Type to earn credits.'
      ];
      updateTerminalDisplay();
      
      // Initialize sticky scrolling
      initStickyScrolling();
    }
    
    // --- SCROLL ENHANCEMENT ---
    function initStickyScrolling() {
      const statsSection = document.querySelector('.stats-section');
      const terminalSection = document.querySelector('.terminal-section');
      const contentSection = document.querySelector('.content-section');
      
      if (!statsSection || !terminalSection) return;
      
      // Function to update dynamic heights
      function updateDynamicHeights() {
        // Wait for layout to settle
        setTimeout(() => {
          const statsHeight = statsSection.offsetHeight;
          const terminalHeight = terminalSection.offsetHeight;
          const isMobilePortrait = window.matchMedia('(orientation: portrait) and (max-width: 768px)').matches;
          
          // Update CSS custom properties
          document.documentElement.style.setProperty('--measured-stats-height', `${statsHeight}px`);
          document.documentElement.style.setProperty('--measured-terminal-height', `${terminalHeight}px`);
          
          // Adjust content section min-height to account for sticky stats
          if (contentSection) {
            if (isMobilePortrait) {
              // On mobile, use minimal spacing and let content flow naturally
              contentSection.style.minHeight = `calc(100vh - ${statsHeight}px - 16px)`;
            } else {
              contentSection.style.minHeight = `calc(100vh - ${statsHeight}px)`;
            }
          }
          
          console.log(`Updated heights - Stats: ${statsHeight}px, Terminal: ${terminalHeight}px, Mobile: ${isMobilePortrait}`);
        }, 100);
      }
      
      // Update heights initially and on resize
      updateDynamicHeights();
      
      // Add scroll listener for smooth transitions
      let ticking = false;
      function updateScrollEffect() {
        const scrollY = window.scrollY;
        const terminalHeight = terminalSection.offsetHeight;
        
        // Calculate scroll progress (0 to 1)
        const scrollProgress = Math.min(scrollY / terminalHeight, 1);
        
        // Apply subtle visual feedback
        statsSection.style.setProperty('--scroll-progress', scrollProgress);
        
        // Add/remove scrolled class for styling
        if (scrollProgress > 0.1) {
          statsSection.classList.add('scrolled');
        } else {
          statsSection.classList.remove('scrolled');
        }
        
        ticking = false;
      }
      
      function onScroll() {
        if (!ticking) {
          requestAnimationFrame(updateScrollEffect);
          ticking = true;
        }
      }
      
      function onResize() {
        updateDynamicHeights();
        if (!ticking) {
          requestAnimationFrame(updateScrollEffect);
          ticking = true;
        }
      }
      
      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onResize);
      
      // Initial call
      updateScrollEffect();
    }
    
    // Start the game
    init();
  </script>
</body>
</html>
