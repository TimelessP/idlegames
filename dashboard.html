<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fighter Jet HUD</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: black;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="hudCanvas"></canvas>
    <script>
        const canvas = document.getElementById('hudCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let scale = 1;

        // Sensor data
        let position = { lat: 0, lon: 0, alt: 0, speed: 0, heading: 0 };
        let orientation = { alpha: 0, beta: 0, gamma: 0 }; // heading, pitch, roll
        let motion = { acceleration: { x: 0, y: 0, z: 0 }, rotationRate: { alpha: 0, beta: 0, gamma: 0 } };
        let lastPosition = null;
        let lastTime = Date.now();

        // HUD elements
        const hudColor = '#00FF00';

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            scale = Math.min(width / 800, height / 600); // Adjusted base for better mobile scaling
        }

        function drawHUD() {
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.scale(scale, scale);
            ctx.translate(width / 2 / scale, height / 2 / scale);

            // Crosshairs
            ctx.strokeStyle = hudColor;
            ctx.lineWidth = 2 / scale;
            ctx.beginPath();
            ctx.moveTo(-20, 0);
            ctx.lineTo(20, 0);
            ctx.moveTo(0, -20);
            ctx.lineTo(0, 20);
            ctx.stroke();

            // Artificial Horizon
            drawArtificialHorizon();

            // Airspeed Indicator
            drawAirspeed();

            // Altitude Indicator
            drawAltitude();

            // Heading Indicator
            drawHeading();

            // Other data
            drawData();

            ctx.restore();
        }

        function drawArtificialHorizon() {
            const pitch = orientation.beta * Math.PI / 180;
            const roll = orientation.gamma * Math.PI / 180;

            ctx.save();
            ctx.rotate(roll);
            ctx.translate(0, pitch * 50); // Pitch scale

            // Horizon line
            ctx.strokeStyle = hudColor;
            ctx.lineWidth = 3 / scale;
            ctx.beginPath();
            ctx.moveTo(-width / scale, 0);
            ctx.lineTo(width / scale, 0);
            ctx.stroke();

            // Pitch ladder
            for (let i = -5; i <= 5; i++) {
                if (i === 0) continue;
                const y = i * 50;
                ctx.beginPath();
                ctx.moveTo(-50, y);
                ctx.lineTo(50, y);
                ctx.stroke();
                ctx.fillStyle = hudColor;
                ctx.font = `${16 / scale}px 'Courier New'`;
                ctx.fillText(Math.abs(i * 5), 60, y + 5);
            }

            ctx.restore();
        }

        function drawAirspeed() {
            const airspeed = position.speed * 3.6; // m/s to km/h
            ctx.save();
            ctx.translate(-width / 2 / scale + 100, 0);

            // Tape
            ctx.strokeStyle = hudColor;
            ctx.lineWidth = 2 / scale;
            ctx.beginPath();
            ctx.moveTo(0, -200);
            ctx.lineTo(0, 200);
            ctx.stroke();

            // Ticks
            for (let i = Math.floor(airspeed / 10) * 10 - 50; i <= Math.floor(airspeed / 10) * 10 + 50; i += 10) {
                const y = (airspeed - i) * 5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(-20, y);
                ctx.stroke();
                if (i % 50 === 0) {
                    ctx.fillStyle = hudColor;
                    ctx.font = `${16 / scale}px 'Courier New'`;
                    ctx.fillText(i, -60, y + 5);
                }
            }

            // Pointer
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(30 / scale, -10 / scale);
            ctx.lineTo(30 / scale, 10 / scale);
            ctx.closePath();
            ctx.fillStyle = hudColor;
            ctx.fill();

            ctx.restore();
        }

        function drawAltitude() {
            const altitude = position.alt;
            ctx.save();
            ctx.translate(width / 2 / scale - 100, 0);

            // Tape
            ctx.strokeStyle = hudColor;
            ctx.lineWidth = 2 / scale;
            ctx.beginPath();
            ctx.moveTo(0, -200);
            ctx.lineTo(0, 200);
            ctx.stroke();

            // Ticks
            for (let i = Math.floor(altitude / 100) * 100 - 500; i <= Math.floor(altitude / 100) * 100 + 500; i += 100) {
                const y = (altitude - i) * 0.5;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(20, y);
                ctx.stroke();
                ctx.fillStyle = hudColor;
                ctx.font = `${16 / scale}px 'Courier New'`;
                ctx.fillText(i, 30, y + 5);
            }

            // Pointer
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-30 / scale, -10 / scale);
            ctx.lineTo(-30 / scale, 10 / scale);
            ctx.closePath();
            ctx.fillStyle = hudColor;
            ctx.fill();

            ctx.restore();
        }

        function drawHeading() {
            const heading = orientation.alpha;
            ctx.save();
            ctx.translate(0, height / 2 / scale - 100);

            // Tape
            ctx.strokeStyle = hudColor;
            ctx.lineWidth = 2 / scale;
            ctx.beginPath();
            ctx.moveTo(-200, 0);
            ctx.lineTo(200, 0);
            ctx.stroke();

            // Ticks
            for (let i = Math.floor(heading / 10) * 10 - 50; i <= Math.floor(heading / 10) * 10 + 50; i += 10) {
                const x = (heading - i) * 5;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 20);
                ctx.stroke();
                if (i % 30 === 0) {
                    ctx.fillStyle = hudColor;
                    ctx.font = `${16 / scale}px 'Courier New'`;
                    ctx.fillText(i, x - 10, 40);
                }
            }

            // Pointer
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10 / scale, 30 / scale);
            ctx.lineTo(10 / scale, 30 / scale);
            ctx.closePath();
            ctx.fillStyle = hudColor;
            ctx.fill();

            ctx.restore();
        }

        function drawData() {
            ctx.fillStyle = hudColor;
            ctx.font = `${16 / scale}px 'Courier New'`;
            ctx.fillText(`SPD: ${Math.round(position.speed * 3.6)} km/h`, -width / 2 / scale + 20, -height / 2 / scale + 40);
            ctx.fillText(`ALT: ${Math.round(position.alt)} m`, width / 2 / scale - 100, -height / 2 / scale + 40);
            ctx.fillText(`HDG: ${Math.round(orientation.alpha)}°`, -50, height / 2 / scale - 120);
            ctx.fillText(`PITCH: ${Math.round(orientation.beta)}°`, -width / 2 / scale + 20, height / 2 / scale - 40);
            ctx.fillText(`ROLL: ${Math.round(orientation.gamma)}°`, width / 2 / scale - 100, height / 2 / scale - 40);
        }

        // Sensor handlers
        function handlePosition(pos) {
            const coords = pos.coords;
            position.lat = coords.latitude;
            position.lon = coords.longitude;
            position.alt = coords.altitude || 0;
            if (lastPosition) {
                const distance = getDistance(lastPosition.lat, lastPosition.lon, position.lat, position.lon);
                const timeDiff = (Date.now() - lastTime) / 1000;
                position.speed = distance / timeDiff;
            }
            lastPosition = { lat: position.lat, lon: position.lon };
            lastTime = Date.now();
        }

        function handleOrientation(event) {
            orientation.alpha = event.alpha; // heading
            orientation.beta = event.beta; // pitch
            orientation.gamma = event.gamma; // roll
        }

        function handleMotion(event) {
            motion.acceleration = event.acceleration;
            motion.rotationRate = event.rotationRate;
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Initialize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Request permissions and start sensors
        if (navigator.geolocation) {
            navigator.geolocation.watchPosition(handlePosition, console.error, { enableHighAccuracy: true });
        }

        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', handleOrientation);
        }

        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', handleMotion);
        }

        // Animation loop
        function animate() {
            drawHUD();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
