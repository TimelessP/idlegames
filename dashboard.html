<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Mobile Aircraft Dashboard</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1724;
      --glass:rgba(255,255,255,0.06);
      --accent:#ffcc00;
      --muted:#94a3b8;
      --size:100vmin; /* base scaling reference */
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;}
    .wrap{
      display:grid;
      grid-template-columns:1fr 1fr;
      grid-template-rows:1fr 1fr;
      gap:0.6vmin;
      height:100vh;
      padding:1vmin;
      box-sizing:border-box;
    }
    /* make single column on narrow screens */
    @media (max-width:700px){
      .wrap{grid-template-columns:1fr;grid-template-rows:repeat(4,1fr);}
    }
    .instrument{
      background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent 60%);
      border-radius:1.6vmin;
      padding:1vmin;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.04);
    }
    /* Make instruments scale by container size */
    .face{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .gauge{
      --gsize:calc(min(40vmin,35vmin));
      width:var(--gsize);
      height:var(--gsize);
      max-width:100%;
      max-height:100%;
      position:relative;
      transform-origin:center center;
    }
    /* Attitude indicator */
    .attitude .gauge{background:linear-gradient(#07101a,#05202b);border-radius:50%;box-shadow:0 6px 18px rgba(0,0,0,0.6);border:2px solid rgba(255,255,255,0.06);}
    .attitude .horizon{
      position:absolute;left:50%;top:50%;width:200%;height:200%;transform:translate(-50%,-50%) rotate(0deg);transform-origin:center center;overflow:visible;border-radius:50%;
    }
    .horizon .sky{position:absolute;left:0;right:0;top:0;height:50%;background:linear-gradient(#48a9ff,#1a6fb3);}
    .horizon .ground{position:absolute;left:0;right:0;bottom:0;height:50%;background:linear-gradient(#9b6b3b,#6b3b2a);}
    .horizon .bank-ticks{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:100%;height:100%;pointer-events:none}
    .attitude .fixed {
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:90%;height:90%;pointer-events:none;display:flex;align-items:center;justify-content:center;
    }
    .fixed .aircraft{
      width:70%;height:0;border-top:2px solid #fff;display:block;position:relative;}
    .fixed .aircraft:before{content:'';position:absolute;left:50%;top:-6px;width:2px;height:12px;background:#fff;transform:translateX(-50%)}
    /* HUD overlay inside attitude */
    .attitude .hud{position:absolute;left:50%;top:8%;transform:translateX(-50%);width:86%;text-align:center;pointer-events:none;display:flex;flex-direction:column;gap:0.6vmin;align-items:center}
    .attitude .hud .hud-line{font-weight:700;color:var(--accent);font-size:calc(var(--gsize) * 0.06)}
    .attitude .hud .hud-small{font-weight:600;color:var(--muted);font-size:calc(var(--gsize) * 0.038)}
  /* heading tape in HUD */
  .attitude .hud .heading-tape{position:relative;overflow:hidden;width:100%;height:calc(var(--gsize) * 0.07);display:flex;align-items:center;justify-content:center}
  .attitude .hud .tape-track{display:flex;align-items:center;transition:transform .08s linear}
  .attitude .hud .tape-tick{min-width:6vmin;text-align:center;font-weight:700;color:var(--accent);padding:0 1vmin}
  /* HUD overlay inside attitude */
  .attitude .hud{position:absolute;left:50%;top:8%;transform:translateX(-50%);width:86%;text-align:center;pointer-events:none;display:flex;flex-direction:column;gap:0.6vmin;align-items:center}
  .attitude .hud .hud-line{font-weight:700;color:var(--accent);font-size:calc(var(--gsize) * 0.06)}
  .attitude .hud .hud-small{font-weight:600;color:var(--muted);font-size:calc(var(--gsize) * 0.038)}
    /* heading indicator */
    .heading .gauge{background:radial-gradient(circle at 30% 20%,rgba(255,255,255,0.03),transparent 20%),#06111a;border-radius:12px;padding:6vmin;color:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.6);}
    .compass{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    .compass .card{position:relative;width:90%;height:42%;overflow:hidden}
    .compass .scale{display:flex;transform:translateX(0);transition:transform .1s linear}
    .tick{min-width:6vmin;text-align:center;font-weight:600;color:var(--muted);}
    .heading .label{position:absolute;left:50%;top:60%;transform:translateX(-50%);font-size:3.2vmin;color:var(--accent);font-weight:700}
    /* turn coordinator */
    .turn .gauge{background:linear-gradient(180deg,#081018,#031018);border-radius:12px;padding:2vmin;display:flex;align-items:center;justify-content:center}
    .turn .ball{width:70%;height:18%;background:linear-gradient(#111,#222);border-radius:4vmin;position:relative;overflow:visible}
    .turn .needle{position:absolute;left:50%;top:25%;width:2px;height:60%;background:var(--accent);transform-origin:50% 80%;transform:translateX(-50%) rotate(0deg)}
    /* altimeter/vs */
    .alt .gauge{background:linear-gradient(180deg,#061018,#041018);border-radius:12px;padding:2vmin;display:flex;align-items:center;justify-content:center;color:var(--muted);}
    .alt .readout{font-weight:700;color:#fff}
    /* responsive font scaling inside gauges */
    .gauge *{box-sizing:border-box}
    .label-large{font-size:calc(var(--gsize) * 0.08);}
    .label-small{font-size:calc(var(--gsize) * 0.045);color:var(--muted)}
    /* subtle glass top */
    .instrument:after{content:'';position:absolute;left:0;top:0;right:0;height:40%;background:linear-gradient(180deg,rgba(255,255,255,0.04),transparent);pointer-events:none;border-top-left-radius:1.6vmin;border-top-right-radius:1.6vmin}
    /* small footer instructions */
    .help{position:fixed;left:50%;bottom:1vmin;transform:translateX(-50%);color:var(--muted);font-size:3.2vmin;padding:0.6vmin 1.2vmin;background:rgba(255,255,255,0.02);border-radius:1vmin}
  </style>
</head>
<body>
  <div class="wrap">
    <section class="instrument attitude" id="attitude">
      <div class="face">
        <div class="gauge" id="att-gauge" aria-label="Attitude Indicator">
          <div class="horizon" id="horizon">
            <div class="sky"></div>
            <div class="ground"></div>
            <div class="pitch-ladder" id="pitch-ladder" aria-hidden="true"></div>
            <svg class="bank-ticks" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
              <g transform="translate(100,100)">
                <!-- ticks at -60 -45 -30 -15 0 15 30 45 60 degrees -->
                <g id="ticks">
                  <g transform="rotate(-60)"><line x1="0" y1="-70" x2="0" y2="-84" stroke="#fff" stroke-width="1.8"/></g>
                  <g transform="rotate(-45)"><line x1="0" y1="-70" x2="0" y2="-80" stroke="#fff" stroke-width="1.6"/></g>
                  <g transform="rotate(-30)"><line x1="0" y1="-70" x2="0" y2="-80" stroke="#fff" stroke-width="1.6"/></g>
                  <g transform="rotate(-15)"><line x1="0" y1="-70" x2="0" y2="-76" stroke="#fff" stroke-width="1.4"/></g>
                  <g transform="rotate(0)"><line x1="0" y1="-70" x2="0" y2="-62" stroke="#fff" stroke-width="2"/></g>
                  <g transform="rotate(15)"><line x1="0" y1="-70" x2="0" y2="-76" stroke="#fff" stroke-width="1.4"/></g>
                  <g transform="rotate(30)"><line x1="0" y1="-70" x2="0" y2="-80" stroke="#fff" stroke-width="1.6"/></g>
                  <g transform="rotate(45)"><line x1="0" y1="-70" x2="0" y2="-80" stroke="#fff" stroke-width="1.6"/></g>
                  <g transform="rotate(60)"><line x1="0" y1="-70" x2="0" y2="-84" stroke="#fff" stroke-width="1.8"/></g>
                </g>
              </g>
            </svg>
          </div>
          <div class="fixed">
            <div class="aircraft"></div>
            <div class="hud" id="att-hud">
              <div class="hud-line" id="hud-alt">ALT: -- m</div>
              <div class="hud-line" id="hud-gs">GS: -- m/s</div>
              <div class="heading-tape" id="hud-heading-tape"><div class="tape-track" id="hud-tape-track"></div></div>
              <div class="hud-small" id="hud-pitch-roll">P: --°  R: --°</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="instrument heading" id="heading">
      <div class="face">
        <div class="gauge" id="head-gauge" aria-label="Heading Indicator">
          <div class="compass">
            <div class="card">
              <div class="scale" id="compass-scale">
                <!-- generate ticks in JS -->
              </div>
            </div>
            <div class="label" id="heading-label">HDG 000°</div>
          </div>
        </div>
      </div>
    </section>

    <section class="instrument turn" id="turn">
      <div class="face">
        <div class="gauge" id="turn-gauge" aria-label="Turn Coordinator">
          <div style="position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center;">
            <div class="ball" id="turn-ball"></div>
            <div class="needle" id="turn-needle"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="instrument alt" id="altimeter">
      <div class="face">
        <div class="gauge" id="alt-gauge" aria-label="Altimeter and Vertical Speed">
          <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;width:100%">
            <div class="label-large" id="alt-readout">ALT: -- m</div>
            <div class="label-small" id="vs-readout">VS: -- m/s</div>
            <div class="label-small" id="acc-readout">ACC: --</div>
            <div class="label-small" id="gs-readout">GS: -- m/s</div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div class="help">Tap to request sensors. Rotate phone to see instruments react.</div>

  <script>
    // Simple contract
    // Inputs: deviceorientation (alpha,beta,gamma), devicemotion (acceleration), geolocation (optional)
    // Outputs: DOM transforms and text updates for 4 instruments
    // Error modes: sensors unavailable or permission denied -> user-friendly fallbacks

    (function(){
      // Helpers
      const $ = (s) => document.querySelector(s);
      const attGauge = $('#att-gauge');
      const horizon = $('#horizon');
      const compassScale = $('#compass-scale');
      const headingLabel = $('#heading-label');
      const turnNeedle = $('#turn-needle');
      const turnBall = $('#turn-ball');
  const altReadout = $('#alt-readout');
  const vsReadout = $('#vs-readout');
  const accReadout = $('#acc-readout');
  const gsReadout = $('#gs-readout');
  const hudAlt = $('#hud-alt');
  const hudGs = $('#hud-gs');
  const hudPR = $('#hud-pitch-roll');
  const pitchLadder = $('#pitch-ladder');
  const hudTape = $('#hud-tape-track');

      // Build compass ticks
      function buildCompass(){
        const labels = ['N','30','60','E','120','150','S','210','240','W','300','330'];
        compassScale.innerHTML='';
        for(let i=0;i<labels.length;i++){
          const tick = document.createElement('div');
          tick.className='tick';
          tick.style.padding='0 1vmin';
          tick.textContent = labels[i];
          compassScale.appendChild(tick);
        }
        // build HUD tape with same labels
        if(hudTape){
          hudTape.innerHTML = '';
          for(let i=0;i<labels.length;i++){
            const t = document.createElement('div');
            t.className = 'tape-tick';
            t.textContent = labels[i];
            hudTape.appendChild(t);
          }
          // duplicate once for smooth wrap
          for(let i=0;i<labels.length;i++){
            const t = hudTape.children[i].cloneNode(true);
            hudTape.appendChild(t);
          }
        }
      }
      buildCompass();

      // scale gauge sizes responsively (font scaling)
      function updateSizes(){
        document.querySelectorAll('.gauge').forEach(g=>{
          const rect = g.getBoundingClientRect();
          g.style.setProperty('--gsize', Math.min(rect.width, rect.height) + 'px');
        });
      }
      window.addEventListener('resize', updateSizes);
      window.addEventListener('orientationchange', ()=>{setTimeout(updateSizes,300)});
      updateSizes();

      // initial state
      let lastAlpha = 0;
      let permissionsGranted = false;

      // mapping functions
      function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

      function setAttitude(roll, pitch){
        // roll degrees -> rotate horizon opposite direction for cockpit
        // pitch moves horizon vertically
        const rollDeg = clamp(roll, -90, 90);
        const pitchDeg = clamp(pitch, -60, 60); // limit
        // compute pixel scale based on gauge size
        const gauge = document.getElementById('att-gauge');
        const rect = gauge.getBoundingClientRect();
        const gsize = Math.min(rect.width, rect.height);
        const pxPerDeg = (gsize * 0.9) / 90; // roughly map 90 deg span to gauge
        const pitchPx = pitchDeg * pxPerDeg;
        // rotate the horizon (opposite roll) and translate for pitch
        horizon.style.transform = `translate(-50%,-50%) rotate(${ -rollDeg }deg) translateY(${ pitchPx }px)`;
        // move ladder lines so they appear at correct pitch relative to center
        pitchLadder.style.left = '50%';
        pitchLadder.style.top = '50%';
        pitchLadder.style.transform = `translate(-50%, ${ -pitchPx }px)`;
      }

      // Build pitch ladder marks (every 5 degrees)
      function buildPitchLadder(){
        pitchLadder.innerHTML = '';
        const gauge = document.getElementById('att-gauge');
        const rect = gauge.getBoundingClientRect();
        const gsize = Math.min(rect.width, rect.height) || Math.min(window.innerWidth, window.innerHeight);
        const pxPerDeg = (gsize * 0.9) / 90;
        for(let p=-60;p<=60;p+=5){
          const el = document.createElement('div');
          el.style.position = 'absolute';
          el.style.left = '50%';
          const y = 0 + ( -p * pxPerDeg );
          el.style.transform = `translateX(-50%) translateY(${y}px)`;
          el.style.width = '80%';
          el.style.textAlign = 'center';
          el.style.color = p===0 ? '#fff' : 'rgba(255,255,255,0.9)';
          el.style.fontSize = 'calc(var(--gsize) * 0.035)';
          if(p===0){
            el.innerHTML = '<span style="display:block;border-top:2px solid rgba(255,255,255,0.9);width:60%;margin:0 auto;height:0"></span>';
          } else {
            el.textContent = `${Math.abs(p)}°`;
          }
          pitchLadder.appendChild(el);
        }
      }
      // initial ladder build
      setTimeout(buildPitchLadder,100);

      function setHeading(alpha){
        // alpha is compass heading (0..360) clockwise from north
        const deg = (360 - alpha) % 360; // rotate scale left as heading increases
        const pxPerDeg = 0.9; // tune for main compass
        const offset = deg * pxPerDeg; // px shift
        compassScale.style.transform = `translateX(${-offset}px)`;
        headingLabel.textContent = 'HDG ' + String(Math.round(alpha)).padStart(3,'0') + '°';
        // HUD tape movement: center the HUD tape so labels scroll under center
        if(hudTape){
          const hudPxPerDeg = 6; // visual tuning for HUD tape (px per deg)
          const hudOffset = deg * hudPxPerDeg;
          hudTape.style.transform = `translateX(${-hudOffset}px)`;
        }
      }

      function setTurn(rate){
        // rate: gamma or rotationRate.alpha; map to needle roll
        const max = 60; // degrees
        const r = clamp(rate, -max, max);
        turnNeedle.style.transform = `translateX(-50%) rotate(${r}deg)`;
        // ball shows slip/slide from lateral acceleration
      }

      function setBall(accX){
        // accX lateral acceleration -> translate ball horizontally
        const max = 9.81; // 1g
        const t = clamp(accX / max, -1, 1) * 40; // px
        turnBall.style.transform = `translateX(${t}px)`;
      }

      // device sensors
      async function requestSensors(){
        // Modern iOS requires permission for DeviceMotion/Orientation
        try{
          // handle iOS 13+ request
          if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
            const r = await DeviceMotionEvent.requestPermission();
            if(r !== 'granted') throw new Error('devicemotion permission denied');
          }
          if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
            const r2 = await DeviceOrientationEvent.requestPermission();
            if(r2 !== 'granted') throw new Error('deviceorientation permission denied');
          }
          permissionsGranted = true;
        }catch(err){
          permissionsGranted = false;
          console.log('permission error',err);
        }

        // add listeners whether or not permission is a thing
        window.addEventListener('deviceorientation', handleOrientation);
        window.addEventListener('devicemotion', handleMotion);
        // request geolocation watch
        if('geolocation' in navigator){
          try{
            startGeoWatch();
          }catch(e){
            console.log('geo watch failed', e);
          }
        }
      }

      // Geo speed calculation
      let lastPos = null;
      let gs = 0; // m/s smoothed
      let geoWatchId = null;
      function haversine(lat1,lon1,lat2,lon2){
        const R = 6371000; // meters
        const toRad = v => v*Math.PI/180;
        const dLat = toRad(lat2-lat1);
        const dLon = toRad(lon2-lon1);
        const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)*Math.sin(dLon/2);
        const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R*c;
      }

      function startGeoWatch(){
        if(geoWatchId != null) return;
        geoWatchId = navigator.geolocation.watchPosition(pos=>{
          const now = pos.timestamp || Date.now();
          const {latitude, longitude} = pos.coords;
          if(lastPos){
            const dt = Math.max((now - lastPos.t)/1000, 0.001);
            const d = haversine(lastPos.lat, lastPos.lon, latitude, longitude);
            const inst = d / dt; // m/s
            // smooth with EMA
            const alpha = 0.25;
            gs = gs * (1-alpha) + inst * alpha;
            gsReadout.textContent = `GS: ${gs.toFixed(2)} m/s`;
          }
          lastPos = {lat: latitude, lon: longitude, t: now};
        }, err=>{
          console.log('geo error',err);
          gsReadout.textContent = 'GS: n/a';
        }, {enableHighAccuracy:true, maximumAge:1000, timeout:5000});
      }

  function handleOrientation(ev){
        // alpha: 0..360 heading
        // beta: -180..180 front-to-back (pitch)
        // gamma: -90..90 left-to-right (roll)
        const alpha = ev.alpha ?? lastAlpha;
        const pitch = ev.beta ?? 0; // positive nose up on some devices
        const roll = ev.gamma ?? 0; // tilt right positive
  // Some devices use different sign conventions; compensate by allowing a toggle via tap
  setAttitude(roll, pitch);
  setHeading(alpha);
  // update HUD pitch/roll
  if(hudPR) hudPR.textContent = `P: ${pitch.toFixed(1)}°  R: ${roll.toFixed(1)}°`;
  lastAlpha = alpha || lastAlpha;
      }

      let lastMotion = {acc:{x:0,y:0,z:0}, rot:{alpha:0,beta:0,gamma:0}};
      function handleMotion(ev){
        const acc = ev.accelerationIncludingGravity || ev.acceleration || {x:0,y:0,z:0};
        const rot = ev.rotationRate || {alpha:0,beta:0,gamma:0};
        // use gamma rotationRate as turn rate
        setTurn(rot.gamma || 0);
        setBall(acc.x || 0);
        // vertical speed approx from z acceleration integration (very rough)
        // integrate acceleration z for a tiny velocity estimate
        const dt = (ev.interval || 0.02);
  // keep a simple low-pass for vertical velocity and integrate to get altitude (very rough)
  lastMotion.vz = (lastMotion.vz || 0) + (-(acc.z||0)) * dt; // sign adjust (device axes vary)
  lastMotion.vz *= 0.98;
  lastMotion.altitude = (lastMotion.altitude || 0) + lastMotion.vz * dt;
  altReadout.textContent = `ALT: ${Math.round(lastMotion.altitude)} m`;
  if(hudAlt) hudAlt.textContent = `ALT: ${Math.round(lastMotion.altitude)} m`;
  vsReadout.textContent = `VS: ${ (lastMotion.vz).toFixed(2) } m/s`;
  accReadout.textContent = `ACC: x:${(acc.x||0).toFixed(2)} y:${(acc.y||0).toFixed(2)} z:${(acc.z||0).toFixed(2)}`;
      }

      // request on first user interaction
      function initOnFirstTouch(){
        const once = async ()=>{
          await requestSensors();
          window.removeEventListener('touchstart',once);
          window.removeEventListener('click',once);
        };
        window.addEventListener('touchstart',once,{passive:true});
        window.addEventListener('click',once,{passive:true});
      }
      initOnFirstTouch();

      // fallback: try Geolocation for heading approximate using movement? We'll just display not available
      // Provide a manual heading control for desktops
      (function(){
        if(!('DeviceOrientationEvent' in window)){
          // enable mouse drag to rotate heading for testing
          let dragging=false;let startX=0;let cur=0;
          window.addEventListener('mousedown',e=>{dragging=true;startX=e.clientX});
          window.addEventListener('mouseup',()=>dragging=false);
          window.addEventListener('mousemove',e=>{if(!dragging) return; const dx = e.clientX - startX; cur += dx * 0.2; startX = e.clientX; setHeading((cur%360+360)%360)});
        }
      })();

      // Quality: try to progressively enhance layout when resizing
      setTimeout(updateSizes,200);

      // Mark todo item 2 as in-progress before finishing
    })();
  </script>
</body>
</html>
