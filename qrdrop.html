<!DOCTYPE html>
<html lang="en" data-theme="system">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QR Drop - Text Sharing via QR Codes</title>
  <meta name="description" content="Simple text sharing between devices using QR codes" />
  <meta name="color-scheme" content="light dark" />
  <link rel="icon" href="favicon.ico" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      color: #333;
      line-height: 1.6;
      min-height: 100vh;
    }
    
    @media (prefers-color-scheme: dark) {
      body {
        background: #1a1a1a;
        color: #e0e0e0;
      }
    }
    
    .container {
      max-width: 100%;
      margin: 0 auto;
      /* background: white; */
      border-radius: 0;
      padding: 0;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    
    @media (prefers-color-scheme: dark) {
      .container {
        background: #2a2a2a;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
    }
    
    .header {
      text-align: center;
      margin-bottom: 40px;
    }
    
    .header h1 {
      margin: 0;
      font-size: 2.5rem;
      font-weight: 300;
      color: #0066cc;
    }
    
    .header p {
      margin: 10px 0 0;
      opacity: 0.7;
      font-size: 1.1rem;
    }
    
    .main-area {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }
    
    @media (max-width: 768px) {
      .main-area {
        grid-template-columns: 1fr;
        gap: 20px;
      }
    }
    
    .panel {
      /* border: 2px solid #e0e0e0; */
      border: 0;
      border-radius: 0px;
      padding: 0;
      text-align: center;
    }
    
    @media (prefers-color-scheme: dark) {
      .panel {
        border-color: #404040;
      }
    }
    
    .panel h2 {
      margin-top: 0;
      font-size: 1.4rem;
      color: #0066cc;
      margin-bottom: 20px;
    }
    
    .text-input {
      width: 100%;
      min-height: 150px;
      padding: 15px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
      background: white;
      color: #333;
    }
    
    @media (prefers-color-scheme: dark) {
      .text-input {
        background: #333;
        color: #e0e0e0;
        border-color: #555;
      }
    }
    
    .text-input:focus {
      outline: none;
      border-color: #0066cc;
      box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
    }
    
    .qr-display {
      min-height: 300px;
      background: #f9f9f9;
      border: 2px dashed #ccc;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      object-fit: contain;
      margin: 0;
      padding: 4%;
    }
    
    @media (prefers-color-scheme: dark) {
      .qr-display {
        background: #333;
        border-color: #555;
      }
    }
    
    .qr-display canvas {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      border-radius: 8px;
      background: white;
      /* Remove padding to maximize QR code size */
      /* Scale up the QR code to fill more of the panel */
      min-width: 92%;
      min-height: 92%;
      object-fit: contain;
      /* Disable anti-aliasing for crisp preview */
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges; 
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    .camera-view {
      position: relative;
      min-height: 300px;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      margin: 20px 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    
    .camera-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      border: 3px solid #00ff00;
      border-radius: 12px;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }
    
    .camera-overlay::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      border: 2px solid rgba(0, 255, 0, 0.2);
      border-radius: 15px;
    }
    
    .controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .control-row {
      display: flex;
      gap: 10px;
    }
    
    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #0066cc;
      color: white;
      flex: 1;
    }
    
    .btn:hover:not(:disabled) {
      background: #0052a3;
      transform: translateY(-1px);
    }
    
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      opacity: 0.6;
    }
    
    .btn.secondary {
      background: #6c757d;
    }
    
    .btn.secondary:hover:not(:disabled) {
      background: #545b62;
    }
    
    .btn.success {
      background: #28a745;
    }
    
    .btn.success:hover:not(:disabled) {
      background: #218838;
    }
    
    .status {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #0066cc;
      background: rgba(0, 102, 204, 0.1);
      font-size: 14px;
    }
    
    .status.error {
      border-color: #dc3545;
      background: rgba(220, 53, 69, 0.1);
      color: #dc3545;
    }
    
    .status.success {
      border-color: #28a745;
      background: rgba(40, 167, 69, 0.1);
      color: #28a745;
    }
    
    .status.warning {
      border-color: #ffc107;
      background: rgba(255, 193, 7, 0.1);
      color: #856404;
    }
    
    .hidden {
      display: none !important;
    }
    
    .char-counter {
      text-align: right;
      font-size: 12px;
      opacity: 0.7;
      margin-top: 5px;
    }
    
    .camera-status {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 20;
    }
    
    /* Fullscreen QR Modal */
    .qr-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    
    .qr-modal.active {
      display: flex;
    }
    
    .qr-modal-content {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    
    .qr-modal canvas {
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      /* Scale to fit the smallest dimension of the client area */
      width: min(90vw, 90vh);
      height: min(90vw, 90vh);
      /* Disable anti-aliasing for crisp QR code pixels */
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    .qr-modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      pointer-events: auto;
      z-index: 10001;
    }
    
    .qr-modal-close:hover {
      background: rgba(255, 255, 255, 1);
      transform: scale(1.1);
    }
    
    .qr-modal-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      pointer-events: none;
      animation: fadeInUp 0.5s ease;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    
    /* Mobile-specific adjustments for fullscreen QR */
    @media (max-width: 768px) {
      .qr-modal-content {
        max-width: 95vw;
        max-height: 95vh;
      }
      
      .qr-modal-close {
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
      
      .qr-modal-hint {
        bottom: 10px;
        font-size: 13px;
        padding: 6px 12px;
      }
    }
    
    /* Ensure QR display canvas is clickable */
    .qr-display canvas {
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    
    .qr-display canvas:hover {
      transform: scale(1.05);
    }
    
    /* File input styles */
    .filename-input {
      flex: 2;
      padding: 12px 15px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 14px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      background: white;
      color: #333;
    }
    
    @media (prefers-color-scheme: dark) {
      .filename-input {
        background: #333;
        color: #e0e0e0;
        border-color: #555;
      }
    }
    
    .filename-input:focus {
      outline: none;
      border-color: #0066cc;
      box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
    }
    
    .filename-input::placeholder {
      opacity: 0.6;
    }
  </style>
  
  <!-- QR Code Libraries -->
  <script>
    const loadScript = (src, fallback) => {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = () => {
          if (fallback) {
            const fallbackScript = document.createElement('script');
            fallbackScript.src = fallback;
            fallbackScript.onload = resolve;
            fallbackScript.onerror = reject;
            document.head.appendChild(fallbackScript);
          } else {
            reject();
          }
        };
        document.head.appendChild(script);
      });
    };

    // Load QRious for generation
    Promise.resolve()
      .then(() => loadScript('https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js'))
      .catch(() => loadScript('https://unpkg.com/qrious@4.0.2/dist/qrious.min.js'))
      .catch(() => {
        console.warn('QRious CDNs failed');
        window.QRious = class {
          constructor(options = {}) {
            this.element = options.element;
            this.value = options.value || '';
            this.size = options.size || 100;
            this._generateStub();
          }
          
          set(options) {
            Object.assign(this, options);
            this._generateStub();
          }
          
          _generateStub() {
            if (this.element) {
              const ctx = this.element.getContext('2d');
              ctx.fillStyle = '#fff';
              ctx.fillRect(0, 0, this.size, this.size);
              ctx.fillStyle = '#000';
              ctx.font = '14px monospace';
              ctx.textAlign = 'center';
              ctx.fillText('QR Generation', this.size/2, this.size/2 - 10);
              ctx.fillText('Not Available', this.size/2, this.size/2 + 10);
            }
          }
        };
      });

    // Load jsQR for scanning  
    Promise.resolve()
      .then(() => loadScript('https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js'))
      .catch(() => loadScript('https://unpkg.com/jsqr@1.4.0/dist/jsQR.js'))
      .catch(() => {
        console.warn('jsQR CDNs failed');
      });
  </script>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>QR Drop</h1>
      <p>Share text between devices using QR codes</p>
    </header>

    <div class="main-area">
      <!-- Send Panel -->
      <div class="panel">
        <h2>üì§ Send Text</h2>
        <textarea 
          id="sendText" 
          class="text-input" 
          placeholder="Enter text to share via QR code...
          
Examples:
‚Ä¢ Meeting notes
‚Ä¢ Contact information  
‚Ä¢ WiFi password
‚Ä¢ Website URLs
‚Ä¢ Shopping lists
‚Ä¢ Quick messages"
        ></textarea>
        <div class="char-counter">
          <span id="charCount">0</span> characters
        </div>
        <div class="qr-display" id="qrDisplay">
          <div style="opacity: 0.5; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 10px;">üì±</div>
            <div>QR Code will appear here</div>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">Enter text above and click Send</div>
          </div>
        </div>
        <div class="controls">
          <button class="btn" id="generateQR">üì± Generate QR Code</button>
          <div class="control-row">
            <button class="btn secondary" id="clearSend">üóëÔ∏è Clear</button>
            <button class="btn secondary" id="copyText" disabled>üìã Copy Text</button>
          </div>
          <div class="control-row">
            <input type="file" id="fileInput" accept="*.*" style="display: none;" />
            <button class="btn secondary" id="loadFile">üìÅ Load from File</button>
          </div>
        </div>
      </div>

      <!-- Receive Panel -->
      <div class="panel">
        <h2>üì• Receive Text</h2>
        <div class="camera-view">
          <video id="video" autoplay muted playsinline></video>
          <div class="camera-overlay"></div>
          <div class="camera-status hidden" id="cameraStatus">Camera: Off</div>
        </div>
        <textarea 
          id="receiveText" 
          class="text-input" 
          placeholder="Scanned text will appear here...

You can also manually paste text here if needed."
          readonly
        ></textarea>
        <div class="controls">
          <button class="btn success" id="startCamera">üì∑ Start Camera</button>
          <div class="control-row">
            <button class="btn secondary" id="useBackCamera" disabled>üì∑ Back</button>
            <button class="btn secondary" id="useFrontCamera" disabled>ü§≥ Front</button>
          </div>
          <button class="btn secondary" id="stopCamera" disabled>‚èπÔ∏è Stop Camera</button>
          <div class="control-row">
            <button class="btn secondary" id="clearReceive">üóëÔ∏è Clear</button>
            <button class="btn secondary" id="copyReceived" disabled>üìã Copy</button>
          </div>
          <div class="control-row">
            <input type="text" id="filenameInput" placeholder="filename.txt" class="filename-input" />
            <button class="btn secondary" id="saveFile" disabled>üíæ Save as File</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Status Messages -->
    <div class="status hidden" id="status">
      Ready to share text via QR codes
    </div>
  </div>
  
  <!-- Fullscreen QR Modal -->
  <div class="qr-modal" id="qrModal" role="dialog" aria-label="Fullscreen QR Code">
    <button class="qr-modal-close" id="qrModalClose" aria-label="Close fullscreen">√ó</button>
    <div class="qr-modal-content" id="qrModalContent">
      <!-- QR code canvas will be inserted here -->
    </div>
    <div class="qr-modal-hint">Tap anywhere to close</div>
  </div>

  <script>
    class QRDrop {
      constructor() {
        this.video = null;
        this.stream = null;
        this.scanning = false;
        this.lastDetectedText = null;
        this.lastDetectionTime = 0;
        this.detectionCooldown = 2000; // 2 seconds
        this.currentFacingMode = null;
        
        this.initializeElements();
        this.setupEventHandlers();
        this.updateUI();
      }
      
      initializeElements() {
        this.elements = {
          sendText: document.getElementById('sendText'),
          receiveText: document.getElementById('receiveText'),
          qrDisplay: document.getElementById('qrDisplay'),
          video: document.getElementById('video'),
          charCount: document.getElementById('charCount'),
          cameraStatus: document.getElementById('cameraStatus'),
          status: document.getElementById('status'),
          
          generateQR: document.getElementById('generateQR'),
          clearSend: document.getElementById('clearSend'),
          copyText: document.getElementById('copyText'),
          loadFile: document.getElementById('loadFile'),
          fileInput: document.getElementById('fileInput'),
          startCamera: document.getElementById('startCamera'),
          useBackCamera: document.getElementById('useBackCamera'),
          useFrontCamera: document.getElementById('useFrontCamera'),
          stopCamera: document.getElementById('stopCamera'),
          clearReceive: document.getElementById('clearReceive'),
          copyReceived: document.getElementById('copyReceived'),
          filenameInput: document.getElementById('filenameInput'),
          saveFile: document.getElementById('saveFile'),
          
          qrModal: document.getElementById('qrModal'),
          qrModalClose: document.getElementById('qrModalClose'),
          qrModalContent: document.getElementById('qrModalContent')
        };
      }
      
      setupEventHandlers() {
        // Text input handlers
        this.elements.sendText.addEventListener('input', () => {
          this.updateCharCount();
          this.updateUI();
        });
        
        this.elements.receiveText.addEventListener('input', () => {
          this.updateUI();
        });
        
        // Send panel handlers
        this.elements.generateQR.addEventListener('click', () => {
          this.generateQRCode();
        });
        
        this.elements.clearSend.addEventListener('click', () => {
          this.elements.sendText.value = '';
          this.clearQRDisplay();
          this.updateCharCount();
          this.updateUI();
          this.showStatus('Send text cleared', 'success');
        });
        
        this.elements.copyText.addEventListener('click', () => {
          this.copyToClipboard(this.elements.sendText.value, 'Send text copied to clipboard');
        });
        
        // File load handlers
        this.elements.loadFile.addEventListener('click', () => {
          this.elements.fileInput.click();
        });
        
        this.elements.fileInput.addEventListener('change', (e) => {
          this.loadFromFile(e.target.files[0]);
        });
        
        // Camera handlers
        this.elements.startCamera.addEventListener('click', () => {
          this.startCamera();
        });
        
        this.elements.useBackCamera.addEventListener('click', () => {
          this.switchCamera('environment');
        });
        
        this.elements.useFrontCamera.addEventListener('click', () => {
          this.switchCamera('user');
        });
        
        this.elements.stopCamera.addEventListener('click', () => {
          this.stopCamera();
        });
        
        // Receive panel handlers
        this.elements.clearReceive.addEventListener('click', () => {
          this.elements.receiveText.value = '';
          this.updateUI();
          this.showStatus('Received text cleared', 'success');
        });
        
        this.elements.copyReceived.addEventListener('click', () => {
          this.copyToClipboard(this.elements.receiveText.value, 'Received text copied to clipboard');
        });
        
        // File save handlers
        this.elements.saveFile.addEventListener('click', () => {
          this.saveToFile();
        });
        
        this.elements.filenameInput.addEventListener('input', () => {
          this.updateUI();
        });
        
        this.elements.filenameInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !this.elements.saveFile.disabled) {
            this.saveToFile();
          }
        });
        
        // QR Modal handlers
        this.elements.qrModal.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeQRModal();
        });
        
        this.elements.qrModalClose.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeQRModal();
        });
        
        // Prevent modal close when clicking the QR content itself
        this.elements.qrModalContent.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        // Keyboard handler for modal
        document.addEventListener('keydown', (e) => {
          if (this.elements.qrModal.classList.contains('active') && (e.key === 'Escape' || e.key === ' ' || e.key === 'Enter')) {
            e.preventDefault();
            this.closeQRModal();
          }
        });
        
        // QR Display click handler - delegate to handle dynamically added canvases
        this.elements.qrDisplay.addEventListener('click', (e) => {
          if (e.target.tagName === 'CANVAS') {
            e.preventDefault();
            this.openQRModal(e.target);
          }
        });
      }
      
      updateCharCount() {
        const count = this.elements.sendText.value.length;
        this.elements.charCount.textContent = count;
        
        if (count > 1800) {
          this.elements.charCount.style.color = '#dc3545';
        } else if (count > 1500) {
          this.elements.charCount.style.color = '#ffc107';
        } else {
          this.elements.charCount.style.color = '';
        }
      }
      
      updateUI() {
        const sendHasText = this.elements.sendText.value.trim().length > 0;
        const receiveHasText = this.elements.receiveText.value.trim().length > 0;
        const filenameEntered = this.elements.filenameInput.value.trim().length > 0;
        
        this.elements.generateQR.disabled = !sendHasText;
        this.elements.copyText.disabled = !sendHasText;
        this.elements.copyReceived.disabled = !receiveHasText;
        this.elements.saveFile.disabled = !receiveHasText || !filenameEntered;
      }
      
      async generateQRCode() {
        const text = this.elements.sendText.value.trim();
        if (!text) {
          this.showStatus('Please enter some text first', 'warning');
          return;
        }
        

        
        this.showStatus('Generating QR code...', 'success');
        
        try {
          // Wait a bit for libraries to load if needed
          await this.waitForQRious();
          
          // Create canvas element for QR code  
          const canvas = document.createElement('canvas');
          
          // Generate QR code with QRious (let it do whatever sizing it wants)
          const tempCanvas = document.createElement('canvas');
          const qr = new QRious({
            element: tempCanvas,
            value: text,
            // calculate the optimal size based on text length
            size: Math.min(512, Math.max(100, text.length * 8)), // Dynamic size
            level: 'M', // Medium error correction
            foreground: '#000000',
            background: '#ffffff'
          });
          
          // Post-process: find the actual QR code bounds and create optimized canvas
          const optimizedCanvas = this.postProcessQRCode(tempCanvas, canvas);
          
          // Display the optimized QR code
          this.elements.qrDisplay.innerHTML = '';
          this.elements.qrDisplay.appendChild(optimizedCanvas);
          
          this.showStatus(`QR code generated! (${text.length} characters)`, 'success');
          
        } catch (error) {
          console.error('QR generation failed:', error);
          this.showStatus('QR code generation failed. Library not available.', 'error');
          this.showTextAsQR(text);
        }
      }
      
      async waitForQRious() {
        let attempts = 0;
        while (attempts < 10 && typeof QRious === 'undefined') {
          await new Promise(resolve => setTimeout(resolve, 200));
          attempts++;
        }
        if (typeof QRious === 'undefined') {
          throw new Error('QRious library not available');
        }
      }
      
      postProcessQRCode(sourceCanvas, targetCanvas) {
        const sourceCtx = sourceCanvas.getContext('2d');
        const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
        const data = imageData.data;
        
        // Find bounds of the actual QR code (non-white pixels)
        let minX = sourceCanvas.width, maxX = 0;
        let minY = sourceCanvas.height, maxY = 0;
        let foundQR = false;
        
        // Scan for black pixels to find QR code bounds
        for (let y = 0; y < sourceCanvas.height; y++) {
          for (let x = 0; x < sourceCanvas.width; x++) {
            const index = (y * sourceCanvas.width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            
            // Check if pixel is significantly darker than white (accounting for any artifacts)
            if (r < 240 || g < 240 || b < 240) {
              foundQR = true;
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
              minY = Math.min(minY, y);
              maxY = Math.max(maxY, y);
            }
          }
        }
        
        if (!foundQR) {
          // Fallback: return the original canvas if no QR code found
          return sourceCanvas;
        }
        
        // Calculate QR code dimensions
        const qrWidth = maxX - minX + 1;
        const qrHeight = maxY - minY + 1;
        const qrSize = Math.max(qrWidth, qrHeight); // Use the larger dimension
        
        // Set target canvas to high resolution (1024x1024) - let browser scale it down
        const canvasSize = 1024;
        
        targetCanvas.width = canvasSize;
        targetCanvas.height = canvasSize;
        // No explicit style sizing - let CSS handle the scaling
        
        const targetCtx = targetCanvas.getContext('2d');
        
        // Disable anti-aliasing for crisp pixel rendering
        targetCtx.imageSmoothingEnabled = false;
        targetCtx.webkitImageSmoothingEnabled = false;
        targetCtx.mozImageSmoothingEnabled = false;
        targetCtx.msImageSmoothingEnabled = false;
        
        // Fill with white background
        targetCtx.fillStyle = '#ffffff';
        targetCtx.fillRect(0, 0, canvasSize, canvasSize);
        
        // Calculate quiet zone (typically 4 modules, we'll use about 8% of canvas)
        const quietZone = Math.floor(canvasSize * 0.08);
        const qrRenderSize = canvasSize - (quietZone * 2);
        
        // Draw the extracted QR code data centered with quiet zones
        targetCtx.drawImage(
          sourceCanvas,
          minX, minY, qrSize, qrSize, // Source: extract just the QR code
          quietZone, quietZone, qrRenderSize, qrRenderSize // Target: centered with quiet zones
        );
        
        return targetCanvas;
      }
      
      showTextAsQR(text) {
        // Fallback: show text in a readable format
        this.elements.qrDisplay.innerHTML = `
          <div style="background: white; padding: 20px; border-radius: 8px; max-width: 100%; word-break: break-word; text-align: left;">
            <div style="text-align: center; font-weight: bold; margin-bottom: 15px; color: #0066cc;">Text to Share</div>
            <div style="font-family: monospace; font-size: 12px; line-height: 1.4; color: #333;">${this.escapeHtml(text)}</div>
            <div style="text-align: center; margin-top: 15px; font-size: 11px; opacity: 0.7;">QR generation not available - share manually</div>
          </div>
        `;
      }
      
      clearQRDisplay() {
        this.elements.qrDisplay.innerHTML = `
          <div style="opacity: 0.5; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 10px;">üì±</div>
            <div>QR Code will appear here</div>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">Enter text above and click Send</div>
          </div>
        `;
      }
      
      async startCamera(facingMode = null) {
        if (!navigator.mediaDevices?.getUserMedia) {
          this.showStatus('Camera not available. Please use HTTPS or localhost.', 'error');
          return;
        }
        
        const requestedMode = facingMode || this.getPreferredCamera();
        
        try {
          let constraints = {
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          };
          
          if (requestedMode) {
            constraints.video.facingMode = requestedMode;
          }
          
          this.stream = await navigator.mediaDevices.getUserMedia(constraints);
          this.elements.video.srcObject = this.stream;
          this.currentFacingMode = requestedMode;
          
          // Update camera status
          this.elements.cameraStatus.classList.remove('hidden');
          this.elements.cameraStatus.textContent = `Camera: ${requestedMode === 'environment' ? 'Back' : requestedMode === 'user' ? 'Front' : 'On'}`;
          
          // Update button states
          this.elements.startCamera.disabled = true;
          this.elements.useBackCamera.disabled = false;
          this.elements.useFrontCamera.disabled = false;
          this.elements.stopCamera.disabled = false;
          
          // Start scanning
          this.scanning = true;
          this.scanLoop();
          
          this.showStatus('Camera started. Point at a QR code to scan.', 'success');
          
        } catch (error) {
          console.error('Camera error:', error);
          await this.tryFallbackCamera(requestedMode);
        }
      }
      
      async tryFallbackCamera(original) {
        const alternatives = original === 'environment' ? ['user', null] : 
                           original === 'user' ? ['environment', null] : 
                           ['environment', 'user'];
        
        for (const mode of alternatives) {
          try {
            let constraints = { video: true };
            if (mode) {
              constraints.video = { facingMode: mode };
            }
            
            this.stream = await navigator.mediaDevices.getUserMedia(constraints);
            this.elements.video.srcObject = this.stream;
            this.currentFacingMode = mode;
            
            this.elements.cameraStatus.classList.remove('hidden');
            this.elements.cameraStatus.textContent = `Camera: ${mode === 'environment' ? 'Back' : mode === 'user' ? 'Front' : 'Default'}`;
            
            this.elements.startCamera.disabled = true;
            this.elements.useBackCamera.disabled = false;
            this.elements.useFrontCamera.disabled = false;
            this.elements.stopCamera.disabled = false;
            
            this.scanning = true;
            this.scanLoop();
            
            this.showStatus('Camera started with fallback mode.', 'success');
            return;
            
          } catch (e) {
            continue;
          }
        }
        
        this.showStatus('Could not access any camera. Please check permissions.', 'error');
      }
      
      getPreferredCamera() {
        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        return isMobile ? 'environment' : null; // Back camera on mobile
      }
      
      async switchCamera(facingMode) {
        if (this.stream) {
          this.stopCamera();
          // Small delay to ensure camera is fully stopped
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        await this.startCamera(facingMode);
      }
      
      stopCamera() {
        this.scanning = false;
        
        if (this.stream) {
          this.stream.getTracks().forEach(track => track.stop());
          this.stream = null;
        }
        
        if (this.elements.video) {
          this.elements.video.srcObject = null;
        }
        
        // Update UI
        this.elements.cameraStatus.classList.add('hidden');
        this.elements.startCamera.disabled = false;
        this.elements.useBackCamera.disabled = true;
        this.elements.useFrontCamera.disabled = true;
        this.elements.stopCamera.disabled = true;
        
        this.showStatus('Camera stopped.', 'success');
      }
      
      scanLoop() {
        if (!this.scanning || !this.elements.video) return;
        
        requestAnimationFrame(() => {
          const result = this.detectQR();
          if (result) {
            this.handleQRDetection(result);
          }
          
          if (this.scanning) {
            this.scanLoop();
          }
        });
      }
      
      detectQR() {
        if (!this.elements.video || this.elements.video.readyState !== 4) return null;
        
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = this.elements.video.videoWidth;
          canvas.height = this.elements.video.videoHeight;
          
          if (canvas.width === 0 || canvas.height === 0) return null;
          
          ctx.drawImage(this.elements.video, 0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          
          if (typeof jsQR !== 'undefined') {
            const code = jsQR(imageData.data, imageData.width, imageData.height, {
              inversionAttempts: 'dontInvert'
            });
            
            return code ? code.data : null;
          }
          
        } catch (error) {
          // Silent fail for QR detection errors
          return null;
        }
        
        return null;
      }
      
      handleQRDetection(data) {
        const now = Date.now();
        
        // Avoid duplicate detections
        if (data === this.lastDetectedText && now - this.lastDetectionTime < this.detectionCooldown) {
          return;
        }
        
        this.lastDetectedText = data;
        this.lastDetectionTime = now;
        
        // Update received text
        this.elements.receiveText.value = data;
        this.updateUI();
        
        // Flash the overlay to show detection
        const overlay = document.querySelector('.camera-overlay');
        if (overlay) {
          overlay.style.borderColor = '#00ff00';
          overlay.style.boxShadow = '0 0 30px rgba(0, 255, 0, 0.8)';
          setTimeout(() => {
            overlay.style.borderColor = '#00ff00';
            overlay.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.3)';
          }, 200);
        }
        
        this.showStatus(`QR code detected! (${data.length} characters)`, 'success');
      }
      
      async copyToClipboard(text, message) {
        try {
          await navigator.clipboard.writeText(text);
          this.showStatus(message, 'success');
        } catch (error) {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = text;
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          
          try {
            document.execCommand('copy');
            this.showStatus(message, 'success');
          } catch (e) {
            this.showStatus('Copy failed. Please manually select and copy the text.', 'error');
          }
          
          document.body.removeChild(textArea);
        }
      }
      
      showStatus(message, type = 'info') {
        this.elements.status.textContent = message;
        this.elements.status.className = 'status';
        if (type !== 'info') {
          this.elements.status.classList.add(type);
        }
        this.elements.status.classList.remove('hidden');
        
        // Auto-hide after a few seconds for success/info messages
        if (type === 'success' || type === 'info') {
          setTimeout(() => {
            this.elements.status.classList.add('hidden');
          }, 3000);
        }
      }
      
      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      async loadFromFile(file) {
        if (!file) return;
        
        try {
          this.showStatus('Loading file...', 'success');
          
          const text = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = reject;
            reader.readAsText(file);
          });
          
          this.elements.sendText.value = text;
          this.updateCharCount();
          this.updateUI();
          
          // Clear any existing QR code
          this.clearQRDisplay();
          
          this.showStatus(`File loaded! (${text.length} characters from ${file.name})`, 'success');
          
        } catch (error) {
          console.error('File load error:', error);
          this.showStatus('Failed to load file. Please check the file format.', 'error');
        }
      }
      
      saveToFile() {
        const text = this.elements.receiveText.value.trim();
        const filename = this.elements.filenameInput.value.trim();
        
        if (!text || !filename) {
          this.showStatus('Please enter both text and filename', 'warning');
          return;
        }
        
        try {
          // Create blob and download
          const blob = new Blob([text], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          // Clean up
          URL.revokeObjectURL(url);
          
          this.showStatus(`File saved as ${filename}! (${text.length} characters)`, 'success');
          
        } catch (error) {
          console.error('File save error:', error);
          this.showStatus('Failed to save file. Please try again.', 'error');
        }
      }
      
      async openQRModal(canvas) {
        try {
          // Request fullscreen
          const element = document.documentElement;
          if (element.requestFullscreen) {
            await element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            await element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            await element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            await element.msRequestFullscreen();
          }
        } catch (error) {
          console.warn('Fullscreen not supported or denied:', error);
          // Continue anyway - modal will still work without fullscreen
        }
        
        // Create a new canvas for the fullscreen modal
        const modalCanvas = document.createElement('canvas');
        
        // Set modal canvas to high resolution (1024x1024) - let CSS handle scaling
        const canvasSize = 1024;
        
        modalCanvas.width = canvasSize;
        modalCanvas.height = canvasSize;
        // CSS will handle the scaling via .qr-modal canvas rules
        
        const modalCtx = modalCanvas.getContext('2d');
        
        // Disable anti-aliasing for crisp QR code rendering
        modalCtx.imageSmoothingEnabled = false;
        modalCtx.webkitImageSmoothingEnabled = false;
        modalCtx.mozImageSmoothingEnabled = false;
        modalCtx.msImageSmoothingEnabled = false;
        
        // Fill with white background
        modalCtx.fillStyle = '#ffffff';
        modalCtx.fillRect(0, 0, canvasSize, canvasSize);
        
        // Calculate quiet zone for fullscreen (about 6% for better visibility)
        const quietZone = Math.floor(canvasSize * 0.06);
        const qrRenderSize = canvasSize - (quietZone * 2);
        
        // Draw the preview canvas scaled to fullscreen size with proper quiet zones
        modalCtx.drawImage(
          canvas,
          0, 0, canvas.width, canvas.height, // Source: entire preview canvas
          quietZone, quietZone, qrRenderSize, qrRenderSize // Target: centered with quiet zones
        );
        
        // Clear modal content and add the new canvas
        this.elements.qrModalContent.innerHTML = '';
        this.elements.qrModalContent.appendChild(modalCanvas);
        
        // Show modal
        this.elements.qrModal.classList.add('active');
        
        // Prevent body scroll while modal is open
        document.body.style.overflow = 'hidden';
        
        this.showStatus('QR code opened in fullscreen. Tap anywhere to close.', 'success');
      }
      
      closeQRModal() {
        // Hide modal
        this.elements.qrModal.classList.remove('active');
        
        // Restore body scroll
        document.body.style.overflow = '';
        
        // Exit fullscreen if active
        try {
          if (document.fullscreenElement || document.webkitFullscreenElement || 
              document.mozFullScreenElement || document.msFullscreenElement) {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
              document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
              document.msExitFullscreen();
            }
          }
        } catch (error) {
          console.warn('Error exiting fullscreen:', error);
        }
        
        this.showStatus('Fullscreen QR closed.', 'success');
      }
    }
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.qrdrop = new QRDrop();
    });
  </script>
</body>
<script src="parental.js"></script>
</html>