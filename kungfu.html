<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iron Fist Arena</title>
    <link rel="icon" type="image/png" sizes="512x512" href="assets/appicons/idle-games-512x512px.png">
    <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512px.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            min-height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            overflow: hidden;
            position: relative;
            touch-action: none;
        }

        #gameContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            width: 900px;
            height: 600px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            z-index: 10;
        }

        .playerInfo {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 300px;
        }

        .playerInfo.right {
            align-items: flex-end;
        }

        .playerName {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .playerName.player { color: #4ecdc4; }
        .playerName.enemy { color: #ff6b6b; }

        .barContainer {
            width: 100%;
            height: 16px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .healthBar {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s ease;
        }

        .staminaBar {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #e67e22);
            transition: width 0.3s ease;
        }

        .barContainer.stamina {
            height: 10px;
        }

        #roundInfo {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #arena {
            position: absolute;
            top: 80px;
            left: 0;
            width: 900px;
            height: 520px;
            background: linear-gradient(180deg, #2c1810 0%, #1a0f0a 100%);
            border: 4px solid #8b4513;
            overflow: hidden;
        }

        /* Arena decorations */
        .arenaFloor {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(90deg, #5d4037 0%, #6d4c41 50%, #5d4037 100%);
            border-top: 4px solid #8d6e63;
        }

        .arenaFloor::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 0;
            right: 0;
            height: 20px;
            background: repeating-linear-gradient(
                90deg,
                #4e342e 0px,
                #4e342e 60px,
                #3e2723 60px,
                #3e2723 120px
            );
        }

        .pillar {
            position: absolute;
            bottom: 60px;
            width: 40px;
            height: 200px;
            background: linear-gradient(90deg, #8b0000 0%, #b22222 50%, #8b0000 100%);
            border: 3px solid #660000;
        }

        .pillar.left { left: 30px; }
        .pillar.right { right: 30px; }

        .pillar::before {
            content: '';
            position: absolute;
            top: -20px;
            left: -10px;
            width: 60px;
            height: 20px;
            background: #660000;
            border-radius: 5px 5px 0 0;
        }

        .lantern {
            position: absolute;
            top: 40px;
            width: 30px;
            height: 40px;
            background: radial-gradient(ellipse at center, #ff6600 0%, #cc3300 100%);
            border-radius: 5px;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.6);
            animation: flicker 2s infinite alternate;
        }

        .lantern.left { left: 100px; }
        .lantern.right { right: 100px; }

        @keyframes flicker {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .banner {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 100px;
            background: linear-gradient(180deg, #8b0000 0%, #660000 100%);
            border: 3px solid #ffcc00;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }

        .banner::after {
            content: 'Ê≠¶';
            color: #ffcc00;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #messageOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }

        #startScreen h1, #gameOverScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,100,0,0.8);
            color: #ff6600;
        }

        #startScreen p, #gameOverScreen p {
            font-size: 20px;
            margin-bottom: 10px;
            color: #aaa;
        }

        .controls {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            text-align: left;
        }

        .controls h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 22px;
        }

        .key {
            display: inline-block;
            background: #333;
            border: 2px solid #555;
            border-radius: 5px;
            padding: 5px 10px;
            margin: 2px;
            font-family: monospace;
            font-size: 16px;
        }

        button {
            margin-top: 20px;
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(180deg, #ff6600 0%, #cc3300 100%);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.2s, box-shadow 0.2s;
            touch-action: manipulation;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,100,0,0.6);
        }

        #helpBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            z-index: 40;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            transition: transform 0.2s;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        #helpBtn:hover {
            transform: scale(1.1);
            background: rgba(0, 0, 0, 0.8);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }

        #helpScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        #helpScreen h1 {
            color: #4ecdc4;
            margin-bottom: 20px;
            font-size: 36px;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <button id="helpBtn">?</button>
        <div id="hud">
            <div class="playerInfo">
                <div class="playerName player" id="playerName">Shadow Dragon <span id="livesDisplay" style="font-size: 0.8em; margin-left: 10px;"></span></div>
                <div class="barContainer">
                    <div class="healthBar" id="playerHealth" style="width: 100%"></div>
                </div>
                <div class="barContainer stamina">
                    <div class="staminaBar" id="playerStamina" style="width: 100%"></div>
                </div>
            </div>
            <div id="roundInfo">Round 1</div>
            <div class="playerInfo right">
                <div class="playerName enemy" id="enemyName">Iron Monk</div>
                <div class="barContainer">
                    <div class="healthBar" id="enemyHealth" style="width: 100%"></div>
                </div>
                <div class="barContainer stamina">
                    <div class="staminaBar" id="enemyStamina" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div id="arena">
            <div class="arenaFloor"></div>
            <div class="pillar left"></div>
            <div class="pillar right"></div>
            <div class="lantern left"></div>
            <div class="lantern right"></div>
            <div class="banner"></div>
            <canvas id="canvas"></canvas>
        </div>

        <div id="messageOverlay"></div>

        <div id="startScreen">
            <h1>ü•ã Iron Fist Arena ü•ã</h1>
            <p>Defeat all opponents to become the champion!</p>
            <p>You are <strong style="color:#4ecdc4">Shadow Dragon</strong></p>
            <button id="startBtn">Begin Fight</button>
        </div>

        <div id="helpScreen" class="hidden">
            <h1>Controls</h1>
            <div class="controls">
                <p><span class="key">‚Üê</span> <span class="key">‚Üí</span> Walk (Gamepad: D-Pad/Stick)</p>
                <p><span class="key">‚Üë</span> Jump (Gamepad: A / Up)</p>
                <p><span class="key">‚Üì</span> Crouch / Block (Gamepad: Down)</p>
                <p><span class="key">W</span> Punch (Gamepad: X / Square)</p>
                <p><span class="key">D</span> Kick (Gamepad: B / Circle)</p>
                <p><span class="key">E</span> Pickup/Drop Weapon (Gamepad: LB)</p>
                <p>Sprint: Double Tap ‚Üê/‚Üí (Gamepad: RB / R1)</p>
                <p><span class="key">P</span> Pause (Gamepad: Start)</p>
            </div>
            <button id="closeHelpBtn">Close</button>
        </div>

        <div id="gameOverScreen" class="hidden">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="gameOverMsg">You were defeated!</p>
            <p id="finalRound"></p>
            <button id="restartBtn">Fight Again</button>
        </div>
    </div>

    <script>
        // ==================== GAME CONSTANTS ====================
        const GROUND_Y = 460;
        const ARENA_WIDTH = 900;
        const ARENA_HEIGHT = 520;
        const GRAVITY = 1800;
        const JUMP_VELOCITY = -600;
        const WALK_SPEED = 200;
        const SPRINT_SPEED = 400;
        const CROUCH_CREEP_SPEED = 80;
        const STUN_DURATION = 500;
        const KNOCKBACK = 30;

        const STAMINA_MAX = 100;
        const STAMINA_REGEN = 20;
        const STAMINA_CROUCH_DRAIN = 15;
        const STAMINA_JUMP_COST = 15;
        const STAMINA_PUNCH_COST = 8;
        const STAMINA_KICK_COST = 12;

        const PUNCH_DAMAGE = 8;
        const KICK_DAMAGE = 12;
        const LOW_PUNCH_DAMAGE = 6;
        const SWEEP_DAMAGE = 15;

        const PLAYER_COLOR = '#4ecdc4';
        const PLAYER_NAME = 'Shadow Dragon';

        // Potion Types
        const POTION_TYPES = [
            { type: 'health', color: '#e74c3c', effect: 'HP +50%', apply: (p) => { p.health = Math.min(100, p.health + 50); } },
            { type: 'stamina', color: '#f1c40f', effect: 'Stamina +50%', apply: (p) => { p.stamina = Math.min(STAMINA_MAX, p.stamina + 50); } },
            { type: 'mixed', color: '#9b59b6', effect: 'HP/Stamina +25%', apply: (p) => { p.health = Math.min(100, p.health + 25); p.stamina = Math.min(STAMINA_MAX, p.stamina + 25); } },
            { type: 'full', color: '#2ecc71', effect: 'Full Restore!', apply: (p) => { p.health = 100; p.stamina = STAMINA_MAX; } },
            { type: 'chi', color: '#3498db', effect: 'Chi Shield!', apply: (p) => { p.invulnerable = true; p.chiShieldTimer = 10000; } }
        ];

        // ==================== WEAPON SYSTEM ====================
        const WEAPON_TYPES = ['sword', 'pole', 'star', 'fan'];
        const WEAPON_STAMINA_MULT = 1.2;
        const WEAPON_DAMAGE_MULT = 1.5;

        // Projectiles array for throwing star and fan
        let projectiles = [];

        class Weapon {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.onGround = true;
                this.owner = null; // Fighter holding this weapon
                this.bobTimer = Math.random() * Math.PI * 2;
                this.groundRotation = 0; // Rotation when on ground
            }

            update(dt) {
                if (this.onGround) {
                    this.bobTimer += dt * 3;
                }
            }

            draw(ctx) {
                if (this.owner) return; // Don't draw if being held - fighter draws it
                
                const bobY = Math.sin(this.bobTimer) * 3;
                const x = this.x;
                const y = this.y - 5 + bobY;
                
                ctx.save();
                ctx.translate(x, y);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 5, 20, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Sword and pole lay flat on ground, star and fan stand/float
                let groundAngle = 0;
                if (this.type === 'sword') {
                    groundAngle = Math.PI / 2; // Lay horizontal
                } else if (this.type === 'pole') {
                    groundAngle = Math.PI / 2; // Lay horizontal
                }
                
                this.drawWeapon(ctx, 0, 0, groundAngle, this.type === 'pole' ? 0.6 : 1);
                ctx.restore();
            }

            drawWeapon(ctx, x, y, angle, scale = 1) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.scale(scale, scale);
                
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#fff';
                ctx.lineWidth = 2;
                
                switch (this.type) {
                    case 'sword':
                        // Longsword - blade
                        ctx.beginPath();
                        ctx.moveTo(-5, 0);
                        ctx.lineTo(-3, -45);
                        ctx.lineTo(0, -50);
                        ctx.lineTo(3, -45);
                        ctx.lineTo(5, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Crossguard
                        ctx.fillRect(-12, 0, 24, 5);
                        ctx.strokeRect(-12, 0, 24, 5);
                        // Handle
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-3, 5, 6, 18);
                        ctx.strokeRect(-3, 5, 6, 18);
                        // Pommel
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(0, 26, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        break;
                        
                    case 'pole':
                        // Bo staff with rounded ends
                        ctx.beginPath();
                        ctx.moveTo(-3, -55);
                        ctx.lineTo(3, -55);
                        ctx.lineTo(3, 55);
                        ctx.lineTo(-3, 55);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Rounded caps
                        ctx.beginPath();
                        ctx.arc(0, -55, 3, Math.PI, 0);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 55, 3, 0, Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        break;
                        
                    case 'star':
                        // 4-pointed shuriken
                        this.drawShuriken(ctx, 0, 0, 12);
                        break;
                        
                    case 'fan':
                        // War fan (tessen)
                        ctx.beginPath();
                        // Fan blades (spread)
                        for (let i = -2; i <= 2; i++) {
                            const angle = (i * 15) * Math.PI / 180;
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.sin(angle) * 35, -Math.cos(angle) * 35);
                        }
                        ctx.stroke();
                        // Fan surface
                        ctx.beginPath();
                        ctx.arc(0, 0, 35, -Math.PI/2 - Math.PI/6, -Math.PI/2 + Math.PI/6);
                        ctx.lineTo(0, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Handle
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-3, 0, 6, 15);
                        ctx.strokeRect(-3, 0, 6, 15);
                        break;
                }
                
                ctx.restore();
            }

            drawShuriken(ctx, x, y, size) {
                ctx.save();
                ctx.translate(x, y);
                
                // 4 pointed star with cutouts
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i * 90) * Math.PI / 180;
                    const nextAngle = ((i + 1) * 90) * Math.PI / 180;
                    const midAngle = angle + Math.PI / 4;
                    
                    // Point tip
                    ctx.lineTo(Math.cos(angle) * size, Math.sin(angle) * size);
                    // Inner notch (creates the cutout appearance)
                    ctx.lineTo(Math.cos(midAngle) * (size * 0.3), Math.sin(midAngle) * (size * 0.3));
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Center circle cutouts between points
                ctx.fillStyle = '#000';
                for (let i = 0; i < 4; i++) {
                    const angle = (i * 90 + 45) * Math.PI / 180;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * (size * 0.5), Math.sin(angle) * (size * 0.5), size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            getHitbox() {
                return {
                    x: this.x - 20,
                    y: this.y - 30,
                    w: 40,
                    h: 40
                };
            }
        }

        // Projectile class for thrown weapons
        class Projectile {
            constructor(weapon, thrower, targetX) {
                this.weapon = weapon;
                this.thrower = thrower;
                this.x = thrower.x + (thrower.facingRight ? 30 : -30);
                this.y = thrower.y - 50;
                this.vx = (thrower.facingRight ? 1 : -1) * 400;
                this.vy = 0;
                this.rotation = 0;
                this.returning = false;
                this.hasHit = false;
                this.type = weapon.type;
            }

            update(dt) {
                this.rotation += dt * 15;
                
                if (this.type === 'fan' && this.returning) {
                    // Fan returns to thrower
                    const dx = this.thrower.x - this.x;
                    const dy = (this.thrower.y - 50) - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 30) {
                        // Caught!
                        this.weapon.owner = this.thrower;
                        this.thrower.weapon = this.weapon;
                        this.weapon.onGround = false;
                        return true; // Remove projectile
                    }
                    
                    const speed = 450;
                    this.vx = (dx / dist) * speed;
                    this.vy = (dy / dist) * speed;
                }
                
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Check arena bounds
                if (this.x < 50 || this.x > ARENA_WIDTH - 50) {
                    if (this.type === 'star') {
                        // Star embeds in wall
                        this.weapon.x = Math.max(60, Math.min(ARENA_WIDTH - 60, this.x));
                        this.weapon.y = GROUND_Y;
                        this.weapon.onGround = true;
                        this.weapon.owner = null;
                        return true; // Remove projectile
                    } else if (this.type === 'fan') {
                        // Fan returns
                        this.returning = true;
                        this.vx = -this.vx;
                    }
                }
                
                return false; // Keep projectile
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#fff';
                ctx.lineWidth = 2;
                
                if (this.type === 'star') {
                    this.weapon.drawShuriken(ctx, 0, 0, 12);
                } else if (this.type === 'fan') {
                    // Spinning fan
                    this.weapon.drawWeapon(ctx, 0, 0, 0, 0.8);
                }
                
                ctx.restore();
            }

            getHitbox() {
                const size = this.type === 'star' ? 16 : 30;
                return {
                    x: this.x - size/2,
                    y: this.y - size/2,
                    w: size,
                    h: size
                };
            }
        }

        let weapons = []; // Ground weapons

        // ==================== AUDIO SYSTEM ====================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        const SoundFX = {
            playTone: (freq, type, duration, vol = 0.1, slide = 0) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if (slide !== 0) {
                    osc.frequency.linearRampToValueAtTime(freq + slide, audioCtx.currentTime + duration);
                }
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playNoise: (duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                noise.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            },
            hit: () => {
                SoundFX.playNoise(0.1, 0.2);
                SoundFX.playTone(60, 'sawtooth', 0.1, 0.1);
            },
            heavyHit: () => {
                SoundFX.playNoise(0.2, 0.3);
                SoundFX.playTone(40, 'square', 0.2, 0.2);
            },
            whiff: () => {
                SoundFX.playNoise(0.05, 0.05);
                SoundFX.playTone(150, 'sine', 0.1, 0.05, -50);
            },
            jump: () => {
                SoundFX.playTone(100, 'sine', 0.1, 0.1, 50);
            },
            block: () => {
                SoundFX.playTone(50, 'square', 0.05, 0.1);
                SoundFX.playNoise(0.05, 0.1);
            },
            // Weapon sounds
            swordSwing: () => {
                SoundFX.playTone(400, 'sawtooth', 0.15, 0.08, -200);
            },
            swordHit: () => {
                SoundFX.playTone(300, 'sawtooth', 0.1, 0.15);
                SoundFX.playNoise(0.1, 0.2);
            },
            poleSwing: () => {
                SoundFX.playTone(120, 'sine', 0.2, 0.1, 80);
            },
            poleHit: () => {
                SoundFX.playTone(80, 'square', 0.15, 0.2);
                SoundFX.playNoise(0.15, 0.25);
            },
            throwSound: () => {
                SoundFX.playTone(500, 'sine', 0.1, 0.1, -200);
            },
            starHit: () => {
                SoundFX.playTone(800, 'triangle', 0.1, 0.15);
                SoundFX.playNoise(0.05, 0.15);
            },
            fanHit: () => {
                SoundFX.playTone(600, 'triangle', 0.1, 0.12);
                SoundFX.playNoise(0.08, 0.1);
            },
            pickup: () => {
                SoundFX.playTone(400, 'sine', 0.1, 0.1, 200);
            }
        };

        const OPPONENTS = [
            { name: 'Iron Monk', color: '#ff6b6b', style: 'defensive', stats: { aggression: 0.3, block: 0.8, jump: 0.2, punch: 0.6, kick: 0.4, sprint: 0.1 } },
            { name: 'Thunder Fist', color: '#ffd93d', style: 'aggressive', stats: { aggression: 0.7, block: 0.3, jump: 0.6, punch: 0.8, kick: 0.2, sprint: 0.6 } },
            { name: 'Silent Viper', color: '#6bcb77', style: 'balanced', stats: { aggression: 0.5, block: 0.5, jump: 0.5, punch: 0.4, kick: 0.6, sprint: 0.3 } },
            { name: 'Storm Blade', color: '#9d4edd', style: 'aggressive', stats: { aggression: 0.8, block: 0.2, jump: 0.7, punch: 0.3, kick: 0.7, sprint: 0.8 } },
            { name: 'Jade Phoenix', color: '#00cec9', style: 'technical', stats: { aggression: 0.4, block: 0.6, jump: 0.8, punch: 0.2, kick: 0.8, sprint: 0.4 } },
            { name: 'Crimson Tiger', color: '#e17055', style: 'aggressive', stats: { aggression: 0.9, block: 0.1, jump: 0.4, punch: 0.7, kick: 0.3, sprint: 0.9 } },
            { name: 'Ghost Mantis', color: '#a29bfe', style: 'evasive', stats: { aggression: 0.3, block: 0.4, jump: 0.9, punch: 0.5, kick: 0.5, sprint: 0.5 } },
            { name: 'Dragon Master', color: '#fd79a8', style: 'master', stats: { aggression: 0.6, block: 0.7, jump: 0.6, punch: 0.6, kick: 0.6, sprint: 0.5 } }
        ];

        // ==================== NAME GENERATION ====================
        const FIRST_NAMES = ["Iron", "Steel", "Golden", "Silver", "Jade", "Flying", "Crouching", "Hidden", "Drunken", "Silent", "Thunder", "Lightning", "Shadow", "Ghost", "Tiger", "Dragon", "Crane", "Mantis", "Monkey", "Snake", "Phoenix", "Lotus", "Burning", "Frozen", "Stone", "Wind", "Water", "Fire", "Void", "Spirit"];
        const LAST_NAMES = ["Fist", "Palm", "Kick", "Strike", "Blade", "Sword", "Spear", "Staff", "Monk", "Master", "Warrior", "Ninja", "Samurai", "Ronin", "Emperor", "General", "Soldier", "Assassin", "Hunter", "Walker", "Runner", "Jumper", "Flyer", "Hand", "Foot", "Claw", "Tooth", "Wing", "Eye", "Heart"];

        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // ==================== ANIMATION POSES ====================
        // Offsets relative to player X,Y (center between feet on ground)
        const POSES = {
            idle: {
                head: {x: 0, y: -80},
                body: {x: 0, y: -40, w: 40, h: 60},
                fistF: {x: 25, y: -55}, // Front
                fistB: {x: 10, y: -50}, // Back
                footF: {x: 15, y: -5},
                footB: {x: -15, y: -5}
            },
            crouch: {
                head: {x: 5, y: -55},
                body: {x: 0, y: -25, w: 45, h: 40},
                fistF: {x: 25, y: -40},
                fistB: {x: 10, y: -35},
                footF: {x: 20, y: -5},
                footB: {x: -10, y: -5}
            },
            walk: { // Base walk pose, modified by sine wave
                head: {x: 5, y: -78},
                body: {x: 0, y: -38, w: 40, h: 60},
                fistF: {x: 25, y: -52},
                fistB: {x: 0, y: -48},
                footF: {x: 10, y: -5},
                footB: {x: -10, y: -5}
            },
            sprint: {
                head: {x: 15, y: -70}, // Leaning forward
                body: {x: 10, y: -35, w: 40, h: 60},
                fistF: {x: 30, y: -50},
                fistB: {x: -10, y: -50},
                footF: {x: 20, y: -5},
                footB: {x: -20, y: -5}
            },
            jump: {
                head: {x: 5, y: -85},
                body: {x: 0, y: -50, w: 35, h: 55},
                fistF: {x: 20, y: -70},
                fistB: {x: -10, y: -60},
                footF: {x: 10, y: -20},
                footB: {x: -15, y: -10}
            },
            punch: {
                head: {x: 15, y: -75},
                body: {x: 10, y: -38, w: 40, h: 60},
                fistF: {x: 60, y: -55}, // Extended
                fistB: {x: -5, y: -50},
                footF: {x: 25, y: -5},
                footB: {x: -20, y: -5}
            },
            lowPunch: {
                head: {x: 15, y: -50},
                body: {x: 10, y: -25, w: 45, h: 40},
                fistF: {x: 55, y: -30}, // Extended Low
                fistB: {x: 0, y: -35},
                footF: {x: 25, y: -5},
                footB: {x: -15, y: -5}
            },
            kick: {
                head: {x: -15, y: -75},
                body: {x: -10, y: -38, w: 40, h: 60},
                fistF: {x: 10, y: -55},
                fistB: {x: -20, y: -50},
                footF: {x: 55, y: -50}, // Extended High
                footB: {x: -20, y: -5}
            },
            sweep: {
                head: {x: 0, y: -45},
                body: {x: 0, y: -20, w: 45, h: 35},
                fistF: {x: 10, y: -30},
                fistB: {x: -10, y: -30},
                footF: {x: 50, y: -5}, // Extended Low
                footB: {x: -20, y: -5}
            },
            jumpPunch: {
                head: {x: 10, y: -80},
                body: {x: 5, y: -45, w: 35, h: 55},
                fistF: {x: 45, y: -20}, // Punch down towards ground
                fistB: {x: -10, y: -60},
                footF: {x: 15, y: -25}, // Legs tucked
                footB: {x: -10, y: -15}
            },
            jumpKick: {
                head: {x: 5, y: -80},
                body: {x: 0, y: -45, w: 35, h: 55},
                fistF: {x: 10, y: -60},
                fistB: {x: -10, y: -60},
                footF: {x: 60, y: -30}, // Flying kick
                footB: {x: -25, y: -10}
            },
            stunned: {
                head: {x: -10, y: -75},
                body: {x: -5, y: -38, w: 40, h: 60},
                fistF: {x: 10, y: -40},
                fistB: {x: -10, y: -40},
                footF: {x: 15, y: -5},
                footB: {x: -15, y: -5}
            },
            tripped: {
                head: {x: -35, y: -15},
                body: {x: 0, y: -15, w: 60, h: 30}, // Horizontal body
                fistF: {x: 10, y: -45},
                fistB: {x: -10, y: -45},
                footF: {x: 35, y: -55}, // Legs kicked up
                footB: {x: 45, y: -35}
            },
            // Pole weapon poses
            poleIdle: {
                head: {x: 0, y: -75},
                body: {x: 0, y: -38, w: 40, h: 60},
                fistF: {x: 30, y: -55}, // Near hand forward and high (shoulder height)
                fistB: {x: -10, y: -25}, // Far hand back and low (waist height)
                footF: {x: 15, y: -5},
                footB: {x: -15, y: -5}
            },
            poleStrike: {
                head: {x: 15, y: -75},
                body: {x: 10, y: -38, w: 40, h: 60},
                fistF: {x: 50, y: -45}, // Thrust forward
                fistB: {x: 10, y: -45}, // Follow through
                footF: {x: 25, y: -5},
                footB: {x: -20, y: -5}
            },
            poleSweep: {
                head: {x: 10, y: -65},
                body: {x: 5, y: -30, w: 45, h: 50},
                fistF: {x: 40, y: -10}, // Low jab to leg area
                fistB: {x: 0, y: -20},
                footF: {x: 20, y: -5},
                footB: {x: -15, y: -5}
            }
        };

        // ==================== GAME STATE ====================
        let canvas, ctx;
        let gameState = 'start';
        let currentRound = 1;
        let lives = 5;
        let koTimer = 0;
        let roundTime = 0; // Time elapsed in current round
        let leftPotionSpawned = false; // Timed spawn tracking
        let rightPotionSpawned = false;
        const POTION_SPAWN_TIME = 10; // Seconds before side potions spawn
        const LEFT_POTION_X = 80; // Left side spawn position
        const RIGHT_POTION_X = ARENA_WIDTH - 80; // Right side spawn position
        let player;
        let enemies = []; // Array of Fighter objects
        let potions = []; // Array of Potion objects
        let keys = {};
        let lastTime = 0;
        
        // Input handling state
        let lastTapTime = 0;
        let lastTapKey = null;
        let lastStartBtn = false;

        // Debug state
        let debugMode = false;
        let debugBuffer = '';

        function getGamepadInput() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = gamepads[0]; // Use first gamepad
            
            if (!gp) return { left: false, right: false, up: false, down: false, punch: false, kick: false, sprint: false, start: false, interact: false };

            const threshold = 0.5;
            return {
                left: gp.axes[0] < -threshold || gp.buttons[14].pressed,
                right: gp.axes[0] > threshold || gp.buttons[15].pressed,
                up: gp.axes[1] < -threshold || gp.buttons[12].pressed || gp.buttons[0].pressed, // Up or A
                down: gp.axes[1] > threshold || gp.buttons[13].pressed,
                punch: gp.buttons[2].pressed || gp.buttons[3].pressed, // X or Y
                kick: gp.buttons[1].pressed || gp.buttons[5].pressed, // B or RB (Wait, RB is sprint usually, let's use B)
                sprint: gp.buttons[5].pressed || gp.buttons[7].pressed, // RB or RT
                start: gp.buttons[9].pressed,
                interact: gp.buttons[4].pressed // LB for pickup/drop weapon
            };
        }

        // ==================== FIGHTER CLASS ====================
        class Fighter {
            constructor(x, isPlayer, color, name, isMinion = false) {
                this.x = x;
                this.y = GROUND_Y;
                this.vx = 0;
                this.vy = 0;
                this.isPlayer = isPlayer;
                this.color = color;
                this.name = name;
                this.facingRight = isPlayer;
                this.isMinion = isMinion;
                
                this.health = 100;
                this.stamina = STAMINA_MAX;
                this.invulnerable = false;
                
                this.state = 'idle';
                this.crouching = false;
                this.onGround = true;
                this.isSprinting = false;
                
                this.attackTimer = 0;
                this.attackDuration = 0;
                this.stunTimer = 0;
                this.canAttack = true;
                this.lastPunchKey = false;
                this.lastKickKey = false;
                
                // Animation State
                this.animTimer = 0;
                this.parts = {
                    head: {x:0, y:0}, 
                    body: {x:0, y:0, w:40, h:60},
                    fistF: {x:0, y:0}, fistB: {x:0, y:0},
                    footF: {x:0, y:0}, footB: {x:0, y:0}
                };
                
                // Initialize parts to idle
                this.snapToPose(POSES.idle);

                // AI properties
                this.aiTimer = 0;
                this.aiDecision = null;
                this.aiStyle = 'balanced';
                this.aiStats = { aggression: 0.5, block: 0.5, jump: 0.5, punch: 0.5, kick: 0.5, sprint: 0.5 };
                this.deathTimer = 0;
                this.hasDealtDamage = false;
                this.chiShieldTimer = 0;
                this.droppedPotion = false;
                
                // Weapon system
                this.weapon = null;
                this.lastInteractKey = false;
                this.poleSwingPhase = 0; // For pole animation
            }

            snapToPose(pose) {
                for (let key in this.parts) {
                    this.parts[key].x = pose[key].x * (this.facingRight ? 1 : -1);
                    this.parts[key].y = pose[key].y;
                    if (key === 'body') {
                        this.parts[key].w = pose[key].w;
                        this.parts[key].h = pose[key].h;
                    }
                }
            }

            getHitboxes() {
                // Calculate absolute positions based on current parts state
                const headSize = 30;
                let fistSize = 16;
                let footSize = 18;
                
                // Extend hitbox for weapons
                let fistExtendX = 0;
                let fistExtendY = 0;
                if (this.weapon) {
                    if (this.weapon.type === 'sword') {
                        fistExtendX = (this.facingRight ? 1 : -1) * 25;
                        fistExtendY = -15;
                        // fistSize remains standard to avoid "enlarged hands" visual
                    } else if (this.weapon.type === 'pole') {
                        fistExtendX = (this.facingRight ? 1 : -1) * 35;
                        // footSize remains standard to avoid "enlarged feet" visual
                    }
                }
                
                return {
                    head: {
                        x: this.x + this.parts.head.x - headSize/2,
                        y: this.y + this.parts.head.y - headSize/2,
                        w: headSize, h: headSize
                    },
                    body: {
                        x: this.x + this.parts.body.x - this.parts.body.w/2,
                        y: this.y + this.parts.body.y - this.parts.body.h/2,
                        w: this.parts.body.w, h: this.parts.body.h
                    },
                    fist: { // Active fist (Front) - extended for weapon
                        x: this.x + this.parts.fistF.x + fistExtendX - fistSize/2,
                        y: this.y + this.parts.fistF.y + fistExtendY - fistSize/2,
                        w: fistSize, h: fistSize
                    },
                    foot: { // Active foot (Front) - or pole sweep area
                        x: this.x + this.parts.footF.x - footSize/2,
                        y: this.y + this.parts.footF.y - footSize/2,
                        w: footSize, h: footSize
                    }
                };
            }

            update(dt, opponent) {
                // --- Physics & State ---
                if (this.stunTimer > 0) {
                    this.stunTimer -= dt * 1000;
                    if (this.state !== 'tripped') this.state = 'stunned';
                    
                    // Higher friction for tripped to prevent sliding
                    if (this.state === 'tripped') this.vx *= 0.8;
                    else this.vx *= 0.9;
                } else if (this.attackTimer > 0) {
                    this.attackTimer -= dt * 1000;
                    if (this.attackTimer <= 0) this.state = 'idle';
                } else {
                    // State determination for animation
                    if (!this.onGround) this.state = 'jumping';
                    else if (this.crouching) this.state = 'crouching';
                    else if (this.isSprinting && Math.abs(this.vx) > 10) this.state = 'sprinting';
                    else if (Math.abs(this.vx) > 10) this.state = 'walking';
                    else this.state = 'idle';
                }

                // Gravity
                if (!this.onGround) this.vy += GRAVITY * dt;

                // Velocity
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Ground collision
                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.vy = 0;
                    this.onGround = true;
                }

                // Minion death cleanup
                if (this.isMinion && this.health <= 0 && this.onGround) {
                    this.deathTimer += dt;
                    // Drop potion on death
                    if (!this.droppedPotion) {
                        this.droppedPotion = true;
                        spawnPotion(this.x);
                    }
                }

                // Chi Shield Timer
                if (this.chiShieldTimer > 0) {
                    this.chiShieldTimer -= dt * 1000;
                    if (this.chiShieldTimer <= 0) {
                        this.invulnerable = false;
                        this.chiShieldTimer = 0;
                    }
                }

                // Bounds
                this.x = Math.max(50, Math.min(ARENA_WIDTH - 50, this.x));

                // Facing
                if (opponent && this.stunTimer <= 0 && this.attackTimer <= 0) {
                    this.facingRight = this.x < opponent.x;
                }

                // Stamina
                if (this.stunTimer <= 0 && !this.crouching && this.onGround && this.attackTimer <= 0) {
                    if (this.state === 'idle') {
                        this.stamina = Math.min(STAMINA_MAX, this.stamina + STAMINA_REGEN * dt);
                    } else if (this.state === 'walking') {
                        this.stamina = Math.min(STAMINA_MAX, this.stamina + (STAMINA_REGEN * 0.5) * dt);
                    }
                }
                if (this.crouching) {
                    this.stamina = Math.max(0, this.stamina - STAMINA_CROUCH_DRAIN * dt);
                }

                // --- Animation System ---
                let targetPose = POSES.idle;
                
                // Weapon-specific idle pose
                if (this.weapon && this.weapon.type === 'pole' && this.state === 'idle') {
                    targetPose = POSES.poleIdle;
                } else if (this.state === 'stunned') targetPose = POSES.stunned;
                else if (this.state === 'tripped') targetPose = POSES.tripped;
                else if (this.state === 'poleStrike') targetPose = POSES.poleStrike;
                else if (this.state === 'poleSweep') targetPose = POSES.poleSweep;
                else if (this.state === 'punching') targetPose = POSES.punch;
                else if (this.state === 'lowPunch') targetPose = POSES.lowPunch;
                else if (this.state === 'jumpPunch') targetPose = POSES.jumpPunch;
                else if (this.state === 'kicking') targetPose = POSES.kick;
                else if (this.state === 'jumpKick') targetPose = POSES.jumpKick;
                else if (this.state === 'sweeping') targetPose = POSES.sweep;
                else if (this.state === 'crouching') targetPose = POSES.crouch;
                else if (this.state === 'jumping') targetPose = POSES.jump;
                else if (this.state === 'sprinting') targetPose = POSES.sprint;
                else if (this.state === 'walking') targetPose = POSES.walk;

                const speed = 15 * dt;
                this.animTimer += dt * 10;

                for (let key in this.parts) {
                    let tx = targetPose[key].x;
                    let ty = targetPose[key].y;

                    // Procedural Animation
                    if (this.state === 'idle') {
                        if (key === 'head' || key === 'body' || key.includes('fist')) {
                            ty += Math.sin(this.animTimer) * 2;
                        }
                    } else if (this.state === 'walking' || this.state === 'sprinting' || (this.state === 'punching' && Math.abs(this.vx) > 10)) {
                        // Apply walking anim to legs if walking OR punching while moving
                        const strideMult = this.state === 'sprinting' ? 25 : 15;
                        const freqMult = this.state === 'sprinting' ? 1.5 : 1;
                        
                        if (key === 'footF') tx += Math.sin(this.animTimer * freqMult) * strideMult;
                        if (key === 'footB') tx += Math.sin(this.animTimer * freqMult + Math.PI) * strideMult;
                        
                        // Only bob body/head if NOT punching (to keep aim steady)
                        if (this.state !== 'punching') {
                             if (key === 'fistF') tx += Math.cos(this.animTimer * freqMult) * 10;
                             if (key === 'fistB') tx += Math.cos(this.animTimer * freqMult + Math.PI) * 10;
                             if (key === 'head' || key === 'body') ty += Math.abs(Math.sin(this.animTimer * 2 * freqMult)) * 3;
                        }
                    }

                    // Apply direction
                    const dir = this.facingRight ? 1 : -1;
                    const finalTx = tx * dir;
                    
                    // Lerp
                    this.parts[key].x += (finalTx - this.parts[key].x) * speed;
                    this.parts[key].y += (ty - this.parts[key].y) * speed;
                    
                    // Dimensions (body only)
                    if (key === 'body') {
                        this.parts[key].w += (targetPose[key].w - this.parts[key].w) * speed;
                        this.parts[key].h += (targetPose[key].h - this.parts[key].h) * speed;
                    }
                }
            }

            punch(isLow = false) {
                if (!this.canAttack || this.attackTimer > 0 || this.stunTimer > 0 || this.state === 'tripped') return false;
                
                // Calculate stamina cost (1.2x with weapon)
                const staminaCost = this.weapon ? STAMINA_PUNCH_COST * WEAPON_STAMINA_MULT : STAMINA_PUNCH_COST;
                if (this.stamina < staminaCost) return false;

                this.stamina -= staminaCost;
                const speedMod = 0.5 + (this.stamina / STAMINA_MAX) * 0.5;
                this.attackDuration = 200 / speedMod;
                this.attackTimer = this.attackDuration;
                this.hasDealtDamage = false;
                
                // Weapon-specific punch behavior
                if (this.weapon) {
                    if (this.weapon.type === 'star') {
                        // Throw star - then lose it
                        this.throwWeapon();
                        this.state = isLow ? 'lowPunch' : 'punching';
                    } else if (this.weapon.type === 'fan') {
                        // Throw fan (returns)
                        this.throwWeapon();
                        this.state = isLow ? 'lowPunch' : 'punching';
                    } else if (this.weapon.type === 'pole') {
                        // Pole strike
                        this.state = 'poleStrike';
                        this.poleSwingPhase = 0;
                        SoundFX.poleSwing();
                        return true;
                    } else if (this.weapon.type === 'sword') {
                        // Sword jab - same pose as punch but extended reach
                        if (!this.onGround) {
                            this.state = 'jumpPunch';
                        } else {
                            this.state = isLow ? 'lowPunch' : 'punching';
                        }
                        SoundFX.swordSwing();
                        return true;
                    }
                }
                
                if (!this.onGround) {
                    this.state = 'jumpPunch';
                } else {
                    this.state = isLow ? 'lowPunch' : 'punching';
                }
                SoundFX.whiff();
                return true;
            }

            kick(isSweep = false) {
                if (!this.canAttack || this.attackTimer > 0 || this.stunTimer > 0 || this.state === 'tripped') return false;
                
                // Pole replaces kicks with sweeps
                if (this.weapon && this.weapon.type === 'pole') {
                    const staminaCost = STAMINA_KICK_COST * WEAPON_STAMINA_MULT;
                    if (this.stamina < staminaCost) return false;
                    
                    this.stamina -= staminaCost;
                    const speedMod = 0.5 + (this.stamina / STAMINA_MAX) * 0.5;
                    this.attackDuration = 300 / speedMod;
                    this.attackTimer = this.attackDuration;
                    this.hasDealtDamage = false;
                    this.state = 'poleSweep';
                    this.poleSwingPhase = 0;
                    SoundFX.poleSwing();
                    return true;
                }
                
                if (this.stamina < STAMINA_KICK_COST) return false;

                this.stamina -= STAMINA_KICK_COST;
                const speedMod = 0.5 + (this.stamina / STAMINA_MAX) * 0.5;
                this.attackDuration = 250 / speedMod;
                this.attackTimer = this.attackDuration;
                this.hasDealtDamage = false;
                
                if (!this.onGround) {
                    this.state = 'jumpKick';
                } else {
                    this.state = isSweep ? 'sweeping' : 'kicking';
                }
                SoundFX.whiff();
                return true;
            }
            
            throwWeapon() {
                if (!this.weapon) return;
                
                const proj = new Projectile(this.weapon, this, 0);
                projectiles.push(proj);
                
                // Star is gone until re-collected
                // Fan returns automatically
                if (this.weapon.type === 'star') {
                    this.weapon.owner = null;
                    this.weapon = null;
                } else if (this.weapon.type === 'fan') {
                    // Fan stays linked to thrower but temporarily no weapon
                    // The projectile will return the fan
                    this.weapon = null;
                }
                
                SoundFX.throwSound();
            }
            
            pickupWeapon(weapon) {
                if (this.weapon) return false; // Already holding one
                
                this.weapon = weapon;
                weapon.owner = this;
                weapon.onGround = false;
                showMessage(`${this.name || 'Player'} picked up ${weapon.type}!`, '#fff');
                SoundFX.pickup();
                return true;
            }
            
            dropWeapon() {
                if (!this.weapon) return;
                
                this.weapon.x = this.x;
                this.weapon.y = GROUND_Y;
                this.weapon.onGround = true;
                this.weapon.owner = null;
                showMessage('Dropped ' + this.weapon.type, '#aaa');
                this.weapon = null;
            }

            jump(direction = 0) {
                if (!this.onGround || this.stunTimer > 0 || this.state === 'tripped') return;
                if (this.stamina < STAMINA_JUMP_COST) return;

                this.stamina -= STAMINA_JUMP_COST;
                this.vy = JUMP_VELOCITY;
                this.vx = direction * WALK_SPEED * 1.2;
                this.onGround = false;
                this.crouching = false;
                SoundFX.jump();
            }

            walk(direction) {
                if (this.stunTimer > 0 || this.state === 'tripped') return;
                const speed = this.crouching ? CROUCH_CREEP_SPEED : (this.isSprinting ? SPRINT_SPEED : WALK_SPEED);
                this.vx = direction * speed;
            }

            crouch(active) {
                if (this.stunTimer > 0 || this.state === 'tripped') return;
                if (!this.onGround) return;
                this.crouching = active;
                if (active) this.vx *= 0.5;
            }

            takeDamage(damage, knockbackDir, attackType = 'normal') {
                if (this.invulnerable) return;

                this.health = Math.max(0, this.health - damage);
                
                if (this.health <= 0) {
                    this.state = 'tripped';
                    this.stunTimer = 999999; // Dead
                    this.vx = knockbackDir * KNOCKBACK * 10;
                    this.vy = -200; // Death hop
                    this.onGround = false;
                    // Drop weapon on death
                    if (this.weapon) this.dropWeapon();
                    SoundFX.heavyHit();
                    return;
                }

                this.stunTimer = STUN_DURATION;
                this.vx = knockbackDir * KNOCKBACK * 10;
                
                if (attackType === 'sweeping' || attackType === 'poleSweep') {
                    this.state = 'tripped';
                    this.stunTimer = STUN_DURATION * 2;
                    this.vy = -200;
                    this.onGround = false;
                    // Drop weapon on trip!
                    if (this.weapon) this.dropWeapon();
                    SoundFX.heavyHit();
                } else {
                    SoundFX.hit();
                }
            }

            draw(ctx) {
                const boxes = this.getHitboxes();
                
                ctx.save();
                
                // Chi Shield glow effect
                if (this.chiShieldTimer > 0) {
                    ctx.shadowColor = '#3498db';
                    ctx.shadowBlur = 20 + Math.sin(performance.now() / 100) * 10;
                }

                // Stunned flash
                if (this.stunTimer > 0 && Math.floor(this.stunTimer / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x, GROUND_Y + 5, 25, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // --- Rigging (Connectors) ---
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.lineWidth = 3;
                
                const cx = boxes.body.x + boxes.body.w/2;
                const cy = boxes.body.y + boxes.body.h/2;
                
                // Body to Head
                ctx.moveTo(cx, boxes.body.y);
                ctx.lineTo(boxes.head.x + boxes.head.w/2, boxes.head.y + boxes.head.h);
                
                // Body to Limbs
                const limbs = [
                    {x: this.x + this.parts.fistF.x, y: this.y + this.parts.fistF.y},
                    {x: this.x + this.parts.fistB.x, y: this.y + this.parts.fistB.y},
                    {x: this.x + this.parts.footF.x, y: this.y + this.parts.footF.y},
                    {x: this.x + this.parts.footB.x, y: this.y + this.parts.footB.y}
                ];
                
                limbs.forEach(p => {
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();

                // --- Draw Parts ---
                const drawRect = (rect, color) => {
                    ctx.fillStyle = color;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                    ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                };

                // Back limbs first
                const fistColor = this.lightenColor(this.color, -20);
                const footColor = fistColor;
                
                // Back Foot
                drawRect({
                    x: this.x + this.parts.footB.x - 9, y: this.y + this.parts.footB.y - 9,
                    w: 18, h: 18
                }, footColor);
                
                // Back Fist
                drawRect({
                    x: this.x + this.parts.fistB.x - 8, y: this.y + this.parts.fistB.y - 8,
                    w: 16, h: 16
                }, fistColor);

                // Body
                drawRect(boxes.body, this.color);

                // Head
                const headColor = this.lightenColor(this.color, 20);
                drawRect(boxes.head, headColor);
                
                // Eyes
                ctx.fillStyle = '#000';
                const eyeY = boxes.head.y + boxes.head.h * 0.4;
                const eyeSize = 4;
                if (this.facingRight) {
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.5, eyeY, eyeSize, eyeSize);
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.75, eyeY, eyeSize, eyeSize);
                } else {
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.25 - eyeSize, eyeY, eyeSize, eyeSize);
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.5 - eyeSize, eyeY, eyeSize, eyeSize);
                }

                // Front Foot
                // Use parts directly for visual to avoid hitbox extension weirdness
                drawRect({
                    x: this.x + this.parts.footF.x - 9, y: this.y + this.parts.footF.y - 9,
                    w: 18, h: 18
                }, footColor);

                // Draw held weapon (before front fist so it looks held)
                if (this.weapon) {
                    this.drawHeldWeapon(ctx);
                }

                // Front Fist
                // Use parts directly for visual to avoid hitbox extension weirdness
                drawRect({
                    x: this.x + this.parts.fistF.x - 8, y: this.y + this.parts.fistF.y - 8,
                    w: 16, h: 16
                }, fistColor);

                // Draw Minion Bars
                if (this.isMinion && this.health > 0) {
                    const barW = 40;
                    const barH = 5;
                    const cx = this.x;
                    const cy = this.y - 110; // Above head
                    
                    // Health
                    ctx.fillStyle = '#333';
                    ctx.fillRect(cx - barW/2, cy, barW, barH);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(cx - barW/2, cy, barW * (this.health / 100), barH);
                    
                    // Stamina
                    ctx.fillStyle = '#333';
                    ctx.fillRect(cx - barW/2, cy + barH + 2, barW, barH);
                    ctx.fillStyle = '#f1c40f';
                    ctx.fillRect(cx - barW/2, cy + barH + 2, barW * (this.stamina / STAMINA_MAX), barH);
                }

                ctx.restore();
            }

            lightenColor(color, amount) {
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                return `rgb(${r},${g},${b})`;
            }
            
            drawHeldWeapon(ctx) {
                if (!this.weapon) return;
                
                const fistX = this.x + this.parts.fistF.x;
                const fistY = this.y + this.parts.fistF.y;
                const dir = this.facingRight ? 1 : -1;
                
                ctx.save();
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#fff';
                ctx.lineWidth = 2;
                
                switch (this.weapon.type) {
                    case 'sword':
                        // Sword drawn at front fist - blade points toward enemy
                        // drawWeapon draws blade at -Y, so angle œÄ/2 = blade right, -œÄ/2 = blade left
                        let swordAngle;
                        if (this.state === 'punching' || this.state === 'jumpPunch') {
                            // Thrust forward - blade horizontal toward enemy
                            swordAngle = this.facingRight ? Math.PI/2 : -Math.PI/2;
                        } else if (this.state === 'lowPunch') {
                            // Low thrust - angled down toward enemy
                            swordAngle = this.facingRight ? Math.PI/2 + Math.PI/6 : -Math.PI/2 - Math.PI/6;
                        } else {
                            // Idle - held ready, blade angled up and forward
                            swordAngle = this.facingRight ? Math.PI/3 : -Math.PI/3;
                        }
                        
                        // Offset so hand holds the handle
                        // Handle center is at local (0, 14) relative to crossguard (0,0)
                        // We want local (0, 14) to be at world (fistX, fistY)
                        // Transformation: Translate(fistX, fistY) -> Rotate(angle) -> Translate(0, -14)
                        
                        ctx.save();
                        ctx.translate(fistX, fistY);
                        ctx.rotate(swordAngle);
                        ctx.translate(0, -14); // Shift back so handle center is at pivot
                        
                        // Draw sword directly here instead of calling drawWeapon to avoid double transform
                        // Or just call drawWeapon with identity since we set up the transform
                        // But drawWeapon expects x, y, angle.
                        // Let's use the weapon's draw method but pass 0,0,0 since we handled transform
                        this.weapon.drawWeapon(ctx, 0, 0, 0, 0.7);
                        
                        ctx.restore();
                        break;
                        
                    case 'pole':
                        // Pole drawn between the two hands
                        const fistFX = this.x + this.parts.fistF.x;
                        const fistFY = this.y + this.parts.fistF.y;
                        const fistBX = this.x + this.parts.fistB.x;
                        const fistBY = this.y + this.parts.fistB.y;
                        
                        // Calculate angle from back hand to front hand
                        const dx = fistFX - fistBX;
                        const dy = fistFY - fistBY;
                        const handDist = Math.sqrt(dx * dx + dy * dy);
                        let poleAngle = Math.atan2(dy, dx);
                        
                        // Pole center is between the hands
                        const poleCenterX = (fistFX + fistBX) / 2;
                        const poleCenterY = (fistFY + fistBY) / 2;
                        
                        // Pole length extends beyond hands
                        // Ensure minimum length so it looks like a staff
                        const poleLength = Math.max(100, handDist * 3.0);
                        
                        ctx.save();
                        ctx.translate(poleCenterX, poleCenterY);
                        ctx.rotate(poleAngle);
                        
                        // Draw pole
                        const halfLen = poleLength / 2;
                        ctx.beginPath();
                        ctx.moveTo(-halfLen, -3);
                        ctx.lineTo(halfLen, -3);
                        ctx.lineTo(halfLen, 3);
                        ctx.lineTo(-halfLen, 3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Rounded caps
                        ctx.beginPath();
                        ctx.arc(-halfLen, 0, 3, Math.PI/2, -Math.PI/2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(halfLen, 0, 3, -Math.PI/2, Math.PI/2);
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.restore();
                        break;
                        
                    case 'star':
                        // Held in hand ready to throw
                        this.weapon.drawShuriken(ctx, fistX + dir * 10, fistY, 10);
                        break;
                        
                    case 'fan':
                        // Held closed in hand
                        const fanAngle = this.facingRight ? -Math.PI/4 : Math.PI + Math.PI/4;
                        ctx.save();
                        ctx.translate(fistX, fistY);
                        ctx.rotate(fanAngle);
                        ctx.scale(0.6, 0.6);
                        // Closed fan (just the ribs)
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, -30);
                        ctx.stroke();
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-2, 0, 4, 12);
                        ctx.strokeRect(-2, 0, 4, 12);
                        ctx.restore();
                        break;
                }
                
                ctx.restore();
            }
        }

        // ==================== POTION CLASS ====================
        class Potion {
            constructor(x) {
                this.x = x;
                this.y = GROUND_Y;
                this.bobTimer = Math.random() * Math.PI * 2;
                
                // Random potion type
                const typeData = POTION_TYPES[Math.floor(Math.random() * POTION_TYPES.length)];
                this.type = typeData.type;
                this.color = typeData.color;
                this.effect = typeData.effect;
                this.apply = typeData.apply;
                
                this.collected = false;
            }

            update(dt) {
                this.bobTimer += dt * 3;
            }

            draw(ctx) {
                if (this.collected) return;
                
                const bobY = Math.sin(this.bobTimer) * 3;
                const x = this.x;
                const y = this.y - 20 + bobY;
                const w = 16;
                const h = 24;
                
                ctx.save();
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(x, GROUND_Y + 2, 10, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Bottle outline (glass)
                ctx.fillStyle = 'rgba(200, 220, 255, 0.3)';
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 1.5;
                
                // Bottle body
                ctx.beginPath();
                ctx.moveTo(x - w/2, y - h/2 + 6); // Left neck bottom
                ctx.lineTo(x - w/2, y + h/2 - 4); // Left body bottom
                ctx.quadraticCurveTo(x - w/2, y + h/2, x - w/2 + 4, y + h/2); // Bottom left curve
                ctx.lineTo(x + w/2 - 4, y + h/2); // Bottom
                ctx.quadraticCurveTo(x + w/2, y + h/2, x + w/2, y + h/2 - 4); // Bottom right curve
                ctx.lineTo(x + w/2, y - h/2 + 6); // Right body top
                ctx.lineTo(x + w/4, y - h/2 + 6); // Shoulder right
                ctx.lineTo(x + w/4, y - h/2); // Neck right
                ctx.lineTo(x - w/4, y - h/2); // Neck top
                ctx.lineTo(x - w/4, y - h/2 + 6); // Neck left
                ctx.lineTo(x - w/2, y - h/2 + 6); // Shoulder left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Liquid inside (filled ~70%)
                const liquidTop = y - h/2 + 10;
                const liquidBot = y + h/2 - 2;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(x - w/2 + 2, liquidTop);
                ctx.lineTo(x - w/2 + 2, liquidBot - 4);
                ctx.quadraticCurveTo(x - w/2 + 2, liquidBot, x - w/2 + 6, liquidBot);
                ctx.lineTo(x + w/2 - 6, liquidBot);
                ctx.quadraticCurveTo(x + w/2 - 2, liquidBot, x + w/2 - 2, liquidBot - 4);
                ctx.lineTo(x + w/2 - 2, liquidTop);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Shine spot on shoulder (SVG-like ellipse)
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.beginPath();
                ctx.ellipse(x - w/4, y - h/2 + 8, 3, 5, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Small secondary shine
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.ellipse(x - w/4 + 2, y - h/2 + 14, 2, 3, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Cork
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - w/4 + 1, y - h/2 - 4, w/2 - 2, 5);
                
                ctx.restore();
            }

            getHitbox() {
                return {
                    x: this.x - 12,
                    y: this.y - 40,
                    w: 24,
                    h: 40
                };
            }
        }

        function spawnPotion(x) {
            potions.push(new Potion(x));
            SoundFX.playTone(800, 'sine', 0.1, 0.1, 200); // Spawn sound
        }

        function hasPotionNear(x, range = 50) {
            return potions.some(p => !p.collected && Math.abs(p.x - x) < range);
        }

        function checkTimedPotionSpawns() {
            if (roundTime >= POTION_SPAWN_TIME) {
                // Left side spawn
                if (!leftPotionSpawned && !hasPotionNear(LEFT_POTION_X)) {
                    leftPotionSpawned = true;
                    spawnPotion(LEFT_POTION_X);
                }
                // Right side spawn
                if (!rightPotionSpawned && !hasPotionNear(RIGHT_POTION_X)) {
                    rightPotionSpawned = true;
                    spawnPotion(RIGHT_POTION_X);
                }
            }
        }

        function checkPotionPickup() {
            if (!player || player.health <= 0) return;
            
            const playerBox = {
                x: player.x - 20,
                y: player.y - 80,
                w: 40,
                h: 80
            };
            
            potions.forEach(potion => {
                if (potion.collected) return;
                
                const potionBox = potion.getHitbox();
                if (rectsOverlap(playerBox, potionBox)) {
                    potion.collected = true;
                    potion.apply(player);
                    showMessage(potion.effect, potion.color);
                    SoundFX.playTone(600, 'sine', 0.15, 0.15, 400); // Pickup sound
                }
            });
            
            // Remove collected potions
            potions = potions.filter(p => !p.collected);
        }

        // ==================== COLLISION DETECTION ====================
        function rectsOverlap(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x &&
                   a.y < b.y + b.h && a.y + a.h > b.y;
        }

        function checkAttackHit(attacker, defender, attackType) {
            const aBoxes = attacker.getHitboxes();
            const dBoxes = defender.getHitboxes();
            
            let attackBox;
            if (attackType === 'punching' || attackType === 'lowPunch' || attackType === 'jumpPunch' || attackType === 'poleStrike' || attackType === 'poleSweep') {
                // Pole sweep is a low jab with the pole end, uses fist hitbox
                attackBox = aBoxes.fist;
            } else {
                attackBox = aBoxes.foot;
            }
            
            // Check if attack connects with head or body
            if (rectsOverlap(attackBox, dBoxes.head) || rectsOverlap(attackBox, dBoxes.body)) {
                // Crouching blocks high attacks
                if (defender.crouching && (attackType === 'punching' || attackType === 'kicking' || attackType === 'jumpPunch' || attackType === 'jumpKick')) {
                    // High attacks miss crouching opponent
                    if (attackBox.y < dBoxes.body.y + 20) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        // ==================== AI CONTROLLER ====================
        function updateAI(fighter, opponent, dt, isNearest = true, overlapDir = 0) {
            fighter.aiTimer -= dt * 1000;
            
            if (fighter.aiTimer <= 0) {
                fighter.aiTimer = 150 + Math.random() * 200;
                fighter.aiDecision = makeAIDecision(fighter, opponent, isNearest, overlapDir);
            }
            
            executeAIDecision(fighter, opponent);
        }

        function makeAIDecision(ai, opponent, isNearest = true, overlapDir = 0) {
            // 1. Non-nearest behavior
            if (!isNearest) {
                // If overlapping with another enemy, move away from THEM
                if (overlapDir !== 0) {
                    return { action: 'walk', direction: overlapDir };
                }
                
                // Otherwise, maintain "Orbit" distance from player
                const dist = Math.abs(ai.x - opponent.x);
                if (dist < 150) {
                    // Too close to player, back off
                    const dir = ai.x < opponent.x ? -1 : 1;
                    return { action: 'walk', direction: dir };
                } else if (dist > 300) {
                    // Too far, catch up
                    const dir = ai.x < opponent.x ? 1 : -1;
                    return { action: 'walk', direction: dir };
                } else {
                    // Just chill or pace
                    if (Math.random() < 0.3) return { action: 'idle' };
                    return { action: 'walk', direction: Math.random() < 0.5 ? 1 : -1 };
                }
            }

            const dist = Math.abs(ai.x - opponent.x);
            const inRange = dist < 80;
            const closeRange = dist < 50;
            const farAway = dist > 200;
            
            const rand = Math.random();
            const stats = ai.aiStats;
            
            // React to opponent attacks
            if (opponent.attackTimer > 0 && rand < stats.block) {
                if (opponent.state === 'sweeping' || opponent.state === 'lowPunch') {
                    return { action: 'jump', direction: ai.x < opponent.x ? -1 : 1 };
                } else {
                    return { action: 'crouch' };
                }
            }
            
            // Attack if in range
            if (inRange && rand < stats.aggression) {
                if (ai.crouching) {
                    return rand < 0.5 ? { action: 'sweep' } : { action: 'lowPunch' };
                }
                // Choose punch or kick based on stats
                const totalAttack = stats.punch + stats.kick;
                const punchChance = stats.punch / totalAttack;
                return rand < punchChance ? { action: 'punch' } : { action: 'kick' };
            }
            
            // Approach if far
            if (farAway && rand < stats.aggression + 0.3) {
                const dir = ai.x < opponent.x ? 1 : -1;
                // Sprint chance
                if (rand < stats.sprint) {
                    return { action: 'sprint', direction: dir };
                }
                return rand < stats.jump ? { action: 'jump', direction: dir } : { action: 'walk', direction: dir };
            }
            
            // Medium range tactics
            if (!closeRange && rand < 0.5) {
                const dir = ai.x < opponent.x ? 1 : -1;
                return { action: 'walk', direction: dir };
            }
            
            // Defensive
            if (closeRange && rand > stats.aggression) {
                if (rand < stats.block) return { action: 'crouch' };
                const dir = ai.x < opponent.x ? -1 : 1;
                return { action: 'walk', direction: dir };
            }
            
            return { action: 'idle' };
        }

        function executeAIDecision(ai, opponent) {
            if (!ai.aiDecision) return;
            
            const decision = ai.aiDecision;
            
            switch (decision.action) {
                case 'walk':
                    ai.isSprinting = false;
                    ai.walk(decision.direction);
                    ai.crouch(false);
                    break;
                case 'sprint':
                    ai.isSprinting = true;
                    ai.walk(decision.direction);
                    ai.crouch(false);
                    break;
                case 'jump':
                    ai.isSprinting = false;
                    ai.crouch(false);
                    ai.jump(decision.direction || 0);
                    ai.aiDecision = null;
                    break;
                case 'crouch':
                    ai.isSprinting = false;
                    ai.crouch(true);
                    ai.vx = 0;
                    break;
                case 'punch':
                    ai.isSprinting = false;
                    ai.crouch(false);
                    if (ai.punch()) ai.aiDecision = null;
                    break;
                case 'kick':
                    ai.isSprinting = false;
                    ai.crouch(false);
                    if (ai.kick()) ai.aiDecision = null;
                    break;
                case 'lowPunch':
                    ai.isSprinting = false;
                    ai.crouch(true);
                    if (ai.punch(true)) ai.aiDecision = null;
                    break;
                case 'sweep':
                    ai.isSprinting = false;
                    ai.crouch(true);
                    if (ai.kick(true)) ai.aiDecision = null;
                    break;
                case 'idle':
                default:
                    ai.isSprinting = false;
                    ai.vx = 0;
                    ai.crouch(false);
                    break;
            }
        }

        // ==================== PLAYER INPUT ====================
        function handlePlayerInput(fighter) {
            if (fighter.stunTimer > 0) return;
            
            const gp = getGamepadInput();

            // Movement
            let moveDir = 0;
            if (keys['ArrowLeft'] || gp.left) moveDir -= 1;
            if (keys['ArrowRight'] || gp.right) moveDir += 1;
            
            // Sprint (Gamepad override)
            if (gp.left || gp.right) {
                fighter.isSprinting = gp.sprint;
            }

            // Crouch
            const wantCrouch = keys['ArrowDown'] || gp.down;
            fighter.crouch(wantCrouch && fighter.onGround);
            
            // Jump
            if ((keys['ArrowUp'] || gp.up) && fighter.onGround && !wantCrouch) {
                fighter.jump(moveDir);
            }
            
            // Walk (if not jumping)
            if (fighter.onGround && moveDir !== 0) {
                fighter.walk(moveDir);
            } else if (fighter.onGround && moveDir === 0 && !fighter.crouching) {
                fighter.vx = 0;
            }
            
            // Punch (W key) - requires release and re-press
            const punchKey = keys['KeyW'] || keys['w'] || gp.punch;
            if (punchKey && !fighter.lastPunchKey) {
                fighter.punch(fighter.crouching);
            }
            fighter.lastPunchKey = punchKey;
            
            // Kick (D key) - requires release and re-press
            const kickKey = keys['KeyD'] || keys['d'] || (gp.kick && !gp.sprint); // Don't kick if sprinting (RB)
            if (kickKey && !fighter.lastKickKey) {
                fighter.kick(fighter.crouching);
            }
            fighter.lastKickKey = kickKey;
            
            // Interact (E key or LB) - pickup/drop weapon
            const interactKey = keys['KeyE'] || keys['e'] || gp.interact;
            if (interactKey && !fighter.lastInteractKey) {
                if (fighter.weapon) {
                    // Drop current weapon
                    fighter.dropWeapon();
                } else {
                    // Try to pick up nearby weapon
                    tryPickupWeapon(fighter);
                }
            }
            fighter.lastInteractKey = interactKey;
        }
        
        function tryPickupWeapon(fighter) {
            const pickupRange = 40;
            for (let w of weapons) {
                if (w.onGround && Math.abs(w.x - fighter.x) < pickupRange) {
                    fighter.pickupWeapon(w);
                    return;
                }
            }
        }
        
        function checkAIWeaponPickup() {
            // AI enemies try to pick up weapons if nearby and unarmed
            enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.weapon) return;
                if (enemy.stunTimer > 0) return;
                
                const pickupRange = 35;
                for (let w of weapons) {
                    if (w.onGround && Math.abs(w.x - enemy.x) < pickupRange) {
                        // 30% chance per check to pick up (prevents instant grab)
                        if (Math.random() < 0.3) {
                            enemy.pickupWeapon(w);
                        }
                        break;
                    }
                }
            });
        }

        // ==================== GAME LOGIC ====================
        function processAttacks() {
            // Check player attacks
            if (player.attackTimer > 0 && !player.hasDealtDamage && player.attackTimer > player.attackDuration - 100) {
                const attackType = player.state;
                let hitAny = false;
                
                enemies.forEach(enemy => {
                    if (enemy.health > 0 && checkAttackHit(player, enemy, attackType)) {
                        let damage = calculateDamage(attackType, player.weapon);
                        const knockDir = player.facingRight ? 1 : -1;
                        enemy.takeDamage(damage, knockDir, attackType);
                        hitAny = true;
                        playWeaponHitSound(player.weapon);
                    }
                });
                
                if (hitAny) {
                    player.hasDealtDamage = true; // Prevent multi-hit
                }
            }
            
            // Check enemy attacks
            enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                if (enemy.attackTimer > 0 && !enemy.hasDealtDamage && enemy.attackTimer > enemy.attackDuration - 100) {
                    const attackType = enemy.state;
                    if (checkAttackHit(enemy, player, attackType)) {
                        let damage = calculateDamage(attackType, enemy.weapon);
                        const knockDir = enemy.facingRight ? 1 : -1;
                        player.takeDamage(damage, knockDir, attackType);
                        enemy.hasDealtDamage = true;
                        playWeaponHitSound(enemy.weapon);
                    }
                }
            });
            
            // Check projectile hits
            processProjectiles();
        }
        
        function calculateDamage(attackType, weapon) {
            let baseDamage;
            switch (attackType) {
                case 'punching': baseDamage = PUNCH_DAMAGE; break;
                case 'lowPunch': baseDamage = LOW_PUNCH_DAMAGE; break;
                case 'jumpPunch': baseDamage = PUNCH_DAMAGE; break;
                case 'kicking': baseDamage = KICK_DAMAGE; break;
                case 'jumpKick': baseDamage = KICK_DAMAGE; break;
                case 'sweeping': baseDamage = SWEEP_DAMAGE; break;
                case 'poleStrike': baseDamage = PUNCH_DAMAGE; break;
                case 'poleSweep': baseDamage = SWEEP_DAMAGE; break;
                default: baseDamage = PUNCH_DAMAGE;
            }
            
            // Weapon damage multiplier
            if (weapon && (attackType === 'punching' || attackType === 'lowPunch' || attackType === 'jumpPunch' || 
                           attackType === 'poleStrike' || attackType === 'poleSweep')) {
                baseDamage *= WEAPON_DAMAGE_MULT;
            }
            
            return baseDamage;
        }
        
        function playWeaponHitSound(weapon) {
            if (!weapon) return;
            switch (weapon.type) {
                case 'sword': SoundFX.swordHit(); break;
                case 'pole': SoundFX.poleHit(); break;
                default: break;
            }
        }
        
        function processProjectiles() {
            projectiles = projectiles.filter(proj => {
                const remove = proj.update(1/60); // Approximate dt
                if (remove) return false;
                
                // Check hit on all fighters
                const projBox = proj.getHitbox();
                const allFighters = [player, ...enemies];
                
                for (let fighter of allFighters) {
                    // Never damage the thrower
                    if (fighter === proj.thrower) continue;
                    if (fighter.health <= 0) continue;
                    if (fighter.invulnerable) continue;
                    
                    const fBoxes = fighter.getHitboxes();
                    if (rectsOverlap(projBox, fBoxes.head) || rectsOverlap(projBox, fBoxes.body)) {
                        // Hit a non-thrower!
                        const damage = PUNCH_DAMAGE * WEAPON_DAMAGE_MULT;
                        const knockDir = proj.vx > 0 ? 1 : -1;
                        fighter.takeDamage(damage, knockDir, 'projectile');
                        
                        if (proj.type === 'star') {
                            SoundFX.starHit();
                            // Star drops to ground
                            proj.weapon.x = fighter.x;
                            proj.weapon.y = GROUND_Y;
                            proj.weapon.onGround = true;
                            proj.weapon.owner = null;
                            return false; // Remove projectile
                        } else if (proj.type === 'fan') {
                            SoundFX.fanHit();
                            // Fan returns after hit
                            proj.returning = true;
                            proj.hasHit = true;
                        }
                    }
                }
                
                return true; // Keep projectile
            });
        }

        function checkRoundEnd() {
            if (gameState === 'ko') return;

            // Win if Boss (enemies[0]) is dead
            if (enemies[0].health <= 0) {
                gameState = 'ko';
                koTimer = 2000;
                
                enemies[0].state = 'tripped';
                enemies[0].stunTimer = 9999;
                enemies[0].vx = 0;
                return;
            }

            // Lose if Player is dead
            if (player.health <= 0) {
                gameState = 'ko';
                koTimer = 2000;
                
                player.state = 'tripped';
                player.stunTimer = 9999;
                player.vx = 0;
            }
        }

        function handleKO(dt) {
            koTimer -= dt * 1000;
            if (koTimer <= 0) {
                if (player.health <= 0) {
                    lives--;
                    updateHUD();
                    if (lives > 0) {
                        gameState = 'roundEnd';
                        showMessage('TRY AGAIN!', '#ff6b6b');
                        setTimeout(() => {
                            startRound();
                        }, 2000);
                    } else {
                        gameState = 'gameOver';
                        showGameOver(false);
                    }
                } else {
                    // Victory
                    if (currentRound >= 8 && currentRound < 8) { 
                        // Wait, logic check: "Round 1 through 8 is boss +0".
                        // If we beat round 8, we go to round 9.
                        // The original code had `currentRound >= OPPONENTS.length` for victory.
                        // Now we have endless mode.
                        // So we never show "Victory" screen unless we want to cap it?
                        // User said "endless adding". So no game end.
                        
                        // Just proceed to next round
                        gameState = 'roundEnd';
                        showMessage('K.O.!', '#ff6b6b');
                        setTimeout(() => {
                            currentRound++;
                            startRound();
                        }, 2000);
                    } else {
                        // Endless mode logic
                        gameState = 'roundEnd';
                        showMessage('K.O.!', '#ff6b6b');
                        setTimeout(() => {
                            currentRound++;
                            startRound();
                        }, 2000);
                    }
                }
            }
        }

        function showMessage(text, color = '#fff') {
            const overlay = document.getElementById('messageOverlay');
            overlay.textContent = text;
            overlay.style.color = color;
            overlay.style.opacity = '1';
            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 1500);
        }

        function showGameOver(isVictory) {
            const screen = document.getElementById('gameOverScreen');
            const title = document.getElementById('gameOverTitle');
            const msg = document.getElementById('gameOverMsg');
            const roundInfo = document.getElementById('finalRound');
            
            if (isVictory) {
                title.textContent = 'üèÜ CHAMPION! üèÜ';
                title.style.color = '#ffd700';
                msg.textContent = 'You have defeated all opponents!';
            } else {
                title.textContent = 'üíÄ DEFEATED üíÄ';
                title.style.color = '#ff6b6b';
                msg.textContent = `You were defeated by ${enemies[0] ? enemies[0].name : 'Enemy'}`;
            }
            roundInfo.textContent = `Round Reached: ${currentRound}`;
            
            screen.classList.remove('hidden');
        }

        function updateHUD() {
            document.getElementById('playerHealth').style.width = `${player.health}%`;
            document.getElementById('playerStamina').style.width = `${player.stamina}%`;
            document.getElementById('livesDisplay').textContent = `‚ù§Ô∏è x ${lives}`;
            
            // Boss HUD
            if (enemies.length > 0) {
                document.getElementById('enemyHealth').style.width = `${enemies[0].health}%`;
                document.getElementById('enemyStamina').style.width = `${enemies[0].stamina}%`;
                document.getElementById('enemyName').textContent = enemies[0].name;
            }
            
            document.getElementById('roundInfo').textContent = `Round ${currentRound}`;
        }

        function togglePause() {
            if (gameState === 'fighting') {
                gameState = 'paused';
            } else if (gameState === 'paused') {
                gameState = 'fighting';
            }
        }

        function resolveEnemyCollisions(dt) {
            const minSpacing = 60; // Minimum distance between enemies
            const separationSpeed = 100; // How fast they push apart

            for (let i = 0; i < enemies.length; i++) {
                for (let j = i + 1; j < enemies.length; j++) {
                    const e1 = enemies[i];
                    const e2 = enemies[j];

                    if (e1.health <= 0 || e2.health <= 0) continue;

                    const dx = e1.x - e2.x;
                    const dist = Math.abs(dx);

                    if (dist < minSpacing) {
                        // Push apart
                        const push = (minSpacing - dist) / minSpacing; // 0 to 1 strength
                        const move = separationSpeed * push * dt;
                        
                        if (dx > 0) {
                            e1.x += move;
                            e2.x -= move;
                        } else if (dx < 0) {
                            e1.x -= move;
                            e2.x += move;
                        } else {
                            // Exact overlap, random push
                            e1.x += move;
                            e2.x -= move;
                        }
                    }
                }
            }
        }

        // ==================== GAME LOOP ====================
        function gameLoop(timestamp) {
            let dt = Math.min((timestamp - lastTime) / 1000, 0.05); // Cap dt to prevent huge jumps
            lastTime = timestamp;
            
            // Gamepad Menu Control
            const gp = getGamepadInput();
            if (gp.start && !lastStartBtn) {
                if (gameState === 'start') startGame();
                else if (gameState === 'gameOver' || gameState === 'victory') restartGame();
                else if (gameState === 'fighting' || gameState === 'paused') togglePause();
            }
            lastStartBtn = gp.start;

            if (gameState === 'fighting' || gameState === 'ko') {
                // Slow motion during KO
                if (gameState === 'ko') dt *= 0.2;

                // Handle input (only if fighting)
                if (gameState === 'fighting') handlePlayerInput(player);
                
                // Update AI (only if fighting)
                if (gameState === 'fighting') {
                    // Find nearest living enemy for coordination
                    let nearestEnemy = null;
                    let minDist = Infinity;
                    enemies.forEach(e => {
                        if (e.health > 0) {
                            const d = Math.abs(e.x - player.x);
                            if (d < minDist) { minDist = d; nearestEnemy = e; }
                        }
                    });

                    enemies.forEach(enemy => {
                        if (enemy.health > 0) {
                            const isNearest = (enemy === nearestEnemy);
                            let overlapDir = 0;

                            if (!isNearest) {
                                for (let other of enemies) {
                                    if (other !== enemy && other.health > 0) {
                                        const dx = enemy.x - other.x;
                                        if (Math.abs(dx) < 60) {
                                            // Move away from the other enemy
                                            overlapDir = dx > 0 ? 1 : -1;
                                            if (dx === 0) overlapDir = Math.random() < 0.5 ? 1 : -1;
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            updateAI(enemy, player, dt, isNearest, overlapDir);
                        }
                    });
                    
                    // Prevent NPC stacking
                    resolveEnemyCollisions(dt);
                }
                
                // Update fighters
                // Find nearest enemy for player facing
                let nearestEnemy = enemies[0];
                let minDist = Infinity;
                enemies.forEach(e => {
                    if (e.health > 0) {
                        const d = Math.abs(e.x - player.x);
                        if (d < minDist) { minDist = d; nearestEnemy = e; }
                    }
                });
                
                player.update(dt, nearestEnemy);
                
                enemies.forEach(enemy => {
                    enemy.update(dt, player);
                });

                // Remove dead minions
                enemies = enemies.filter(e => !(e.isMinion && e.health <= 0 && e.deathTimer > 2));
                
                // Update potions
                potions.forEach(p => p.update(dt));
                
                // Update weapons on ground
                weapons.forEach(w => w.update(dt));
                
                // Track round time and check for timed potion spawns
                if (gameState === 'fighting') {
                    roundTime += dt;
                    checkTimedPotionSpawns();
                    
                    // AI weapon pickup
                    checkAIWeaponPickup();
                }
                
                // Check potion pickup
                if (gameState === 'fighting') checkPotionPickup();
                
                // Process attacks
                if (gameState === 'fighting') processAttacks();
                
                // Check round end
                checkRoundEnd();
                
                // Handle KO timer
                if (gameState === 'ko') handleKO(dt / 0.2); // Pass real time for timer
                
                // Update HUD
                updateHUD();
            }
            
            // Render
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function render() {
            // Clear using logical dimensions (context is scaled)
            ctx.clearRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            
            if (!player || enemies.length === 0) return;

            // Draw ground weapons first (behind fighters)
            weapons.forEach(w => w.draw(ctx));
            
            // Draw fighters (sort by Y to fake depth)
            const allFighters = [player, ...enemies];
            allFighters.sort((a, b) => a.y - b.y); // Actually they are all on GROUND_Y usually, but maybe jump?
            // If same Y, maybe sort by Z-index logic? 
            // Let's just draw enemies then player if same Y?
            // Actually, simple loop is fine.
            
            allFighters.forEach(f => f.draw(ctx));
            
            // Draw potions
            potions.forEach(p => p.draw(ctx));
            
            // Draw projectiles (in front of everything)
            projectiles.forEach(proj => proj.draw(ctx));

            if (gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 48px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        // ==================== SCALING LOGIC ====================
        function resizeGame() {
            const container = document.getElementById('gameContainer');
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calculate scale to fit window while maintaining aspect ratio (900x600)
            const scaleX = windowWidth / 900;
            const scaleY = windowHeight / 600;
            const scale = Math.min(scaleX, scaleY);
            
            // Apply scale to container
            container.style.transform = `translate(-50%, -50%) scale(${scale})`;
            
            // Update canvas resolution for sharpness
            // We scale the internal resolution by the display scale AND device pixel ratio
            const dpr = window.devicePixelRatio || 1;
            const resolutionScale = scale * dpr;
            
            // Only resize if dimensions changed significantly to avoid thrashing
            if (Math.abs(canvas.width - ARENA_WIDTH * resolutionScale) > 1) {
                canvas.width = ARENA_WIDTH * resolutionScale;
                canvas.height = ARENA_HEIGHT * resolutionScale;
                
                // Normalize coordinate system to logical pixels
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(resolutionScale, resolutionScale);
            }
        }

        // ==================== GAME INITIALIZATION ====================
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Handle resizing
            window.addEventListener('resize', resizeGame);
            resizeGame();
            
            // Event listeners
            document.addEventListener('keydown', (e) => {
                // Modal handling
                const startScreen = document.getElementById('startScreen');
                const gameOverScreen = document.getElementById('gameOverScreen');
                const isActionKey = e.code === 'KeyW' || e.code === 'KeyD' || e.key === 'w' || e.key === 'd' || e.key === 'W' || e.key === 'D';

                if (isActionKey) {
                    if (!startScreen.classList.contains('hidden')) {
                        startGame();
                        return;
                    }
                    if (!gameOverScreen.classList.contains('hidden')) {
                        restartGame();
                        return;
                    }
                }

                // Debug Sequence
                if (e.key.length === 1) {
                    debugBuffer += e.key.toLowerCase();
                    if (debugBuffer.length > 5) debugBuffer = debugBuffer.slice(-5);
                    if (debugBuffer === 'debug') {
                        debugMode = !debugMode;
                        showMessage(debugMode ? 'DEBUG MODE ON' : 'DEBUG MODE OFF', '#00ff00');
                        debugBuffer = '';
                    }
                }

                if (debugMode && gameState === 'fighting') {
                    if (e.code === 'KeyK') {
                        enemies.forEach(enemy => {
                            enemy.health = 0;
                        });
                        showMessage('INSTA-KILL!', '#ff0000');
                    }
                    if (e.code === 'KeyZ') {
                        enemies.forEach(enemy => {
                            enemy.health = 1;
                        });
                        showMessage('1 HP LEFT!', '#ffff00');
                    }
                    if (e.key === '+' || e.code === 'Equal') {
                        currentRound++;
                        startRound();
                    }
                    if (e.key === '-' || e.code === 'Minus') {
                        if (currentRound > 1) {
                            currentRound--;
                            startRound();
                        }
                    }
                    if (e.key === 'L') {
                        lives++;
                        updateHUD();
                        showMessage(`LIVES: ${lives}`, '#00ff00');
                    }
                    if (e.key === 'l') {
                        lives = Math.max(0, lives - 1);
                        updateHUD();
                        showMessage(`LIVES: ${lives}`, '#ff0000');
                    }
                    if (e.key === 'V') {
                        if (player) player.invulnerable = true;
                        showMessage('INVULNERABLE', '#00ff00');
                    }
                    if (e.key === 'v') {
                        if (player) player.invulnerable = false;
                        showMessage('VULNERABLE', '#ff0000');
                    }
                }

                // Pause toggle
                if (e.code === 'KeyP' || e.key === 'p' || e.key === 'P') {
                    togglePause();
                }

                if (!e.repeat && gameState === 'fighting') {
                    if (['ArrowLeft', 'ArrowRight'].includes(e.code)) {
                        const now = performance.now();
                        if (lastTapKey === e.code && now - lastTapTime < 300) {
                            if (player) player.isSprinting = true;
                        }
                    }
                }
                keys[e.code] = true;
                keys[e.key] = true;
                // Prevent scrolling
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (['ArrowLeft', 'ArrowRight'].includes(e.code)) {
                    lastTapTime = performance.now();
                    lastTapKey = e.code;
                    // Stop sprinting if we release the movement key
                    if (player) player.isSprinting = false;
                }
                keys[e.code] = false;
                keys[e.key] = false;
            });
            
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            document.getElementById('helpBtn').addEventListener('click', () => {
                document.getElementById('helpScreen').classList.remove('hidden');
                if (gameState === 'fighting') togglePause();
            });
            
            document.getElementById('closeHelpBtn').addEventListener('click', () => {
                document.getElementById('helpScreen').classList.add('hidden');
            });

            // Start loop immediately for gamepad polling
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            currentRound = 1;
            lives = 5;
            startRound();
            gameState = 'fighting';
            lastTime = performance.now();
        }

        function startRound() {
            enemies = [];
            potions = []; // Clear potions on new round
            weapons = []; // Clear weapons on new round
            projectiles = []; // Clear projectiles
            roundTime = 0; // Reset round timer
            leftPotionSpawned = false; // Reset timed spawn flags
            rightPotionSpawned = false;
            let bossName, bossColor, bossStyle, bossStats;

            if (currentRound <= 8) {
                const opp = OPPONENTS[currentRound - 1];
                bossName = opp.name;
                bossColor = opp.color;
                bossStyle = opp.style;
                bossStats = opp.stats;
            } else {
                // Seeded Random
                const seed = currentRound * 12345;
                const rng = mulberry32(seed);
                
                const fName = FIRST_NAMES[Math.floor(rng() * FIRST_NAMES.length)];
                const lName = LAST_NAMES[Math.floor(rng() * LAST_NAMES.length)];
                bossName = `${fName} ${lName}`;
                
                // Random Color
                const r = Math.floor(rng() * 200 + 55);
                const g = Math.floor(rng() * 200 + 55);
                const b = Math.floor(rng() * 200 + 55);
                const toHex = (c) => c.toString(16).padStart(2, '0');
                bossColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                
                // Random Style/Stats
                const styles = ['defensive', 'aggressive', 'balanced', 'technical', 'evasive', 'master'];
                bossStyle = styles[Math.floor(rng() * styles.length)];
                
                bossStats = {
                    aggression: 0.3 + rng() * 0.6,
                    block: 0.2 + rng() * 0.6,
                    jump: 0.2 + rng() * 0.6,
                    punch: 0.3 + rng() * 0.6,
                    kick: 0.3 + rng() * 0.6,
                    sprint: 0.1 + rng() * 0.8
                };
            }
            
            // Create Boss
            const boss = new Fighter(700, false, bossColor, bossName);
            boss.aiStyle = bossStyle;
            boss.aiStats = bossStats;
            enemies.push(boss);
            
            // Give boss a random weapon (50% chance, higher in later rounds)
            const weaponChance = Math.min(0.8, 0.3 + currentRound * 0.05);
            if (Math.random() < weaponChance) {
                const weaponType = WEAPON_TYPES[Math.floor(Math.random() * WEAPON_TYPES.length)];
                const bossWeapon = new Weapon(weaponType, boss.x, GROUND_Y);
                boss.pickupWeapon(bossWeapon);
                weapons.push(bossWeapon);
            }
            
            // Create Minions (Round 9 starts with 1 minion)
            // Formula: Round 1-8: 0 minions. Round 9-16: 1 minion. Round 17-24: 2 minions.
            const numMinions = Math.floor((currentRound - 1) / 8);
            
            for (let i = 0; i < numMinions; i++) {
                // Position minions around
                const mx = 600 + (i * 100); 
                // Ensure they are within bounds
                const safeMx = Math.min(ARENA_WIDTH - 50, Math.max(50, mx));
                
                const minion = new Fighter(safeMx, false, '#888888', '', true); // isMinion = true
                minion.aiStyle = 'aggressive'; // Minions are usually aggressive fodder
                minion.aiStats = { aggression: 0.8, block: 0.1, jump: 0.2, punch: 0.5, kick: 0.5, sprint: 0.5 };
                enemies.push(minion);
            }
            
            // Preserve debug invulnerability across rounds
            const wasInvulnerable = player && player.invulnerable;
            player = new Fighter(200, true, PLAYER_COLOR, PLAYER_NAME);
            if (debugMode && wasInvulnerable) {
                player.invulnerable = true;
            }
            
            updateHUD();
            gameState = 'fighting';
            
            showMessage(`Round ${currentRound}: ${bossName}`, bossColor);
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            currentRound = 1;
            lives = 5;
            startRound();
            gameState = 'fighting';
        }

        // Start
        init();
    </script>
    <script src="parental.js" defer></script>
    <script src="assets/js/pwa.js" defer></script>
</body>
</html>
