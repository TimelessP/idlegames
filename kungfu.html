<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iron Fist Arena</title>
    <link rel="icon" type="image/png" sizes="512x512" href="assets/appicons/idle-games-512x512px.png">
    <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512px.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            background: #000;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            min-height: 100vh;
            min-height: 100dvh;
            width: 100vw;
            width: 100dvw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            touch-action: none;
        }

        #gameContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            width: 960px;
            height: 540px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            overflow: visible;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            z-index: 10;
        }

        .playerInfo {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 300px;
        }

        .playerInfo.right {
            align-items: flex-end;
        }

        .playerName {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .playerName.player { color: #4ecdc4; }
        .playerName.enemy { color: #ff6b6b; }

        .barContainer {
            width: 100%;
            height: 16px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .healthBar {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s ease;
        }

        .staminaBar {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #e67e22);
            transition: width 0.3s ease;
        }

        .barContainer.stamina {
            height: 10px;
        }

        #roundInfo {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #arena {
            position: absolute;
            top: 80px;
            left: 0;
            width: 960px;
            height: 460px;
            background: #000;
            border: 4px solid #8b4513;
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #messageOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
        }

        #startScreen, #gameOverScreen, #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }

        #startScreen h1, #gameOverScreen h1, #pauseMenu h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,100,0,0.8);
            color: #ff6600;
        }

        #startScreen p, #gameOverScreen p, #pauseMenu p {
            font-size: 20px;
            margin-bottom: 10px;
            color: #aaa;
        }

        .controls {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            text-align: left;
        }

        .controls h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
            font-size: 22px;
        }

        .key {
            display: inline-block;
            background: #333;
            border: 2px solid #555;
            border-radius: 5px;
            padding: 5px 10px;
            margin: 2px;
            font-family: monospace;
            font-size: 16px;
        }

        button {
            margin-top: 20px;
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(180deg, #ff6600 0%, #cc3300 100%);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.2s, box-shadow 0.2s;
            touch-action: manipulation;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,100,0,0.6);
        }

        /* ==================== TITLE SCREEN STYLES ==================== */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            overflow: hidden;
        }

        #titleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .menuOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            padding: 40px 20px;
            box-sizing: border-box;
        }

        .menuOverlay > * {
            pointer-events: auto;
        }

        .titleLogo {
            font-size: 56px;
            font-weight: bold;
            color: #ff6600;
            text-shadow: 0 0 30px rgba(255,100,0,0.8), 4px 4px 8px rgba(0,0,0,0.8);
            margin-bottom: 10px;
            letter-spacing: 4px;
        }

        .titleSubtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 25px;
            letter-spacing: 2px;
        }

        .menuContainer {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            width: 100%;
            max-width: 320px;
        }

        .menuBtn {
            width: 100%;
            padding: 12px 24px;
            font-size: 18px;
            background: linear-gradient(180deg, rgba(255,102,0,0.9) 0%, rgba(204,51,0,0.9) 100%);
            border: 3px solid rgba(255,150,50,0.6);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.2s ease;
            touch-action: manipulation;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }

        .menuBtn:hover, .menuBtn.selected {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255,100,0,0.7);
            border-color: rgba(255,200,100,0.9);
        }

        .menuBtn:disabled {
            background: linear-gradient(180deg, rgba(100,100,100,0.7) 0%, rgba(60,60,60,0.7) 100%);
            border-color: rgba(100,100,100,0.4);
            color: rgba(255,255,255,0.4);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .menuBtn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .menuBtn.secondary {
            background: linear-gradient(180deg, rgba(78,205,196,0.8) 0%, rgba(45,150,145,0.8) 100%);
            border-color: rgba(100,220,210,0.6);
            font-size: 16px;
            padding: 10px 24px;
        }

        .menuBtn.secondary:hover, .menuBtn.secondary.selected {
            box-shadow: 0 0 25px rgba(78,205,196,0.7);
            border-color: rgba(150,255,245,0.9);
        }

        .comingSoon {
            font-size: 10px;
            opacity: 0.6;
            display: block;
            margin-top: 4px;
            letter-spacing: 1px;
        }

        /* ==================== SETTINGS SCREEN STYLES ==================== */
        #settingsScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, rgba(20,20,40,0.95) 100%);
            z-index: 110;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .settingsHeader {
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255,102,0,0.3);
        }

        .settingsHeader h1 {
            font-size: 32px;
            color: #ff6600;
            text-shadow: 0 0 20px rgba(255,100,0,0.5);
            margin: 0;
        }

        .settingsBody {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .settingsTabs {
            width: 200px;
            min-width: 200px;
            background: rgba(0,0,0,0.3);
            border-right: 2px solid rgba(255,102,0,0.2);
            display: flex;
            flex-direction: column;
            padding: 15px 0;
            gap: 5px;
        }

        .settingsTab {
            padding: 14px 20px;
            margin: 0 10px;
            font-size: 13px;
            color: #aaa;
            cursor: pointer;
            border: none;
            background: transparent;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            border-radius: 4px;
        }

        .settingsTab:hover, .settingsTab:focus {
            color: #fff;
            background: rgba(255,102,0,0.15);
            outline: none;
        }

        .settingsTab:focus {
            border-left-color: rgba(255,102,0,0.5);
        }

        .settingsTab.active {
            color: #ff6600;
            background: rgba(255,102,0,0.2);
            border-left-color: #ff6600;
        }

        .settingsContent {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .settingsPanel {
            display: none;
        }

        .settingsPanel.active {
            display: block;
        }

        /* Custom scrollbar styling */
        .settingsContent::-webkit-scrollbar {
            width: 8px;
        }

        .settingsContent::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        .settingsContent::-webkit-scrollbar-thumb {
            background: rgba(255,102,0,0.4);
            border-radius: 4px;
        }

        .settingsContent::-webkit-scrollbar-thumb:hover {
            background: rgba(255,102,0,0.6);
        }

        /* Firefox scrollbar */
        .settingsContent {
            scrollbar-width: thin;
            scrollbar-color: rgba(255,102,0,0.4) rgba(0,0,0,0.3);
        }

        .playerConfigSection {
            margin-bottom: 30px;
        }

        .playerConfigHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .playerConfigHeader h2 {
            font-size: 20px;
            color: #4ecdc4;
            margin: 0;
        }

        .controlsGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
            gap: 10px;
        }

        .controlMapping {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            gap: 10px;
        }

        .controlMapping:hover {
            border-color: rgba(255,102,0,0.4);
        }

        .controlMapping.listening {
            border-color: #ff6600;
            box-shadow: 0 0 10px rgba(255,102,0,0.3);
        }

        .controlKeyGroup {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .controlLabel {
            font-size: 14px;
            color: #ccc;
            flex-shrink: 0;
        }

        .controlKey {
            padding: 5px 8px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            color: #fff;
            font-family: monospace;
            font-size: 11px;
            min-width: 50px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .controlKey.listening {
            border-color: #ff6600;
            animation: pulse 1s infinite;
        }

        .controlKey:hover, .controlKey:focus {
            border-color: #ff6600;
            background: rgba(255,102,0,0.2);
            outline: none;
        }

        .controlKey.listening {
            background: rgba(255,102,0,0.3);
            border-color: #ff6600;
        }

        .settingsActions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .presetSlots {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .presetLabel {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .presetButtons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .presetSlot {
            width: 50px;
            min-width: 50px;
            max-width: 50px;
            height: 38px;
            border-radius: 6px;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.3);
            color: #888;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            flex-grow: 0;
        }

        .presetSlot:hover {
            border-color: #ff6600;
            color: #fff;
            background: rgba(255,102,0,0.2);
        }

        .presetSlot.active {
            border-color: #ff6600;
            background: rgba(255,102,0,0.3);
            color: #ff6600;
            box-shadow: 0 0 10px rgba(255,102,0,0.4);
        }

        .presetSlot:focus {
            outline: none;
            border-color: #ff6600;
            box-shadow: 0 0 8px rgba(255,102,0,0.5);
        }

        .presetSlot.modified {
            border-color: rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.05);
        }

        .actionBtn {
            padding: 10px 20px;
            font-size: 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .actionBtn:hover, .actionBtn:focus {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
            outline: none;
        }

        .actionBtn.danger {
            border-color: rgba(255,100,100,0.4);
            color: #ff6b6b;
        }

        .actionBtn.danger:hover, .actionBtn.danger:focus {
            background: rgba(255,100,100,0.2);
        }

        .settingsFooter {
            padding: 15px 20px;
            border-top: 2px solid rgba(255,102,0,0.3);
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .settingsFooter .menuBtn {
            max-width: 320px;
        }

        .gamepadIndicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 12px;
            color: #888;
        }

        .gamepadDot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #555;
        }

        .gamepadDot.connected {
            background: #4ecdc4;
            box-shadow: 0 0 8px rgba(78,205,196,0.6);
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Title Screen (Canvas-based with overlay menu) -->
        <div id="titleScreen">
            <canvas id="titleCanvas"></canvas>
            <div class="menuOverlay">
                <div class="titleLogo">IRON FIST ARENA</div>
                <div class="titleSubtitle">Defeat all opponents to become the champion</div>
                <div class="menuContainer" id="mainMenu">
                    <button class="menuBtn selected" id="btnOnePlayer" data-index="0">One Player</button>
                    <button class="menuBtn" id="btnTwoPlayerCoop" data-index="1" disabled>
                        Two Players (Co-op)
                        <span class="comingSoon">Coming Soon</span>
                    </button>
                    <button class="menuBtn" id="btnTwoPlayerPvP" data-index="2" disabled>
                        Two Players (PvP)
                        <span class="comingSoon">Coming Soon</span>
                    </button>
                    <button class="menuBtn secondary" id="btnSettings" data-index="3">Settings</button>
                </div>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settingsScreen" class="hidden">
            <div class="settingsHeader">
                <h1>‚öôÔ∏è Settings</h1>
            </div>
            <div class="settingsBody">
                <div class="settingsTabs">
                    <button class="settingsTab active" data-panel="player1">Player 1</button>
                    <button class="settingsTab" data-panel="player2">Player 2</button>
                    <button class="settingsTab" data-panel="gamepad">Gamepads</button>
                    <button class="settingsTab" data-panel="debug">Debug</button>
                    <button class="settingsTab" data-panel="about">About</button>
                </div>
                <div class="settingsContent">
                    <!-- Player 1 Controls -->
                    <div class="settingsPanel active" id="panelPlayer1">
                        <div class="playerConfigSection">
                            <div class="playerConfigHeader">
                                <h2>Player 1 Controls</h2>
                            </div>
                            <div class="controlsGrid" id="p1ControlsGrid">
                                <!-- Populated by JS -->
                            </div>
                            <div class="settingsActions">
                                <button class="actionBtn" id="p1ResetBtn">Reset to Default</button>
                                <button class="actionBtn" id="swapPlayersBtn">Swap P1 ‚Üî P2</button>
                            </div>
                            <div class="presetSlots" id="p1PresetSlots">
                                <span class="presetLabel">Presets:</span>
                                <div class="presetButtons">
                                    <button class="presetSlot active" data-player="1" data-preset="0">1</button>
                                    <button class="presetSlot" data-player="1" data-preset="1">2</button>
                                    <button class="presetSlot" data-player="1" data-preset="2">3</button>
                                    <button class="presetSlot" data-player="1" data-preset="3">4</button>
                                    <button class="presetSlot" data-player="1" data-preset="4">5</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Player 2 Controls -->
                    <div class="settingsPanel" id="panelPlayer2">
                        <div class="playerConfigSection">
                            <div class="playerConfigHeader">
                                <h2>Player 2 Controls</h2>
                            </div>
                            <div class="controlsGrid" id="p2ControlsGrid">
                                <!-- Populated by JS -->
                            </div>
                            <div class="settingsActions">
                                <button class="actionBtn" id="p2ResetBtn">Reset to Default</button>
                                <button class="actionBtn" id="swapPlayersBtn2">Swap P1 ‚Üî P2</button>
                            </div>
                            <div class="presetSlots" id="p2PresetSlots">
                                <span class="presetLabel">Presets:</span>
                                <div class="presetButtons">
                                    <button class="presetSlot active" data-player="2" data-preset="0">1</button>
                                    <button class="presetSlot" data-player="2" data-preset="1">2</button>
                                    <button class="presetSlot" data-player="2" data-preset="2">3</button>
                                    <button class="presetSlot" data-player="2" data-preset="3">4</button>
                                    <button class="presetSlot" data-player="2" data-preset="4">5</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Gamepad Panel -->
                    <div class="settingsPanel" id="panelGamepad">
                        <div class="playerConfigSection">
                            <div class="playerConfigHeader">
                                <h2>Gamepad Configuration</h2>
                            </div>
                            <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                                <div class="gamepadIndicator">
                                    <span class="gamepadDot" id="gp1Dot"></span>
                                    <span>Gamepad 1: <span id="gp1Status">Not Connected</span></span>
                                </div>
                                <div class="gamepadIndicator">
                                    <span class="gamepadDot" id="gp2Dot"></span>
                                    <span>Gamepad 2: <span id="gp2Status">Not Connected</span></span>
                                </div>
                            </div>
                            <p style="color: #888; font-size: 14px; line-height: 1.6;">
                                Gamepads are automatically detected. Player 1 uses Gamepad 1, Player 2 uses Gamepad 2.<br>
                                Press any button on a gamepad to wake it up if not detected.
                            </p>
                            <div class="controlsGrid" id="gpControlsGrid" style="margin-top: 20px;">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>

                    <!-- Debug Panel -->
                    <div class="settingsPanel" id="panelDebug">
                        <div class="playerConfigSection">
                            <div class="playerConfigHeader">
                                <h2>Debug Controls</h2>
                            </div>
                            <p style="color: #888; font-size: 14px; line-height: 1.6; margin-bottom: 15px;">
                                These keys are active during gameplay. Type "debug" anywhere to disable.
                            </p>
                            <div class="controlsGrid" id="debugControlsGrid">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>

                    <!-- About Panel -->
                    <div class="settingsPanel" id="panelAbout">
                        <div class="playerConfigSection">
                            <div class="playerConfigHeader">
                                <h2>About Iron Fist Arena</h2>
                            </div>
                            <div style="color: #aaa; font-size: 14px; line-height: 1.8;">
                                <p style="margin-bottom: 15px;">
                                    A retro-style kung fu fighting game built with HTML5 Canvas and vanilla JavaScript.
                                </p>
                                <h3 style="color: #4ecdc4; font-size: 16px; margin-bottom: 10px;">Authors</h3>
                                <ul style="margin: 0 0 15px 20px; padding: 0;">
                                    <li>Timeless Prototype</li>
                                    <li>Claude Opus 4.5 (Preview)</li>
                                    <li>Gemini 2.5 Pro (Preview)</li>
                                </ul>
                                <div style="margin-top: 15px;">
                                    <div style="margin-bottom: 10px; font-weight: 600; color: #fff;">Support the Developer:</div>
                                    <a href="https://buymeacoffee.com/timelessp" target="_blank" rel="noopener noreferrer" aria-label="Buy me a coffee">
                                        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 45px; width: auto; display: block; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);" />
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="settingsFooter">
                <button class="menuBtn secondary" id="btnBackToTitle">Back to Title</button>
            </div>
        </div>

        <div id="hud" class="hidden">
            <div class="playerInfo">
                <div class="playerName player" id="playerName">Shadow Dragon <span id="livesDisplay" style="font-size: 0.8em; margin-left: 10px;"></span></div>
                <div class="barContainer">
                    <div class="healthBar" id="playerHealth" style="width: 100%"></div>
                </div>
                <div class="barContainer stamina">
                    <div class="staminaBar" id="playerStamina" style="width: 100%"></div>
                </div>
            </div>
            <div id="roundInfo">Round 1</div>
            <div class="playerInfo right">
                <div class="playerName enemy" id="enemyName">Iron Monk</div>
                <div class="barContainer">
                    <div class="healthBar" id="enemyHealth" style="width: 100%"></div>
                </div>
                <div class="barContainer stamina">
                    <div class="staminaBar" id="enemyStamina" style="width: 100%"></div>
                </div>
            </div>
        </div>

        <div id="arena" style="display: none;">
            <canvas id="canvas"></canvas>
        </div>

        <div id="messageOverlay"></div>

        <div id="gameOverScreen" class="hidden">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="gameOverMsg">You were defeated!</p>
            <p id="finalRound"></p>
            <button id="restartBtn">Fight Again</button>
        </div>

        <div id="pauseMenu" class="hidden">
            <h1>Paused</h1>
            <div class="menuContainer">
                <button class="menuBtn selected" id="btnResume">Continue</button>
                <button class="menuBtn secondary" id="btnQuitToTitle">Quit to Title</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== GAME CONSTANTS ====================
        const GROUND_Y = 400;
        const ARENA_WIDTH = 960;
        const ARENA_HEIGHT = 460;
        const GRAVITY = 1800;
        const JUMP_VELOCITY = -600;
        const WALK_SPEED = 200;
        const SPRINT_SPEED = 400;
        const CROUCH_CREEP_SPEED = 80;
        const STUN_DURATION = 500;
        const KNOCKBACK = 30;

        const STAMINA_MAX = 100;
        const STAMINA_REGEN = 20;
        const STAMINA_CROUCH_DRAIN = 15;

        // ==================== INPUT CONFIGURATION SYSTEM ====================
        const STORAGE_KEY = 'ironFistArena_controls';
        
        // Control action names
        const CONTROL_ACTIONS = ['left', 'right', 'up', 'down', 'punch', 'kick', 'interact', 'pause'];
        const CONTROL_LABELS = {
            left: 'Move Left',
            right: 'Move Right',
            up: 'Jump',
            down: 'Crouch',
            punch: 'Punch',
            kick: 'Kick',
            interact: 'Interact',
            pause: 'Pause'
        };
        
        // Debug key actions (configurable)
        const DEBUG_ACTIONS = ['killAll', 'oneHp', 'nextRound', 'prevRound', 'addLife', 'removeLife', 'invulnOn', 'invulnOff', 'addPotion', 'removePotion'];
        const DEBUG_LABELS = {
            killAll: 'Kill All Enemies',
            oneHp: 'Set Enemies to 1 HP',
            nextRound: 'Next Round',
            prevRound: 'Previous Round',
            addLife: 'Add Life',
            removeLife: 'Remove Life',
            invulnOn: 'Invulnerable ON',
            invulnOff: 'Invulnerable OFF',
            addPotion: 'Add Traitor Potion',
            removePotion: 'Remove Traitor Potion'
        };
        
        const DEFAULT_DEBUG_KEYS = {
            killAll: 'Digit1',
            oneHp: 'Digit2',
            nextRound: 'Digit3',
            prevRound: 'Digit4',
            addLife: 'Digit5',
            removeLife: 'Digit6',
            invulnOn: 'Digit7',
            invulnOff: 'Digit8',
            addPotion: 'Comma',
            removePotion: 'Period'
        };
        
        // Unified binding format: each binding can be:
        // - String like 'KeyA' for keyboard
        // - Object like {type:'button', btn:0} or {type:'axis', axis:0, dir:1} for gamepad
        // - null for unbound
        
        // Default P1 bindings: [keyboard, gamepad]
        // WASD movement, C/X punch/kick, E interact, Q pause
        const DEFAULT_P1_BINDINGS = {
            left: ['KeyA', {type:'axis', axis:0, dir:-1}],
            right: ['KeyD', {type:'axis', axis:0, dir:1}],
            up: ['KeyW', {type:'button', btn:12}],  // DPad Up
            down: ['KeyS', {type:'button', btn:13}], // DPad Down
            punch: ['KeyC', {type:'button', btn:2}], // X
            kick: ['KeyX', {type:'button', btn:1}],  // B
            interact: ['KeyE', {type:'button', btn:4}], // LB
            pause: ['KeyQ', {type:'button', btn:9}]  // Start
        };
        
        // Default P2 bindings: [keyboard, gamepad]
        // IJKL movement, M/N punch/kick, O interact, P pause
        const DEFAULT_P2_BINDINGS = {
            left: ['KeyJ', {type:'axis', axis:0, dir:-1}],
            right: ['KeyL', {type:'axis', axis:0, dir:1}],
            up: ['KeyI', {type:'button', btn:12}],
            down: ['KeyK', {type:'button', btn:13}],
            punch: ['KeyM', {type:'button', btn:2}],
            kick: ['KeyN', {type:'button', btn:1}],
            interact: ['KeyO', {type:'button', btn:4}],
            pause: ['KeyP', {type:'button', btn:9}]
        };
        
        // Helper to deep clone bindings (handles nested objects and arrays)
        function cloneBindings(template) {
            const clone = {};
            for (const key in template) {
                if (Array.isArray(template[key])) {
                    clone[key] = template[key].map(b => 
                        b && typeof b === 'object' ? {...b} : b
                    );
                } else if (template[key] && typeof template[key] === 'object') {
                    clone[key] = {...template[key]};
                } else {
                    clone[key] = template[key];
                }
            }
            return clone;
        }

        // Current control configuration
        let controlConfig = {
            player1: {
                activePreset: 0,
                presets: [
                    cloneBindings(DEFAULT_P1_BINDINGS),
                    cloneBindings(DEFAULT_P1_BINDINGS),
                    cloneBindings(DEFAULT_P1_BINDINGS),
                    cloneBindings(DEFAULT_P1_BINDINGS),
                    cloneBindings(DEFAULT_P1_BINDINGS)
                ],
                gamepadIndex: 0
            },
            player2: {
                activePreset: 0,
                presets: [
                    cloneBindings(DEFAULT_P2_BINDINGS),
                    cloneBindings(DEFAULT_P2_BINDINGS),
                    cloneBindings(DEFAULT_P2_BINDINGS),
                    cloneBindings(DEFAULT_P2_BINDINGS),
                    cloneBindings(DEFAULT_P2_BINDINGS)
                ],
                gamepadIndex: 1
            },
            debug: { ...DEFAULT_DEBUG_KEYS }
        };
        
        // Load saved configuration
        function loadControlConfig() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to handle missing keys
                    controlConfig = {
                        player1: { ...controlConfig.player1, ...parsed.player1 },
                        player2: { ...controlConfig.player2, ...parsed.player2 },
                        debug: { ...controlConfig.debug, ...parsed.debug }
                    };
                    // Migrate old single-key bindings to array format
                    migrateBindingsToArray(controlConfig.player1);
                    migrateBindingsToArray(controlConfig.player2);
                }
            } catch (e) {
                console.warn('Could not load control config:', e);
            }
        }
        
        // Migrate old single-key bindings to [primary, secondary] array format
        function migrateBindingsToArray(playerConfig) {
            if (!playerConfig.presets) return;
            playerConfig.presets.forEach(preset => {
                for (const action of CONTROL_ACTIONS) {
                    if (preset[action] && !Array.isArray(preset[action])) {
                        preset[action] = [preset[action], null];
                    }
                }
            });
        }
        
        // Save configuration
        function saveControlConfig() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(controlConfig));
            } catch (e) {
                console.warn('Could not save control config:', e);
            }
        }
        
        // Get active keybinds for a player
        function getPlayerKeybinds(playerNum) {
            const pConfig = playerNum === 1 ? controlConfig.player1 : controlConfig.player2;
            return pConfig.presets[pConfig.activePreset];
        }
        
        // Get the gamepad for a player
        function getPlayerGamepad(playerNum) {
            const pConfig = playerNum === 1 ? controlConfig.player1 : controlConfig.player2;
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            return gamepads[pConfig.gamepadIndex] || null;
        }
        
        // Check if a single binding matches keyboard key
        function bindingMatchesKey(binding, keyCode) {
            if (!binding || typeof binding === 'object') return false;
            return binding === keyCode;
        }
        
        // Check if a single binding matches current gamepad state
        function bindingMatchesGamepad(binding, gamepad) {
            if (!binding || typeof binding !== 'object' || !gamepad) return false;
            if (binding.type === 'button') {
                return gamepad.buttons[binding.btn]?.pressed;
            } else if (binding.type === 'axis') {
                const val = gamepad.axes[binding.axis] || 0;
                return binding.dir < 0 ? val < -0.5 : val > 0.5;
            }
            return false;
        }
        
        // Check if a key code matches any binding for an action (keyboard only)
        function isKeyBound(binds, action, keyCode) {
            const binding = binds[action];
            if (Array.isArray(binding)) {
                return bindingMatchesKey(binding[0], keyCode) || bindingMatchesKey(binding[1], keyCode);
            }
            return bindingMatchesKey(binding, keyCode);
        }
        
        // Check if any bound input for an action is active (keyboard + gamepad)
        function isActionPressed(binds, action, gamepad) {
            const binding = binds[action];
            if (Array.isArray(binding)) {
                const b0 = binding[0];
                const b1 = binding[1];
                // Check both slots against keyboard and gamepad
                const key0 = b0 && typeof b0 === 'string' && keys[b0];
                const key1 = b1 && typeof b1 === 'string' && keys[b1];
                const gp0 = bindingMatchesGamepad(b0, gamepad);
                const gp1 = bindingMatchesGamepad(b1, gamepad);
                return key0 || key1 || gp0 || gp1;
            }
            // Legacy single binding
            if (typeof binding === 'string') return keys[binding];
            return bindingMatchesGamepad(binding, gamepad);
        }
        
        // Format binding for display
        function formatBindingName(binding) {
            if (!binding) return '---';
            
            // Gamepad binding
            if (typeof binding === 'object') {
                if (binding.type === 'button') {
                    const btnNames = {
                        0: 'A', 1: 'B', 2: 'X', 3: 'Y',
                        4: 'LB', 5: 'RB', 6: 'LT', 7: 'RT',
                        8: 'Back', 9: 'Start', 10: 'LS', 11: 'RS',
                        12: 'D‚Üë', 13: 'D‚Üì', 14: 'D‚Üê', 15: 'D‚Üí'
                    };
                    return 'üéÆ' + (btnNames[binding.btn] || `B${binding.btn}`);
                } else if (binding.type === 'axis') {
                    const axisNames = { 0: 'LX', 1: 'LY', 2: 'RX', 3: 'RY' };
                    const dir = binding.dir < 0 ? '-' : '+';
                    return 'üéÆ' + (axisNames[binding.axis] || `A${binding.axis}`) + dir;
                }
                return 'üéÆ?';
            }
            
            // Keyboard binding
            const map = {
                'ArrowLeft': '‚Üê', 'ArrowRight': '‚Üí', 'ArrowUp': '‚Üë', 'ArrowDown': '‚Üì',
                'Space': 'Space', 'Escape': 'Esc', 'Enter': 'Enter', 'Tab': 'Tab',
                'ShiftLeft': 'L-Shift', 'ShiftRight': 'R-Shift',
                'ControlLeft': 'L-Ctrl', 'ControlRight': 'R-Ctrl',
                'AltLeft': 'L-Alt', 'AltRight': 'R-Alt',
                'BracketLeft': '[', 'BracketRight': ']',
                'Equal': '=', 'Minus': '-',
                'Semicolon': ';', 'Quote': "'",
                'Comma': ',', 'Period': '.', 'Slash': '/',
                'Backslash': '\\', 'Backquote': '`'
            };
            if (map[binding]) return map[binding];
            if (binding.startsWith('Key')) return binding.slice(3);
            if (binding.startsWith('Digit')) return binding.slice(5);
            if (binding.startsWith('Numpad')) return 'Num' + binding.slice(6);
            return binding;
        }
        
        // Legacy alias
        function formatKeyName(code) {
            return formatBindingName(code);
        }
        
        // Swap player configs
        function swapPlayerConfigs() {
            const temp = { ...controlConfig.player1 };
            controlConfig.player1 = { ...controlConfig.player2 };
            controlConfig.player2 = temp;
            // Also swap gamepad indices
            const tempGp = controlConfig.player1.gamepadIndex;
            controlConfig.player1.gamepadIndex = controlConfig.player2.gamepadIndex;
            controlConfig.player2.gamepadIndex = tempGp;
            saveControlConfig();
        }
        
        // Reset player to defaults
        function resetPlayerConfig(playerNum) {
            const defaults = playerNum === 1 ? DEFAULT_P1_BINDINGS : DEFAULT_P2_BINDINGS;
            const pConfig = playerNum === 1 ? controlConfig.player1 : controlConfig.player2;
            pConfig.presets[pConfig.activePreset] = cloneBindings(defaults);
            saveControlConfig();
        }

        // ==================== TITLE SCREEN SYSTEM ====================
        let titleCanvas, titleCtx;
        let titleAnimTime = 0;
        let menuSelectedIndex = 0;
        let currentScreen = 'title'; // 'title', 'settings', 'game'
        let settingsListeningFor = null; // { player: 1|2, action: 'punch', element: DOM }
        
        // Title screen character animation
        const titleCharacter = {
            x: ARENA_WIDTH * 0.75,
            y: GROUND_Y,
            pose: 'idle',
            animTimer: 0,
            facingRight: false
        };
        
        // Particle system for title screen
        let titleParticles = [];
        
        function initTitleParticles() {
            titleParticles = [];
            for (let i = 0; i < 30; i++) {
                titleParticles.push({
                    x: Math.random() * ARENA_WIDTH,
                    y: Math.random() * ARENA_HEIGHT,
                    vx: (Math.random() - 0.5) * 20,
                    vy: -Math.random() * 30 - 10,
                    size: Math.random() * 3 + 1,
                    alpha: Math.random() * 0.5 + 0.2,
                    color: Math.random() < 0.5 ? '#ff6600' : '#4ecdc4'
                });
            }
        }
        
        function updateTitleParticles(dt) {
            titleParticles.forEach(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.alpha -= dt * 0.1;
                
                // Respawn at bottom
                if (p.y < -10 || p.alpha <= 0) {
                    p.x = Math.random() * ARENA_WIDTH;
                    p.y = ARENA_HEIGHT + 10;
                    p.alpha = Math.random() * 0.5 + 0.2;
                    p.vy = -Math.random() * 30 - 10;
                }
            });
        }
        
        function renderTitleScreen(dt) {
            titleAnimTime += dt;
            updateTitleParticles(dt);
            
            const ctx = titleCtx;
            ctx.clearRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT + 80);
            
            // Draw background - reuse Dojo arena style
            drawTitleBackground(ctx);
            
            // Draw particles
            titleParticles.forEach(p => {
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw character with idle animation
            drawTitleCharacter(ctx);
            
            // Draw ground reflection/glow
            const gradient = ctx.createLinearGradient(0, GROUND_Y, 0, GROUND_Y + 60);
            gradient.addColorStop(0, 'rgba(255, 100, 0, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, GROUND_Y, ARENA_WIDTH, 60);
        }
        
        function drawTitleBackground(ctx) {
            // Dark gradient background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT + 80);
            bgGrad.addColorStop(0, '#0a0a15');
            bgGrad.addColorStop(0.5, '#151525');
            bgGrad.addColorStop(1, '#0a0a12');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT + 80);
            
            // Draw distant mountains/silhouettes
            ctx.fillStyle = 'rgba(30, 30, 50, 0.8)';
            ctx.beginPath();
            ctx.moveTo(0, ARENA_HEIGHT * 0.6);
            for (let x = 0; x <= ARENA_WIDTH; x += 80) {
                const h = Math.sin(x * 0.01 + 1) * 50 + Math.sin(x * 0.02) * 30 + 100;
                ctx.lineTo(x, ARENA_HEIGHT * 0.6 - h);
            }
            ctx.lineTo(ARENA_WIDTH, ARENA_HEIGHT);
            ctx.lineTo(0, ARENA_HEIGHT);
            ctx.closePath();
            ctx.fill();
            
            // Closer mountains
            ctx.fillStyle = 'rgba(20, 20, 35, 0.9)';
            ctx.beginPath();
            ctx.moveTo(0, ARENA_HEIGHT * 0.7);
            for (let x = 0; x <= ARENA_WIDTH; x += 60) {
                const h = Math.sin(x * 0.015 + 2) * 40 + Math.sin(x * 0.025) * 25 + 60;
                ctx.lineTo(x, ARENA_HEIGHT * 0.7 - h);
            }
            ctx.lineTo(ARENA_WIDTH, ARENA_HEIGHT);
            ctx.lineTo(0, ARENA_HEIGHT);
            ctx.closePath();
            ctx.fill();
            
            // Draw moon
            const moonX = ARENA_WIDTH * 0.15;
            const moonY = 80;
            const moonR = 40;
            
            // Moon glow
            const moonGlow = ctx.createRadialGradient(moonX, moonY, moonR * 0.5, moonX, moonY, moonR * 3);
            moonGlow.addColorStop(0, 'rgba(255, 240, 200, 0.3)');
            moonGlow.addColorStop(0.5, 'rgba(255, 200, 100, 0.1)');
            moonGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = moonGlow;
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonR * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Moon body
            ctx.fillStyle = '#fffde7';
            ctx.beginPath();
            ctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
            ctx.fill();
            
            // Moon craters
            ctx.fillStyle = 'rgba(200, 190, 170, 0.3)';
            ctx.beginPath();
            ctx.arc(moonX - 10, moonY - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(moonX + 15, moonY + 10, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(moonX + 5, moonY - 15, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw floor
            ctx.fillStyle = '#1a1a25';
            ctx.fillRect(0, GROUND_Y, ARENA_WIDTH, 140);
            
            // Floor shine
            const floorGrad = ctx.createLinearGradient(0, GROUND_Y, 0, GROUND_Y + 20);
            floorGrad.addColorStop(0, 'rgba(255, 100, 0, 0.15)');
            floorGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = floorGrad;
            ctx.fillRect(0, GROUND_Y, ARENA_WIDTH, 20);
            
            // Draw some bamboo/pillars for atmosphere
            for (let i = 0; i < 5; i++) {
                const x = 50 + i * 220;
                const h = 200 + Math.sin(i * 2) * 50;
                
                // Pillar shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(x + 3, GROUND_Y - h + 3, 15, h);
                
                // Pillar
                const pillarGrad = ctx.createLinearGradient(x, 0, x + 15, 0);
                pillarGrad.addColorStop(0, '#4a3728');
                pillarGrad.addColorStop(0.5, '#6b4c35');
                pillarGrad.addColorStop(1, '#3d2d1f');
                ctx.fillStyle = pillarGrad;
                ctx.fillRect(x, GROUND_Y - h, 15, h);
            }
            
            // Draw stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 50; i++) {
                const sx = (i * 137.5) % ARENA_WIDTH;
                const sy = (i * 73.3) % (ARENA_HEIGHT * 0.4);
                const twinkle = Math.sin(titleAnimTime * 3 + i) * 0.5 + 0.5;
                ctx.globalAlpha = 0.3 + twinkle * 0.5;
                ctx.beginPath();
                ctx.arc(sx, sy, 1 + twinkle, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        function drawTitleCharacter(ctx) {
            // Match the in-game Fighter class draw style exactly using POSES.idle values
            const t = titleAnimTime;
            const breathe = Math.sin(t * 2) * 2;
            
            const x = titleCharacter.x;
            const y = titleCharacter.y;
            const color = '#4ecdc4'; // Player color
            const facingRight = false; // Face left towards menu
            
            // Use exact POSES.idle values with subtle breathing animation
            // idle: head:{x:0,y:-80}, body:{x:0,y:-40,w:40,h:60}, fistF:{x:25,y:-55}, etc.
            const parts = {
                head: { x: 0, y: -80 + breathe * 0.3 },
                body: { x: 0, y: -40, w: 40, h: 60 },  // Match POSES.idle exactly
                fistF: { x: facingRight ? 25 : -25, y: -55 + breathe * 0.5 },
                fistB: { x: facingRight ? 10 : -10, y: -50 + breathe * 0.3 },
                footF: { x: facingRight ? 15 : -15, y: -5 },
                footB: { x: facingRight ? -15 : 15, y: -5 }
            };
            
            ctx.save();
            
            // Shadow (same as Fighter class)
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + 5, 25, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Helper to draw rectangles matching Fighter style
            const drawRect = (rect, fillColor) => {
                ctx.fillStyle = fillColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
            };
            
            // Lighten/darken helper
            const adjustColor = (col, amt) => {
                const num = parseInt(col.slice(1), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amt));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amt));
                const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
                return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
            };
            
            const limbColor = adjustColor(color, -20);
            const headColor = adjustColor(color, 20);
            
            // --- Rigging (Connectors) like Fighter class ---
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 3;
            
            // Body is drawn centered: top at (y + body.y - body.h/2)
            const bodyTop = y + parts.body.y - parts.body.h/2;
            const bodyCenter = y + parts.body.y;
            const cx = x + parts.body.x;
            
            // Body to Head - head bottom connects to body top
            ctx.moveTo(cx, bodyTop);
            ctx.lineTo(x + parts.head.x, y + parts.head.y + 15);
            
            // Body to Limbs
            const limbs = [
                {x: x + parts.fistF.x, y: y + parts.fistF.y},
                {x: x + parts.fistB.x, y: y + parts.fistB.y},
                {x: x + parts.footF.x, y: y + parts.footF.y},
                {x: x + parts.footB.x, y: y + parts.footB.y}
            ];
            
            limbs.forEach(p => {
                ctx.moveTo(cx, bodyCenter);
                ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
            
            // --- Draw Parts (back to front) ---
            // Back Foot
            drawRect({
                x: x + parts.footB.x - 9, y: y + parts.footB.y - 9,
                w: 18, h: 18
            }, limbColor);
            
            // Back Fist
            drawRect({
                x: x + parts.fistB.x - 8, y: y + parts.fistB.y - 8,
                w: 16, h: 16
            }, limbColor);
            
            // Body - draw centered on body.y (same as Fighter.getHitboxes)
            drawRect({
                x: x + parts.body.x - parts.body.w/2,
                y: y + parts.body.y - parts.body.h/2,
                w: parts.body.w,
                h: parts.body.h
            }, color);
            
            // Head - use 30x30 to match Fighter.getHitboxes headSize
            const headW = 30, headH = 30;
            drawRect({
                x: x + parts.head.x - headW/2,
                y: y + parts.head.y - headH/2,
                w: headW, h: headH
            }, headColor);
            
            // Eyes (facing left)
            ctx.fillStyle = '#000';
            const eyeY = y + parts.head.y - 2;
            const eyeSize = 4;
            ctx.fillRect(x + parts.head.x - 10, eyeY, eyeSize, eyeSize);
            ctx.fillRect(x + parts.head.x - 3, eyeY, eyeSize, eyeSize);
            
            // Headband
            ctx.fillStyle = '#ff6600';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            const bandY = y + parts.head.y - headH/2 + 6;
            ctx.fillRect(x + parts.head.x - headW/2 - 3, bandY, headW + 6, 5);
            ctx.strokeRect(x + parts.head.x - headW/2 - 3, bandY, headW + 6, 5);
            
            // Headband tails (flowing animation)
            const tailWave = Math.sin(t * 4) * 4;
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x + parts.head.x + headW/2 + 3, bandY + 2);
            ctx.quadraticCurveTo(
                x + parts.head.x + headW/2 + 18, bandY + tailWave,
                x + parts.head.x + headW/2 + 28, bandY + 12 + tailWave
            );
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + parts.head.x + headW/2 + 3, bandY + 4);
            ctx.quadraticCurveTo(
                x + parts.head.x + headW/2 + 14, bandY + 5 + tailWave * 0.7,
                x + parts.head.x + headW/2 + 22, bandY + 16 + tailWave * 0.7
            );
            ctx.stroke();
            
            // Front Foot
            drawRect({
                x: x + parts.footF.x - 9, y: y + parts.footF.y - 9,
                w: 18, h: 18
            }, limbColor);
            
            // Front Fist
            drawRect({
                x: x + parts.fistF.x - 8, y: y + parts.fistF.y - 8,
                w: 16, h: 16
            }, limbColor);
            
            ctx.restore();
        }
        
        function titleScreenLoop(timestamp) {
            if (currentScreen !== 'title') return;
            
            const dt = Math.min((timestamp - (titleScreenLoop.lastTime || timestamp)) / 1000, 0.05);
            titleScreenLoop.lastTime = timestamp;
            
            renderTitleScreen(dt);
            requestAnimationFrame(titleScreenLoop);
        }
        
        // ==================== MENU NAVIGATION ====================
        function updateMenuSelection(delta) {
            const buttons = document.querySelectorAll('#mainMenu .menuBtn');
            const enabledButtons = Array.from(buttons).filter(b => !b.disabled);
            
            // Find current enabled index
            let currentEnabledIdx = enabledButtons.findIndex(b => b.classList.contains('selected'));
            if (currentEnabledIdx === -1) currentEnabledIdx = 0;
            
            // Move selection
            currentEnabledIdx = (currentEnabledIdx + delta + enabledButtons.length) % enabledButtons.length;
            
            // Update visual
            buttons.forEach(b => b.classList.remove('selected'));
            enabledButtons[currentEnabledIdx].classList.add('selected');
            menuSelectedIndex = Array.from(buttons).indexOf(enabledButtons[currentEnabledIdx]);
        }
        
        function activateMenuSelection() {
            const buttons = document.querySelectorAll('#mainMenu .menuBtn');
            const selectedBtn = buttons[menuSelectedIndex];
            if (selectedBtn && !selectedBtn.disabled) {
                selectedBtn.click();
            }
        }
        
        function initSettingsUI() {
            // Tab switching
            document.querySelectorAll('.settingsTab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.settingsTab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.settingsPanel').forEach(p => p.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById('panel' + tab.dataset.panel.charAt(0).toUpperCase() + tab.dataset.panel.slice(1)).classList.add('active');
                });
            });
            
            // Preset slot clicks
            document.querySelectorAll('.presetSlot').forEach(slot => {
                slot.addEventListener('click', () => {
                    const playerNum = parseInt(slot.dataset.player);
                    const presetIdx = parseInt(slot.dataset.preset);
                    const pConfig = playerNum === 1 ? controlConfig.player1 : controlConfig.player2;
                    pConfig.activePreset = presetIdx;
                    saveControlConfig();
                    renderControlsGrid(playerNum);
                    updatePresetSlots(playerNum);
                });
            });
            
            // Reset buttons
            document.getElementById('p1ResetBtn').addEventListener('click', () => {
                resetPlayerConfig(1);
                renderControlsGrid(1);
                updatePresetSlots(1);
            });
            
            document.getElementById('p2ResetBtn').addEventListener('click', () => {
                resetPlayerConfig(2);
                renderControlsGrid(2);
                updatePresetSlots(2);
            });
            
            // Swap buttons
            document.getElementById('swapPlayersBtn').addEventListener('click', () => {
                swapPlayerConfigs();
                renderControlsGrid(1);
                renderControlsGrid(2);
                updatePresetSlots(1);
                updatePresetSlots(2);
            });
            
            document.getElementById('swapPlayersBtn2').addEventListener('click', () => {
                swapPlayerConfigs();
                renderControlsGrid(1);
                renderControlsGrid(2);
                updatePresetSlots(1);
                updatePresetSlots(2);
            });
            
            // Back button
            document.getElementById('btnBackToTitle').addEventListener('click', () => {
                showTitleScreen();
            });
            
            // Initial render
            renderControlsGrid(1);
            renderControlsGrid(2);
            renderGamepadInfo();
            renderDebugControlsGrid();
            updateDebugTabVisibility();
            updatePresetSlots(1);
            updatePresetSlots(2);
        }
        
        function updatePresetSlots(playerNum) {
            const pConfig = playerNum === 1 ? controlConfig.player1 : controlConfig.player2;
            const slots = document.querySelectorAll(`#p${playerNum}PresetSlots .presetSlot`);
            
            slots.forEach((slot, idx) => {
                slot.classList.remove('active');
                if (idx === pConfig.activePreset) {
                    slot.classList.add('active');
                }
            });
        }
        
        function renderControlsGrid(playerNum) {
            const grid = document.getElementById(`p${playerNum}ControlsGrid`);
            const binds = getPlayerKeybinds(playerNum);
            
            grid.innerHTML = '';
            
            CONTROL_ACTIONS.forEach(action => {
                const binding = binds[action];
                // Support both legacy (string) and new (array) format
                const key1 = Array.isArray(binding) ? binding[0] : binding;
                const key2 = Array.isArray(binding) ? binding[1] : null;
                
                const div = document.createElement('div');
                div.className = 'controlMapping';
                div.innerHTML = `
                    <span class="controlLabel">${CONTROL_LABELS[action]}</span>
                    <span class="controlKeyGroup">
                        <span class="controlKey" tabindex="0" data-player="${playerNum}" data-action="${action}" data-slot="0">${formatKeyName(key1)}</span>
                        <span class="controlKey" tabindex="0" data-player="${playerNum}" data-action="${action}" data-slot="1">${formatKeyName(key2)}</span>
                    </span>
                `;
                grid.appendChild(div);
                
                // Click or Enter to rebind each slot
                div.querySelectorAll('.controlKey').forEach(keySpan => {
                    const slot = parseInt(keySpan.dataset.slot);
                    keySpan.addEventListener('click', () => startListening(playerNum, action, keySpan, slot));
                    keySpan.addEventListener('keydown', (e) => {
                        if (e.code === 'Enter' || e.code === 'Space') {
                            e.preventDefault();
                            startListening(playerNum, action, keySpan, slot);
                        }
                    });
                });
            });
        }
        
        function renderGamepadInfo() {
            updateGamepadStatus();
        }
        
        function updateGamepadStatus() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            
            const gp1 = gamepads[0];
            const gp2 = gamepads[1];
            
            document.getElementById('gp1Dot').classList.toggle('connected', !!gp1);
            document.getElementById('gp1Status').textContent = gp1 ? (gp1.id.slice(0, 30) + '...') : 'Not Connected';
            
            document.getElementById('gp2Dot').classList.toggle('connected', !!gp2);
            document.getElementById('gp2Status').textContent = gp2 ? (gp2.id.slice(0, 30) + '...') : 'Not Connected';
        }
        
        function startListening(playerNum, action, element, slot = 0) {
            // Cancel any existing listening
            if (settingsListeningFor) {
                const oldEl = settingsListeningFor.element;
                if (oldEl) {
                    oldEl.classList.remove('listening');
                }
                if (settingsListeningFor.gamepadPollId) {
                    cancelAnimationFrame(settingsListeningFor.gamepadPollId);
                }
            }
            
            settingsListeningFor = { player: playerNum, action, element, slot, gamepadPollId: null };
            element.classList.add('listening');
            element.textContent = '...';
            
            // Start polling for gamepad input
            startGamepadListening();
        }
        
        // Track last gamepad state to detect new presses
        let lastGamepadState = { buttons: [], axes: [] };
        
        function startGamepadListening() {
            if (!settingsListeningFor || settingsListeningFor.debug) return;
            
            const gamepad = getPlayerGamepad(settingsListeningFor.player);
            if (gamepad) {
                // Check for new button press
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    const pressed = gamepad.buttons[i]?.pressed;
                    const wasPressed = lastGamepadState.buttons[i];
                    if (pressed && !wasPressed) {
                        // New button press detected
                        applyGamepadBinding({ type: 'button', btn: i });
                        return;
                    }
                }
                
                // Check for axis movement
                for (let i = 0; i < gamepad.axes.length; i++) {
                    const val = gamepad.axes[i] || 0;
                    const lastVal = lastGamepadState.axes[i] || 0;
                    if (Math.abs(val) > 0.7 && Math.abs(lastVal) < 0.5) {
                        // New axis movement detected
                        applyGamepadBinding({ type: 'axis', axis: i, dir: val < 0 ? -1 : 1 });
                        return;
                    }
                }
                
                // Update last state
                lastGamepadState.buttons = gamepad.buttons.map(b => b?.pressed);
                lastGamepadState.axes = [...gamepad.axes];
            }
            
            // Continue polling
            if (settingsListeningFor && !settingsListeningFor.debug) {
                settingsListeningFor.gamepadPollId = requestAnimationFrame(startGamepadListening);
            }
        }
        
        function applyGamepadBinding(gpBinding) {
            if (!settingsListeningFor) return;
            
            const { player, action, element, slot } = settingsListeningFor;
            
            // Clear any existing bindings to this gamepad input
            clearConflictingBindings(player, action, gpBinding, slot);
            
            const pConfig = player === 1 ? controlConfig.player1 : controlConfig.player2;
            const binding = pConfig.presets[pConfig.activePreset][action];
            
            if (Array.isArray(binding)) {
                binding[slot] = gpBinding;
            } else {
                const newBinding = [null, null];
                newBinding[slot] = gpBinding;
                pConfig.presets[pConfig.activePreset][action] = newBinding;
            }
            
            saveControlConfig();
            renderControlsGrid(1);
            renderControlsGrid(2);
            
            element.classList.remove('listening');
            if (settingsListeningFor.gamepadPollId) {
                cancelAnimationFrame(settingsListeningFor.gamepadPollId);
            }
            settingsListeningFor = null;
        }
        
        function handleSettingsKeydown(e) {
            if (!settingsListeningFor) return false;
            
            // Handle debug key rebinding
            if (settingsListeningFor.debug) {
                return handleDebugKeydown(e);
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            const { player, action, element, slot } = settingsListeningFor;
            const newKey = e.code;
            
            // Backspace/Delete clears the binding
            if (e.code === 'Backspace' || e.code === 'Delete') {
                const pConfig = player === 1 ? controlConfig.player1 : controlConfig.player2;
                const binding = pConfig.presets[pConfig.activePreset][action];
                if (Array.isArray(binding)) {
                    binding[slot] = null;
                } else {
                    pConfig.presets[pConfig.activePreset][action] = [null, null];
                }
                saveControlConfig();
                renderControlsGrid(1);
                renderControlsGrid(2);
                element.classList.remove('listening');
                if (settingsListeningFor.gamepadPollId) {
                    cancelAnimationFrame(settingsListeningFor.gamepadPollId);
                }
                settingsListeningFor = null;
                return true;
            }
            
            // Clear any existing bindings to this key (except pause can be duplicated for pause)
            clearConflictingBindings(player, action, newKey, slot);
            
            const pConfig = player === 1 ? controlConfig.player1 : controlConfig.player2;
            const binding = pConfig.presets[pConfig.activePreset][action];
            
            // Ensure binding is array format
            if (Array.isArray(binding)) {
                binding[slot] = newKey;
            } else {
                // Convert legacy format to array
                const newBinding = [null, null];
                newBinding[slot] = newKey;
                if (slot === 1 && binding) newBinding[0] = binding;
                pConfig.presets[pConfig.activePreset][action] = newBinding;
            }
            
            saveControlConfig();
            
            // Refresh both grids to show cleared bindings
            renderControlsGrid(1);
            renderControlsGrid(2);
            
            element.classList.remove('listening');
            if (settingsListeningFor.gamepadPollId) {
                cancelAnimationFrame(settingsListeningFor.gamepadPollId);
            }
            settingsListeningFor = null;
            
            return true;
        }
        
        function clearConflictingBindings(newPlayer, newAction, newBinding, newSlot) {
            // Pause bindings can be duplicated across players (both can pause with same key)
            // But within the same player, and for non-pause actions, clear conflicts
            
            const players = [controlConfig.player1, controlConfig.player2];
            
            players.forEach((pConfig, idx) => {
                const playerNum = idx + 1;
                const preset = pConfig.presets[pConfig.activePreset];
                
                for (const act of CONTROL_ACTIONS) {
                    const binding = preset[act];
                    
                    // Handle array format
                    if (Array.isArray(binding)) {
                        for (let slot = 0; slot < 2; slot++) {
                            if (bindingsEqual(binding[slot], newBinding)) {
                                // Skip if it's the same slot we're assigning to
                                if (playerNum === newPlayer && act === newAction && slot === newSlot) {
                                    continue;
                                }
                                // Allow pause to be duplicated if both are pause actions
                                if (act === 'pause' && newAction === 'pause') {
                                    continue;
                                }
                                // Clear the conflicting binding
                                binding[slot] = null;
                            }
                        }
                    } else if (bindingsEqual(binding, newBinding)) {
                        // Legacy single binding format
                        if (act === 'pause' && newAction === 'pause') {
                            continue;
                        }
                        preset[act] = [null, null];
                    }
                }
            });
        }
        
        // Check if two bindings are equal (handles both keyboard strings and gamepad objects)
        function bindingsEqual(a, b) {
            if (a === b) return true;
            if (!a || !b) return false;
            if (typeof a === 'string' || typeof b === 'string') return a === b;
            // Both are objects (gamepad bindings)
            if (a.type !== b.type) return false;
            if (a.type === 'button') return a.btn === b.btn;
            if (a.type === 'axis') return a.axis === b.axis && a.dir === b.dir;
            return false;
        }
        
        // Debug controls grid
        function renderDebugControlsGrid() {
            const grid = document.getElementById('debugControlsGrid');
            if (!grid) return;
            
            const binds = controlConfig.debug;
            
            grid.innerHTML = '';
            
            DEBUG_ACTIONS.forEach(action => {
                const div = document.createElement('div');
                div.className = 'controlMapping';
                div.innerHTML = `
                    <span class="controlLabel">${DEBUG_LABELS[action]}</span>
                    <span class="controlKey" tabindex="0" data-debug="true" data-action="${action}">${formatKeyName(binds[action])}</span>
                `;
                grid.appendChild(div);
                
                // Click or Enter to rebind
                const keySpan = div.querySelector('.controlKey');
                keySpan.addEventListener('click', () => startDebugListening(action, keySpan));
                keySpan.addEventListener('keydown', (e) => {
                    if (e.code === 'Enter' || e.code === 'Space') {
                        e.preventDefault();
                        startDebugListening(action, keySpan);
                    }
                });
            });
        }
        
        function startDebugListening(action, element) {
            // Cancel any existing listening
            if (settingsListeningFor) {
                const oldEl = settingsListeningFor.element;
                if (oldEl) {
                    oldEl.classList.remove('listening');
                    oldEl.parentElement.classList.remove('listening');
                }
            }
            
            settingsListeningFor = { debug: true, action, element };
            element.classList.add('listening');
            element.parentElement.classList.add('listening');
            element.textContent = 'Press key...';
        }
        
        function handleDebugKeydown(e) {
            if (!settingsListeningFor || !settingsListeningFor.debug) return false;
            
            e.preventDefault();
            e.stopPropagation();
            
            const { action, element } = settingsListeningFor;
            const newKey = e.code;
            
            controlConfig.debug[action] = newKey;
            
            saveControlConfig();
            renderDebugControlsGrid();
            
            element.classList.remove('listening');
            element.parentElement.classList.remove('listening');
            settingsListeningFor = null;
            
            return true;
        }
        
        function updateDebugTabVisibility() {
            const debugTab = document.querySelector('.settingsTab[data-panel="debug"]');
            const debugPanel = document.getElementById('panelDebug');
            if (debugTab) {
                debugTab.style.display = debugMode ? '' : 'none';
            }
            // If debug is off and we're viewing the debug panel, switch to Player 1
            if (!debugMode && debugPanel && debugPanel.classList.contains('active')) {
                document.querySelectorAll('.settingsTab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.settingsPanel').forEach(p => p.classList.remove('active'));
                document.querySelector('.settingsTab[data-panel="player1"]').classList.add('active');
                document.getElementById('panelPlayer1').classList.add('active');
            }
        }
        
        function showTitleScreen() {
            currentScreen = 'title';
            document.getElementById('titleScreen').classList.remove('hidden');
            document.getElementById('settingsScreen').classList.add('hidden');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('arena').style.display = 'none';
            
            // Reset menu selection to first enabled item
            menuSelectedIndex = 0;
            const buttons = document.querySelectorAll('#mainMenu .menuBtn');
            buttons.forEach((b, i) => b.classList.toggle('selected', i === 0));
            
            initTitleParticles();
            titleScreenLoop.lastTime = performance.now();
            requestAnimationFrame(titleScreenLoop);
            startMenuGamepadPolling();
        }
        
        function showSettingsScreen() {
            currentScreen = 'settings';
            document.getElementById('titleScreen').classList.add('hidden');
            document.getElementById('settingsScreen').classList.remove('hidden');
            renderControlsGrid(1);
            renderControlsGrid(2);
            updateGamepadStatus();
            updateDebugTabVisibility();
            renderDebugControlsGrid();
            updatePresetSlots(1);
            updatePresetSlots(2);
            startMenuGamepadPolling();
            // Focus first tab for keyboard navigation
            document.querySelector('.settingsTab.active')?.focus();
        }
        
        function showGameScreen() {
            currentScreen = 'game';
            document.getElementById('titleScreen').classList.add('hidden');
            document.getElementById('settingsScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('arena').style.display = 'block';
            stopMenuGamepadPolling();
        }

        // ==================== META-TEXT DIALOG SYSTEM ====================
        // Player: calm, centered, aloof, rising above
        const PLAYER_ADJECTIVES = [
            'serene', 'tranquil', 'centered', 'composed', 'unruffled',
            'patient', 'measured', 'thoughtful', 'gentle', 'peaceful',
            'still', 'grounded', 'balanced', 'quiet', 'mindful',
            'detached', 'unbothered', 'accepting', 'wise', 'knowing',
            'calm', 'poised', 'steady', 'harmonious', 'settled',
            'reflective', 'unhurried', 'placid', 'mellow', 'relaxed',
            'contemplative', 'stoic', 'impassive', 'neutral', 'tranquil',
            'collected', 'cool', 'dispassionate', 'level', 'reserved',
            'subdued', 'temperate', 'unfazed', 'assured', 'certain'
        ];
        const PLAYER_NOUNS = [
            'observation', 'silence', 'breath', 'pause', 'clarity',
            'acceptance', 'understanding', 'presence', 'stillness', 'moment',
            'reflection', 'awareness', 'equilibrium', 'peace', 'insight',
            'emptiness', 'listening', 'acknowledgment', 'release', 'letting go',
            'nod', 'sigh', 'waiting', 'patience', 'distance',
            'compassion', 'mercy', 'forgiveness', 'grace', 'humility',
            'tranquility', 'serenity', 'poise', 'detachment', 'equanimity',
            'composure', 'repose', 'quietude', 'calm', 'contentment',
            'wisdom', 'dignity', 'restraint', 'forbearance', 'tolerance'
        ];

        // Boss: flawed, defensive, projecting, insecure
        const BOSS_ADJECTIVES = [
            'guilty', 'ashamed', 'stammering', 'bitter', 'jealous',
            'petty', 'spiteful', 'defensive', 'accusatory', 'desperate',
            'frantic', 'hollow', 'wounded', 'resentful', 'envious',
            'cowardly', 'sneering', 'trembling', 'vicious', 'pathetic',
            'scheming', 'whining', 'sulking', 'fuming', 'seething',
            'paranoid', 'pompous', 'arrogant', 'insecure', 'fragile',
            'venomous', 'grasping', 'craven', 'theatrical', 'hysterical',
            'flustered', 'agitated', 'unhinged', 'rattled', 'panicked',
            'indignant', 'outraged', 'offended', 'slighted', 'wronged',
            'manic', 'erratic', 'volatile', 'unstable', 'cornered'
        ];
        const BOSS_NOUNS = [
            'blame', 'deflection', 'accusation', 'threat', 'vendetta',
            'tantrum', 'excuse', 'projection', 'denial', 'grievance',
            'insult', 'boast', 'ultimatum', 'warning', 'posturing',
            'retort', 'whimper', 'sneer', 'snarl', 'demand',
            'complaint', 'self-pity', 'bluster', 'mockery', 'contempt',
            'cowardice', 'bravado', 'intimidation', 'manipulation', 'lie',
            'justification', 'rationalization', 'outburst', 'tirade', 'rant',
            'accusation', 'recrimination', 'reproach', 'rebuke', 'censure',
            'indictment', 'arraignment', 'finger-pointing', 'scapegoating', 'blame-shift',
            'tantrum', 'meltdown', 'explosion', 'eruption', 'breakdown'
        ];

        // Dialog state
        let dialogState = {
            active: false,
            lines: [],
            currentLine: 0,
            speakers: [] // 'player' or 'boss'
        };

        function generateMetaPhrase(adjectives, nouns) {
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            return `${adj} ${noun}`;
        }

        function generateDialog() {
            // Always 4 exchanges: player, boss, player, boss
            const lines = [];
            const speakers = [];
            
            for (let i = 0; i < 4; i++) {
                if (i % 2 === 0) {
                    // Player speaks (even indices: 0, 2)
                    lines.push(generateMetaPhrase(PLAYER_ADJECTIVES, PLAYER_NOUNS));
                    speakers.push('player');
                } else {
                    // Boss speaks (odd indices: 1, 3)
                    lines.push(generateMetaPhrase(BOSS_ADJECTIVES, BOSS_NOUNS));
                    speakers.push('boss');
                }
            }
            
            return { lines, speakers };
        }

        function drawSpeechBubble(ctx, text, x, y, isPlayer, scale = 1) {
            ctx.save();
            
            const padding = 12 * scale;
            const tailHeight = 15 * scale;
            const radius = 8 * scale;
            const maxWidth = 200 * scale;
            
            // Measure text
            ctx.font = `italic ${14 * scale}px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif`;
            const textWidth = Math.min(ctx.measureText(text).width + padding * 2, maxWidth);
            const textHeight = 20 * scale;
            const bubbleWidth = textWidth;
            const bubbleHeight = textHeight + padding * 2;
            
            // Position bubble above character
            const bubbleX = x - bubbleWidth / 2;
            const bubbleY = y - bubbleHeight - tailHeight;
            
            // Draw bubble shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.roundRect(bubbleX + 3, bubbleY + 3, bubbleWidth, bubbleHeight, radius);
            ctx.fill();
            
            // Draw bubble background
            const bgColor = isPlayer ? '#e8f5e9' : '#ffebee';
            const borderColor = isPlayer ? '#4caf50' : '#f44336';
            
            ctx.fillStyle = bgColor;
            ctx.beginPath();
            ctx.roundRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight, radius);
            ctx.fill();
            
            // Draw border
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 2 * scale;
            ctx.stroke();
            
            // Draw tail (pointing down to character)
            const tailX = x;
            const tailY = bubbleY + bubbleHeight;
            ctx.fillStyle = bgColor;
            ctx.beginPath();
            ctx.moveTo(tailX - 8 * scale, tailY);
            ctx.lineTo(tailX, tailY + tailHeight);
            ctx.lineTo(tailX + 8 * scale, tailY);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = borderColor;
            ctx.beginPath();
            ctx.moveTo(tailX - 8 * scale, tailY);
            ctx.lineTo(tailX, tailY + tailHeight);
            ctx.lineTo(tailX + 8 * scale, tailY);
            ctx.stroke();
            
            // Cover the gap where tail meets bubble
            ctx.fillStyle = bgColor;
            ctx.fillRect(tailX - 9 * scale, tailY - 2, 18 * scale, 4);
            
            // Draw text
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x, bubbleY + bubbleHeight / 2);
            
            ctx.restore();
        }

        function startDialog() {
            const dialog = generateDialog();
            dialogState = {
                active: true,
                lines: dialog.lines,
                speakers: dialog.speakers,
                currentLine: 0
            };
            gameState = 'dialog';
        }

        function advanceDialog() {
            if (!dialogState.active) return;
            
            dialogState.currentLine++;
            
            if (dialogState.currentLine >= dialogState.lines.length) {
                // Dialog finished, start fighting
                dialogState.active = false;
                gameState = 'fighting';
            }
        }

        function renderDialog() {
            if (!dialogState.active || dialogState.currentLine >= dialogState.lines.length) return;
            
            const speaker = dialogState.speakers[dialogState.currentLine];
            const text = dialogState.lines[dialogState.currentLine];
            const isPlayer = speaker === 'player';
            
            // Get character position - raise bubble higher so tail doesn't cover face
            let charX, charY;
            if (isPlayer && player) {
                charX = player.x;
                charY = player.y - 120; // Well above head
            } else if (!isPlayer && enemies.length > 0) {
                charX = enemies[0].x;
                charY = enemies[0].y - 120; // Well above head
            } else {
                // Fallback positions
                charX = isPlayer ? ARENA_WIDTH * 0.22 : ARENA_WIDTH - 100;
                charY = GROUND_Y - 120;
            }
            
            drawSpeechBubble(ctx, text, charX, charY, isPlayer);
            
            // Draw "press any key" hint
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('[ press any key ]', ARENA_WIDTH / 2, ARENA_HEIGHT - 20);
            ctx.restore();
        }
        const STAMINA_JUMP_COST = 15;
        const STAMINA_PUNCH_COST = 8;
        const STAMINA_KICK_COST = 12;

        const PUNCH_DAMAGE = 8;
        const KICK_DAMAGE = 12;
        const LOW_PUNCH_DAMAGE = 6;
        const SWEEP_DAMAGE = 15;

        const PLAYER_COLOR = '#4ecdc4';
        const TRAITOR_COLOR = '#3ba89e'; // Darker teal for player's minions
        const PLAYER_NAME = 'Shadow Dragon';

        // Potion Types
        const POTION_TYPES = [
            { type: 'health', color: '#e74c3c', effect: 'HP +50%', apply: (p) => { p.health = Math.min(100, p.health + 50); } },
            { type: 'stamina', color: '#f1c40f', effect: 'Stamina +50%', apply: (p) => { p.stamina = Math.min(STAMINA_MAX, p.stamina + 50); } },
            { type: 'mixed', color: '#9b59b6', effect: 'HP/Stamina +25%', apply: (p) => { p.health = Math.min(100, p.health + 25); p.stamina = Math.min(STAMINA_MAX, p.stamina + 25); } },
            { type: 'full', color: '#2ecc71', effect: 'Full Restore!', apply: (p) => { p.health = 100; p.stamina = STAMINA_MAX; } },
            { type: 'chi', color: '#3498db', effect: 'Chi Shield!', apply: (p) => { if (p.activateChiShield) p.activateChiShield(10000); } }
        ];
        
        // Special Traitor Potion (turns a minion against their boss, or stores in inventory)
        const TRAITOR_POTION = { type: 'traitor', color: '#ff00ff', effect: 'Traitor!', apply: (p) => { applyTraitorPotion(); } };
        
        // Apply traitor potion - use immediately if possible, otherwise store
        function applyTraitorPotion() {
            if (canSpawnTraitorPotion()) {
                // There's a minion to turn - use immediately
                turnMinionTraitor();
            } else if (traitorPotionInventory < MAX_TRAITOR_POTIONS) {
                // No minions to turn - store for later
                traitorPotionInventory++;
                showMessage('Potion Stored!', '#ff00ff');
            } else {
                // Inventory full, just show message
                showMessage('Inventory Full!', '#ff6666');
            }
        }

        // ==================== WEAPON SYSTEM ====================
        const WEAPON_TYPES = ['sword', 'pole', 'star', 'fan'];
        const WEAPON_STAMINA_MULT = 1.2;
        const WEAPON_DAMAGE_MULT = 1.5;

        // Projectiles array for throwing star and fan
        let projectiles = [];

        class Weapon {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.onGround = true;
                this.owner = null; // Fighter holding this weapon
                this.bobTimer = Math.random() * Math.PI * 2;
                this.groundRotation = 0; // Rotation when on ground
            }

            update(dt) {
                if (this.onGround) {
                    this.bobTimer += dt * 3;
                }
            }

            draw(ctx) {
                if (this.owner) return; // Don't draw if being held - fighter draws it
                if (!this.onGround) return; // Don't draw if in-flight as projectile
                
                const bobY = Math.sin(this.bobTimer) * 3;
                const x = this.x;
                const y = this.y - 5 + bobY;
                
                ctx.save();
                ctx.translate(x, y);
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 5, 20, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Sword and pole lay flat on ground, star and fan stand/float
                let groundAngle = 0;
                if (this.type === 'sword') {
                    groundAngle = Math.PI / 2; // Lay horizontal
                } else if (this.type === 'pole') {
                    groundAngle = Math.PI / 2; // Lay horizontal
                }
                
                this.drawWeapon(ctx, 0, 0, groundAngle, this.type === 'pole' ? 0.6 : 1);
                ctx.restore();
            }

            drawWeapon(ctx, x, y, angle, scale = 1) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.scale(scale, scale);
                
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#fff';
                ctx.lineWidth = 2;
                
                switch (this.type) {
                    case 'sword':
                        // Longsword - blade
                        ctx.beginPath();
                        ctx.moveTo(-5, 0);
                        ctx.lineTo(-3, -45);
                        ctx.lineTo(0, -50);
                        ctx.lineTo(3, -45);
                        ctx.lineTo(5, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Crossguard
                        ctx.fillRect(-12, 0, 24, 5);
                        ctx.strokeRect(-12, 0, 24, 5);
                        // Handle
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-3, 5, 6, 18);
                        ctx.strokeRect(-3, 5, 6, 18);
                        // Pommel
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(0, 26, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        break;
                        
                    case 'pole':
                        // Bo staff with rounded ends
                        ctx.beginPath();
                        ctx.moveTo(-3, -55);
                        ctx.lineTo(3, -55);
                        ctx.lineTo(3, 55);
                        ctx.lineTo(-3, 55);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Rounded caps
                        ctx.beginPath();
                        ctx.arc(0, -55, 3, Math.PI, 0);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 55, 3, 0, Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        break;
                        
                    case 'star':
                        // 4-pointed shuriken
                        this.drawShuriken(ctx, 0, 0, 12);
                        break;
                        
                    case 'fan':
                        // War fan (tessen)
                        ctx.beginPath();
                        // Fan blades (spread)
                        for (let i = -2; i <= 2; i++) {
                            const angle = (i * 15) * Math.PI / 180;
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.sin(angle) * 35, -Math.cos(angle) * 35);
                        }
                        ctx.stroke();
                        // Fan surface
                        ctx.beginPath();
                        ctx.arc(0, 0, 35, -Math.PI/2 - Math.PI/6, -Math.PI/2 + Math.PI/6);
                        ctx.lineTo(0, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Handle
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-3, 0, 6, 15);
                        ctx.strokeRect(-3, 0, 6, 15);
                        break;
                }
                
                ctx.restore();
            }

            drawShuriken(ctx, x, y, size) {
                ctx.save();
                ctx.translate(x, y);
                
                // 4 pointed star with cutouts
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i * 90) * Math.PI / 180;
                    const nextAngle = ((i + 1) * 90) * Math.PI / 180;
                    const midAngle = angle + Math.PI / 4;
                    
                    // Point tip
                    ctx.lineTo(Math.cos(angle) * size, Math.sin(angle) * size);
                    // Inner notch (creates the cutout appearance)
                    ctx.lineTo(Math.cos(midAngle) * (size * 0.3), Math.sin(midAngle) * (size * 0.3));
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Center circle cutouts between points
                ctx.fillStyle = '#000';
                for (let i = 0; i < 4; i++) {
                    const angle = (i * 90 + 45) * Math.PI / 180;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * (size * 0.5), Math.sin(angle) * (size * 0.5), size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            getHitbox() {
                return {
                    x: this.x - 20,
                    y: this.y - 30,
                    w: 40,
                    h: 40
                };
            }
        }

        // Projectile class for thrown weapons
        class Projectile {
            constructor(weapon, thrower, targetX) {
                this.weapon = weapon;
                this.thrower = thrower;
                this.x = thrower.x + (thrower.facingRight ? 30 : -30);
                this.y = thrower.y - 50;
                this.vx = (thrower.facingRight ? 1 : -1) * 400;
                this.vy = 0;
                this.rotation = 0;
                this.returning = false;
                this.hitFighters = new Set(); // Track fighters hit during this flight
                this.type = weapon.type;
            }

            update(dt) {
                this.rotation += dt * 15;
                
                if (this.type === 'fan' && this.returning) {
                    // Fan returns to thrower
                    const dx = this.thrower.x - this.x;
                    const dy = (this.thrower.y - 50) - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 30) {
                        // Caught!
                        this.weapon.owner = this.thrower;
                        this.thrower.weapon = this.weapon;
                        this.weapon.onGround = false;
                        return true; // Remove projectile
                    }
                    
                    const speed = 450;
                    this.vx = (dx / dist) * speed;
                    this.vy = (dy / dist) * speed;
                }
                
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                
                // Check arena bounds
                if (this.x < 50 || this.x > ARENA_WIDTH - 50) {
                    if (this.type === 'star') {
                        // Star embeds in wall
                        this.weapon.x = Math.max(60, Math.min(ARENA_WIDTH - 60, this.x));
                        this.weapon.y = GROUND_Y;
                        this.weapon.onGround = true;
                        this.weapon.owner = null;
                        // Ensure weapon is in weapons array for pickup
                        if (!weapons.includes(this.weapon)) {
                            weapons.push(this.weapon);
                        }
                        return true; // Remove projectile
                    } else if (this.type === 'fan') {
                        // Fan returns
                        this.returning = true;
                        this.vx = -this.vx;
                    }
                }
                
                return false; // Keep projectile
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#fff';
                ctx.lineWidth = 2;
                
                if (this.type === 'star') {
                    this.weapon.drawShuriken(ctx, 0, 0, 12);
                } else if (this.type === 'fan') {
                    // Spinning fan
                    this.weapon.drawWeapon(ctx, 0, 0, 0, 0.8);
                }
                
                ctx.restore();
            }

            getHitbox() {
                const size = this.type === 'star' ? 16 : 30;
                return {
                    x: this.x - size/2,
                    y: this.y - size/2,
                    w: size,
                    h: size
                };
            }
        }

        let weapons = []; // Ground weapons

        // ==================== AUDIO SYSTEM ====================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        const SoundFX = {
            playTone: (freq, type, duration, vol = 0.1, slide = 0) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if (slide !== 0) {
                    osc.frequency.linearRampToValueAtTime(freq + slide, audioCtx.currentTime + duration);
                }
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playNoise: (duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                noise.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            },
            hit: () => {
                SoundFX.playNoise(0.1, 0.2);
                SoundFX.playTone(60, 'sawtooth', 0.1, 0.1);
            },
            heavyHit: () => {
                SoundFX.playNoise(0.2, 0.3);
                SoundFX.playTone(40, 'square', 0.2, 0.2);
            },
            whiff: () => {
                SoundFX.playNoise(0.05, 0.05);
                SoundFX.playTone(150, 'sine', 0.1, 0.05, -50);
            },
            jump: () => {
                SoundFX.playTone(100, 'sine', 0.1, 0.1, 50);
            },
            block: () => {
                SoundFX.playTone(50, 'square', 0.05, 0.1);
                SoundFX.playNoise(0.05, 0.1);
            },
            // Weapon sounds
            swordSwing: () => {
                SoundFX.playTone(400, 'sawtooth', 0.15, 0.08, -200);
            },
            swordHit: () => {
                SoundFX.playTone(300, 'sawtooth', 0.1, 0.15);
                SoundFX.playNoise(0.1, 0.2);
            },
            poleSwing: () => {
                SoundFX.playTone(120, 'sine', 0.2, 0.1, 80);
            },
            poleHit: () => {
                SoundFX.playTone(80, 'square', 0.15, 0.2);
                SoundFX.playNoise(0.15, 0.25);
            },
            throwSound: () => {
                SoundFX.playTone(500, 'sine', 0.1, 0.1, -200);
            },
            starHit: () => {
                SoundFX.playTone(800, 'triangle', 0.1, 0.15);
                SoundFX.playNoise(0.05, 0.15);
            },
            fanHit: () => {
                SoundFX.playTone(600, 'triangle', 0.1, 0.12);
                SoundFX.playNoise(0.08, 0.1);
            },
            pickup: () => {
                SoundFX.playTone(400, 'sine', 0.1, 0.1, 200);
            }
        };

        const OPPONENTS = [
            // Stats scaled to 75%-100% range for bosses
            { name: 'Iron Monk', color: '#ff6b6b', style: 'defensive', stats: { aggression: 0.75, block: 1.0, jump: 0.75, punch: 0.88, kick: 0.80, sprint: 0.75 } },
            { name: 'Thunder Fist', color: '#ffd93d', style: 'aggressive', stats: { aggression: 0.93, block: 0.75, jump: 0.88, punch: 1.0, kick: 0.75, sprint: 0.88 } },
            { name: 'Silent Viper', color: '#6bcb77', style: 'balanced', stats: { aggression: 0.88, block: 0.88, jump: 0.88, punch: 0.80, kick: 0.88, sprint: 0.75 } },
            { name: 'Storm Blade', color: '#9d4edd', style: 'aggressive', stats: { aggression: 1.0, block: 0.75, jump: 0.93, punch: 0.75, kick: 0.93, sprint: 1.0 } },
            { name: 'Jade Phoenix', color: '#00cec9', style: 'technical', stats: { aggression: 0.80, block: 0.88, jump: 1.0, punch: 0.75, kick: 1.0, sprint: 0.80 } },
            { name: 'Crimson Tiger', color: '#e17055', style: 'aggressive', stats: { aggression: 1.0, block: 0.75, jump: 0.80, punch: 0.93, kick: 0.75, sprint: 1.0 } },
            { name: 'Ghost Mantis', color: '#a29bfe', style: 'evasive', stats: { aggression: 0.75, block: 0.80, jump: 1.0, punch: 0.88, kick: 0.88, sprint: 0.88 } },
            { name: 'Dragon Master', color: '#fd79a8', style: 'master', stats: { aggression: 0.88, block: 0.93, jump: 0.88, punch: 0.88, kick: 0.88, sprint: 0.88 } }
        ];

        // ==================== NAME GENERATION ====================
        const FIRST_NAMES = ["Iron", "Steel", "Golden", "Silver", "Jade", "Flying", "Crouching", "Hidden", "Drunken", "Silent", "Thunder", "Lightning", "Shadow", "Ghost", "Tiger", "Dragon", "Crane", "Mantis", "Monkey", "Snake", "Phoenix", "Lotus", "Burning", "Frozen", "Stone", "Wind", "Water", "Fire", "Void", "Spirit"];
        const LAST_NAMES = ["Fist", "Palm", "Kick", "Strike", "Blade", "Sword", "Spear", "Staff", "Monk", "Master", "Warrior", "Ninja", "Samurai", "Ronin", "Emperor", "General", "Soldier", "Assassin", "Hunter", "Walker", "Runner", "Jumper", "Flyer", "Hand", "Foot", "Claw", "Tooth", "Wing", "Eye", "Heart"];

        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // ==================== ANIMATION POSES ====================
        // Offsets relative to player X,Y (center between feet on ground)
        const POSES = {
            idle: {
                head: {x: 0, y: -80},
                body: {x: 0, y: -40, w: 40, h: 60},
                fistF: {x: 25, y: -55}, // Front
                fistB: {x: 10, y: -50}, // Back
                footF: {x: 15, y: -5},
                footB: {x: -15, y: -5}
            },
            crouch: {
                head: {x: 5, y: -55},
                body: {x: 0, y: -25, w: 45, h: 40},
                fistF: {x: 25, y: -40},
                fistB: {x: 10, y: -35},
                footF: {x: 20, y: -5},
                footB: {x: -10, y: -5}
            },
            walk: { // Base walk pose, modified by sine wave
                head: {x: 5, y: -78},
                body: {x: 0, y: -38, w: 40, h: 60},
                fistF: {x: 25, y: -52},
                fistB: {x: 0, y: -48},
                footF: {x: 10, y: -5},
                footB: {x: -10, y: -5}
            },
            sprint: {
                head: {x: 15, y: -70}, // Leaning forward
                body: {x: 10, y: -35, w: 40, h: 60},
                fistF: {x: 30, y: -50},
                fistB: {x: -10, y: -50},
                footF: {x: 20, y: -5},
                footB: {x: -20, y: -5}
            },
            jump: {
                head: {x: 5, y: -85},
                body: {x: 0, y: -50, w: 35, h: 55},
                fistF: {x: 20, y: -70},
                fistB: {x: -10, y: -60},
                footF: {x: 10, y: -20},
                footB: {x: -15, y: -10}
            },
            punch: {
                head: {x: 15, y: -75},
                body: {x: 10, y: -38, w: 40, h: 60},
                fistF: {x: 60, y: -55}, // Extended
                fistB: {x: -5, y: -50},
                footF: {x: 25, y: -5},
                footB: {x: -20, y: -5}
            },
            lowPunch: {
                head: {x: 15, y: -50},
                body: {x: 10, y: -25, w: 45, h: 40},
                fistF: {x: 55, y: -30}, // Extended Low
                fistB: {x: 0, y: -35},
                footF: {x: 25, y: -5},
                footB: {x: -15, y: -5}
            },
            kick: {
                head: {x: -15, y: -75},
                body: {x: -10, y: -38, w: 40, h: 60},
                fistF: {x: 10, y: -55},
                fistB: {x: -20, y: -50},
                footF: {x: 55, y: -50}, // Extended High
                footB: {x: -20, y: -5}
            },
            sweep: {
                head: {x: 0, y: -45},
                body: {x: 0, y: -20, w: 45, h: 35},
                fistF: {x: 10, y: -30},
                fistB: {x: -10, y: -30},
                footF: {x: 50, y: -5}, // Extended Low
                footB: {x: -20, y: -5}
            },
            jumpPunch: {
                head: {x: 10, y: -80},
                body: {x: 5, y: -45, w: 35, h: 55},
                fistF: {x: 45, y: -20}, // Punch down towards ground
                fistB: {x: -10, y: -60},
                footF: {x: 15, y: -25}, // Legs tucked
                footB: {x: -10, y: -15}
            },
            jumpKick: {
                head: {x: 5, y: -80},
                body: {x: 0, y: -45, w: 35, h: 55},
                fistF: {x: 10, y: -60},
                fistB: {x: -10, y: -60},
                footF: {x: 60, y: -30}, // Flying kick
                footB: {x: -25, y: -10}
            },
            stunned: {
                head: {x: -10, y: -75},
                body: {x: -5, y: -38, w: 40, h: 60},
                fistF: {x: 10, y: -40},
                fistB: {x: -10, y: -40},
                footF: {x: 15, y: -5},
                footB: {x: -15, y: -5}
            },
            tripped: {
                head: {x: -35, y: -15},
                body: {x: 0, y: -15, w: 60, h: 30}, // Horizontal body
                fistF: {x: 10, y: -45},
                fistB: {x: -10, y: -45},
                footF: {x: 35, y: -55}, // Legs kicked up
                footB: {x: 45, y: -35}
            },
            // Pole weapon poses
            poleIdle: {
                head: {x: 0, y: -75},
                body: {x: 0, y: -38, w: 40, h: 60},
                fistF: {x: -10, y: -25}, // Near hand back and low (waist height)
                fistB: {x: 30, y: -55}, // Far hand forward and high (shoulder height)
                footF: {x: 15, y: -5},
                footB: {x: -15, y: -5}
            },
            poleStrike: {
                head: {x: 15, y: -75},
                body: {x: 10, y: -38, w: 40, h: 60},
                fistF: {x: 10, y: -45}, // Follow through
                fistB: {x: 50, y: -45}, // Thrust forward
                footF: {x: 25, y: -5},
                footB: {x: -20, y: -5}
            },
            poleSweep: {
                head: {x: 10, y: -65},
                body: {x: 5, y: -30, w: 45, h: 50},
                fistF: {x: 0, y: -20}, // Back hand
                fistB: {x: 40, y: -10}, // Low jab to leg area
                footF: {x: 20, y: -5},
                footB: {x: -15, y: -5}
            },
            poleCrouch: {
                head: {x: 5, y: -55},
                body: {x: 0, y: -25, w: 45, h: 40},
                fistF: {x: -5, y: -20}, // Near hand back and low (swapped)
                fistB: {x: 25, y: -40}, // Far hand forward and high (swapped)
                footF: {x: 20, y: -5},
                footB: {x: -10, y: -5}
            }
        };

        // ==================== ARENA SYSTEM ====================
        class Arena {
            constructor(name, type, drawFn) {
                this.name = name;
                this.type = type; // 'travel' or 'place'
                this.drawFn = drawFn;
            }
            
            draw(ctx) {
                this.drawFn(ctx);
            }
        }

        const ARENAS = [
            new Arena('Dojo', 'place', (ctx) => {
                // Background
                const grad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                grad.addColorStop(0, '#2c1810');
                grad.addColorStop(1, '#1a0f0a');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);

                // Floor
                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;
                const fGrad = ctx.createLinearGradient(0, 0, ARENA_WIDTH, 0);
                fGrad.addColorStop(0, '#5d4037');
                fGrad.addColorStop(0.5, '#6d4c41');
                fGrad.addColorStop(1, '#5d4037');
                ctx.fillStyle = fGrad;
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);
                
                // Floor Border
                ctx.fillStyle = '#8d6e63';
                ctx.fillRect(0, floorY, ARENA_WIDTH, 4);
                
                // Floor Pattern
                ctx.fillStyle = '#4e342e';
                ctx.fillRect(0, floorY + 4, ARENA_WIDTH, 20);
                ctx.fillStyle = '#3e2723';
                for(let x = 60; x < ARENA_WIDTH; x += 120) {
                    ctx.fillRect(x, floorY + 4, 60, 20);
                }

                // Pillars
                const drawPillar = (x) => {
                    const w = 40;
                    const h = 200;
                    const y = ARENA_HEIGHT - 60 - h;
                    
                    // Body
                    const pGrad = ctx.createLinearGradient(x, 0, x + w, 0);
                    pGrad.addColorStop(0, '#8b0000');
                    pGrad.addColorStop(0.5, '#b22222');
                    pGrad.addColorStop(1, '#8b0000');
                    ctx.fillStyle = pGrad;
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeStyle = '#660000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, w, h);
                    
                    // Cap
                    ctx.fillStyle = '#660000';
                    ctx.beginPath();
                    // Rounded top corners (x-10, y-20, w=60, h=20, r=5)
                    const cx = x - 10;
                    const cy = y - 20;
                    const cw = 60;
                    const ch = 20;
                    const r = 5;
                    ctx.moveTo(cx, cy + ch);
                    ctx.lineTo(cx, cy + r);
                    ctx.quadraticCurveTo(cx, cy, cx + r, cy);
                    ctx.lineTo(cx + cw - r, cy);
                    ctx.quadraticCurveTo(cx + cw, cy, cx + cw, cy + r);
                    ctx.lineTo(cx + cw, cy + ch);
                    ctx.closePath();
                    ctx.fill();
                };
                drawPillar(30);
                drawPillar(ARENA_WIDTH - 30 - 40);

                // Banner
                const bx = ARENA_WIDTH / 2 - 100;
                const by = 20;
                const bw = 200;
                const bh = 100;
                
                const bGrad = ctx.createLinearGradient(0, by, 0, by + bh);
                bGrad.addColorStop(0, '#8b0000');
                bGrad.addColorStop(1, '#660000');
                ctx.fillStyle = bGrad;
                ctx.fillRect(bx, by, bw, bh);
                
                ctx.strokeStyle = '#ffcc00';
                ctx.lineWidth = 3;
                ctx.strokeRect(bx, by, bw, bh);
                
                // Banner Text
                ctx.fillStyle = '#ffcc00';
                ctx.font = '40px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.fillText('Ê≠¶', ARENA_WIDTH / 2, by + bh / 2);
                ctx.shadowColor = 'transparent';

                // Lanterns
                const drawLantern = (x, y) => {
                    const flicker = 0.8 + Math.sin(performance.now() * 0.005) * 0.1 + Math.random() * 0.1;
                    ctx.save();
                    ctx.globalAlpha = flicker;
                    ctx.shadowColor = 'rgba(255, 102, 0, 0.6)';
                    ctx.shadowBlur = 30;
                    
                    const lGrad = ctx.createRadialGradient(x + 15, y + 20, 0, x + 15, y + 20, 20);
                    lGrad.addColorStop(0, '#ff6600');
                    lGrad.addColorStop(1, '#cc3300');
                    ctx.fillStyle = lGrad;
                    
                    // Rounded rect (w=30, h=40, r=5)
                    const w = 30;
                    const h = 40;
                    const r = 5;
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                };
                drawLantern(100, 40);
                drawLantern(ARENA_WIDTH - 100 - 30, 40);
            }),

            new Arena('Paper Dojo', 'place', (ctx) => {
                // Background - darker, moodier paper color (evening/candlelit)
                const grad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                grad.addColorStop(0, '#4a4538');
                grad.addColorStop(1, '#3d372c');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);

                // Wooden frame color (darker tones)
                const woodDark = '#2e2218';
                const woodMid = '#3d2e1f';
                const woodLight = '#4a3828';

                // Shoji panels (paper walls with wooden grid) - dimmer paper
                const panelCount = 6;
                const panelWidth = ARENA_WIDTH / panelCount;
                const panelTop = 20;
                const panelBottom = ARENA_HEIGHT - 80;
                const panelHeight = panelBottom - panelTop;

                // Draw each shoji panel
                for (let i = 0; i < panelCount; i++) {
                    const px = i * panelWidth;
                    
                    // Paper background - muted, warm glow as if backlit by candles
                    const paperGrad = ctx.createLinearGradient(px, panelTop, px + panelWidth, panelBottom);
                    paperGrad.addColorStop(0, '#8a8070');
                    paperGrad.addColorStop(0.5, '#9a9080');
                    paperGrad.addColorStop(1, '#8a8070');
                    ctx.fillStyle = paperGrad;
                    ctx.fillRect(px + 4, panelTop + 4, panelWidth - 8, panelHeight - 8);
                    
                    // Vertical frame pieces
                    ctx.fillStyle = woodDark;
                    ctx.fillRect(px, panelTop, 8, panelHeight);
                    ctx.fillRect(px + panelWidth - 8, panelTop, 8, panelHeight);
                    
                    // Horizontal dividers (3 sections per panel)
                    const sectionHeight = panelHeight / 3;
                    for (let j = 1; j < 3; j++) {
                        ctx.fillStyle = woodMid;
                        ctx.fillRect(px + 4, panelTop + j * sectionHeight - 3, panelWidth - 8, 6);
                    }
                    
                    // Inner vertical divider
                    ctx.fillStyle = woodMid;
                    ctx.fillRect(px + panelWidth / 2 - 2, panelTop + 4, 4, panelHeight - 8);
                }

                // Top beam
                const beamGrad = ctx.createLinearGradient(0, 0, 0, 24);
                beamGrad.addColorStop(0, woodLight);
                beamGrad.addColorStop(0.5, woodDark);
                beamGrad.addColorStop(1, '#1a1410');
                ctx.fillStyle = beamGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, 24);
                
                // Bottom beam above floor
                ctx.fillStyle = beamGrad;
                ctx.fillRect(0, panelBottom - 4, ARENA_WIDTH, 24);

                // Tatami floor - darker evening tones
                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;
                
                // Base tatami color (muted)
                ctx.fillStyle = '#6b5c3e';
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);
                
                // Tatami mat pattern (rectangular mats)
                const matWidth = 120;
                const matHeight = floorH;
                ctx.strokeStyle = '#4a3d2a';
                ctx.lineWidth = 2;
                
                for (let x = 0; x < ARENA_WIDTH; x += matWidth) {
                    // Mat border
                    ctx.strokeRect(x + 2, floorY + 2, matWidth - 4, matHeight - 4);
                    
                    // Subtle horizontal lines for texture
                    ctx.strokeStyle = 'rgba(74, 61, 42, 0.4)';
                    ctx.lineWidth = 1;
                    for (let y = floorY + 10; y < floorY + floorH; y += 8) {
                        ctx.beginPath();
                        ctx.moveTo(x + 4, y);
                        ctx.lineTo(x + matWidth - 4, y);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = '#4a3d2a';
                    ctx.lineWidth = 2;
                }
                
                // Black border strip at mat edges
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, floorY, ARENA_WIDTH, 3);

                // Decorative elements - hanging scrolls (kakejiku) - dimmer
                const drawScroll = (x, text) => {
                    const scrollW = 60;
                    const scrollH = 140;
                    const scrollY = 40;
                    
                    // Scroll backing rod (top)
                    ctx.fillStyle = woodDark;
                    ctx.fillRect(x - 5, scrollY - 8, scrollW + 10, 12);
                    
                    // Paper scroll - aged/dim
                    ctx.fillStyle = '#a89878';
                    ctx.fillRect(x, scrollY, scrollW, scrollH);
                    ctx.strokeStyle = '#786850';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, scrollY, scrollW, scrollH);
                    
                    // Scroll bottom rod
                    ctx.fillStyle = woodDark;
                    ctx.fillRect(x - 5, scrollY + scrollH - 4, scrollW + 10, 12);
                    
                    // Calligraphy character
                    ctx.fillStyle = '#2a2a2a';
                    ctx.font = 'bold 36px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, x + scrollW / 2, scrollY + scrollH / 2);
                };
                
                drawScroll(80, 'ÈÅì'); // "Way/Path"
                drawScroll(ARENA_WIDTH - 140, 'ÂøÉ'); // "Heart/Mind"

                // Subtle warm candlelight glow effect
                const glowGrad = ctx.createRadialGradient(
                    ARENA_WIDTH / 2, ARENA_HEIGHT / 2, 0,
                    ARENA_WIDTH / 2, ARENA_HEIGHT / 2, ARENA_WIDTH / 2
                );
                glowGrad.addColorStop(0, 'rgba(255, 200, 150, 0.05)');
                glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                ctx.fillStyle = glowGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            }),

            new Arena('Bamboo Forest', 'travel', (ctx) => {
                // Background - misty forest gradient
                const grad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                grad.addColorStop(0, '#1a2f1a');
                grad.addColorStop(0.5, '#243524');
                grad.addColorStop(1, '#1a2a1a');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);

                // Mist layers in background
                for (let i = 0; i < 3; i++) {
                    const mistY = 50 + i * 80;
                    const mistGrad = ctx.createLinearGradient(0, mistY, 0, mistY + 60);
                    mistGrad.addColorStop(0, 'rgba(180, 200, 180, 0)');
                    mistGrad.addColorStop(0.5, `rgba(180, 200, 180, ${0.05 - i * 0.01})`);
                    mistGrad.addColorStop(1, 'rgba(180, 200, 180, 0)');
                    ctx.fillStyle = mistGrad;
                    ctx.fillRect(0, mistY, ARENA_WIDTH, 60);
                }

                // Draw bamboo stalks
                const drawBamboo = (x, height, thickness, shade) => {
                    const baseY = ARENA_HEIGHT - 60;
                    const segments = Math.floor(height / 40);
                    
                    // Main stalk color
                    const stalkGrad = ctx.createLinearGradient(x, 0, x + thickness, 0);
                    stalkGrad.addColorStop(0, shade === 'dark' ? '#2d4a2d' : '#4a6b4a');
                    stalkGrad.addColorStop(0.3, shade === 'dark' ? '#3d5a3d' : '#5a7b5a');
                    stalkGrad.addColorStop(0.7, shade === 'dark' ? '#3d5a3d' : '#5a7b5a');
                    stalkGrad.addColorStop(1, shade === 'dark' ? '#2d4a2d' : '#4a6b4a');
                    
                    ctx.fillStyle = stalkGrad;
                    ctx.fillRect(x, baseY - height, thickness, height);
                    
                    // Segment joints (nodes)
                    ctx.fillStyle = shade === 'dark' ? '#1a3a1a' : '#3a5a3a';
                    for (let i = 1; i < segments; i++) {
                        const nodeY = baseY - i * 40;
                        ctx.fillRect(x - 2, nodeY - 3, thickness + 4, 6);
                    }
                    
                    // Highlight stripe
                    ctx.fillStyle = 'rgba(150, 200, 150, 0.2)';
                    ctx.fillRect(x + thickness * 0.6, baseY - height, thickness * 0.15, height);
                };

                // Background bamboo (darker, thinner)
                drawBamboo(40, 380, 12, 'dark');
                drawBamboo(85, 350, 10, 'dark');
                drawBamboo(ARENA_WIDTH - 50, 370, 12, 'dark');
                drawBamboo(ARENA_WIDTH - 95, 340, 10, 'dark');
                
                // Midground bamboo
                drawBamboo(15, 400, 16, 'mid');
                drawBamboo(110, 320, 14, 'mid');
                drawBamboo(ARENA_WIDTH - 25, 390, 16, 'mid');
                drawBamboo(ARENA_WIDTH - 120, 310, 14, 'mid');
                
                // Foreground bamboo (lighter, thicker)
                drawBamboo(55, 420, 20, 'light');
                drawBamboo(ARENA_WIDTH - 75, 410, 20, 'light');

                // Bamboo leaves (scattered)
                const drawLeaves = (x, y) => {
                    ctx.fillStyle = 'rgba(80, 120, 80, 0.8)';
                    for (let i = 0; i < 5; i++) {
                        const angle = (i - 2) * 0.4 + Math.sin(x + y) * 0.2;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(15, -3, 30, 0);
                        ctx.quadraticCurveTo(15, 3, 0, 0);
                        ctx.fill();
                        ctx.restore();
                    }
                };
                
                drawLeaves(70, 60);
                drawLeaves(50, 120);
                drawLeaves(ARENA_WIDTH - 60, 70);
                drawLeaves(ARENA_WIDTH - 80, 130);

                // Forest floor - mossy earth
                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;
                
                const floorGrad = ctx.createLinearGradient(0, floorY, 0, ARENA_HEIGHT);
                floorGrad.addColorStop(0, '#3a4a30');
                floorGrad.addColorStop(1, '#2a3a20');
                ctx.fillStyle = floorGrad;
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);
                
                // Moss patches
                ctx.fillStyle = '#4a5a40';
                for (let x = 20; x < ARENA_WIDTH; x += 80) {
                    ctx.beginPath();
                    ctx.ellipse(x + Math.sin(x) * 20, floorY + 15, 30, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Ground line
                ctx.fillStyle = '#2a3a1a';
                ctx.fillRect(0, floorY, ARENA_WIDTH, 3);

                // Fallen bamboo leaves on ground
                ctx.fillStyle = 'rgba(90, 110, 70, 0.5)';
                for (let x = 50; x < ARENA_WIDTH - 50; x += 60) {
                    ctx.save();
                    ctx.translate(x, floorY + 25 + Math.sin(x) * 5);
                    ctx.rotate(Math.sin(x * 0.1) * 0.5);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(10, -2, 20, 0);
                    ctx.quadraticCurveTo(10, 2, 0, 0);
                    ctx.fill();
                    ctx.restore();
                }
            }),

            new Arena('Water Gardens', 'place', (ctx) => {
                // Time in seconds since page load - frame-rate independent
                // Using wall-clock time means animations run at same speed regardless of FPS
                const timeSeconds = performance.now() * 0.001; // Convert ms to seconds
                
                // Background - twilight sky with sunset hints
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#1a1a2e');
                skyGrad.addColorStop(0.3, '#2d2d4a');
                skyGrad.addColorStop(0.6, '#3d3d5a');
                skyGrad.addColorStop(0.85, '#4a3a5a');
                skyGrad.addColorStop(1, '#3a4a5a');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);

                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;

                // === TORII GATE (arch gate) - background element ===
                const toriiX = ARENA_WIDTH / 2;
                const toriiY = floorY - 10;
                const toriiWidth = 180;
                const toriiHeight = 200;
                
                // Main pillars
                ctx.fillStyle = '#8b2020';
                ctx.fillRect(toriiX - toriiWidth/2, toriiY - toriiHeight, 18, toriiHeight);
                ctx.fillRect(toriiX + toriiWidth/2 - 18, toriiY - toriiHeight, 18, toriiHeight);
                
                // Top beam (kasagi) - curved
                ctx.fillStyle = '#6b1515';
                ctx.beginPath();
                ctx.moveTo(toriiX - toriiWidth/2 - 25, toriiY - toriiHeight + 10);
                ctx.quadraticCurveTo(toriiX, toriiY - toriiHeight - 15, toriiX + toriiWidth/2 + 25, toriiY - toriiHeight + 10);
                ctx.lineTo(toriiX + toriiWidth/2 + 25, toriiY - toriiHeight + 25);
                ctx.quadraticCurveTo(toriiX, toriiY - toriiHeight, toriiX - toriiWidth/2 - 25, toriiY - toriiHeight + 25);
                ctx.closePath();
                ctx.fill();
                
                // Secondary beam (nuki)
                ctx.fillStyle = '#8b2020';
                ctx.fillRect(toriiX - toriiWidth/2 - 10, toriiY - toriiHeight + 50, toriiWidth + 20, 12);
                
                // Beam end caps
                ctx.fillStyle = '#5a1010';
                ctx.fillRect(toriiX - toriiWidth/2 - 15, toriiY - toriiHeight + 48, 10, 16);
                ctx.fillRect(toriiX + toriiWidth/2 + 5, toriiY - toriiHeight + 48, 10, 16);

                // === CHERRY BLOSSOM TREES ===
                const drawCherryTree = (baseX, scale, flip) => {
                    ctx.save();
                    ctx.translate(baseX, floorY);
                    ctx.scale(flip ? -scale : scale, scale);
                    
                    // Trunk
                    const trunkGrad = ctx.createLinearGradient(-15, 0, 15, 0);
                    trunkGrad.addColorStop(0, '#2a1515');
                    trunkGrad.addColorStop(0.5, '#3d2020');
                    trunkGrad.addColorStop(1, '#2a1515');
                    ctx.fillStyle = trunkGrad;
                    
                    ctx.beginPath();
                    ctx.moveTo(-12, 0);
                    ctx.bezierCurveTo(-15, -40, -10, -80, -5, -120);
                    ctx.bezierCurveTo(0, -140, 10, -150, 20, -160);
                    ctx.bezierCurveTo(30, -140, 25, -120, 20, -100);
                    ctx.bezierCurveTo(15, -80, 18, -40, 12, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Main branches
                    ctx.strokeStyle = '#3d2020';
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    
                    // Branch 1
                    ctx.beginPath();
                    ctx.moveTo(5, -100);
                    ctx.bezierCurveTo(30, -120, 60, -130, 90, -125);
                    ctx.stroke();
                    
                    // Branch 2
                    ctx.beginPath();
                    ctx.moveTo(15, -140);
                    ctx.bezierCurveTo(40, -160, 70, -170, 100, -160);
                    ctx.stroke();
                    
                    // Branch 3 (upward)
                    ctx.beginPath();
                    ctx.moveTo(10, -120);
                    ctx.bezierCurveTo(-10, -150, -20, -180, -15, -200);
                    ctx.stroke();
                    
                    // Cherry blossoms (clusters of pink flowers)
                    const blossomClusters = [
                        { x: 90, y: -125, r: 25 },
                        { x: 70, y: -130, r: 20 },
                        { x: 100, y: -160, r: 28 },
                        { x: 75, y: -165, r: 22 },
                        { x: -15, y: -200, r: 24 },
                        { x: -5, y: -180, r: 18 },
                        { x: 50, y: -140, r: 15 },
                        { x: 40, y: -170, r: 18 }
                    ];
                    
                    blossomClusters.forEach(cluster => {
                        // Outer glow
                        const glowGrad = ctx.createRadialGradient(cluster.x, cluster.y, 0, cluster.x, cluster.y, cluster.r * 1.5);
                        glowGrad.addColorStop(0, 'rgba(255, 182, 193, 0.4)');
                        glowGrad.addColorStop(1, 'rgba(255, 182, 193, 0)');
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.arc(cluster.x, cluster.y, cluster.r * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Individual blossoms in cluster - use deterministic positions based on index
                        for (let i = 0; i < 8; i++) {
                            // Very slow gentle sway using combined sine waves (timeSeconds for frame-rate independence)
                            const slowSway = Math.sin(timeSeconds * 0.1 + cluster.x * 0.01 + i * 0.5) * 0.08;
                            const angle = (i / 8) * Math.PI * 2 + slowSway;
                            // Deterministic distance based on index, not random
                            const dist = cluster.r * (0.3 + ((i * 7) % 5) * 0.1);
                            const bx = cluster.x + Math.cos(angle) * dist;
                            const by = cluster.y + Math.sin(angle) * dist;
                            // Deterministic size based on index
                            const size = 4 + ((i * 3) % 4);
                            
                            // Petal color varies deterministically
                            const colors = ['#ffb7c5', '#ffc4d0', '#ffa5b4', '#ffd6e3', '#fff0f3'];
                            ctx.fillStyle = colors[i % colors.length];
                            
                            // Draw 5-petal flower
                            ctx.save();
                            ctx.translate(bx, by);
                            ctx.rotate(angle);
                            for (let p = 0; p < 5; p++) {
                                ctx.rotate(Math.PI * 2 / 5);
                                ctx.beginPath();
                                ctx.ellipse(size * 0.5, 0, size * 0.6, size * 0.3, 0, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            // Center
                            ctx.fillStyle = '#ffeeaa';
                            ctx.beginPath();
                            ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    });
                    
                    ctx.restore();
                };
                
                // Draw trees on sides (behind torii)
                drawCherryTree(70, 0.8, false);
                drawCherryTree(ARENA_WIDTH - 70, 0.8, true);

                // === LANTERNS ===
                const drawLantern = (x, y) => {
                    // Gentle flicker using timeSeconds for frame-rate independence
                    const flicker = 0.85 + Math.sin(timeSeconds * 2.5 + x * 0.01) * 0.1;
                    
                    // Post
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(x - 4, y, 8, 60);
                    
                    // Lantern body
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(x - 15, y - 35, 30, 35);
                    
                    // Roof
                    ctx.fillStyle = '#0a0a0a';
                    ctx.beginPath();
                    ctx.moveTo(x - 20, y - 35);
                    ctx.lineTo(x, y - 50);
                    ctx.lineTo(x + 20, y - 35);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Light glow
                    ctx.save();
                    ctx.globalAlpha = flicker;
                    const glowGrad = ctx.createRadialGradient(x, y - 18, 0, x, y - 18, 40);
                    glowGrad.addColorStop(0, 'rgba(255, 200, 100, 0.6)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 150, 50, 0.3)');
                    glowGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = glowGrad;
                    ctx.fillRect(x - 50, y - 60, 100, 90);
                    
                    // Inner light
                    ctx.fillStyle = 'rgba(255, 220, 150, 0.8)';
                    ctx.fillRect(x - 10, y - 30, 20, 25);
                    ctx.restore();
                };
                
                drawLantern(150, floorY - 10);
                drawLantern(ARENA_WIDTH - 150, floorY - 10);

                // Water/pond floor
                const waterGrad = ctx.createLinearGradient(0, floorY, 0, ARENA_HEIGHT);
                waterGrad.addColorStop(0, '#2a4a5a');
                waterGrad.addColorStop(0.5, '#1a3a4a');
                waterGrad.addColorStop(1, '#0a2a3a');
                ctx.fillStyle = waterGrad;
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);

                // === WATER LILIES ===
                const drawWaterLily = (x, y, size, phase) => {
                    // Gentle bobbing with combined slow waves for organic feel (timeSeconds for frame-rate independence)
                    const bob = Math.sin(timeSeconds * 0.12 + phase) * 1.5 + Math.sin(timeSeconds * 0.08 + phase * 1.7) * 0.8;
                    const ly = y + bob;
                    
                    // Lily pad (green circular leaf)
                    ctx.fillStyle = '#2d5a3d';
                    ctx.beginPath();
                    ctx.arc(x, ly, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Darker center and notch
                    ctx.fillStyle = '#1d4a2d';
                    ctx.beginPath();
                    ctx.moveTo(x, ly);
                    ctx.arc(x, ly, size, -0.3, 0.3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Vein lines
                    ctx.strokeStyle = '#3d6a4d';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + 0.5;
                        ctx.beginPath();
                        ctx.moveTo(x, ly);
                        ctx.lineTo(x + Math.cos(angle) * size * 0.8, ly + Math.sin(angle) * size * 0.8);
                        ctx.stroke();
                    }
                    
                    // Pink lotus flower on top
                    const flowerSize = size * 0.6;
                    const petalColors = ['#ffb6c1', '#ff9eb5', '#ffc0cb', '#ffaabb'];
                    
                    // Outer petals
                    for (let i = 0; i < 8; i++) {
                        // Very subtle slow rotation (timeSeconds for frame-rate independence)
                        const angle = (i / 8) * Math.PI * 2 + Math.sin(timeSeconds * 0.06 + phase + i * 0.3) * 0.03;
                        ctx.fillStyle = petalColors[i % petalColors.length];
                        ctx.save();
                        ctx.translate(x, ly - size * 0.3);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.ellipse(flowerSize * 0.4, 0, flowerSize * 0.5, flowerSize * 0.2, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // Inner petals
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + 0.3;
                        ctx.fillStyle = '#ffd0d8';
                        ctx.save();
                        ctx.translate(x, ly - size * 0.35);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.ellipse(flowerSize * 0.2, 0, flowerSize * 0.3, flowerSize * 0.12, 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    // Center (yellow stamens)
                    ctx.fillStyle = '#ffdd44';
                    ctx.beginPath();
                    ctx.arc(x, ly - size * 0.35, flowerSize * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                };
                
                // Draw water lilies in the pond
                drawWaterLily(60, floorY + 25, 18, 0);
                drawWaterLily(ARENA_WIDTH - 50, floorY + 30, 15, 1.5);
                drawWaterLily(ARENA_WIDTH - 90, floorY + 20, 12, 3.0);

                // === REEDS ===
                const drawReeds = (x, count) => {
                    for (let i = 0; i < count; i++) {
                        const rx = x + (i - count/2) * 8;
                        // Deterministic height based on position
                        const height = 60 + ((rx * 7) % 40);
                        // Very slow gentle sway with layered waves for natural breeze effect (timeSeconds for frame-rate independence)
                        const sway = Math.sin(timeSeconds * 0.08 + rx * 0.02) * 3 + Math.sin(timeSeconds * 0.05 + rx * 0.03 + i) * 2;
                        
                        // Reed stem
                        ctx.strokeStyle = '#3a5a3a';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(rx, floorY + 10);
                        ctx.quadraticCurveTo(rx + sway * 0.5, floorY - height/2, rx + sway, floorY - height);
                        ctx.stroke();
                        
                        // Reed head (cattail-like)
                        ctx.fillStyle = '#5a4030';
                        ctx.beginPath();
                        ctx.ellipse(rx + sway, floorY - height - 8, 4, 12, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                };
                
                drawReeds(30, 5);
                drawReeds(ARENA_WIDTH - 30, 4);

                // Animated water ripples (timeSeconds for frame-rate independence)
                ctx.strokeStyle = 'rgba(100, 150, 180, 0.25)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const rippleY = floorY + 10 + i * 10;
                    const ripplePhase = timeSeconds * 0.6 + i * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, rippleY);
                    for (let x = 0; x < ARENA_WIDTH; x += 15) {
                        ctx.lineTo(x + 7, rippleY + Math.sin(x * 0.03 + ripplePhase) * 2);
                    }
                    ctx.stroke();
                }

                // Wooden walkway/bridge (fighting platform)
                ctx.fillStyle = '#4a3a2a';
                ctx.fillRect(100, floorY - 5, ARENA_WIDTH - 200, 15);

                // Walkway planks
                ctx.strokeStyle = '#3a2a1a';
                ctx.lineWidth = 2;
                for (let x = 110; x < ARENA_WIDTH - 110; x += 40) {
                    ctx.beginPath();
                    ctx.moveTo(x, floorY - 5);
                    ctx.lineTo(x, floorY + 10);
                    ctx.stroke();
                }

                // Stone edges
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(0, floorY - 2, ARENA_WIDTH, 4);

                // Subtle moonlight glow
                const moonGrad = ctx.createRadialGradient(
                    ARENA_WIDTH * 0.7, 50, 0,
                    ARENA_WIDTH * 0.7, 50, 150
                );
                moonGrad.addColorStop(0, 'rgba(200, 210, 255, 0.1)');
                moonGrad.addColorStop(1, 'rgba(200, 210, 255, 0)');
                ctx.fillStyle = moonGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            }),

            new Arena('Mountain Temple', 'place', (ctx) => {
                // Background - dramatic mountain sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#0a0a1a');
                skyGrad.addColorStop(0.3, '#1a1a3a');
                skyGrad.addColorStop(0.6, '#2a2a4a');
                skyGrad.addColorStop(1, '#3a3a5a');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);

                // Distant mountains silhouette
                ctx.fillStyle = '#1a1a2a';
                ctx.beginPath();
                ctx.moveTo(0, ARENA_HEIGHT - 150);
                ctx.lineTo(100, ARENA_HEIGHT - 250);
                ctx.lineTo(200, ARENA_HEIGHT - 200);
                ctx.lineTo(350, ARENA_HEIGHT - 320);
                ctx.lineTo(500, ARENA_HEIGHT - 220);
                ctx.lineTo(650, ARENA_HEIGHT - 280);
                ctx.lineTo(800, ARENA_HEIGHT - 180);
                ctx.lineTo(ARENA_WIDTH, ARENA_HEIGHT - 220);
                ctx.lineTo(ARENA_WIDTH, ARENA_HEIGHT);
                ctx.lineTo(0, ARENA_HEIGHT);
                ctx.closePath();
                ctx.fill();

                // Closer mountain
                ctx.fillStyle = '#2a2a3a';
                ctx.beginPath();
                ctx.moveTo(0, ARENA_HEIGHT - 100);
                ctx.lineTo(150, ARENA_HEIGHT - 180);
                ctx.lineTo(300, ARENA_HEIGHT - 120);
                ctx.lineTo(450, ARENA_HEIGHT - 160);
                ctx.lineTo(600, ARENA_HEIGHT - 100);
                ctx.lineTo(750, ARENA_HEIGHT - 140);
                ctx.lineTo(ARENA_WIDTH, ARENA_HEIGHT - 90);
                ctx.lineTo(ARENA_WIDTH, ARENA_HEIGHT);
                ctx.lineTo(0, ARENA_HEIGHT);
                ctx.closePath();
                ctx.fill();

                // Temple structure
                const templeX = ARENA_WIDTH / 2;
                const templeBaseY = ARENA_HEIGHT - 60;
                
                // Temple roof (tiered)
                const drawRoof = (x, y, width, height) => {
                    ctx.fillStyle = '#2a2020';
                    ctx.beginPath();
                    ctx.moveTo(x - width/2 - 20, y + height);
                    ctx.lineTo(x, y);
                    ctx.lineTo(x + width/2 + 20, y + height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Roof edge curl
                    ctx.strokeStyle = '#3a3030';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x - width/2 - 20, y + height);
                    ctx.quadraticCurveTo(x - width/2 - 30, y + height - 10, x - width/2 - 25, y + height - 20);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + width/2 + 20, y + height);
                    ctx.quadraticCurveTo(x + width/2 + 30, y + height - 10, x + width/2 + 25, y + height - 20);
                    ctx.stroke();
                };
                
                // Three-tiered roof
                drawRoof(templeX, templeBaseY - 280, 80, 40);
                drawRoof(templeX, templeBaseY - 240, 120, 50);
                drawRoof(templeX, templeBaseY - 190, 160, 60);
                
                // Temple body
                ctx.fillStyle = '#3a3030';
                ctx.fillRect(templeX - 70, templeBaseY - 130, 140, 130);
                
                // Temple entrance (dark)
                ctx.fillStyle = '#1a1010';
                ctx.fillRect(templeX - 25, templeBaseY - 80, 50, 80);
                
                // Pillars
                ctx.fillStyle = '#4a3535';
                ctx.fillRect(templeX - 65, templeBaseY - 130, 12, 130);
                ctx.fillRect(templeX + 53, templeBaseY - 130, 12, 130);

                // Stone lanterns on sides
                const drawStoneLantern = (x) => {
                    // Base
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(x - 12, templeBaseY - 15, 24, 15);
                    
                    // Stem
                    ctx.fillRect(x - 6, templeBaseY - 50, 12, 35);
                    
                    // Lantern housing
                    ctx.fillRect(x - 15, templeBaseY - 75, 30, 25);
                    
                    // Roof cap
                    ctx.beginPath();
                    ctx.moveTo(x - 18, templeBaseY - 75);
                    ctx.lineTo(x, templeBaseY - 90);
                    ctx.lineTo(x + 18, templeBaseY - 75);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lantern glow
                    ctx.fillStyle = 'rgba(255, 150, 50, 0.6)';
                    ctx.fillRect(x - 10, templeBaseY - 70, 20, 15);
                    
                    // Glow effect
                    const glowGrad = ctx.createRadialGradient(x, templeBaseY - 62, 0, x, templeBaseY - 62, 30);
                    glowGrad.addColorStop(0, 'rgba(255, 150, 50, 0.3)');
                    glowGrad.addColorStop(1, 'rgba(255, 150, 50, 0)');
                    ctx.fillStyle = glowGrad;
                    ctx.fillRect(x - 30, templeBaseY - 92, 60, 60);
                };
                
                drawStoneLantern(120);
                drawStoneLantern(ARENA_WIDTH - 120);

                // Stone floor
                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;
                
                ctx.fillStyle = '#3a3a3a';
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);
                
                // Stone tiles pattern
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 2;
                for (let x = 0; x < ARENA_WIDTH; x += 60) {
                    ctx.beginPath();
                    ctx.moveTo(x, floorY);
                    ctx.lineTo(x, ARENA_HEIGHT);
                    ctx.stroke();
                }
                for (let y = floorY + 20; y < ARENA_HEIGHT; y += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(ARENA_WIDTH, y);
                    ctx.stroke();
                }
                
                // Floor edge
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, floorY, ARENA_WIDTH, 4);

                // Stars
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                const starPositions = [
                    [50, 30], [150, 50], [250, 20], [400, 45], [550, 25], 
                    [700, 55], [800, 35], [900, 50], [100, 70], [600, 65]
                ];
                starPositions.forEach(([sx, sy]) => {
                    ctx.beginPath();
                    ctx.arc(sx, sy, 1, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Atmospheric fog at base
                const fogGrad = ctx.createLinearGradient(0, ARENA_HEIGHT - 100, 0, ARENA_HEIGHT - 40);
                fogGrad.addColorStop(0, 'rgba(60, 60, 80, 0)');
                fogGrad.addColorStop(1, 'rgba(60, 60, 80, 0.3)');
                ctx.fillStyle = fogGrad;
                ctx.fillRect(0, ARENA_HEIGHT - 100, ARENA_WIDTH, 60);
            }),

            new Arena('Village Market', 'place', (ctx) => {
                // Time in seconds for animations
                const timeSeconds = performance.now() * 0.001;
                
                // Background - stormy overcast sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#3a3d42');
                skyGrad.addColorStop(0.3, '#4a4d52');
                skyGrad.addColorStop(0.5, '#5a5d62');
                skyGrad.addColorStop(0.7, '#4a4d52');
                skyGrad.addColorStop(1, '#3a3d42');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                // Storm clouds - layered dark shapes
                const drawCloud = (x, y, width, darkness) => {
                    ctx.fillStyle = `rgba(40, 42, 48, ${darkness})`;
                    ctx.beginPath();
                    ctx.ellipse(x, y, width, width * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(x - width * 0.5, y + 10, width * 0.6, width * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(x + width * 0.5, y + 5, width * 0.7, width * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                };
                
                drawCloud(150, 40, 80, 0.5);
                drawCloud(400, 30, 100, 0.6);
                drawCloud(700, 45, 90, 0.5);
                drawCloud(850, 35, 70, 0.4);

                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;

                // === LONG GRASS FIELDS (background) ===
                const drawGrassField = (startX, endX, baseY, density, heightMult) => {
                    for (let x = startX; x < endX; x += density) {
                        const height = 30 + ((x * 7) % 25) * heightMult;
                        const sway = Math.sin(timeSeconds * 0.15 + x * 0.03) * 4;
                        
                        ctx.strokeStyle = `rgba(70, 85, 55, ${0.4 + ((x * 3) % 3) * 0.1})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, baseY);
                        ctx.quadraticCurveTo(x + sway * 0.5, baseY - height/2, x + sway, baseY - height);
                        ctx.stroke();
                    }
                };
                
                // Distant grass field
                drawGrassField(0, 150, floorY - 30, 6, 0.8);
                drawGrassField(ARENA_WIDTH - 150, ARENA_WIDTH, floorY - 30, 6, 0.8);
                
                // Closer grass
                drawGrassField(0, 100, floorY - 10, 4, 1.2);
                drawGrassField(ARENA_WIDTH - 100, ARENA_WIDTH, floorY - 10, 4, 1.2);

                // === THATCHED ROOF BUILDINGS (background) ===
                const drawBuilding = (x, width, height, hasWindow) => {
                    const buildingY = floorY - height;
                    
                    // Wall
                    const wallGrad = ctx.createLinearGradient(x, buildingY, x + width, buildingY);
                    wallGrad.addColorStop(0, '#5a5040');
                    wallGrad.addColorStop(0.5, '#6a6050');
                    wallGrad.addColorStop(1, '#5a5040');
                    ctx.fillStyle = wallGrad;
                    ctx.fillRect(x, buildingY, width, height);
                    
                    // Wall texture (horizontal lines)
                    ctx.strokeStyle = 'rgba(80, 70, 55, 0.3)';
                    ctx.lineWidth = 1;
                    for (let y = buildingY + 15; y < floorY; y += 15) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + width, y);
                        ctx.stroke();
                    }
                    
                    // Thatched roof
                    ctx.fillStyle = '#4a4030';
                    ctx.beginPath();
                    ctx.moveTo(x - 15, buildingY);
                    ctx.lineTo(x + width/2, buildingY - 50);
                    ctx.lineTo(x + width + 15, buildingY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Thatch texture
                    ctx.strokeStyle = '#3a3020';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const tx = x + (i + 1) * (width / 9);
                        ctx.beginPath();
                        ctx.moveTo(tx, buildingY);
                        ctx.lineTo(x + width/2, buildingY - 50);
                        ctx.stroke();
                    }
                    
                    // Window (if present)
                    if (hasWindow) {
                        ctx.fillStyle = '#2a2520';
                        ctx.fillRect(x + width/2 - 15, buildingY + 20, 30, 25);
                        ctx.strokeStyle = '#3a3025';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x + width/2 - 15, buildingY + 20, 30, 25);
                        // Window cross
                        ctx.beginPath();
                        ctx.moveTo(x + width/2, buildingY + 20);
                        ctx.lineTo(x + width/2, buildingY + 45);
                        ctx.moveTo(x + width/2 - 15, buildingY + 32);
                        ctx.lineTo(x + width/2 + 15, buildingY + 32);
                        ctx.stroke();
                    }
                };
                
                // Background buildings
                drawBuilding(20, 100, 120, true);
                drawBuilding(ARENA_WIDTH - 130, 110, 130, true);

                // === MARKET STALLS ===
                const drawStall = (x, width, color, hasAwning) => {
                    const stallY = floorY;
                    const stallHeight = 70;
                    const counterHeight = 35;
                    
                    // Counter/table
                    ctx.fillStyle = '#5a4a35';
                    ctx.fillRect(x, stallY - counterHeight, width, counterHeight);
                    
                    // Counter top
                    ctx.fillStyle = '#6a5a45';
                    ctx.fillRect(x - 3, stallY - counterHeight - 5, width + 6, 8);
                    
                    // Awning/canopy
                    if (hasAwning) {
                        // Support poles
                        ctx.fillStyle = '#4a3a25';
                        ctx.fillRect(x + 5, stallY - stallHeight - 30, 6, stallHeight + 30 - counterHeight);
                        ctx.fillRect(x + width - 11, stallY - stallHeight - 30, 6, stallHeight + 30 - counterHeight);
                        
                        // Awning fabric (striped)
                        const stripeWidth = width / 5;
                        for (let i = 0; i < 5; i++) {
                            ctx.fillStyle = i % 2 === 0 ? color : '#f5f0e5';
                            ctx.beginPath();
                            ctx.moveTo(x + i * stripeWidth, stallY - stallHeight - 20);
                            ctx.lineTo(x + (i + 1) * stripeWidth, stallY - stallHeight - 20);
                            ctx.lineTo(x + (i + 1) * stripeWidth + 5, stallY - stallHeight + 10);
                            ctx.lineTo(x + i * stripeWidth + 5, stallY - stallHeight + 10);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // Awning edge (scalloped)
                        ctx.fillStyle = color;
                        for (let i = 0; i < 6; i++) {
                            ctx.beginPath();
                            ctx.arc(x + 8 + i * (width / 6), stallY - stallHeight + 12, 8, 0, Math.PI);
                            ctx.fill();
                        }
                    }
                };
                
                // Market stalls on sides
                drawStall(50, 90, '#8b4513', true);
                drawStall(ARENA_WIDTH - 140, 90, '#2e5a3e', true);

                // === BARRELS, CRATES, SACKS ===
                const drawBarrel = (x, y) => {
                    // Barrel body
                    const barrelGrad = ctx.createLinearGradient(x - 15, y, x + 15, y);
                    barrelGrad.addColorStop(0, '#5a4030');
                    barrelGrad.addColorStop(0.3, '#7a6050');
                    barrelGrad.addColorStop(0.7, '#7a6050');
                    barrelGrad.addColorStop(1, '#5a4030');
                    ctx.fillStyle = barrelGrad;
                    ctx.beginPath();
                    ctx.ellipse(x, y - 20, 18, 22, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Top
                    ctx.fillStyle = '#4a3525';
                    ctx.beginPath();
                    ctx.ellipse(x, y - 42, 16, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Metal bands
                    ctx.strokeStyle = '#3a3530';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(x, y - 10, 17, 4, 0, 0, Math.PI);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.ellipse(x, y - 32, 17, 4, 0, 0, Math.PI);
                    ctx.stroke();
                };
                
                const drawCrate = (x, y, size) => {
                    // Main box
                    ctx.fillStyle = '#6a5a40';
                    ctx.fillRect(x - size/2, y - size, size, size);
                    
                    // Top face (perspective)
                    ctx.fillStyle = '#7a6a50';
                    ctx.beginPath();
                    ctx.moveTo(x - size/2, y - size);
                    ctx.lineTo(x - size/2 + 8, y - size - 8);
                    ctx.lineTo(x + size/2 + 8, y - size - 8);
                    ctx.lineTo(x + size/2, y - size);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Right face
                    ctx.fillStyle = '#5a4a30';
                    ctx.beginPath();
                    ctx.moveTo(x + size/2, y - size);
                    ctx.lineTo(x + size/2 + 8, y - size - 8);
                    ctx.lineTo(x + size/2 + 8, y - 8);
                    ctx.lineTo(x + size/2, y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Planks
                    ctx.strokeStyle = '#4a3a25';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - size/2, y - size * 0.33);
                    ctx.lineTo(x + size/2, y - size * 0.33);
                    ctx.moveTo(x - size/2, y - size * 0.66);
                    ctx.lineTo(x + size/2, y - size * 0.66);
                    ctx.stroke();
                };
                
                const drawSack = (x, y, leanAngle) => {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(leanAngle);
                    
                    // Sack body
                    ctx.fillStyle = '#8a7a60';
                    ctx.beginPath();
                    ctx.moveTo(-12, 0);
                    ctx.bezierCurveTo(-15, -15, -12, -35, -8, -40);
                    ctx.bezierCurveTo(-2, -48, 2, -48, 8, -40);
                    ctx.bezierCurveTo(12, -35, 15, -15, 12, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Tied top
                    ctx.fillStyle = '#6a5a40';
                    ctx.beginPath();
                    ctx.ellipse(0, -42, 6, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Texture lines
                    ctx.strokeStyle = 'rgba(100, 90, 70, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-8, -10);
                    ctx.lineTo(8, -10);
                    ctx.moveTo(-10, -25);
                    ctx.lineTo(10, -25);
                    ctx.stroke();
                    
                    ctx.restore();
                };
                
                // Props near stalls
                drawBarrel(165, floorY);
                drawBarrel(185, floorY);
                drawCrate(210, floorY, 28);
                drawSack(235, floorY, 0.15);
                drawSack(255, floorY, -0.1);
                
                drawBarrel(ARENA_WIDTH - 165, floorY);
                drawCrate(ARENA_WIDTH - 200, floorY, 32);
                drawCrate(ARENA_WIDTH - 220, floorY - 30, 25);
                drawSack(ARENA_WIDTH - 250, floorY, -0.2);

                // === STREET LANTERNS ===
                const drawStreetLantern = (x) => {
                    const flicker = 0.8 + Math.sin(timeSeconds * 3 + x * 0.02) * 0.15;
                    
                    // Tall post
                    ctx.fillStyle = '#2a2520';
                    ctx.fillRect(x - 4, floorY - 140, 8, 140);
                    
                    // Arm extending out
                    ctx.fillRect(x - 4, floorY - 145, 30, 6);
                    
                    // Lantern housing
                    ctx.fillStyle = '#3a3530';
                    ctx.fillRect(x + 18, floorY - 175, 24, 35);
                    
                    // Roof
                    ctx.beginPath();
                    ctx.moveTo(x + 15, floorY - 175);
                    ctx.lineTo(x + 30, floorY - 190);
                    ctx.lineTo(x + 45, floorY - 175);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Light glow
                    ctx.save();
                    ctx.globalAlpha = flicker;
                    const glowGrad = ctx.createRadialGradient(x + 30, floorY - 158, 0, x + 30, floorY - 158, 60);
                    glowGrad.addColorStop(0, 'rgba(255, 180, 80, 0.7)');
                    glowGrad.addColorStop(0.3, 'rgba(255, 150, 50, 0.4)');
                    glowGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = glowGrad;
                    ctx.fillRect(x - 30, floorY - 220, 120, 130);
                    
                    // Inner light
                    ctx.fillStyle = 'rgba(255, 200, 120, 0.9)';
                    ctx.fillRect(x + 22, floorY - 168, 16, 22);
                    ctx.restore();
                    
                    // Ground light pool
                    ctx.save();
                    ctx.globalAlpha = flicker * 0.3;
                    const poolGrad = ctx.createRadialGradient(x + 30, floorY + 20, 0, x + 30, floorY + 20, 50);
                    poolGrad.addColorStop(0, 'rgba(255, 180, 80, 0.4)');
                    poolGrad.addColorStop(1, 'rgba(255, 180, 80, 0)');
                    ctx.fillStyle = poolGrad;
                    ctx.beginPath();
                    ctx.ellipse(x + 30, floorY + 20, 50, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                };
                
                // Street lanterns
                drawStreetLantern(300);
                drawStreetLantern(ARENA_WIDTH - 330);
                drawStreetLantern(ARENA_WIDTH / 2 - 15);

                // === COBBLESTONE STREET ===
                const streetGrad = ctx.createLinearGradient(0, floorY, 0, ARENA_HEIGHT);
                streetGrad.addColorStop(0, '#5a5550');
                streetGrad.addColorStop(0.3, '#4a4540');
                streetGrad.addColorStop(1, '#3a3530');
                ctx.fillStyle = streetGrad;
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);
                
                // Cobblestone pattern
                ctx.strokeStyle = '#3a3530';
                ctx.lineWidth = 1;
                
                // Irregular stone pattern
                const stoneRows = [
                    { y: floorY + 5, stones: [0, 45, 95, 140, 200, 250, 310, 365, 420, 480, 535, 590, 650, 710, 765, 820, 880, 940] },
                    { y: floorY + 22, stones: [20, 70, 130, 175, 235, 290, 345, 405, 455, 515, 570, 625, 685, 740, 800, 855, 915] },
                    { y: floorY + 40, stones: [0, 55, 105, 165, 215, 275, 325, 385, 440, 495, 555, 605, 665, 720, 780, 835, 895, 950] }
                ];
                
                stoneRows.forEach(row => {
                    for (let i = 0; i < row.stones.length - 1; i++) {
                        const x = row.stones[i];
                        const nextX = row.stones[i + 1];
                        const width = nextX - x - 4;
                        const height = 14;
                        
                        // Stone fill with slight variation
                        const shade = 0.9 + ((x * 7) % 10) * 0.02;
                        ctx.fillStyle = `rgba(${70 * shade}, ${65 * shade}, ${60 * shade}, 1)`;
                        ctx.fillRect(x + 2, row.y, width, height);
                        
                        // Stone outline
                        ctx.strokeRect(x + 2, row.y, width, height);
                    }
                });
                
                // Curb/edge
                ctx.fillStyle = '#4a4540';
                ctx.fillRect(0, floorY, ARENA_WIDTH, 4);

                // === AMBIENT OVERLAY ===
                // Dim stormy atmosphere
                const atmosphereGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                atmosphereGrad.addColorStop(0, 'rgba(50, 55, 65, 0.15)');
                atmosphereGrad.addColorStop(0.5, 'rgba(40, 45, 55, 0.1)');
                atmosphereGrad.addColorStop(1, 'rgba(30, 35, 45, 0.2)');
                ctx.fillStyle = atmosphereGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                // Subtle warm glow from lanterns (central area)
                const warmGlow = ctx.createRadialGradient(ARENA_WIDTH / 2, floorY - 50, 0, ARENA_WIDTH / 2, floorY - 50, 300);
                warmGlow.addColorStop(0, 'rgba(255, 200, 150, 0.05)');
                warmGlow.addColorStop(1, 'rgba(255, 200, 150, 0)');
                ctx.fillStyle = warmGlow;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            }),

            new Arena('Fishing Junk', 'travel', (ctx) => {
                // Time in seconds for animations
                const timeSeconds = performance.now() * 0.001;
                
                // Gentle boat rocking motion
                const boatRock = Math.sin(timeSeconds * 0.4) * 0.015;
                const boatBob = Math.sin(timeSeconds * 0.5) * 3;
                
                // Background - misty sea and sky at dawn/dusk
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#2a3a4a');
                skyGrad.addColorStop(0.2, '#3a4a5a');
                skyGrad.addColorStop(0.4, '#5a6a7a');
                skyGrad.addColorStop(0.6, '#7a8a9a');
                skyGrad.addColorStop(0.8, '#8a9aaa');
                skyGrad.addColorStop(1, '#6a8090');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                // Distant mountains/coastline silhouette
                ctx.fillStyle = '#3a4a5a';
                ctx.beginPath();
                ctx.moveTo(0, 180);
                ctx.lineTo(80, 140);
                ctx.lineTo(150, 165);
                ctx.lineTo(250, 120);
                ctx.lineTo(350, 150);
                ctx.lineTo(450, 130);
                ctx.lineTo(550, 155);
                ctx.lineTo(650, 125);
                ctx.lineTo(750, 145);
                ctx.lineTo(850, 115);
                ctx.lineTo(ARENA_WIDTH, 140);
                ctx.lineTo(ARENA_WIDTH, 200);
                ctx.lineTo(0, 200);
                ctx.closePath();
                ctx.fill();
                
                // Mist over distant shore
                const mistGrad = ctx.createLinearGradient(0, 120, 0, 200);
                mistGrad.addColorStop(0, 'rgba(150, 170, 190, 0)');
                mistGrad.addColorStop(0.5, 'rgba(150, 170, 190, 0.3)');
                mistGrad.addColorStop(1, 'rgba(150, 170, 190, 0.1)');
                ctx.fillStyle = mistGrad;
                ctx.fillRect(0, 120, ARENA_WIDTH, 80);
                
                // === SEA ===
                const seaY = 180;
                const seaGrad = ctx.createLinearGradient(0, seaY, 0, ARENA_HEIGHT);
                seaGrad.addColorStop(0, '#4a6070');
                seaGrad.addColorStop(0.3, '#3a5060');
                seaGrad.addColorStop(0.6, '#2a4050');
                seaGrad.addColorStop(1, '#1a3040');
                ctx.fillStyle = seaGrad;
                ctx.fillRect(0, seaY, ARENA_WIDTH, ARENA_HEIGHT - seaY);
                
                // Animated waves
                ctx.strokeStyle = 'rgba(100, 140, 170, 0.3)';
                ctx.lineWidth = 2;
                for (let row = 0; row < 8; row++) {
                    const waveY = seaY + 20 + row * 30;
                    const wavePhase = timeSeconds * 0.8 + row * 0.7;
                    const waveAmp = 3 + row * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, waveY);
                    for (let x = 0; x < ARENA_WIDTH; x += 10) {
                        ctx.lineTo(x, waveY + Math.sin(x * 0.02 + wavePhase) * waveAmp);
                    }
                    ctx.stroke();
                }
                
                // Wave foam/highlights near boat
                ctx.fillStyle = 'rgba(200, 220, 240, 0.15)';
                for (let i = 0; i < 6; i++) {
                    const foamX = 200 + i * 100 + Math.sin(timeSeconds * 0.6 + i) * 20;
                    const foamY = seaY + 30 + Math.sin(timeSeconds * 0.5 + i * 1.3) * 5;
                    ctx.beginPath();
                    ctx.ellipse(foamX, foamY, 25 + i * 3, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;
                
                // === BOAT HULL (junk ship) ===
                ctx.save();
                ctx.translate(ARENA_WIDTH / 2, floorY + boatBob);
                ctx.rotate(boatRock);
                ctx.translate(-ARENA_WIDTH / 2, -floorY);
                
                // Hull shadow in water
                ctx.fillStyle = 'rgba(20, 40, 60, 0.4)';
                ctx.beginPath();
                ctx.ellipse(ARENA_WIDTH / 2, floorY + 50, 380, 25, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Main hull
                const hullGrad = ctx.createLinearGradient(0, floorY - 80, 0, floorY + 30);
                hullGrad.addColorStop(0, '#5a4030');
                hullGrad.addColorStop(0.5, '#4a3525');
                hullGrad.addColorStop(1, '#3a2a1a');
                ctx.fillStyle = hullGrad;
                
                ctx.beginPath();
                // Curved junk hull shape
                ctx.moveTo(80, floorY);
                ctx.quadraticCurveTo(60, floorY + 20, 100, floorY + 35);
                ctx.lineTo(ARENA_WIDTH - 100, floorY + 35);
                ctx.quadraticCurveTo(ARENA_WIDTH - 60, floorY + 20, ARENA_WIDTH - 80, floorY);
                ctx.lineTo(ARENA_WIDTH - 50, floorY - 30);
                ctx.quadraticCurveTo(ARENA_WIDTH - 30, floorY - 60, ARENA_WIDTH - 60, floorY - 80);
                ctx.lineTo(60, floorY - 80);
                ctx.quadraticCurveTo(30, floorY - 60, 50, floorY - 30);
                ctx.closePath();
                ctx.fill();
                
                // Hull planks
                ctx.strokeStyle = '#2a1a10';
                ctx.lineWidth = 1;
                for (let y = floorY - 70; y < floorY + 20; y += 18) {
                    ctx.beginPath();
                    ctx.moveTo(70, y);
                    ctx.lineTo(ARENA_WIDTH - 70, y);
                    ctx.stroke();
                }
                
                // Bow decoration (eye motif - traditional on Chinese junks)
                const drawEye = (x, flip) => {
                    ctx.save();
                    ctx.translate(x, floorY - 40);
                    ctx.scale(flip ? -1 : 1, 1);
                    
                    // Eye white
                    ctx.fillStyle = '#f0e8d8';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 18, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye outline
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Pupil
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath();
                    ctx.arc(3, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Highlight
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(5, -2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                };
                
                drawEye(95, false);
                drawEye(ARENA_WIDTH - 95, true);
                
                // Raised stern cabin
                const cabinX = ARENA_WIDTH - 200;
                const cabinW = 130;
                const cabinH = 90;
                const cabinY = floorY - 80 - cabinH;
                
                // Cabin walls
                const cabinGrad = ctx.createLinearGradient(cabinX, cabinY, cabinX + cabinW, cabinY);
                cabinGrad.addColorStop(0, '#5a4535');
                cabinGrad.addColorStop(0.5, '#6a5545');
                cabinGrad.addColorStop(1, '#5a4535');
                ctx.fillStyle = cabinGrad;
                ctx.fillRect(cabinX, cabinY, cabinW, cabinH);
                
                // Cabin roof (curved traditional style)
                ctx.fillStyle = '#3a3030';
                ctx.beginPath();
                ctx.moveTo(cabinX - 15, cabinY);
                ctx.quadraticCurveTo(cabinX + cabinW/2, cabinY - 25, cabinX + cabinW + 15, cabinY);
                ctx.lineTo(cabinX + cabinW + 10, cabinY + 8);
                ctx.quadraticCurveTo(cabinX + cabinW/2, cabinY - 15, cabinX - 10, cabinY + 8);
                ctx.closePath();
                ctx.fill();
                
                // Roof edge decorations
                ctx.strokeStyle = '#8b0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cabinX - 15, cabinY);
                ctx.quadraticCurveTo(cabinX + cabinW/2, cabinY - 25, cabinX + cabinW + 15, cabinY);
                ctx.stroke();
                
                // Cabin window
                ctx.fillStyle = '#2a2520';
                ctx.fillRect(cabinX + cabinW/2 - 20, cabinY + 25, 40, 35);
                ctx.strokeStyle = '#4a3a30';
                ctx.lineWidth = 2;
                ctx.strokeRect(cabinX + cabinW/2 - 20, cabinY + 25, 40, 35);
                // Window cross
                ctx.beginPath();
                ctx.moveTo(cabinX + cabinW/2, cabinY + 25);
                ctx.lineTo(cabinX + cabinW/2, cabinY + 60);
                ctx.moveTo(cabinX + cabinW/2 - 20, cabinY + 42);
                ctx.lineTo(cabinX + cabinW/2 + 20, cabinY + 42);
                ctx.stroke();
                
                // Lantern glow from window
                ctx.fillStyle = 'rgba(255, 180, 100, 0.3)';
                ctx.fillRect(cabinX + cabinW/2 - 18, cabinY + 27, 36, 31);
                
                // === MAST AND SAIL ===
                const mastX = ARENA_WIDTH / 2 - 50;
                const mastY = floorY - 80;
                const mastHeight = 280;
                
                // Main mast
                ctx.fillStyle = '#4a3a25';
                ctx.fillRect(mastX - 8, mastY - mastHeight, 16, mastHeight);
                
                // Mast top ornament
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.moveTo(mastX, mastY - mastHeight - 15);
                ctx.lineTo(mastX - 10, mastY - mastHeight);
                ctx.lineTo(mastX + 10, mastY - mastHeight);
                ctx.closePath();
                ctx.fill();
                
                // Batten sail (traditional Chinese junk sail with horizontal battens)
                const sailWidth = 200;
                const sailHeight = 220;
                const sailX = mastX + 20;
                const sailY = mastY - mastHeight + 30;
                const battenCount = 7;
                
                // Sail billow based on wind
                const windBillow = Math.sin(timeSeconds * 0.3) * 8 + 15;
                
                // Draw sail panels between battens
                for (let i = 0; i < battenCount - 1; i++) {
                    const y1 = sailY + i * (sailHeight / (battenCount - 1));
                    const y2 = sailY + (i + 1) * (sailHeight / (battenCount - 1));
                    const billow1 = Math.sin((i / battenCount) * Math.PI) * windBillow;
                    const billow2 = Math.sin(((i + 1) / battenCount) * Math.PI) * windBillow;
                    
                    // Aged canvas color
                    const sailShade = 0.85 + (i % 2) * 0.1;
                    ctx.fillStyle = `rgb(${Math.floor(180 * sailShade)}, ${Math.floor(160 * sailShade)}, ${Math.floor(130 * sailShade)})`;
                    
                    ctx.beginPath();
                    ctx.moveTo(sailX, y1);
                    ctx.quadraticCurveTo(sailX + sailWidth/2 + billow1, (y1 + y2)/2, sailX, y2);
                    ctx.lineTo(sailX + sailWidth - 20, y2);
                    ctx.quadraticCurveTo(sailX + sailWidth/2 + billow2, (y1 + y2)/2, sailX + sailWidth - 20, y1);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Battens (horizontal bamboo poles)
                ctx.strokeStyle = '#6a5a40';
                ctx.lineWidth = 4;
                for (let i = 0; i < battenCount; i++) {
                    const y = sailY + i * (sailHeight / (battenCount - 1));
                    const billow = Math.sin((i / battenCount) * Math.PI) * windBillow * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(sailX - 10, y);
                    ctx.quadraticCurveTo(sailX + sailWidth/2 + billow, y + 3, sailX + sailWidth - 10, y);
                    ctx.stroke();
                }
                
                // Rigging lines
                ctx.strokeStyle = 'rgba(60, 50, 40, 0.6)';
                ctx.lineWidth = 1;
                // From mast top to sail corners
                ctx.beginPath();
                ctx.moveTo(mastX, mastY - mastHeight);
                ctx.lineTo(sailX + sailWidth - 10, sailY);
                ctx.moveTo(mastX, mastY - mastHeight);
                ctx.lineTo(sailX + sailWidth - 10, sailY + sailHeight);
                ctx.stroke();
                
                // Secondary smaller mast (stern)
                const mast2X = ARENA_WIDTH - 250;
                const mast2Height = 150;
                ctx.fillStyle = '#4a3a25';
                ctx.fillRect(mast2X - 5, mastY - mast2Height, 10, mast2Height);
                
                // Small flag/pennant
                const flagWave = Math.sin(timeSeconds * 2) * 5;
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.moveTo(mast2X, mastY - mast2Height);
                ctx.lineTo(mast2X + 40 + flagWave, mastY - mast2Height + 15);
                ctx.lineTo(mast2X, mastY - mast2Height + 30);
                ctx.closePath();
                ctx.fill();
                
                // === DECK DETAILS ===
                // Deck floor (fighting platform)
                ctx.fillStyle = '#5a4a35';
                ctx.fillRect(100, floorY - 5, ARENA_WIDTH - 200, 10);
                
                // Deck planks
                ctx.strokeStyle = '#3a2a1a';
                ctx.lineWidth = 1;
                for (let x = 110; x < ARENA_WIDTH - 110; x += 35) {
                    ctx.beginPath();
                    ctx.moveTo(x, floorY - 5);
                    ctx.lineTo(x, floorY + 5);
                    ctx.stroke();
                }
                
                // Fishing nets draped on side
                const drawNet = (startX, startY, width, height) => {
                    ctx.strokeStyle = 'rgba(90, 80, 60, 0.5)';
                    ctx.lineWidth = 1;
                    const meshSize = 12;
                    for (let x = startX; x < startX + width; x += meshSize) {
                        for (let y = startY; y < startY + height; y += meshSize) {
                            const sag = Math.sin((x - startX) / width * Math.PI) * 8;
                            ctx.beginPath();
                            ctx.moveTo(x, y + sag);
                            ctx.lineTo(x + meshSize, y + sag);
                            ctx.lineTo(x + meshSize, y + meshSize + sag);
                            ctx.stroke();
                        }
                    }
                };
                
                drawNet(120, floorY - 70, 80, 50);
                
                // Barrels and crates
                // Barrel
                ctx.fillStyle = '#5a4530';
                ctx.beginPath();
                ctx.ellipse(170, floorY - 25, 18, 22, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#4a3525';
                ctx.beginPath();
                ctx.ellipse(170, floorY - 47, 16, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#3a2a1a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(170, floorY - 15, 17, 4, 0, 0, Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(170, floorY - 38, 17, 4, 0, 0, Math.PI);
                ctx.stroke();
                
                // Coiled rope
                ctx.strokeStyle = '#8a7a60';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(220, floorY - 15, 15, 0, Math.PI * 1.8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(220, floorY - 15, 10, 0.5, Math.PI * 1.5);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(220, floorY - 15, 5, 1, Math.PI * 1.2);
                ctx.stroke();
                
                // Fish baskets
                const drawBasket = (x, y) => {
                    ctx.fillStyle = '#6a5a40';
                    ctx.beginPath();
                    ctx.moveTo(x - 15, y);
                    ctx.lineTo(x - 12, y - 25);
                    ctx.lineTo(x + 12, y - 25);
                    ctx.lineTo(x + 15, y);
                    ctx.closePath();
                    ctx.fill();
                    // Weave pattern
                    ctx.strokeStyle = '#4a3a25';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x - 14 + i, y - 5 - i * 5);
                        ctx.lineTo(x + 14 - i, y - 5 - i * 5);
                        ctx.stroke();
                    }
                };
                
                drawBasket(ARENA_WIDTH - 200, floorY - 5);
                drawBasket(ARENA_WIDTH - 170, floorY - 5);
                
                // Lantern on deck
                const lanternX = 280;
                const flicker = 0.85 + Math.sin(timeSeconds * 3) * 0.1;
                
                ctx.fillStyle = '#2a2520';
                ctx.fillRect(lanternX - 3, floorY - 60, 6, 55);
                
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.ellipse(lanternX, floorY - 75, 12, 18, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.save();
                ctx.globalAlpha = flicker;
                const lanternGlow = ctx.createRadialGradient(lanternX, floorY - 75, 0, lanternX, floorY - 75, 50);
                lanternGlow.addColorStop(0, 'rgba(255, 150, 50, 0.5)');
                lanternGlow.addColorStop(0.5, 'rgba(255, 100, 30, 0.2)');
                lanternGlow.addColorStop(1, 'rgba(255, 50, 0, 0)');
                ctx.fillStyle = lanternGlow;
                ctx.fillRect(lanternX - 60, floorY - 130, 120, 110);
                ctx.restore();
                
                ctx.restore(); // End boat transform
                
                // === AMBIENT EFFECTS ===
                // Sea spray mist at bottom
                const sprayGrad = ctx.createLinearGradient(0, ARENA_HEIGHT - 80, 0, ARENA_HEIGHT);
                sprayGrad.addColorStop(0, 'rgba(150, 180, 200, 0)');
                sprayGrad.addColorStop(1, 'rgba(150, 180, 200, 0.15)');
                ctx.fillStyle = sprayGrad;
                ctx.fillRect(0, ARENA_HEIGHT - 80, ARENA_WIDTH, 80);
                
                // Distant seabirds
                const drawBird = (x, y, size, phase) => {
                    const wingFlap = Math.sin(timeSeconds * 4 + phase) * 0.3;
                    ctx.strokeStyle = '#2a3a4a';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - size, y + Math.sin(wingFlap) * size);
                    ctx.quadraticCurveTo(x, y - size * 0.3, x + size, y + Math.sin(wingFlap) * size);
                    ctx.stroke();
                };
                
                drawBird(150, 80, 8, 0);
                drawBird(180, 70, 6, 1);
                drawBird(200, 85, 7, 2);
                drawBird(ARENA_WIDTH - 200, 75, 7, 3);
                drawBird(ARENA_WIDTH - 170, 90, 5, 4);
                
                // Golden hour sun glow
                const sunGlow = ctx.createRadialGradient(100, 100, 0, 100, 100, 200);
                sunGlow.addColorStop(0, 'rgba(255, 200, 100, 0.15)');
                sunGlow.addColorStop(0.5, 'rgba(255, 180, 80, 0.05)');
                sunGlow.addColorStop(1, 'rgba(255, 150, 50, 0)');
                ctx.fillStyle = sunGlow;
                ctx.fillRect(0, 0, 300, 300);
            }),

            new Arena('Mountain Path', 'travel', (ctx) => {
                // Time in seconds for animations
                const timeSeconds = performance.now() * 0.001;
                
                // Background - misty mountain sky with depth
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#87a5b5');
                skyGrad.addColorStop(0.2, '#9ab5c5');
                skyGrad.addColorStop(0.4, '#adc5d0');
                skyGrad.addColorStop(0.6, '#c5d5dc');
                skyGrad.addColorStop(1, '#d8e5e8');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                // === DISTANT MOUNTAIN LAYERS (parallax feel) ===
                
                // Very distant peaks (faded blue)
                ctx.fillStyle = '#8a9fad';
                ctx.beginPath();
                ctx.moveTo(0, 160);
                ctx.lineTo(60, 100);
                ctx.lineTo(120, 130);
                ctx.lineTo(200, 70);
                ctx.lineTo(280, 110);
                ctx.lineTo(380, 55);
                ctx.lineTo(480, 95);
                ctx.lineTo(560, 60);
                ctx.lineTo(650, 100);
                ctx.lineTo(750, 50);
                ctx.lineTo(850, 90);
                ctx.lineTo(ARENA_WIDTH, 70);
                ctx.lineTo(ARENA_WIDTH, 200);
                ctx.lineTo(0, 200);
                ctx.closePath();
                ctx.fill();
                
                // Mid-distant peaks (slightly greener)
                ctx.fillStyle = '#7a9a8a';
                ctx.beginPath();
                ctx.moveTo(0, 180);
                ctx.lineTo(80, 130);
                ctx.lineTo(150, 155);
                ctx.lineTo(240, 110);
                ctx.lineTo(340, 145);
                ctx.lineTo(420, 100);
                ctx.lineTo(520, 140);
                ctx.lineTo(620, 95);
                ctx.lineTo(720, 135);
                ctx.lineTo(820, 105);
                ctx.lineTo(ARENA_WIDTH, 130);
                ctx.lineTo(ARENA_WIDTH, 220);
                ctx.lineTo(0, 220);
                ctx.closePath();
                ctx.fill();
                
                // Closer mountain range (lush green)
                ctx.fillStyle = '#5a8a6a';
                ctx.beginPath();
                ctx.moveTo(0, 200);
                ctx.lineTo(100, 160);
                ctx.lineTo(180, 180);
                ctx.lineTo(280, 140);
                ctx.lineTo(380, 170);
                ctx.lineTo(480, 130);
                ctx.lineTo(580, 165);
                ctx.lineTo(680, 125);
                ctx.lineTo(780, 160);
                ctx.lineTo(880, 140);
                ctx.lineTo(ARENA_WIDTH, 155);
                ctx.lineTo(ARENA_WIDTH, 250);
                ctx.lineTo(0, 250);
                ctx.closePath();
                ctx.fill();
                
                // Mist between mountain layers
                const mistGrad = ctx.createLinearGradient(0, 100, 0, 220);
                mistGrad.addColorStop(0, 'rgba(200, 220, 230, 0)');
                mistGrad.addColorStop(0.4, 'rgba(200, 220, 230, 0.25)');
                mistGrad.addColorStop(0.7, 'rgba(200, 220, 230, 0.15)');
                mistGrad.addColorStop(1, 'rgba(200, 220, 230, 0)');
                ctx.fillStyle = mistGrad;
                ctx.fillRect(0, 100, ARENA_WIDTH, 120);
                
                // === FOREGROUND MOUNTAINSIDE (where we stand) ===
                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;
                
                // Lush hillside gradient
                const hillGrad = ctx.createLinearGradient(0, 200, 0, floorY);
                hillGrad.addColorStop(0, '#4a7a5a');
                hillGrad.addColorStop(0.5, '#3a6a4a');
                hillGrad.addColorStop(1, '#2a5a3a');
                ctx.fillStyle = hillGrad;
                ctx.fillRect(0, 200, ARENA_WIDTH, floorY - 200);
                
                // === WEATHERED STONE PATH ===
                // Path winds from distance to foreground
                
                // Distant path section (creates depth illusion)
                ctx.fillStyle = '#6a6560';
                ctx.beginPath();
                ctx.moveTo(ARENA_WIDTH / 2 - 30, 210);
                ctx.lineTo(ARENA_WIDTH / 2 + 30, 210);
                ctx.lineTo(ARENA_WIDTH / 2 + 80, 280);
                ctx.lineTo(ARENA_WIDTH / 2 - 80, 280);
                ctx.closePath();
                ctx.fill();
                
                // Mid path
                ctx.fillStyle = '#5a5550';
                ctx.beginPath();
                ctx.moveTo(ARENA_WIDTH / 2 - 80, 280);
                ctx.lineTo(ARENA_WIDTH / 2 + 80, 280);
                ctx.lineTo(ARENA_WIDTH / 2 + 150, floorY - 30);
                ctx.lineTo(ARENA_WIDTH / 2 - 150, floorY - 30);
                ctx.closePath();
                ctx.fill();
                
                // === TREES AND VEGETATION ===
                
                // Pine/cypress tree function (classic Chinese mountain painting style)
                const drawPine = (x, baseY, height, lean) => {
                    ctx.save();
                    ctx.translate(x, baseY);
                    ctx.rotate(lean);
                    
                    // Trunk
                    const trunkGrad = ctx.createLinearGradient(-8, 0, 8, 0);
                    trunkGrad.addColorStop(0, '#3a2a1a');
                    trunkGrad.addColorStop(0.5, '#4a3a2a');
                    trunkGrad.addColorStop(1, '#3a2a1a');
                    ctx.fillStyle = trunkGrad;
                    ctx.fillRect(-6, -height, 12, height);
                    
                    // Branches with foliage (layered triangular shapes)
                    const layers = 5;
                    for (let i = 0; i < layers; i++) {
                        const layerY = -height + 20 + i * (height * 0.15);
                        const layerWidth = 25 + i * 15;
                        const layerHeight = 40 + i * 5;
                        
                        // Slight animation sway
                        const sway = Math.sin(timeSeconds * 0.2 + x * 0.01 + i * 0.5) * 2;
                        
                        ctx.fillStyle = i % 2 === 0 ? '#2a5a3a' : '#3a6a4a';
                        ctx.beginPath();
                        ctx.moveTo(sway, layerY);
                        ctx.lineTo(-layerWidth + sway, layerY + layerHeight);
                        ctx.lineTo(layerWidth + sway, layerY + layerHeight);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    ctx.restore();
                };
                
                // Background trees (smaller, more faded)
                ctx.globalAlpha = 0.6;
                drawPine(80, 220, 100, -0.05);
                drawPine(180, 230, 80, 0.03);
                drawPine(ARENA_WIDTH - 100, 225, 90, 0.05);
                drawPine(ARENA_WIDTH - 200, 235, 70, -0.02);
                ctx.globalAlpha = 1;
                
                // Foreground trees
                drawPine(40, floorY - 40, 160, -0.08);
                drawPine(130, floorY - 20, 140, 0.05);
                drawPine(ARENA_WIDTH - 50, floorY - 30, 150, 0.1);
                drawPine(ARENA_WIDTH - 150, floorY - 10, 130, -0.03);
                
                // === WILD GRASS AND FERNS ===
                const drawGrassClump = (x, y, count, height) => {
                    for (let i = 0; i < count; i++) {
                        const gx = x + (i - count/2) * 5;
                        const gh = height + ((gx * 7) % 15);
                        const sway = Math.sin(timeSeconds * 0.25 + gx * 0.05 + i) * 3;
                        
                        ctx.strokeStyle = `rgba(60, 100, 60, ${0.6 + (i % 3) * 0.15})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(gx, y);
                        ctx.quadraticCurveTo(gx + sway * 0.5, y - gh/2, gx + sway, y - gh);
                        ctx.stroke();
                    }
                };
                
                // Grass clumps along path edges
                drawGrassClump(200, floorY - 5, 8, 25);
                drawGrassClump(350, floorY - 3, 6, 30);
                drawGrassClump(550, floorY - 4, 7, 28);
                drawGrassClump(750, floorY - 5, 8, 25);
                
                // === ROCKY PATH SURFACE (fighting area) ===
                const pathGrad = ctx.createLinearGradient(0, floorY, 0, ARENA_HEIGHT);
                pathGrad.addColorStop(0, '#6a6560');
                pathGrad.addColorStop(0.3, '#5a5550');
                pathGrad.addColorStop(1, '#4a4540');
                ctx.fillStyle = pathGrad;
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);
                
                // Irregular stone slabs
                ctx.strokeStyle = '#3a3530';
                ctx.lineWidth = 2;
                
                // Large irregular flagstones
                const stones = [
                    { x: 20, y: floorY + 5, w: 70, h: 25, angle: 0.05 },
                    { x: 100, y: floorY + 8, w: 85, h: 22, angle: -0.03 },
                    { x: 195, y: floorY + 3, w: 75, h: 28, angle: 0.02 },
                    { x: 280, y: floorY + 10, w: 90, h: 20, angle: -0.04 },
                    { x: 380, y: floorY + 5, w: 80, h: 26, angle: 0.03 },
                    { x: 470, y: floorY + 8, w: 70, h: 24, angle: -0.02 },
                    { x: 550, y: floorY + 4, w: 85, h: 25, angle: 0.04 },
                    { x: 645, y: floorY + 9, w: 75, h: 22, angle: -0.03 },
                    { x: 730, y: floorY + 6, w: 80, h: 27, angle: 0.02 },
                    { x: 820, y: floorY + 5, w: 90, h: 23, angle: -0.05 },
                    { x: 920, y: floorY + 8, w: 35, h: 25, angle: 0.03 },
                    // Second row
                    { x: 40, y: floorY + 32, w: 65, h: 22, angle: -0.02 },
                    { x: 115, y: floorY + 35, w: 80, h: 20, angle: 0.04 },
                    { x: 205, y: floorY + 30, w: 70, h: 25, angle: -0.03 },
                    { x: 285, y: floorY + 38, w: 85, h: 18, angle: 0.02 },
                    { x: 380, y: floorY + 33, w: 75, h: 22, angle: -0.04 },
                    { x: 465, y: floorY + 35, w: 80, h: 20, angle: 0.03 },
                    { x: 555, y: floorY + 32, w: 70, h: 24, angle: -0.02 },
                    { x: 635, y: floorY + 37, w: 85, h: 19, angle: 0.04 },
                    { x: 730, y: floorY + 34, w: 75, h: 22, angle: -0.03 },
                    { x: 815, y: floorY + 36, w: 80, h: 20, angle: 0.02 },
                    { x: 905, y: floorY + 33, w: 50, h: 23, angle: -0.04 }
                ];
                
                stones.forEach(stone => {
                    ctx.save();
                    ctx.translate(stone.x + stone.w/2, stone.y + stone.h/2);
                    ctx.rotate(stone.angle);
                    
                    // Stone with subtle color variation
                    const shade = 0.9 + ((stone.x * 3) % 10) * 0.02;
                    ctx.fillStyle = `rgb(${Math.floor(90 * shade)}, ${Math.floor(85 * shade)}, ${Math.floor(80 * shade)})`;
                    ctx.fillRect(-stone.w/2, -stone.h/2, stone.w, stone.h);
                    ctx.strokeRect(-stone.w/2, -stone.h/2, stone.w, stone.h);
                    
                    ctx.restore();
                });
                
                // Moss on some stones
                ctx.fillStyle = 'rgba(80, 120, 70, 0.4)';
                stones.slice(0, 8).forEach((stone, i) => {
                    if (i % 2 === 0) {
                        ctx.beginPath();
                        ctx.ellipse(stone.x + stone.w * 0.3, stone.y + 8, 12, 5, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Edge of path (worn edges)
                ctx.fillStyle = '#4a5a4a';
                ctx.fillRect(0, floorY - 3, ARENA_WIDTH, 5);
                
                // === MILESTONE MARKER (journey reminder) ===
                const milestoneX = 680;
                
                // Weathered stone marker
                ctx.fillStyle = '#5a5550';
                ctx.beginPath();
                ctx.moveTo(milestoneX - 12, floorY - 5);
                ctx.lineTo(milestoneX - 8, floorY - 70);
                ctx.lineTo(milestoneX + 8, floorY - 70);
                ctx.lineTo(milestoneX + 12, floorY - 5);
                ctx.closePath();
                ctx.fill();
                
                // Rounded top
                ctx.beginPath();
                ctx.arc(milestoneX, floorY - 70, 10, Math.PI, 0);
                ctx.fill();
                
                // Carved character (distance marker)
                ctx.fillStyle = '#3a3530';
                ctx.font = '18px serif';
                ctx.textAlign = 'center';
                ctx.fillText('Èáå', milestoneX, floorY - 35);
                
                // === WORN TRAVELER'S SHRINE ===
                const shrineX = 260;
                
                // Small stone base
                ctx.fillStyle = '#5a5a55';
                ctx.fillRect(shrineX - 25, floorY - 15, 50, 15);
                
                // Tiny shrine/jizo statue
                ctx.fillStyle = '#6a6a65';
                ctx.beginPath();
                ctx.moveTo(shrineX - 10, floorY - 15);
                ctx.lineTo(shrineX - 8, floorY - 45);
                ctx.quadraticCurveTo(shrineX, floorY - 55, shrineX + 8, floorY - 45);
                ctx.lineTo(shrineX + 10, floorY - 15);
                ctx.closePath();
                ctx.fill();
                
                // Faded red cloth offering (tattered by weather)
                ctx.fillStyle = 'rgba(150, 60, 60, 0.6)';
                const clothWave = Math.sin(timeSeconds * 0.5) * 2;
                ctx.beginPath();
                ctx.moveTo(shrineX - 5, floorY - 40);
                ctx.quadraticCurveTo(shrineX - 15 + clothWave, floorY - 35, shrineX - 12 + clothWave, floorY - 25);
                ctx.lineTo(shrineX - 3, floorY - 38);
                ctx.closePath();
                ctx.fill();
                
                // Small incense holder (cold - no one has visited in a while)
                ctx.fillStyle = '#4a4a45';
                ctx.fillRect(shrineX + 15, floorY - 20, 8, 5);
                
                // === CLOUDS DRIFTING ===
                const drawCloud = (baseX, y, size, speed) => {
                    const x = ((baseX + timeSeconds * speed * 10) % (ARENA_WIDTH + 200)) - 100;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(x, y, size, size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(x + size * 0.6, y + 5, size * 0.7, size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(x - size * 0.5, y + 3, size * 0.6, size * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                };
                
                drawCloud(100, 50, 50, 0.3);
                drawCloud(400, 35, 40, 0.2);
                drawCloud(700, 55, 45, 0.25);
                
                // === DISTANT WATERFALL (between peaks) ===
                const waterfallX = 440;
                ctx.fillStyle = 'rgba(200, 230, 250, 0.4)';
                ctx.fillRect(waterfallX, 110, 4, 70);
                // Mist at base
                ctx.fillStyle = 'rgba(200, 230, 250, 0.2)';
                ctx.beginPath();
                ctx.ellipse(waterfallX + 2, 180, 15, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // === EAGLE CIRCLING ===
                const eagleTime = timeSeconds * 0.3;
                const eagleX = ARENA_WIDTH / 2 + Math.cos(eagleTime) * 150;
                const eagleY = 90 + Math.sin(eagleTime * 0.7) * 20;
                const wingPos = Math.sin(timeSeconds * 2) * 0.4;
                
                ctx.strokeStyle = '#2a3a4a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(eagleX - 15, eagleY + Math.sin(wingPos) * 8);
                ctx.quadraticCurveTo(eagleX, eagleY - 3, eagleX + 15, eagleY + Math.sin(wingPos) * 8);
                ctx.stroke();
                
                // === ATMOSPHERIC HAZE ===
                const hazeGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                hazeGrad.addColorStop(0, 'rgba(180, 200, 210, 0.1)');
                hazeGrad.addColorStop(0.5, 'rgba(180, 200, 210, 0.05)');
                hazeGrad.addColorStop(1, 'rgba(150, 180, 190, 0.15)');
                ctx.fillStyle = hazeGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            }),

            new Arena('Imperial Palace', 'place', (ctx) => {
                // Time in seconds for animations
                const timeSeconds = performance.now() * 0.001;
                
                // Background - warm evening sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#1a1a2e');
                skyGrad.addColorStop(0.2, '#2a2a3e');
                skyGrad.addColorStop(0.4, '#3a3040');
                skyGrad.addColorStop(0.6, '#4a3545');
                skyGrad.addColorStop(1, '#3a3040');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                const floorH = 60;
                const floorY = ARENA_HEIGHT - floorH;
                
                // === DISTANT PALACE BUILDINGS (background) ===
                // Back hall silhouette
                ctx.fillStyle = '#2a2530';
                ctx.fillRect(200, 80, 560, 180);
                
                // Back hall roof
                ctx.fillStyle = '#3a2020';
                ctx.beginPath();
                ctx.moveTo(180, 80);
                ctx.quadraticCurveTo(480, 30, 780, 80);
                ctx.lineTo(780, 100);
                ctx.quadraticCurveTo(480, 55, 180, 100);
                ctx.closePath();
                ctx.fill();
                
                // Roof ridge ornaments
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.moveTo(480, 30);
                ctx.lineTo(475, 45);
                ctx.lineTo(485, 45);
                ctx.closePath();
                ctx.fill();
                
                // === MAIN PALACE HALL ===
                const hallX = ARENA_WIDTH / 2;
                const hallWidth = 500;
                const hallHeight = 200;
                const hallY = floorY - hallHeight;
                
                // Main wall
                const wallGrad = ctx.createLinearGradient(hallX - hallWidth/2, 0, hallX + hallWidth/2, 0);
                wallGrad.addColorStop(0, '#5a2020');
                wallGrad.addColorStop(0.3, '#7a3030');
                wallGrad.addColorStop(0.5, '#8a3535');
                wallGrad.addColorStop(0.7, '#7a3030');
                wallGrad.addColorStop(1, '#5a2020');
                ctx.fillStyle = wallGrad;
                ctx.fillRect(hallX - hallWidth/2, hallY, hallWidth, hallHeight);
                
                // === ORNATE ROOF ===
                // Main roof (curved traditional style)
                const roofGrad = ctx.createLinearGradient(0, hallY - 80, 0, hallY);
                roofGrad.addColorStop(0, '#4a3a20');
                roofGrad.addColorStop(0.5, '#6a5030');
                roofGrad.addColorStop(1, '#4a3a20');
                ctx.fillStyle = roofGrad;
                
                ctx.beginPath();
                ctx.moveTo(hallX - hallWidth/2 - 50, hallY);
                ctx.quadraticCurveTo(hallX - hallWidth/4, hallY - 60, hallX, hallY - 80);
                ctx.quadraticCurveTo(hallX + hallWidth/4, hallY - 60, hallX + hallWidth/2 + 50, hallY);
                ctx.lineTo(hallX + hallWidth/2 + 40, hallY + 15);
                ctx.quadraticCurveTo(hallX + hallWidth/4, hallY - 40, hallX, hallY - 60);
                ctx.quadraticCurveTo(hallX - hallWidth/4, hallY - 40, hallX - hallWidth/2 - 40, hallY + 15);
                ctx.closePath();
                ctx.fill();
                
                // Roof edge decoration (golden trim)
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(hallX - hallWidth/2 - 50, hallY);
                ctx.quadraticCurveTo(hallX - hallWidth/4, hallY - 60, hallX, hallY - 80);
                ctx.quadraticCurveTo(hallX + hallWidth/4, hallY - 60, hallX + hallWidth/2 + 50, hallY);
                ctx.stroke();
                
                // Roof corner upturns (traditional Chinese roof ends)
                const drawRoofCorner = (x, flip) => {
                    ctx.save();
                    ctx.translate(x, hallY);
                    ctx.scale(flip ? -1 : 1, 1);
                    
                    ctx.fillStyle = '#6a5030';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(30, -10, 50, -30);
                    ctx.quadraticCurveTo(55, -25, 45, -5);
                    ctx.lineTo(10, 15);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Corner ornament (dragon/phoenix finial)
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(50, -30, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                };
                
                drawRoofCorner(hallX - hallWidth/2 - 50, false);
                drawRoofCorner(hallX + hallWidth/2 + 50, true);
                
                // Roof ridge with ornaments
                ctx.fillStyle = '#ffd700';
                // Central dragon/pearl ornament
                ctx.beginPath();
                ctx.arc(hallX, hallY - 85, 8, 0, Math.PI * 2);
                ctx.fill();
                // Ridge beasts (simplified)
                for (let i = 1; i <= 4; i++) {
                    ctx.beginPath();
                    ctx.arc(hallX - i * 50, hallY - 80 + i * 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(hallX + i * 50, hallY - 80 + i * 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // === PILLARS ===
                const pillarCount = 6;
                const pillarSpacing = hallWidth / (pillarCount + 1);
                
                for (let i = 1; i <= pillarCount; i++) {
                    const px = hallX - hallWidth/2 + i * pillarSpacing;
                    
                    // Pillar shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(px - 12, hallY + 5, 28, hallHeight - 5);
                    
                    // Main pillar
                    const pillarGrad = ctx.createLinearGradient(px - 14, 0, px + 14, 0);
                    pillarGrad.addColorStop(0, '#6a1515');
                    pillarGrad.addColorStop(0.3, '#9a2525');
                    pillarGrad.addColorStop(0.6, '#aa3030');
                    pillarGrad.addColorStop(1, '#6a1515');
                    ctx.fillStyle = pillarGrad;
                    ctx.fillRect(px - 14, hallY, 28, hallHeight);
                    
                    // Pillar base
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(px - 18, floorY - 15, 36, 15);
                    
                    // Pillar capital (top decoration)
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(px - 16, hallY, 32, 8);
                    
                    // Gold band near top
                    ctx.fillRect(px - 14, hallY + 30, 28, 4);
                }
                
                // === CENTRAL DOORWAY ===
                const doorWidth = 80;
                const doorHeight = 140;
                const doorX = hallX - doorWidth/2;
                const doorY = floorY - doorHeight;
                
                // Door frame
                ctx.fillStyle = '#3a1010';
                ctx.fillRect(doorX - 8, doorY - 8, doorWidth + 16, doorHeight + 8);
                
                // Inner darkness
                ctx.fillStyle = '#1a0a0a';
                ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
                
                // Door panels (double door, slightly open)
                ctx.fillStyle = '#5a2020';
                ctx.fillRect(doorX + 2, doorY + 2, doorWidth/2 - 4, doorHeight - 4);
                ctx.fillRect(doorX + doorWidth/2 + 2, doorY + 2, doorWidth/2 - 4, doorHeight - 4);
                
                // Door studs (golden)
                ctx.fillStyle = '#ffd700';
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 3; col++) {
                        // Left door
                        ctx.beginPath();
                        ctx.arc(doorX + 10 + col * 12, doorY + 20 + row * 28, 3, 0, Math.PI * 2);
                        ctx.fill();
                        // Right door
                        ctx.beginPath();
                        ctx.arc(doorX + doorWidth/2 + 8 + col * 12, doorY + 20 + row * 28, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Door ring handles
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(doorX + doorWidth/2 - 12, doorY + doorHeight/2, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(doorX + doorWidth/2 + 12, doorY + doorHeight/2, 8, 0, Math.PI * 2);
                ctx.stroke();
                
                // === WINDOWS (latticed) ===
                const drawWindow = (x, y) => {
                    const ww = 50;
                    const wh = 70;
                    
                    // Frame
                    ctx.fillStyle = '#3a1010';
                    ctx.fillRect(x - 4, y - 4, ww + 8, wh + 8);
                    
                    // Inner glow (lantern light from inside)
                    const windowGlow = ctx.createRadialGradient(x + ww/2, y + wh/2, 0, x + ww/2, y + wh/2, ww);
                    windowGlow.addColorStop(0, 'rgba(255, 200, 100, 0.6)');
                    windowGlow.addColorStop(1, 'rgba(255, 150, 50, 0.2)');
                    ctx.fillStyle = windowGlow;
                    ctx.fillRect(x, y, ww, wh);
                    
                    // Lattice pattern
                    ctx.strokeStyle = '#4a2020';
                    ctx.lineWidth = 2;
                    // Vertical bars
                    for (let i = 1; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x + i * ww/4, y);
                        ctx.lineTo(x + i * ww/4, y + wh);
                        ctx.stroke();
                    }
                    // Horizontal bars
                    for (let i = 1; i < 5; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x, y + i * wh/5);
                        ctx.lineTo(x + ww, y + i * wh/5);
                        ctx.stroke();
                    }
                };
                
                drawWindow(hallX - 180, hallY + 50);
                drawWindow(hallX - 110, hallY + 50);
                drawWindow(hallX + 60, hallY + 50);
                drawWindow(hallX + 130, hallY + 50);
                
                // === GUARDIAN LION STATUES ===
                const drawLion = (x, flip) => {
                    ctx.save();
                    ctx.translate(x, floorY);
                    ctx.scale(flip ? -1 : 1, 1);
                    
                    // Pedestal
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(-25, -20, 50, 20);
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(-30, -25, 60, 8);
                    
                    // Lion body
                    ctx.fillStyle = '#6a6a5a';
                    ctx.beginPath();
                    ctx.moveTo(-15, -20);
                    ctx.bezierCurveTo(-20, -50, -15, -70, 0, -75);
                    ctx.bezierCurveTo(15, -70, 20, -50, 15, -20);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Mane curls
                    ctx.fillStyle = '#5a5a4a';
                    for (let i = 0; i < 5; i++) {
                        const angle = -0.8 + i * 0.4;
                        const mx = Math.cos(angle) * 18;
                        const my = -55 + Math.sin(angle) * 15;
                        ctx.beginPath();
                        ctx.arc(mx, my, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Face features
                    ctx.fillStyle = '#4a4a3a';
                    // Eyes
                    ctx.beginPath();
                    ctx.arc(-5, -60, 3, 0, Math.PI * 2);
                    ctx.fill();
                    // Nose
                    ctx.beginPath();
                    ctx.arc(2, -52, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                };
                
                drawLion(hallX - hallWidth/2 - 80, false);
                drawLion(hallX + hallWidth/2 + 80, true);
                
                // === HANGING LANTERNS ===
                const drawHangingLantern = (x, y) => {
                    const flicker = 0.85 + Math.sin(timeSeconds * 2.5 + x * 0.02) * 0.1;
                    
                    // Cord
                    ctx.strokeStyle = '#3a1010';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, hallY);
                    ctx.lineTo(x, y - 25);
                    ctx.stroke();
                    
                    // Lantern top cap
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(x - 12, y - 25);
                    ctx.lineTo(x, y - 35);
                    ctx.lineTo(x + 12, y - 25);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lantern body
                    ctx.fillStyle = '#cc0000';
                    ctx.beginPath();
                    ctx.ellipse(x, y, 15, 22, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glow
                    ctx.save();
                    ctx.globalAlpha = flicker;
                    const lanternGlow = ctx.createRadialGradient(x, y, 0, x, y, 50);
                    lanternGlow.addColorStop(0, 'rgba(255, 100, 50, 0.5)');
                    lanternGlow.addColorStop(0.5, 'rgba(255, 50, 20, 0.2)');
                    lanternGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = lanternGlow;
                    ctx.fillRect(x - 60, y - 60, 120, 120);
                    ctx.restore();
                    
                    // Lantern character (Á¶è = fortune)
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '14px serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Á¶è', x, y);
                    
                    // Tassel
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(x - 2, y + 22, 4, 15);
                    ctx.beginPath();
                    ctx.moveTo(x - 8, y + 37);
                    ctx.lineTo(x, y + 50);
                    ctx.lineTo(x + 8, y + 37);
                    ctx.closePath();
                    ctx.fill();
                };
                
                drawHangingLantern(hallX - 150, hallY + 70);
                drawHangingLantern(hallX + 150, hallY + 70);
                
                // === INCENSE BURNER (center) ===
                const burnerX = hallX;
                const burnerY = floorY;
                
                // Tripod base
                ctx.fillStyle = '#4a4a40';
                ctx.beginPath();
                ctx.moveTo(burnerX - 25, burnerY);
                ctx.lineTo(burnerX - 15, burnerY - 40);
                ctx.lineTo(burnerX + 15, burnerY - 40);
                ctx.lineTo(burnerX + 25, burnerY);
                ctx.closePath();
                ctx.fill();
                
                // Bowl
                ctx.fillStyle = '#5a5a50';
                ctx.beginPath();
                ctx.ellipse(burnerX, burnerY - 45, 20, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#3a3a30';
                ctx.beginPath();
                ctx.ellipse(burnerX, burnerY - 45, 15, 7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Incense smoke (rising wisps)
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const smokeX = burnerX - 5 + i * 5;
                    const smokeOffset = Math.sin(timeSeconds * 0.5 + i) * 10;
                    ctx.beginPath();
                    ctx.moveTo(smokeX, burnerY - 50);
                    ctx.bezierCurveTo(
                        smokeX + smokeOffset, burnerY - 70,
                        smokeX - smokeOffset, burnerY - 90,
                        smokeX + smokeOffset * 0.5, burnerY - 110
                    );
                    ctx.stroke();
                }
                
                // === MARBLE FLOOR ===
                const floorGrad = ctx.createLinearGradient(0, floorY, 0, ARENA_HEIGHT);
                floorGrad.addColorStop(0, '#6a6a65');
                floorGrad.addColorStop(0.3, '#5a5a55');
                floorGrad.addColorStop(1, '#4a4a45');
                ctx.fillStyle = floorGrad;
                ctx.fillRect(0, floorY, ARENA_WIDTH, floorH);
                
                // Floor tiles (large marble squares)
                ctx.strokeStyle = '#4a4a40';
                ctx.lineWidth = 2;
                const tileSize = 80;
                for (let x = 0; x < ARENA_WIDTH; x += tileSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, floorY);
                    ctx.lineTo(x, ARENA_HEIGHT);
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.moveTo(0, floorY + 30);
                ctx.lineTo(ARENA_WIDTH, floorY + 30);
                ctx.stroke();
                
                // Floor shine/polish effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                for (let x = 40; x < ARENA_WIDTH; x += tileSize) {
                    ctx.beginPath();
                    ctx.ellipse(x, floorY + 15, 30, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Red carpet runner (leading to door)
                ctx.fillStyle = '#6a1515';
                ctx.fillRect(hallX - 50, floorY, 100, floorH);
                ctx.fillStyle = '#8a2020';
                ctx.fillRect(hallX - 45, floorY, 90, floorH);
                // Carpet border pattern
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(hallX - 45, floorY + 2, 2, floorH - 4);
                ctx.fillRect(hallX + 43, floorY + 2, 2, floorH - 4);
                
                // Raised edge
                ctx.fillStyle = '#5a5a50';
                ctx.fillRect(0, floorY - 3, ARENA_WIDTH, 5);
                
                // === DECORATIVE BANNERS ===
                const drawBanner = (x) => {
                    const bannerWave = Math.sin(timeSeconds * 0.3 + x * 0.01) * 3;
                    
                    // Pole
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(x - 3, hallY + 20, 6, 150);
                    
                    // Banner fabric
                    ctx.fillStyle = '#cc0000';
                    ctx.beginPath();
                    ctx.moveTo(x + 5, hallY + 30);
                    ctx.quadraticCurveTo(x + 35 + bannerWave, hallY + 90, x + 30, hallY + 150);
                    ctx.lineTo(x + 5, hallY + 150);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Banner text (vertical Chinese)
                    ctx.fillStyle = '#ffd700';
                    ctx.font = '16px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Â§©', x + 18 + bannerWave * 0.3, hallY + 60);
                    ctx.fillText('‰∏ã', x + 18 + bannerWave * 0.5, hallY + 85);
                    ctx.fillText('Â§™', x + 18 + bannerWave * 0.7, hallY + 110);
                    ctx.fillText('Âπ≥', x + 18 + bannerWave * 0.9, hallY + 135);
                };
                
                drawBanner(hallX - hallWidth/2 + 30);
                drawBanner(hallX + hallWidth/2 - 60);
                
                // === AMBIENT GLOW ===
                // Warm interior glow
                const interiorGlow = ctx.createRadialGradient(hallX, hallY + 100, 0, hallX, hallY + 100, 300);
                interiorGlow.addColorStop(0, 'rgba(255, 180, 100, 0.1)');
                interiorGlow.addColorStop(1, 'rgba(255, 150, 80, 0)');
                ctx.fillStyle = interiorGlow;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                // Moon glow (top right)
                const moonGlow = ctx.createRadialGradient(ARENA_WIDTH - 100, 60, 0, ARENA_WIDTH - 100, 60, 80);
                moonGlow.addColorStop(0, 'rgba(255, 255, 230, 0.3)');
                moonGlow.addColorStop(0.3, 'rgba(255, 255, 220, 0.1)');
                moonGlow.addColorStop(1, 'rgba(255, 255, 200, 0)');
                ctx.fillStyle = moonGlow;
                ctx.fillRect(ARENA_WIDTH - 180, 0, 180, 150);
                
                // Moon
                ctx.fillStyle = 'rgba(255, 255, 230, 0.8)';
                ctx.beginPath();
                ctx.arc(ARENA_WIDTH - 100, 60, 25, 0, Math.PI * 2);
                ctx.fill();
            }),

            new Arena('Forest Bridge', 'travel', (ctx) => {
                // Time in seconds for animations
                const timeSeconds = performance.now() * 0.001;
                
                // Background - misty mountain valley sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#6a8a9a');
                skyGrad.addColorStop(0.2, '#8aaaba');
                skyGrad.addColorStop(0.4, '#a5c5d5');
                skyGrad.addColorStop(0.7, '#c5dde8');
                skyGrad.addColorStop(1, '#d5e8ef');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                // === DISTANT CLOUDS ===
                const drawCloud = (x, y, size, speed) => {
                    const drift = (timeSeconds * speed) % (ARENA_WIDTH + 200) - 100;
                    const cx = (x + drift) % (ARENA_WIDTH + 200) - 100;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(cx, y, size, 0, Math.PI * 2);
                    ctx.arc(cx + size * 0.8, y - size * 0.2, size * 0.7, 0, Math.PI * 2);
                    ctx.arc(cx + size * 1.4, y, size * 0.8, 0, Math.PI * 2);
                    ctx.arc(cx - size * 0.6, y + size * 0.1, size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                };
                
                drawCloud(100, 50, 25, 3);
                drawCloud(400, 35, 20, 4);
                drawCloud(700, 55, 30, 2.5);
                drawCloud(250, 70, 18, 5);
                
                // === DISTANT MOUNTAINS ===
                // Very distant (faded blue)
                ctx.fillStyle = '#9ab5c5';
                ctx.beginPath();
                ctx.moveTo(0, 200);
                ctx.lineTo(80, 100);
                ctx.lineTo(180, 150);
                ctx.lineTo(300, 60);
                ctx.lineTo(420, 130);
                ctx.lineTo(550, 80);
                ctx.lineTo(680, 140);
                ctx.lineTo(800, 90);
                ctx.lineTo(900, 160);
                ctx.lineTo(ARENA_WIDTH, 120);
                ctx.lineTo(ARENA_WIDTH, 250);
                ctx.lineTo(0, 250);
                ctx.closePath();
                ctx.fill();
                
                // Mid-distant mountains
                ctx.fillStyle = '#7a9aaa';
                ctx.beginPath();
                ctx.moveTo(0, 250);
                ctx.lineTo(60, 180);
                ctx.lineTo(150, 220);
                ctx.lineTo(280, 140);
                ctx.lineTo(380, 200);
                ctx.lineTo(500, 160);
                ctx.lineTo(620, 210);
                ctx.lineTo(750, 150);
                ctx.lineTo(850, 190);
                ctx.lineTo(ARENA_WIDTH, 170);
                ctx.lineTo(ARENA_WIDTH, 300);
                ctx.lineTo(0, 300);
                ctx.closePath();
                ctx.fill();
                
                // === STEEP CLIFFS (valley sides) ===
                const floorY = ARENA_HEIGHT - 60;
                const valleyBottom = ARENA_HEIGHT + 100; // Below visible area
                
                // Left cliff face
                const leftCliffGrad = ctx.createLinearGradient(0, 0, 150, 0);
                leftCliffGrad.addColorStop(0, '#4a5a4a');
                leftCliffGrad.addColorStop(0.5, '#5a6a5a');
                leftCliffGrad.addColorStop(1, '#3a4a3a');
                ctx.fillStyle = leftCliffGrad;
                ctx.beginPath();
                ctx.moveTo(0, 180);
                ctx.lineTo(80, 200);
                ctx.lineTo(120, floorY - 10);
                ctx.lineTo(140, floorY);
                ctx.lineTo(140, valleyBottom);
                ctx.lineTo(0, valleyBottom);
                ctx.closePath();
                ctx.fill();
                
                // Left cliff rocks/texture
                ctx.fillStyle = '#3a4a3a';
                ctx.beginPath();
                ctx.moveTo(30, 220);
                ctx.lineTo(60, 250);
                ctx.lineTo(40, 300);
                ctx.lineTo(20, 280);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(70, 260);
                ctx.lineTo(100, 300);
                ctx.lineTo(90, 350);
                ctx.lineTo(60, 320);
                ctx.closePath();
                ctx.fill();
                
                // Right cliff face
                const rightCliffGrad = ctx.createLinearGradient(ARENA_WIDTH - 150, 0, ARENA_WIDTH, 0);
                rightCliffGrad.addColorStop(0, '#3a4a3a');
                rightCliffGrad.addColorStop(0.5, '#5a6a5a');
                rightCliffGrad.addColorStop(1, '#4a5a4a');
                ctx.fillStyle = rightCliffGrad;
                ctx.beginPath();
                ctx.moveTo(ARENA_WIDTH, 190);
                ctx.lineTo(ARENA_WIDTH - 70, 210);
                ctx.lineTo(ARENA_WIDTH - 110, floorY - 10);
                ctx.lineTo(ARENA_WIDTH - 130, floorY);
                ctx.lineTo(ARENA_WIDTH - 130, valleyBottom);
                ctx.lineTo(ARENA_WIDTH, valleyBottom);
                ctx.closePath();
                ctx.fill();
                
                // Right cliff rocks
                ctx.fillStyle = '#3a4a3a';
                ctx.beginPath();
                ctx.moveTo(ARENA_WIDTH - 40, 230);
                ctx.lineTo(ARENA_WIDTH - 70, 270);
                ctx.lineTo(ARENA_WIDTH - 50, 320);
                ctx.lineTo(ARENA_WIDTH - 30, 290);
                ctx.closePath();
                ctx.fill();
                
                // === VALLEY WATER (far below) ===
                const waterY = floorY + 30;
                const waterGrad = ctx.createLinearGradient(0, waterY, 0, ARENA_HEIGHT);
                waterGrad.addColorStop(0, '#4a7a8a');
                waterGrad.addColorStop(0.5, '#3a6a7a');
                waterGrad.addColorStop(1, '#2a5a6a');
                ctx.fillStyle = waterGrad;
                ctx.fillRect(140, waterY, ARENA_WIDTH - 280, ARENA_HEIGHT - waterY);
                
                // Water ripples (animated)
                ctx.strokeStyle = 'rgba(150, 200, 220, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    const rippleY = waterY + 10 + i * 12;
                    const ripplePhase = timeSeconds * 0.5 + i * 0.7;
                    ctx.beginPath();
                    ctx.moveTo(145, rippleY);
                    for (let x = 145; x < ARENA_WIDTH - 145; x += 20) {
                        ctx.lineTo(x + 10, rippleY + Math.sin(x * 0.02 + ripplePhase) * 2);
                    }
                    ctx.stroke();
                }
                
                // Water shimmer highlights
                ctx.fillStyle = 'rgba(200, 230, 255, 0.15)';
                for (let i = 0; i < 5; i++) {
                    const shimmerX = 200 + i * 120 + Math.sin(timeSeconds * 0.3 + i) * 20;
                    const shimmerY = waterY + 15 + (i % 3) * 10;
                    ctx.beginPath();
                    ctx.ellipse(shimmerX, shimmerY, 25, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // === FOREST TREES AT CLIFF EDGES ===
                const drawTree = (x, height, lean) => {
                    // Trunk
                    ctx.fillStyle = '#3a2a1a';
                    ctx.beginPath();
                    ctx.moveTo(x - 8, floorY - 10);
                    ctx.lineTo(x - 5 + lean * 0.5, floorY - height * 0.6);
                    ctx.lineTo(x + 5 + lean * 0.5, floorY - height * 0.6);
                    ctx.lineTo(x + 8, floorY - 10);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Foliage layers
                    const foliageColors = ['#2a4a2a', '#3a5a3a', '#4a6a4a'];
                    for (let layer = 0; layer < 3; layer++) {
                        const layerY = floorY - height * 0.4 - layer * (height * 0.25);
                        const layerWidth = 35 - layer * 8;
                        ctx.fillStyle = foliageColors[layer];
                        ctx.beginPath();
                        ctx.moveTo(x + lean * (layer + 1) * 0.3, layerY - 25);
                        ctx.lineTo(x - layerWidth + lean * layer * 0.2, layerY);
                        ctx.lineTo(x + layerWidth + lean * layer * 0.2, layerY);
                        ctx.closePath();
                        ctx.fill();
                    }
                };
                
                // Left forest edge
                drawTree(30, 180, -5);
                drawTree(70, 150, -3);
                drawTree(100, 130, 0);
                
                // Right forest edge  
                drawTree(ARENA_WIDTH - 35, 175, 5);
                drawTree(ARENA_WIDTH - 75, 145, 3);
                drawTree(ARENA_WIDTH - 105, 125, 0);
                
                // === THE BRIDGE ===
                const bridgeY = floorY;
                const bridgeStartX = 130;
                const bridgeEndX = ARENA_WIDTH - 130;
                const bridgeWidth = bridgeEndX - bridgeStartX;
                
                // Bridge supports (angled wooden beams going down)
                ctx.strokeStyle = '#3a2a1a';
                ctx.lineWidth = 8;
                // Left supports
                ctx.beginPath();
                ctx.moveTo(bridgeStartX + 20, bridgeY);
                ctx.lineTo(bridgeStartX - 10, bridgeY + 80);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(bridgeStartX + 60, bridgeY);
                ctx.lineTo(bridgeStartX + 30, bridgeY + 80);
                ctx.stroke();
                // Right supports
                ctx.beginPath();
                ctx.moveTo(bridgeEndX - 20, bridgeY);
                ctx.lineTo(bridgeEndX + 10, bridgeY + 80);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(bridgeEndX - 60, bridgeY);
                ctx.lineTo(bridgeEndX - 30, bridgeY + 80);
                ctx.stroke();
                
                // Main bridge deck
                const deckGrad = ctx.createLinearGradient(0, bridgeY - 15, 0, bridgeY + 5);
                deckGrad.addColorStop(0, '#6a5040');
                deckGrad.addColorStop(0.5, '#5a4030');
                deckGrad.addColorStop(1, '#4a3020');
                ctx.fillStyle = deckGrad;
                ctx.fillRect(bridgeStartX, bridgeY - 12, bridgeWidth, 18);
                
                // Bridge planks
                ctx.strokeStyle = '#3a2a1a';
                ctx.lineWidth = 2;
                for (let x = bridgeStartX + 15; x < bridgeEndX - 10; x += 25) {
                    ctx.beginPath();
                    ctx.moveTo(x, bridgeY - 12);
                    ctx.lineTo(x, bridgeY + 6);
                    ctx.stroke();
                }
                
                // Bridge side rails
                ctx.fillStyle = '#4a3020';
                // Left rail posts
                for (let x = bridgeStartX + 30; x < bridgeEndX - 20; x += 80) {
                    ctx.fillRect(x - 4, bridgeY - 50, 8, 40);
                }
                // Top rail (left side visual, since we're looking at it from front/side)
                ctx.fillStyle = '#5a4030';
                ctx.fillRect(bridgeStartX + 20, bridgeY - 52, bridgeWidth - 40, 6);
                
                // Decorative rail pattern (X pattern between posts)
                ctx.strokeStyle = '#5a4030';
                ctx.lineWidth = 3;
                for (let x = bridgeStartX + 30; x < bridgeEndX - 100; x += 80) {
                    ctx.beginPath();
                    ctx.moveTo(x + 4, bridgeY - 45);
                    ctx.lineTo(x + 76, bridgeY - 15);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + 4, bridgeY - 15);
                    ctx.lineTo(x + 76, bridgeY - 45);
                    ctx.stroke();
                }
                
                // Bridge edge trim
                ctx.fillStyle = '#3a2a1a';
                ctx.fillRect(bridgeStartX, bridgeY - 14, bridgeWidth, 3);
                
                // === LANTERNS AT BRIDGE ENDS ===
                const drawBridgeLantern = (x, side) => {
                    const flicker = 0.85 + Math.sin(timeSeconds * 2.5 + x * 0.02) * 0.1;
                    
                    // Lantern post
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(x - 5, bridgeY - 100, 10, 90);
                    
                    // Post top ornament
                    ctx.fillStyle = '#4a3a2a';
                    ctx.beginPath();
                    ctx.moveTo(x - 10, bridgeY - 100);
                    ctx.lineTo(x, bridgeY - 115);
                    ctx.lineTo(x + 10, bridgeY - 100);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lantern body
                    const lanternY = bridgeY - 85;
                    ctx.fillStyle = '#2a1a0a';
                    ctx.fillRect(x - 12, lanternY - 25, 24, 35);
                    
                    // Lantern roof
                    ctx.fillStyle = '#3a2a1a';
                    ctx.beginPath();
                    ctx.moveTo(x - 18, lanternY - 25);
                    ctx.lineTo(x, lanternY - 40);
                    ctx.lineTo(x + 18, lanternY - 25);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Lantern glow
                    ctx.save();
                    ctx.globalAlpha = flicker;
                    const glowGrad = ctx.createRadialGradient(x, lanternY - 8, 0, x, lanternY - 8, 50);
                    glowGrad.addColorStop(0, 'rgba(255, 180, 80, 0.5)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)');
                    glowGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = glowGrad;
                    ctx.fillRect(x - 60, lanternY - 60, 120, 100);
                    
                    // Lantern inner light
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                    ctx.fillRect(x - 8, lanternY - 20, 16, 25);
                    ctx.restore();
                    
                    // Lantern bottom ornament
                    ctx.fillStyle = '#3a2a1a';
                    ctx.fillRect(x - 6, lanternY + 10, 12, 5);
                };
                
                drawBridgeLantern(bridgeStartX + 50, 'left');
                drawBridgeLantern(bridgeEndX - 50, 'right');
                
                // === MIST IN VALLEY ===
                const mistGrad = ctx.createLinearGradient(0, floorY, 0, ARENA_HEIGHT);
                mistGrad.addColorStop(0, 'rgba(200, 220, 230, 0)');
                mistGrad.addColorStop(0.3, 'rgba(200, 220, 230, 0.2)');
                mistGrad.addColorStop(1, 'rgba(180, 200, 210, 0.4)');
                ctx.fillStyle = mistGrad;
                ctx.fillRect(140, floorY, ARENA_WIDTH - 280, ARENA_HEIGHT - floorY);
                
                // Floating mist wisps
                ctx.fillStyle = 'rgba(220, 235, 245, 0.15)';
                for (let i = 0; i < 4; i++) {
                    const mistX = 200 + i * 150 + Math.sin(timeSeconds * 0.15 + i * 2) * 30;
                    const mistY = floorY + 20 + (i % 2) * 15;
                    ctx.beginPath();
                    ctx.ellipse(mistX, mistY, 60 + i * 10, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // === ATMOSPHERIC DEPTH ===
                // Subtle blue haze for depth
                const hazeGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT * 0.6);
                hazeGrad.addColorStop(0, 'rgba(150, 180, 200, 0.1)');
                hazeGrad.addColorStop(1, 'rgba(150, 180, 200, 0)');
                ctx.fillStyle = hazeGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT * 0.6);
            }),

            new Arena('Moonlit Ruins', 'travel', (ctx) => {
                // Time in seconds for animations
                const timeSeconds = performance.now() * 0.001;
                
                // Background - deep night sky
                const skyGrad = ctx.createLinearGradient(0, 0, 0, ARENA_HEIGHT);
                skyGrad.addColorStop(0, '#0a0a15');
                skyGrad.addColorStop(0.3, '#0f1020');
                skyGrad.addColorStop(0.6, '#151828');
                skyGrad.addColorStop(1, '#1a2030');
                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
                
                // === STARS ===
                const drawStars = () => {
                    // Fixed star positions based on deterministic pattern
                    const starPositions = [
                        {x: 50, y: 30, s: 1.5}, {x: 120, y: 55, s: 1}, {x: 200, y: 25, s: 2},
                        {x: 280, y: 70, s: 1}, {x: 350, y: 40, s: 1.5}, {x: 420, y: 20, s: 1},
                        {x: 500, y: 60, s: 2}, {x: 580, y: 35, s: 1}, {x: 650, y: 50, s: 1.5},
                        {x: 720, y: 25, s: 1}, {x: 800, y: 65, s: 2}, {x: 870, y: 45, s: 1},
                        {x: 150, y: 90, s: 1}, {x: 380, y: 85, s: 1.5}, {x: 550, y: 95, s: 1},
                        {x: 700, y: 80, s: 1}, {x: 820, y: 100, s: 1.5}, {x: 920, y: 30, s: 1},
                        {x: 75, y: 110, s: 1}, {x: 250, y: 105, s: 1}, {x: 450, y: 115, s: 1.5}
                    ];
                    
                    starPositions.forEach((star, i) => {
                        // Gentle twinkling
                        const twinkle = 0.5 + Math.sin(timeSeconds * 2 + i * 1.3) * 0.3 + 0.2;
                        ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.s, 0, Math.PI * 2);
                        ctx.fill();
                    });
                };
                drawStars();
                
                // === MOON ===
                const moonX = ARENA_WIDTH - 120;
                const moonY = 80;
                const moonRadius = 45;
                
                // Moon glow (outer)
                const moonGlow = ctx.createRadialGradient(moonX, moonY, moonRadius * 0.8, moonX, moonY, moonRadius * 3);
                moonGlow.addColorStop(0, 'rgba(200, 210, 255, 0.3)');
                moonGlow.addColorStop(0.5, 'rgba(150, 170, 220, 0.1)');
                moonGlow.addColorStop(1, 'rgba(100, 120, 180, 0)');
                ctx.fillStyle = moonGlow;
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonRadius * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Moon body
                const moonBodyGrad = ctx.createRadialGradient(moonX - 10, moonY - 10, 0, moonX, moonY, moonRadius);
                moonBodyGrad.addColorStop(0, '#f5f5ff');
                moonBodyGrad.addColorStop(0.7, '#d0d5e8');
                moonBodyGrad.addColorStop(1, '#b0b8d0');
                ctx.fillStyle = moonBodyGrad;
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Moon craters (subtle)
                ctx.fillStyle = 'rgba(150, 155, 180, 0.3)';
                ctx.beginPath();
                ctx.arc(moonX - 15, moonY - 10, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(moonX + 10, moonY + 15, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(moonX + 5, moonY - 5, 4, 0, Math.PI * 2);
                ctx.fill();
                
                const floorY = ARENA_HEIGHT - 60;
                
                // === DISTANT TREELINE SILHOUETTE ===
                ctx.fillStyle = '#0a0f15';
                ctx.beginPath();
                ctx.moveTo(0, 180);
                for (let x = 0; x <= ARENA_WIDTH; x += 30) {
                    const treeHeight = 150 + Math.sin(x * 0.05) * 30 + Math.cos(x * 0.08) * 20;
                    ctx.lineTo(x, ARENA_HEIGHT - treeHeight);
                }
                ctx.lineTo(ARENA_WIDTH, ARENA_HEIGHT);
                ctx.lineTo(0, ARENA_HEIGHT);
                ctx.closePath();
                ctx.fill();
                
                // === RUINED PILLARS ===
                const drawPillar = (x, height, broken, lean = 0) => {
                    const pillarWidth = 35;
                    const baseY = floorY;
                    
                    ctx.save();
                    ctx.translate(x, baseY);
                    ctx.rotate(lean * 0.05);
                    
                    // Pillar body
                    const pillarGrad = ctx.createLinearGradient(-pillarWidth/2, 0, pillarWidth/2, 0);
                    pillarGrad.addColorStop(0, '#3a3a40');
                    pillarGrad.addColorStop(0.3, '#5a5a65');
                    pillarGrad.addColorStop(0.7, '#5a5a65');
                    pillarGrad.addColorStop(1, '#3a3a40');
                    ctx.fillStyle = pillarGrad;
                    
                    if (broken) {
                        // Broken/crumbled top
                        ctx.beginPath();
                        ctx.moveTo(-pillarWidth/2, 0);
                        ctx.lineTo(-pillarWidth/2, -height + 20);
                        ctx.lineTo(-pillarWidth/3, -height + 10);
                        ctx.lineTo(-pillarWidth/6, -height + 25);
                        ctx.lineTo(0, -height);
                        ctx.lineTo(pillarWidth/4, -height + 15);
                        ctx.lineTo(pillarWidth/2, -height + 5);
                        ctx.lineTo(pillarWidth/2, 0);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Full pillar with capital
                        ctx.fillRect(-pillarWidth/2, -height, pillarWidth, height);
                        // Capital (top decoration)
                        ctx.fillStyle = '#4a4a55';
                        ctx.fillRect(-pillarWidth/2 - 5, -height - 10, pillarWidth + 10, 12);
                    }
                    
                    // Pillar base
                    ctx.fillStyle = '#4a4a50';
                    ctx.fillRect(-pillarWidth/2 - 5, -8, pillarWidth + 10, 10);
                    
                    // Cracks and weathering
                    ctx.strokeStyle = 'rgba(30, 30, 35, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-5, -height * 0.3);
                    ctx.lineTo(3, -height * 0.5);
                    ctx.lineTo(-2, -height * 0.7);
                    ctx.stroke();
                    
                    ctx.restore();
                };
                
                // Background pillars (darker, smaller)
                ctx.globalAlpha = 0.6;
                drawPillar(180, 180, true, 0.5);
                drawPillar(280, 200, false, 0);
                drawPillar(680, 190, true, -0.3);
                drawPillar(780, 170, true, 0.8);
                ctx.globalAlpha = 1;
                
                // Foreground pillars
                drawPillar(80, 220, true, 1);
                drawPillar(ARENA_WIDTH - 80, 230, false, 0);
                
                // === FALLEN PILLAR (horizontal) ===
                ctx.fillStyle = '#4a4a55';
                ctx.save();
                ctx.translate(450, floorY - 20);
                ctx.rotate(-0.1);
                ctx.fillRect(-80, -15, 160, 30);
                // Cracks on fallen pillar
                ctx.strokeStyle = 'rgba(30, 30, 35, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-30, -15);
                ctx.lineTo(-25, 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(40, -15);
                ctx.lineTo(50, 10);
                ctx.stroke();
                ctx.restore();
                
                // === OVERGROWN VINES ===
                const drawVine = (startX, startY, length, direction) => {
                    ctx.strokeStyle = '#2a4a2a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    
                    let x = startX;
                    let y = startY;
                    for (let i = 0; i < length; i += 10) {
                        x += direction * (8 + Math.sin(i * 0.3) * 4);
                        y += 8 + Math.cos(i * 0.2) * 3;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // Leaves on vine
                    ctx.fillStyle = '#3a5a3a';
                    for (let i = 15; i < length; i += 25) {
                        const lx = startX + direction * (8 * i/10 + Math.sin(i * 0.3) * 4);
                        const ly = startY + (8 * i/10 + Math.cos(i * 0.2) * 3);
                        ctx.beginPath();
                        ctx.ellipse(lx + direction * 8, ly, 8, 5, direction * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                };
                
                drawVine(80, floorY - 200, 80, 1);
                drawVine(ARENA_WIDTH - 80, floorY - 210, 90, -1);
                drawVine(280, floorY - 180, 60, 1);
                
                // === FIREFLIES ===
                const drawFireflies = () => {
                    for (let i = 0; i < 12; i++) {
                        // Deterministic base positions
                        const baseX = 100 + (i * 73) % (ARENA_WIDTH - 200);
                        const baseY = 150 + (i * 47) % 200;
                        
                        // Gentle floating motion
                        const floatX = Math.sin(timeSeconds * 0.5 + i * 1.7) * 20;
                        const floatY = Math.cos(timeSeconds * 0.4 + i * 2.1) * 15;
                        const x = baseX + floatX;
                        const y = baseY + floatY;
                        
                        // Pulsing glow
                        const pulse = 0.3 + Math.sin(timeSeconds * 3 + i * 2.5) * 0.3 + 0.2;
                        
                        // Outer glow
                        const fireflyGlow = ctx.createRadialGradient(x, y, 0, x, y, 15);
                        fireflyGlow.addColorStop(0, `rgba(180, 255, 100, ${pulse * 0.8})`);
                        fireflyGlow.addColorStop(0.5, `rgba(150, 230, 80, ${pulse * 0.3})`);
                        fireflyGlow.addColorStop(1, 'rgba(100, 200, 50, 0)');
                        ctx.fillStyle = fireflyGlow;
                        ctx.beginPath();
                        ctx.arc(x, y, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Core
                        ctx.fillStyle = `rgba(220, 255, 150, ${pulse})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                };
                drawFireflies();
                
                // === GROUND/FLOOR ===
                // Ancient stone floor with moss
                const floorGrad = ctx.createLinearGradient(0, floorY, 0, ARENA_HEIGHT);
                floorGrad.addColorStop(0, '#3a3a40');
                floorGrad.addColorStop(0.3, '#2a2a30');
                floorGrad.addColorStop(1, '#1a1a20');
                ctx.fillStyle = floorGrad;
                ctx.fillRect(0, floorY, ARENA_WIDTH, ARENA_HEIGHT - floorY);
                
                // Stone tiles
                ctx.strokeStyle = '#25252a';
                ctx.lineWidth = 2;
                for (let x = 0; x < ARENA_WIDTH; x += 70) {
                    const offset = (Math.floor(x / 70) % 2) * 35;
                    ctx.beginPath();
                    ctx.moveTo(x, floorY);
                    ctx.lineTo(x, ARENA_HEIGHT);
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.moveTo(0, floorY + 25);
                ctx.lineTo(ARENA_WIDTH, floorY + 25);
                ctx.stroke();
                
                // Moss patches on floor
                ctx.fillStyle = '#2a4a2a';
                for (let i = 0; i < 8; i++) {
                    const mx = 50 + i * 120 + Math.sin(i * 3) * 30;
                    const my = floorY + 15 + (i % 3) * 12;
                    ctx.beginPath();
                    ctx.ellipse(mx, my, 25 + (i % 3) * 10, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Scattered rubble/debris
                ctx.fillStyle = '#4a4a50';
                const rubblePositions = [
                    {x: 150, y: floorY + 5}, {x: 320, y: floorY + 8}, {x: 520, y: floorY + 3},
                    {x: 620, y: floorY + 6}, {x: 750, y: floorY + 4}, {x: 850, y: floorY + 7}
                ];
                rubblePositions.forEach(r => {
                    ctx.beginPath();
                    ctx.moveTo(r.x, r.y);
                    ctx.lineTo(r.x + 12, r.y + 3);
                    ctx.lineTo(r.x + 8, r.y + 10);
                    ctx.lineTo(r.x - 5, r.y + 8);
                    ctx.closePath();
                    ctx.fill();
                });
                
                // Edge stones
                ctx.fillStyle = '#35353a';
                ctx.fillRect(0, floorY - 3, ARENA_WIDTH, 5);
                
                // === MOONLIGHT RAYS ===
                ctx.save();
                ctx.globalAlpha = 0.08;
                ctx.fillStyle = '#a0b0d0';
                // Diagonal light beams from moon
                ctx.beginPath();
                ctx.moveTo(moonX, moonY);
                ctx.lineTo(300, ARENA_HEIGHT);
                ctx.lineTo(450, ARENA_HEIGHT);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(moonX, moonY);
                ctx.lineTo(550, ARENA_HEIGHT);
                ctx.lineTo(700, ARENA_HEIGHT);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                // === ATMOSPHERIC MIST ===
                const mistGrad = ctx.createLinearGradient(0, floorY - 50, 0, floorY + 30);
                mistGrad.addColorStop(0, 'rgba(100, 110, 140, 0)');
                mistGrad.addColorStop(0.5, 'rgba(100, 110, 140, 0.15)');
                mistGrad.addColorStop(1, 'rgba(80, 90, 120, 0.1)');
                ctx.fillStyle = mistGrad;
                ctx.fillRect(0, floorY - 50, ARENA_WIDTH, 80);
                
                // Drifting mist wisps
                for (let i = 0; i < 3; i++) {
                    const mistX = (200 + i * 300 + timeSeconds * 8) % (ARENA_WIDTH + 200) - 100;
                    const mistY = floorY - 20 + i * 10;
                    ctx.fillStyle = 'rgba(120, 130, 160, 0.1)';
                    ctx.beginPath();
                    ctx.ellipse(mistX, mistY, 80, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            })
        ];

        // ==================== ARENA CYCLE ====================
        // Alternating travel/place pattern so players see variety early
        // Travel: outdoor journeys (no dialog) | Place: buildings/destinations (dialog before fight)
        const ARENA_CYCLE = [
            'Bamboo Forest',    // Travel - no dialog
            'Village Market',   // Place - dialog before fight
            'Fishing Junk',     // Travel - no dialog
            'Paper Dojo',       // Place - dialog before fight
            'Mountain Path',    // Travel - no dialog
            'Water Gardens',    // Place - dialog before fight
            'Forest Bridge',    // Travel - no dialog
            'Mountain Temple',  // Place - dialog before fight
            'Fishing Junk',     // Travel (repeat) - no dialog
            'Imperial Palace',  // Place - dialog before fight
            'Moonlit Ruins',    // Travel - no dialog (was Mountain Path repeat)
            'Dojo',             // Place - dialog before fight
        ];
        let arenaCycleIndex = 0;

        function getArenaByName(name) {
            return ARENAS.find(a => a.name === name) || ARENAS[0];
        }

        // ==================== GAME STATE ====================
        let canvas, ctx;
        let gameState = 'start';
        let currentRound = 1;
        let currentArena = getArenaByName(ARENA_CYCLE[0]);
        let lives = 5;
        let koTimer = 0;
        let roundTime = 0; // Time elapsed in current round
        let leftPotionSpawned = false; // Timed spawn tracking
        let rightPotionSpawned = false;
        const POTION_SPAWN_TIME = 10; // Seconds before side potions spawn
        const LEFT_POTION_X = 80; // Left side spawn position
        const RIGHT_POTION_X = ARENA_WIDTH - 80; // Right side spawn position
        let player;
        let enemies = []; // Array of Fighter objects
        let survivingTraitors = []; // Traitors that survived the round and carry forward
        let traitorPotionInventory = 0; // Stored traitor potions (max 10, persists across rounds/lives)
        const MAX_TRAITOR_POTIONS = 10;
        let potions = []; // Array of Potion objects
        let keys = {};
        let lastTime = 0;
        
        // Input handling state
        let lastTapTime = 0;
        let lastTapKey = null;
        let lastStartBtn = false;
        let lastPunchBtn = false;
        let lastKickBtn = false;

        // Debug state
        let debugMode = false;
        let debugBuffer = '';
        
        // Menu gamepad state
        let menuGamepadState = { up: false, down: false, left: false, right: false, a: false, b: false };
        let menuGamepadPollId = null;
        
        function pollMenuGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = gamepads[0];
            
            if (!gp) {
                menuGamepadPollId = requestAnimationFrame(pollMenuGamepad);
                return;
            }
            
            const threshold = 0.5;
            const newState = {
                up: gp.axes[1] < -threshold || gp.buttons[12]?.pressed,
                down: gp.axes[1] > threshold || gp.buttons[13]?.pressed,
                left: gp.axes[0] < -threshold || gp.buttons[14]?.pressed,
                right: gp.axes[0] > threshold || gp.buttons[15]?.pressed,
                a: gp.buttons[0]?.pressed,
                b: gp.buttons[1]?.pressed
            };
            
            // Detect rising edges
            if (newState.up && !menuGamepadState.up) handleMenuGamepadInput('up');
            if (newState.down && !menuGamepadState.down) handleMenuGamepadInput('down');
            if (newState.left && !menuGamepadState.left) handleMenuGamepadInput('left');
            if (newState.right && !menuGamepadState.right) handleMenuGamepadInput('right');
            if (newState.a && !menuGamepadState.a) handleMenuGamepadInput('a');
            if (newState.b && !menuGamepadState.b) handleMenuGamepadInput('b');
            
            menuGamepadState = newState;
            
            if (currentScreen === 'title' || currentScreen === 'settings') {
                menuGamepadPollId = requestAnimationFrame(pollMenuGamepad);
            }
        }
        
        function handleMenuGamepadInput(action) {
            if (currentScreen === 'title') {
                if (action === 'up') updateMenuSelection(-1);
                if (action === 'down') updateMenuSelection(1);
                if (action === 'a') activateMenuSelection();
            } else if (currentScreen === 'settings') {
                const focusedEl = document.activeElement;
                const isInTabs = focusedEl && focusedEl.classList.contains('settingsTab');
                
                if (action === 'b') {
                    showTitleScreen();
                    return;
                }
                
                // Helper to get all focusables including back button
                const getAllSettingsFocusables = () => {
                    const activePanel = document.querySelector('.settingsPanel.active');
                    const panelFocusables = activePanel ? 
                        Array.from(activePanel.querySelectorAll('[tabindex="0"], button:not(:disabled), a')) : [];
                    const backBtn = document.getElementById('btnBackToTitle');
                    return [...panelFocusables, backBtn];
                };
                
                if (isInTabs) {
                    const tabs = Array.from(document.querySelectorAll('.settingsTab')).filter(t => t.style.display !== 'none');
                    const currentIdx = tabs.indexOf(focusedEl);
                    
                    if (action === 'up' && currentIdx > 0) {
                        tabs[currentIdx - 1].focus();
                    } else if (action === 'down' && currentIdx < tabs.length - 1) {
                        tabs[currentIdx + 1].focus();
                    } else if (action === 'a' || action === 'right') {
                        // Activate tab if not already active
                        if (!focusedEl.classList.contains('active')) {
                            focusedEl.click();
                        }
                        // Move focus into panel
                        setTimeout(() => {
                            const focusables = getAllSettingsFocusables();
                            if (focusables.length > 0) {
                                focusables[0].focus();
                                focusables[0].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }, 50);
                    }
                } else {
                    const isBackBtn = focusedEl && focusedEl.id === 'btnBackToTitle';
                    const focusables = getAllSettingsFocusables();
                    const currentIdx = focusables.indexOf(focusedEl);
                    
                    if (action === 'left') {
                        const activeTab = document.querySelector('.settingsTab.active');
                        if (activeTab) activeTab.focus();
                    } else if (action === 'a') {
                        if (focusedEl) focusedEl.click();
                    } else if (action === 'up' && currentIdx > 0) {
                        focusables[currentIdx - 1].focus();
                        focusables[currentIdx - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    } else if (action === 'down' && currentIdx < focusables.length - 1) {
                        focusables[currentIdx + 1].focus();
                        focusables[currentIdx + 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }
        }
        
        function startMenuGamepadPolling() {
            if (menuGamepadPollId) cancelAnimationFrame(menuGamepadPollId);
            menuGamepadState = { up: false, down: false, left: false, right: false, a: false, b: false };
            menuGamepadPollId = requestAnimationFrame(pollMenuGamepad);
        }
        
        function stopMenuGamepadPolling() {
            if (menuGamepadPollId) {
                cancelAnimationFrame(menuGamepadPollId);
                menuGamepadPollId = null;
            }
        }

        function getGamepadInput() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = gamepads[0]; // Use first gamepad
            
            if (!gp) return { left: false, right: false, up: false, down: false, punch: false, kick: false, sprint: false, start: false, interact: false, dpadUp: false, dpadDown: false };

            const threshold = 0.5;
            return {
                left: gp.axes[0] < -threshold || gp.buttons[14].pressed,
                right: gp.axes[0] > threshold || gp.buttons[15].pressed,
                up: gp.axes[1] < -threshold || gp.buttons[12].pressed || gp.buttons[0].pressed, // Up or A
                down: gp.axes[1] > threshold || gp.buttons[13].pressed,
                dpadUp: gp.buttons[12]?.pressed || gp.axes[1] < -threshold,
                dpadDown: gp.buttons[13]?.pressed || gp.axes[1] > threshold,
                punch: gp.buttons[2].pressed || gp.buttons[3].pressed, // X or Y
                kick: gp.buttons[1].pressed || gp.buttons[5].pressed, // B or RB (Wait, RB is sprint usually, let's use B)
                sprint: gp.buttons[5].pressed || gp.buttons[7].pressed, // RB or RT
                start: gp.buttons[9].pressed,
                interact: gp.buttons[4].pressed // LB for pickup/drop weapon
            };
        }

        // ==================== FIGHTER CLASS ====================
        class Fighter {
            constructor(x, isPlayer, color, name, isMinion = false) {
                this.x = x;
                this.y = GROUND_Y;
                this.vx = 0;
                this.vy = 0;
                this.isPlayer = isPlayer;
                this.color = color;
                this.name = name;
                this.facingRight = isPlayer;
                this.isMinion = isMinion;
                this.turnedTraitor = false; // For minions who turn against their boss
                
                this.health = 100;
                this.stamina = STAMINA_MAX;
                this.invulnerable = false;
                this.debugInvulnerable = false;
                this.chiShieldActive = false;
                
                this.state = 'idle';
                this.crouching = false;
                this.onGround = true;
                this.isSprinting = false;
                
                this.attackTimer = 0;
                this.attackDuration = 0;
                this.stunTimer = 0;
                this.canAttack = true;
                this.lastPunchKey = false;
                this.lastKickKey = false;
                
                // Animation State
                this.animTimer = 0;
                this.parts = {
                    head: {x:0, y:0}, 
                    body: {x:0, y:0, w:40, h:60},
                    fistF: {x:0, y:0}, fistB: {x:0, y:0},
                    footF: {x:0, y:0}, footB: {x:0, y:0}
                };
                
                // Initialize parts to idle
                this.snapToPose(POSES.idle);

                // AI properties
                this.aiTimer = 0;
                this.aiDecision = null;
                this.aiStyle = 'balanced';
                this.aiStats = { aggression: 0.5, block: 0.5, jump: 0.5, punch: 0.5, kick: 0.5, sprint: 0.5 };
                this.deathTimer = 0;
                this.hasDealtDamage = false;
                this.chiShieldTimer = 0;
                this.droppedPotion = false;
                
                // Weapon system
                this.weapon = null;
                this.lastInteractKey = false;
                this.poleSwingPhase = 0; // For pole animation
            }

            updateInvulnerabilityState() {
                this.invulnerable = this.debugInvulnerable || this.chiShieldActive;
            }

            activateChiShield(duration = 10000) {
                this.chiShieldTimer = duration;
                this.chiShieldActive = true;
                this.updateInvulnerabilityState();
            }

            setDebugInvulnerable(enabled) {
                this.debugInvulnerable = enabled;
                this.updateInvulnerabilityState();
            }

            snapToPose(pose) {
                for (let key in this.parts) {
                    this.parts[key].x = pose[key].x * (this.facingRight ? 1 : -1);
                    this.parts[key].y = pose[key].y;
                    if (key === 'body') {
                        this.parts[key].w = pose[key].w;
                        this.parts[key].h = pose[key].h;
                    }
                }
            }

            getHitboxes() {
                // Calculate absolute positions based on current parts state
                const headSize = 30;
                let fistSize = 16;
                let footSize = 18;
                
                // Extend hitbox for weapons
                let fistExtendX = 0;
                let fistExtendY = 0;
                // For pole, we use fistB (the forward hand after swap), otherwise fistF
                const hasPole = this.weapon && this.weapon.type === 'pole';
                if (this.weapon) {
                    if (this.weapon.type === 'sword') {
                        fistExtendX = (this.facingRight ? 1 : -1) * 25;
                        fistExtendY = -15;
                        // fistSize remains standard to avoid "enlarged hands" visual
                    } else if (this.weapon.type === 'pole') {
                        fistExtendX = (this.facingRight ? 1 : -1) * 35;
                        // footSize remains standard to avoid "enlarged feet" visual
                    }
                }
                
                // Choose which fist to use for attack hitbox
                const attackFist = hasPole ? this.parts.fistB : this.parts.fistF;
                
                return {
                    head: {
                        x: this.x + this.parts.head.x - headSize/2,
                        y: this.y + this.parts.head.y - headSize/2,
                        w: headSize, h: headSize
                    },
                    body: {
                        x: this.x + this.parts.body.x - this.parts.body.w/2,
                        y: this.y + this.parts.body.y - this.parts.body.h/2,
                        w: this.parts.body.w, h: this.parts.body.h
                    },
                    fist: { // Active fist - extended for weapon (use fistB for pole since hands are swapped)
                        x: this.x + attackFist.x + fistExtendX - fistSize/2,
                        y: this.y + attackFist.y + fistExtendY - fistSize/2,
                        w: fistSize, h: fistSize
                    },
                    foot: { // Active foot (Front) - or pole sweep area
                        x: this.x + this.parts.footF.x - footSize/2,
                        y: this.y + this.parts.footF.y - footSize/2,
                        w: footSize, h: footSize
                    }
                };
            }

            update(dt, opponent) {
                // --- Physics & State ---
                if (this.stunTimer > 0) {
                    this.stunTimer -= dt * 1000;
                    if (this.state !== 'tripped') this.state = 'stunned';
                    
                    // Higher friction for tripped to prevent sliding
                    if (this.state === 'tripped') this.vx *= 0.8;
                    else this.vx *= 0.9;
                } else if (this.attackTimer > 0) {
                    this.attackTimer -= dt * 1000;
                    if (this.attackTimer <= 0) this.state = 'idle';
                } else {
                    // State determination for animation
                    if (!this.onGround) this.state = 'jumping';
                    else if (this.crouching) this.state = 'crouching';
                    else if (this.isSprinting && Math.abs(this.vx) > 10) this.state = 'sprinting';
                    else if (Math.abs(this.vx) > 10) this.state = 'walking';
                    else this.state = 'idle';
                }

                // Gravity
                if (!this.onGround) this.vy += GRAVITY * dt;

                // Velocity
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Ground collision
                if (this.y >= GROUND_Y) {
                    this.y = GROUND_Y;
                    this.vy = 0;
                    this.onGround = true;
                }

                // Minion death cleanup
                if (this.isMinion && this.health <= 0 && this.onGround) {
                    this.deathTimer += dt;
                    // Drop potion on death
                    if (!this.droppedPotion) {
                        this.droppedPotion = true;
                        spawnPotion(this.x);
                    }
                }

                // Chi Shield Timer
                if (this.chiShieldTimer > 0) {
                    this.chiShieldTimer -= dt * 1000;
                    if (this.chiShieldTimer <= 0) {
                        this.chiShieldTimer = 0;
                        this.chiShieldActive = false;
                        this.updateInvulnerabilityState();
                    }
                }

                // Bounds
                this.x = Math.max(50, Math.min(ARENA_WIDTH - 50, this.x));

                // Facing
                if (opponent && this.stunTimer <= 0 && this.attackTimer <= 0) {
                    this.facingRight = this.x < opponent.x;
                }

                // Stamina
                if (this.stunTimer <= 0 && !this.crouching && this.onGround && this.attackTimer <= 0) {
                    if (this.state === 'idle') {
                        this.stamina = Math.min(STAMINA_MAX, this.stamina + STAMINA_REGEN * dt);
                    } else if (this.state === 'walking') {
                        this.stamina = Math.min(STAMINA_MAX, this.stamina + (STAMINA_REGEN * 0.5) * dt);
                    }
                }
                if (this.crouching) {
                    this.stamina = Math.max(0, this.stamina - STAMINA_CROUCH_DRAIN * dt);
                }

                // --- Animation System ---
                let targetPose = POSES.idle;
                
                // Weapon-specific idle pose
                if (this.weapon && this.weapon.type === 'pole' && this.state === 'idle') {
                    targetPose = POSES.poleIdle;
                } else if (this.weapon && this.weapon.type === 'pole' && this.state === 'walking') {
                    targetPose = POSES.poleIdle; // Use pole stance as base for walking
                } else if (this.weapon && this.weapon.type === 'pole' && this.state === 'sprinting') {
                    targetPose = POSES.poleIdle; // Use pole stance as base for sprinting
                } else if (this.weapon && this.weapon.type === 'pole' && this.state === 'crouching') {
                    targetPose = POSES.poleCrouch; // Use pole crouch stance
                } else if (this.weapon && this.weapon.type === 'pole' && this.state === 'jumping') {
                    targetPose = POSES.poleIdle; // Use pole stance as base for jumping
                } else if (this.state === 'stunned') targetPose = POSES.stunned;
                else if (this.state === 'tripped') targetPose = POSES.tripped;
                else if (this.state === 'poleStrike') targetPose = POSES.poleStrike;
                else if (this.state === 'poleSweep') targetPose = POSES.poleSweep;
                else if (this.state === 'punching') targetPose = POSES.punch;
                else if (this.state === 'lowPunch') targetPose = POSES.lowPunch;
                else if (this.state === 'jumpPunch') targetPose = POSES.jumpPunch;
                else if (this.state === 'kicking') targetPose = POSES.kick;
                else if (this.state === 'jumpKick') targetPose = POSES.jumpKick;
                else if (this.state === 'sweeping') targetPose = POSES.sweep;
                else if (this.state === 'crouching') targetPose = POSES.crouch;
                else if (this.state === 'jumping') targetPose = POSES.jump;
                else if (this.state === 'sprinting') targetPose = POSES.sprint;
                else if (this.state === 'walking') targetPose = POSES.walk;

                const speed = 15 * dt;
                this.animTimer += dt * 10;
                const hasPoleEquipped = this.weapon && this.weapon.type === 'pole';

                for (let key in this.parts) {
                    let tx = targetPose[key].x;
                    let ty = targetPose[key].y;

                    // Procedural Animation
                    if (this.state === 'idle') {
                        if (key === 'head' || key === 'body' || key.includes('fist')) {
                            ty += Math.sin(this.animTimer) * 2;
                        }
                    } else if (this.state === 'walking' || this.state === 'sprinting' || (this.state === 'punching' && Math.abs(this.vx) > 10)) {
                        // Apply walking anim to legs if walking OR punching while moving
                        const strideMult = this.state === 'sprinting' ? 25 : 15;
                        const freqMult = this.state === 'sprinting' ? 1.5 : 1;
                        
                        if (key === 'footF') tx += Math.sin(this.animTimer * freqMult) * strideMult;
                        if (key === 'footB') tx += Math.sin(this.animTimer * freqMult + Math.PI) * strideMult;
                        
                        // Only bob body/head if NOT punching (to keep aim steady)
                        if (this.state !== 'punching') {
                             const allowArmSwing = !(hasPoleEquipped && (this.state === 'walking' || this.state === 'sprinting'));
                             if (allowArmSwing) {
                                 // Swap fist swing direction when holding a pole
                                 if (key === 'fistF') tx += Math.cos(this.animTimer * freqMult + (hasPoleEquipped ? Math.PI : 0)) * 10;
                                 if (key === 'fistB') tx += Math.cos(this.animTimer * freqMult + (hasPoleEquipped ? 0 : Math.PI)) * 10;
                             }
                             if (key === 'head' || key === 'body') ty += Math.abs(Math.sin(this.animTimer * 2 * freqMult)) * 3;
                        }
                    }

                    // Apply direction
                    const dir = this.facingRight ? 1 : -1;
                    const finalTx = tx * dir;
                    
                    // Lerp
                    this.parts[key].x += (finalTx - this.parts[key].x) * speed;
                    this.parts[key].y += (ty - this.parts[key].y) * speed;
                    
                    // Dimensions (body only)
                    if (key === 'body') {
                        this.parts[key].w += (targetPose[key].w - this.parts[key].w) * speed;
                        this.parts[key].h += (targetPose[key].h - this.parts[key].h) * speed;
                    }
                }
            }

            punch(isLow = false) {
                if (!this.canAttack || this.attackTimer > 0 || this.stunTimer > 0 || this.state === 'tripped') return false;
                
                // Calculate stamina cost (1.2x with weapon)
                const staminaCost = this.weapon ? STAMINA_PUNCH_COST * WEAPON_STAMINA_MULT : STAMINA_PUNCH_COST;
                if (this.stamina < staminaCost) return false;

                this.stamina -= staminaCost;
                const speedMod = 0.5 + (this.stamina / STAMINA_MAX) * 0.5;
                this.attackDuration = 200 / speedMod;
                this.attackTimer = this.attackDuration;
                this.hasDealtDamage = false;
                
                // Weapon-specific punch behavior
                if (this.weapon) {
                    if (this.weapon.type === 'star') {
                        // Throw star - then lose it
                        this.throwWeapon();
                        this.state = isLow ? 'lowPunch' : 'punching';
                    } else if (this.weapon.type === 'fan') {
                        // Throw fan (returns)
                        this.throwWeapon();
                        this.state = isLow ? 'lowPunch' : 'punching';
                    } else if (this.weapon.type === 'pole') {
                        // Pole strike
                        this.state = 'poleStrike';
                        this.poleSwingPhase = 0;
                        SoundFX.poleSwing();
                        return true;
                    } else if (this.weapon.type === 'sword') {
                        // Sword jab - same pose as punch but extended reach
                        if (!this.onGround) {
                            this.state = 'jumpPunch';
                        } else {
                            this.state = isLow ? 'lowPunch' : 'punching';
                        }
                        SoundFX.swordSwing();
                        return true;
                    }
                }
                
                if (!this.onGround) {
                    this.state = 'jumpPunch';
                } else {
                    this.state = isLow ? 'lowPunch' : 'punching';
                }
                SoundFX.whiff();
                return true;
            }

            kick(isSweep = false) {
                if (!this.canAttack || this.attackTimer > 0 || this.stunTimer > 0 || this.state === 'tripped') return false;
                
                // Pole replaces kicks with sweeps
                if (this.weapon && this.weapon.type === 'pole') {
                    const staminaCost = STAMINA_KICK_COST * WEAPON_STAMINA_MULT;
                    if (this.stamina < staminaCost) return false;
                    
                    this.stamina -= staminaCost;
                    const speedMod = 0.5 + (this.stamina / STAMINA_MAX) * 0.5;
                    this.attackDuration = 300 / speedMod;
                    this.attackTimer = this.attackDuration;
                    this.hasDealtDamage = false;
                    this.state = 'poleSweep';
                    this.poleSwingPhase = 0;
                    SoundFX.poleSwing();
                    return true;
                }
                
                if (this.stamina < STAMINA_KICK_COST) return false;

                this.stamina -= STAMINA_KICK_COST;
                const speedMod = 0.5 + (this.stamina / STAMINA_MAX) * 0.5;
                this.attackDuration = 250 / speedMod;
                this.attackTimer = this.attackDuration;
                this.hasDealtDamage = false;
                
                if (!this.onGround) {
                    this.state = 'jumpKick';
                } else {
                    this.state = isSweep ? 'sweeping' : 'kicking';
                }
                SoundFX.whiff();
                return true;
            }
            
            throwWeapon() {
                if (!this.weapon) return;
                
                const proj = new Projectile(this.weapon, this, 0);
                projectiles.push(proj);
                
                // Star is gone until re-collected
                // Fan returns automatically
                if (this.weapon.type === 'star') {
                    this.weapon.owner = null;
                    this.weapon = null;
                } else if (this.weapon.type === 'fan') {
                    // Fan stays linked to thrower but temporarily no weapon
                    // The projectile will return the fan
                    this.weapon = null;
                }
                
                SoundFX.throwSound();
            }
            
            pickupWeapon(weapon) {
                if (this.weapon) return false; // Already holding one
                
                this.weapon = weapon;
                weapon.owner = this;
                weapon.onGround = false;
                showMessage(`${this.name || 'Player'} picked up ${weapon.type}!`, '#fff');
                SoundFX.pickup();
                return true;
            }
            
            dropWeapon() {
                if (!this.weapon) return;
                
                this.weapon.x = this.x;
                this.weapon.y = GROUND_Y;
                this.weapon.onGround = true;
                this.weapon.owner = null;
                
                // Ensure weapon is in the weapons array so it can be drawn and picked up
                if (!weapons.includes(this.weapon)) {
                    weapons.push(this.weapon);
                }
                
                showMessage('Dropped ' + this.weapon.type, '#aaa');
                this.weapon = null;
            }

            jump(direction = 0) {
                if (!this.onGround || this.stunTimer > 0 || this.state === 'tripped') return;
                if (this.stamina < STAMINA_JUMP_COST) return;

                this.stamina -= STAMINA_JUMP_COST;
                this.vy = JUMP_VELOCITY;
                this.vx = direction * WALK_SPEED * 1.2;
                this.onGround = false;
                this.crouching = false;
                SoundFX.jump();
            }

            walk(direction) {
                if (this.stunTimer > 0 || this.state === 'tripped') return;
                const speed = this.crouching ? CROUCH_CREEP_SPEED : (this.isSprinting ? SPRINT_SPEED : WALK_SPEED);
                this.vx = direction * speed;
            }

            crouch(active) {
                if (this.stunTimer > 0 || this.state === 'tripped') return;
                if (!this.onGround) return;
                this.crouching = active;
                if (active) this.vx *= 0.5;
            }

            takeDamage(damage, knockbackDir, attackType = 'normal') {
                if (this.invulnerable) return;

                this.health = Math.max(0, this.health - damage);
                
                if (this.health <= 0) {
                    this.state = 'tripped';
                    this.stunTimer = 999999; // Dead
                    this.vx = knockbackDir * KNOCKBACK * 10;
                    this.vy = -200; // Death hop
                    this.onGround = false;
                    // Drop weapon on death
                    if (this.weapon) this.dropWeapon();
                    SoundFX.heavyHit();
                    return;
                }

                this.stunTimer = STUN_DURATION;
                this.vx = knockbackDir * KNOCKBACK * 10;
                
                if (attackType === 'sweeping' || attackType === 'poleSweep') {
                    this.state = 'tripped';
                    this.stunTimer = STUN_DURATION * 2;
                    this.vy = -200;
                    this.onGround = false;
                    // Drop weapon on trip!
                    if (this.weapon) this.dropWeapon();
                    SoundFX.heavyHit();
                } else {
                    SoundFX.hit();
                }
            }

            draw(ctx) {
                const boxes = this.getHitboxes();
                
                ctx.save();
                
                // Chi Shield glow effect
                if (this.chiShieldTimer > 0) {
                    ctx.shadowColor = '#3498db';
                    ctx.shadowBlur = 20 + Math.sin(performance.now() / 100) * 10;
                }

                // Stunned flash
                if (this.stunTimer > 0 && Math.floor(this.stunTimer / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x, GROUND_Y + 5, 25, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // --- Rigging (Connectors) ---
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.lineWidth = 3;
                
                const cx = boxes.body.x + boxes.body.w/2;
                const cy = boxes.body.y + boxes.body.h/2;
                
                // Body to Head
                ctx.moveTo(cx, boxes.body.y);
                ctx.lineTo(boxes.head.x + boxes.head.w/2, boxes.head.y + boxes.head.h);
                
                // Body to Limbs
                const limbs = [
                    {x: this.x + this.parts.fistF.x, y: this.y + this.parts.fistF.y},
                    {x: this.x + this.parts.fistB.x, y: this.y + this.parts.fistB.y},
                    {x: this.x + this.parts.footF.x, y: this.y + this.parts.footF.y},
                    {x: this.x + this.parts.footB.x, y: this.y + this.parts.footB.y}
                ];
                
                limbs.forEach(p => {
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();

                // --- Draw Parts ---
                const drawRect = (rect, color) => {
                    ctx.fillStyle = color;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
                    ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                };

                // Back limbs first
                const fistColor = this.lightenColor(this.color, -20);
                const footColor = fistColor;
                
                // Back Foot
                drawRect({
                    x: this.x + this.parts.footB.x - 9, y: this.y + this.parts.footB.y - 9,
                    w: 18, h: 18
                }, footColor);
                
                // Back Fist
                drawRect({
                    x: this.x + this.parts.fistB.x - 8, y: this.y + this.parts.fistB.y - 8,
                    w: 16, h: 16
                }, fistColor);

                // Body
                drawRect(boxes.body, this.color);

                // Head
                const headColor = this.lightenColor(this.color, 20);
                drawRect(boxes.head, headColor);
                
                // Eyes
                ctx.fillStyle = '#000';
                const eyeY = boxes.head.y + boxes.head.h * 0.4;
                const eyeSize = 4;
                if (this.facingRight) {
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.5, eyeY, eyeSize, eyeSize);
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.75, eyeY, eyeSize, eyeSize);
                } else {
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.25 - eyeSize, eyeY, eyeSize, eyeSize);
                    ctx.fillRect(boxes.head.x + boxes.head.w * 0.5 - eyeSize, eyeY, eyeSize, eyeSize);
                }

                // Front Foot
                // Use parts directly for visual to avoid hitbox extension weirdness
                drawRect({
                    x: this.x + this.parts.footF.x - 9, y: this.y + this.parts.footF.y - 9,
                    w: 18, h: 18
                }, footColor);

                // Draw held weapon (before front fist so it looks held)
                if (this.weapon) {
                    this.drawHeldWeapon(ctx);
                }

                // Front Fist
                // Use parts directly for visual to avoid hitbox extension weirdness
                drawRect({
                    x: this.x + this.parts.fistF.x - 8, y: this.y + this.parts.fistF.y - 8,
                    w: 16, h: 16
                }, fistColor);

                // Draw Minion Bars
                if (this.isMinion && this.health > 0) {
                    const barW = 40;
                    const barH = 5;
                    const cx = this.x;
                    const cy = this.y - 110; // Above head
                    
                    // Health
                    ctx.fillStyle = '#333';
                    ctx.fillRect(cx - barW/2, cy, barW, barH);
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(cx - barW/2, cy, barW * (this.health / 100), barH);
                    
                    // Stamina
                    ctx.fillStyle = '#333';
                    ctx.fillRect(cx - barW/2, cy + barH + 2, barW, barH);
                    ctx.fillStyle = '#f1c40f';
                    ctx.fillRect(cx - barW/2, cy + barH + 2, barW * (this.stamina / STAMINA_MAX), barH);
                }

                ctx.restore();
            }

            lightenColor(color, amount) {
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                return `rgb(${r},${g},${b})`;
            }
            
            drawHeldWeapon(ctx) {
                if (!this.weapon) return;
                
                const fistX = this.x + this.parts.fistF.x;
                const fistY = this.y + this.parts.fistF.y;
                const dir = this.facingRight ? 1 : -1;
                
                ctx.save();
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#fff';
                ctx.lineWidth = 2;
                
                switch (this.weapon.type) {
                    case 'sword':
                        // Sword drawn at front fist - blade points toward enemy
                        // drawWeapon draws blade at -Y, so angle œÄ/2 = blade right, -œÄ/2 = blade left
                        let swordAngle;
                        if (this.state === 'punching' || this.state === 'jumpPunch') {
                            // Thrust forward - blade horizontal toward enemy
                            swordAngle = this.facingRight ? Math.PI/2 : -Math.PI/2;
                        } else if (this.state === 'lowPunch') {
                            // Low thrust - angled down toward enemy
                            swordAngle = this.facingRight ? Math.PI/2 + Math.PI/6 : -Math.PI/2 - Math.PI/6;
                        } else {
                            // Idle - held ready, blade angled up and forward
                            swordAngle = this.facingRight ? Math.PI/3 : -Math.PI/3;
                        }
                        
                        // Offset so hand holds the handle
                        // Handle center is at local (0, 14) relative to crossguard (0,0)
                        // We want local (0, 14) to be at world (fistX, fistY)
                        // Transformation: Translate(fistX, fistY) -> Rotate(angle) -> Translate(0, -14)
                        
                        ctx.save();
                        ctx.translate(fistX, fistY);
                        ctx.rotate(swordAngle);
                        ctx.translate(0, -14); // Shift back so handle center is at pivot
                        
                        // Draw sword directly here instead of calling drawWeapon to avoid double transform
                        // Or just call drawWeapon with identity since we set up the transform
                        // But drawWeapon expects x, y, angle.
                        // Let's use the weapon's draw method but pass 0,0,0 since we handled transform
                        this.weapon.drawWeapon(ctx, 0, 0, 0, 0.7);
                        
                        ctx.restore();
                        break;
                        
                    case 'pole':
                        // Pole drawn between the two hands
                        const fistFX = this.x + this.parts.fistF.x;
                        const fistFY = this.y + this.parts.fistF.y;
                        const fistBX = this.x + this.parts.fistB.x;
                        const fistBY = this.y + this.parts.fistB.y;
                        
                        // Calculate angle from back hand to front hand
                        const dx = fistFX - fistBX;
                        const dy = fistFY - fistBY;
                        const handDist = Math.sqrt(dx * dx + dy * dy);
                        let poleAngle = Math.atan2(dy, dx);
                        
                        // Pole center is between the hands
                        const poleCenterX = (fistFX + fistBX) / 2;
                        const poleCenterY = (fistFY + fistBY) / 2;
                        
                        // Pole length extends beyond hands
                        // Ensure minimum length so it looks like a staff
                        const poleLength = Math.max(100, handDist * 3.0);
                        
                        ctx.save();
                        ctx.translate(poleCenterX, poleCenterY);
                        ctx.rotate(poleAngle);
                        
                        // Draw pole
                        const halfLen = poleLength / 2;
                        ctx.beginPath();
                        ctx.moveTo(-halfLen, -3);
                        ctx.lineTo(halfLen, -3);
                        ctx.lineTo(halfLen, 3);
                        ctx.lineTo(-halfLen, 3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Rounded caps
                        ctx.beginPath();
                        ctx.arc(-halfLen, 0, 3, Math.PI/2, -Math.PI/2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(halfLen, 0, 3, -Math.PI/2, Math.PI/2);
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.restore();
                        break;
                        
                    case 'star':
                        // Held in hand ready to throw
                        this.weapon.drawShuriken(ctx, fistX + dir * 10, fistY, 10);
                        break;
                        
                    case 'fan':
                        // Fan held open in hand, similar to sword grip
                        // drawWeapon draws fan pointing up (-Y), handle at +Y
                        // We want fan to point toward enemy
                        let fanAngle;
                        if (this.state === 'punching' || this.state === 'jumpPunch') {
                            // Throwing pose - fan forward
                            fanAngle = this.facingRight ? Math.PI/2 : -Math.PI/2;
                        } else {
                            // Idle - held ready, fan angled up and forward
                            fanAngle = this.facingRight ? Math.PI/4 : -Math.PI/4;
                        }
                        
                        // Offset so hand holds the handle (handle center ~7px from origin)
                        ctx.save();
                        ctx.translate(fistX, fistY);
                        ctx.rotate(fanAngle);
                        ctx.translate(0, -7); // Shift so handle is at fist
                        
                        this.weapon.drawWeapon(ctx, 0, 0, 0, 0.6);
                        
                        ctx.restore();
                        break;
                }
                
                ctx.restore();
            }
        }

        // ==================== POTION CLASS ====================
        class Potion {
            constructor(x, forceTraitor = false) {
                this.x = x;
                this.y = GROUND_Y;
                this.bobTimer = Math.random() * Math.PI * 2;
                
                // Determine potion type - may be traitor potion
                let typeData;
                if (forceTraitor || Math.random() < 0.25) {
                    // 25% chance of traitor potion
                    typeData = TRAITOR_POTION;
                } else {
                    typeData = POTION_TYPES[Math.floor(Math.random() * POTION_TYPES.length)];
                }
                this.type = typeData.type;
                this.color = typeData.color;
                this.effect = typeData.effect;
                this.apply = typeData.apply;
                
                this.collected = false;
            }

            update(dt) {
                this.bobTimer += dt * 3;
            }

            draw(ctx) {
                if (this.collected) return;
                
                const bobY = Math.sin(this.bobTimer) * 3;
                const x = this.x;
                const y = this.y - 20 + bobY;
                const w = 16;
                const h = 24;
                
                ctx.save();
                
                // Special glow for traitor potion
                if (this.type === 'traitor') {
                    // Pulsing magenta glow
                    const glowSize = 20 + Math.sin(this.bobTimer * 2) * 5;
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
                    gradient.addColorStop(0, 'rgba(255, 0, 255, 0.4)');
                    gradient.addColorStop(0.5, 'rgba(255, 0, 255, 0.15)');
                    gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Swirling particles
                    for (let i = 0; i < 3; i++) {
                        const angle = this.bobTimer * 2 + (i * Math.PI * 2 / 3);
                        const px = x + Math.cos(angle) * 12;
                        const py = y + Math.sin(angle) * 8;
                        ctx.fillStyle = 'rgba(255, 100, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(px, py, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(x, GROUND_Y + 2, 10, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Bottle outline (glass)
                ctx.fillStyle = 'rgba(200, 220, 255, 0.3)';
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 1.5;
                
                // Bottle body
                ctx.beginPath();
                ctx.moveTo(x - w/2, y - h/2 + 6); // Left neck bottom
                ctx.lineTo(x - w/2, y + h/2 - 4); // Left body bottom
                ctx.quadraticCurveTo(x - w/2, y + h/2, x - w/2 + 4, y + h/2); // Bottom left curve
                ctx.lineTo(x + w/2 - 4, y + h/2); // Bottom
                ctx.quadraticCurveTo(x + w/2, y + h/2, x + w/2, y + h/2 - 4); // Bottom right curve
                ctx.lineTo(x + w/2, y - h/2 + 6); // Right body top
                ctx.lineTo(x + w/4, y - h/2 + 6); // Shoulder right
                ctx.lineTo(x + w/4, y - h/2); // Neck right
                ctx.lineTo(x - w/4, y - h/2); // Neck top
                ctx.lineTo(x - w/4, y - h/2 + 6); // Neck left
                ctx.lineTo(x - w/2, y - h/2 + 6); // Shoulder left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Liquid inside (filled ~70%)
                const liquidTop = y - h/2 + 10;
                const liquidBot = y + h/2 - 2;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(x - w/2 + 2, liquidTop);
                ctx.lineTo(x - w/2 + 2, liquidBot - 4);
                ctx.quadraticCurveTo(x - w/2 + 2, liquidBot, x - w/2 + 6, liquidBot);
                ctx.lineTo(x + w/2 - 6, liquidBot);
                ctx.quadraticCurveTo(x + w/2 - 2, liquidBot, x + w/2 - 2, liquidBot - 4);
                ctx.lineTo(x + w/2 - 2, liquidTop);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Shine spot on shoulder (SVG-like ellipse)
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.beginPath();
                ctx.ellipse(x - w/4, y - h/2 + 8, 3, 5, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Small secondary shine
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.ellipse(x - w/4 + 2, y - h/2 + 14, 2, 3, -0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Cork
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - w/4 + 1, y - h/2 - 4, w/2 - 2, 5);
                
                ctx.restore();
            }

            getHitbox() {
                return {
                    x: this.x - 12,
                    y: this.y - 40,
                    w: 24,
                    h: 40
                };
            }
        }

        function spawnPotion(x) {
            potions.push(new Potion(x));
            SoundFX.playTone(800, 'sine', 0.1, 0.1, 200); // Spawn sound
        }
        
        // Draw traitor potion inventory in top-left corner (below where HUD health bars would be)
        function drawTraitorPotionInventory(ctx) {
            if (traitorPotionInventory <= 0) return;
            
            const startX = 15;
            const startY = 10; // Just inside the arena, below the HUD overlay
            const potionSize = 12;
            const spacing = 16;
            
            ctx.save();
            
            for (let i = 0; i < traitorPotionInventory; i++) {
                const x = startX + (i % 5) * spacing;
                const y = startY + Math.floor(i / 5) * (spacing + 2);
                
                // Draw mini potion bottle
                drawMiniTraitorPotion(ctx, x, y, potionSize);
            }
            
            ctx.restore();
        }
        
        // Draw a small traitor potion icon
        function drawMiniTraitorPotion(ctx, x, y, size) {
            const w = size * 0.6;
            const h = size;
            
            // Glow effect
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, 'rgba(255, 0, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Bottle outline
            ctx.fillStyle = 'rgba(200, 220, 255, 0.4)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 1;
            
            // Simple bottle shape
            ctx.beginPath();
            ctx.roundRect(x - w/2, y - h/2 + 2, w, h - 2, 2);
            ctx.fill();
            ctx.stroke();
            
            // Neck
            ctx.fillRect(x - w/4, y - h/2 - 1, w/2, 3);
            ctx.strokeRect(x - w/4, y - h/2 - 1, w/2, 3);
            
            // Liquid (magenta)
            ctx.fillStyle = '#ff00ff';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.roundRect(x - w/2 + 1, y - h/2 + 5, w - 2, h - 6, 1);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        
        // Check if there are any minions that could be turned traitor
        function canSpawnTraitorPotion() {
            // Need at least one living minion that hasn't turned yet
            return enemies.some(e => e.isMinion && e.health > 0 && !e.turnedTraitor);
        }
        
        // Turn the nearest non-traitor minion into a traitor
        function turnMinionTraitor() {
            // Find nearest living minion to the player that hasn't turned yet
            let nearestMinion = null;
            let minDist = Infinity;
            
            enemies.forEach(e => {
                if (e.isMinion && e.health > 0 && !e.turnedTraitor) {
                    const dist = Math.abs(e.x - player.x);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestMinion = e;
                    }
                }
            });
            
            if (nearestMinion) {
                nearestMinion.turnedTraitor = true;
                nearestMinion.color = TRAITOR_COLOR; // Darker teal for player's minions
                // Rising victory sounds (staggered)
                SoundFX.playTone(440, 'sine', 0.15, 0.2);
                setTimeout(() => SoundFX.playTone(550, 'sine', 0.15, 0.2), 100);
                setTimeout(() => SoundFX.playTone(660, 'sine', 0.15, 0.2), 200);
            }
        }

        function hasPotionNear(x, range = 50) {
            return potions.some(p => !p.collected && Math.abs(p.x - x) < range);
        }

        function checkTimedPotionSpawns() {
            if (roundTime >= POTION_SPAWN_TIME) {
                // Left side spawn
                if (!leftPotionSpawned && !hasPotionNear(LEFT_POTION_X)) {
                    leftPotionSpawned = true;
                    spawnPotion(LEFT_POTION_X);
                }
                // Right side spawn
                if (!rightPotionSpawned && !hasPotionNear(RIGHT_POTION_X)) {
                    rightPotionSpawned = true;
                    spawnPotion(RIGHT_POTION_X);
                }
            }
        }

        function checkPotionPickup() {
            if (!player || player.health <= 0) return;
            
            const playerBox = {
                x: player.x - 20,
                y: player.y - 80,
                w: 40,
                h: 80
            };
            
            potions.forEach(potion => {
                if (potion.collected) return;
                
                const potionBox = potion.getHitbox();
                if (rectsOverlap(playerBox, potionBox)) {
                    potion.collected = true;
                    potion.apply(player);
                    showMessage(potion.effect, potion.color);
                    SoundFX.playTone(600, 'sine', 0.15, 0.15, 400); // Pickup sound
                }
            });
            
            // Remove collected potions
            potions = potions.filter(p => !p.collected);
        }

        // ==================== COLLISION DETECTION ====================
        function rectsOverlap(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x &&
                   a.y < b.y + b.h && a.y + a.h > b.y;
        }

        function checkAttackHit(attacker, defender, attackType) {
            const aBoxes = attacker.getHitboxes();
            const dBoxes = defender.getHitboxes();
            
            let attackBox;
            if (attackType === 'punching' || attackType === 'lowPunch' || attackType === 'jumpPunch' || attackType === 'poleStrike' || attackType === 'poleSweep') {
                // Pole sweep is a low jab with the pole end, uses fist hitbox
                attackBox = aBoxes.fist;
            } else {
                attackBox = aBoxes.foot;
            }
            
            // Check if attack connects with head or body
            if (rectsOverlap(attackBox, dBoxes.head) || rectsOverlap(attackBox, dBoxes.body)) {
                // Crouching blocks high attacks
                if (defender.crouching && (attackType === 'punching' || attackType === 'kicking' || attackType === 'jumpPunch' || attackType === 'jumpKick')) {
                    // High attacks miss crouching opponent
                    if (attackBox.y < dBoxes.body.y + 20) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }

        // ==================== AI CONTROLLER ====================
        function updateAI(fighter, opponent, dt, isNearest = true, overlapDir = 0) {
            fighter.aiTimer -= dt * 1000;
            
            if (fighter.aiTimer <= 0) {
                fighter.aiTimer = 150 + Math.random() * 200;
                fighter.aiDecision = makeAIDecision(fighter, opponent, isNearest, overlapDir);
            }
            
            executeAIDecision(fighter, opponent);
        }

        function makeAIDecision(ai, opponent, isNearest = true, overlapDir = 0) {
            // 1. Non-nearest behavior
            if (!isNearest) {
                // If overlapping with another enemy, move away from THEM
                if (overlapDir !== 0) {
                    return { action: 'walk', direction: overlapDir };
                }
                
                // Otherwise, maintain "Orbit" distance from player
                const dist = Math.abs(ai.x - opponent.x);
                if (dist < 150) {
                    // Too close to player, back off
                    const dir = ai.x < opponent.x ? -1 : 1;
                    return { action: 'walk', direction: dir };
                } else if (dist > 300) {
                    // Too far, catch up
                    const dir = ai.x < opponent.x ? 1 : -1;
                    return { action: 'walk', direction: dir };
                } else {
                    // Just chill or pace
                    if (Math.random() < 0.3) return { action: 'idle' };
                    return { action: 'walk', direction: Math.random() < 0.5 ? 1 : -1 };
                }
            }

            const dist = Math.abs(ai.x - opponent.x);
            const inRange = dist < 80;
            const closeRange = dist < 50;
            const farAway = dist > 200;
            
            const rand = Math.random();
            const stats = ai.aiStats;
            
            // React to opponent attacks
            if (opponent.attackTimer > 0 && rand < stats.block) {
                if (opponent.state === 'sweeping' || opponent.state === 'lowPunch') {
                    return { action: 'jump', direction: ai.x < opponent.x ? -1 : 1 };
                } else {
                    return { action: 'crouch' };
                }
            }
            
            // Attack if in range
            if (inRange && rand < stats.aggression) {
                if (ai.crouching) {
                    return rand < 0.5 ? { action: 'sweep' } : { action: 'lowPunch' };
                }
                // Choose punch or kick based on stats
                const totalAttack = stats.punch + stats.kick;
                const punchChance = stats.punch / totalAttack;
                return rand < punchChance ? { action: 'punch' } : { action: 'kick' };
            }
            
            // Approach if far
            if (farAway && rand < stats.aggression + 0.3) {
                const dir = ai.x < opponent.x ? 1 : -1;
                // Sprint chance
                if (rand < stats.sprint) {
                    return { action: 'sprint', direction: dir };
                }
                return rand < stats.jump ? { action: 'jump', direction: dir } : { action: 'walk', direction: dir };
            }
            
            // Medium range tactics
            if (!closeRange && rand < 0.5) {
                const dir = ai.x < opponent.x ? 1 : -1;
                return { action: 'walk', direction: dir };
            }
            
            // Defensive
            if (closeRange && rand > stats.aggression) {
                if (rand < stats.block) return { action: 'crouch' };
                const dir = ai.x < opponent.x ? -1 : 1;
                return { action: 'walk', direction: dir };
            }
            
            return { action: 'idle' };
        }

        function executeAIDecision(ai, opponent) {
            if (!ai.aiDecision) return;
            
            const decision = ai.aiDecision;
            
            switch (decision.action) {
                case 'walk':
                    ai.isSprinting = false;
                    ai.walk(decision.direction);
                    ai.crouch(false);
                    break;
                case 'sprint':
                    ai.isSprinting = true;
                    ai.walk(decision.direction);
                    ai.crouch(false);
                    break;
                case 'jump':
                    ai.isSprinting = false;
                    ai.crouch(false);
                    ai.jump(decision.direction || 0);
                    ai.aiDecision = null;
                    break;
                case 'crouch':
                    ai.isSprinting = false;
                    ai.crouch(true);
                    ai.vx = 0;
                    break;
                case 'punch':
                    ai.isSprinting = false;
                    ai.crouch(false);
                    if (ai.punch()) ai.aiDecision = null;
                    break;
                case 'kick':
                    ai.isSprinting = false;
                    ai.crouch(false);
                    if (ai.kick()) ai.aiDecision = null;
                    break;
                case 'lowPunch':
                    ai.isSprinting = false;
                    ai.crouch(true);
                    if (ai.punch(true)) ai.aiDecision = null;
                    break;
                case 'sweep':
                    ai.isSprinting = false;
                    ai.crouch(true);
                    if (ai.kick(true)) ai.aiDecision = null;
                    break;
                case 'idle':
                default:
                    ai.isSprinting = false;
                    ai.vx = 0;
                    ai.crouch(false);
                    break;
            }
        }

        // ==================== PLAYER INPUT ====================
        function handlePlayerInput(fighter) {
            if (fighter.stunTimer > 0) return;
            
            const gamepad = getPlayerGamepad(1);
            const binds = getPlayerKeybinds(1); // Player 1 controls

            // Movement - unified bindings (keyboard + gamepad in config)
            // Also always allow arrow keys and gamepad D-pad/stick as hardcoded fallback
            let moveDir = 0;
            const hardLeft = keys['ArrowLeft'] || (gamepad && (gamepad.axes[0] < -0.5 || gamepad.buttons[14]?.pressed));
            const hardRight = keys['ArrowRight'] || (gamepad && (gamepad.axes[0] > 0.5 || gamepad.buttons[15]?.pressed));
            if (isActionPressed(binds, 'left', gamepad) || hardLeft) moveDir -= 1;
            if (isActionPressed(binds, 'right', gamepad) || hardRight) moveDir += 1;
            
            // Sprint (Gamepad RB)
            const gpSprint = gamepad && gamepad.buttons[5]?.pressed;
            if (gamepad && (gamepad.axes[0] < -0.5 || gamepad.axes[0] > 0.5 || gamepad.buttons[14]?.pressed || gamepad.buttons[15]?.pressed)) {
                fighter.isSprinting = gpSprint;
            }

            // Crouch - unified bindings + hardcoded fallback
            const hardDown = keys['ArrowDown'] || (gamepad && (gamepad.axes[1] > 0.5 || gamepad.buttons[13]?.pressed));
            const wantCrouch = isActionPressed(binds, 'down', gamepad) || hardDown;
            fighter.crouch(wantCrouch && fighter.onGround);
            
            // Jump - unified bindings + hardcoded fallback
            const hardUp = keys['ArrowUp'] || (gamepad && (gamepad.buttons[0]?.pressed || gamepad.buttons[12]?.pressed));
            if ((isActionPressed(binds, 'up', gamepad) || hardUp) && fighter.onGround && !wantCrouch) {
                fighter.jump(moveDir);
            }
            
            // Walk (if not jumping)
            if (fighter.onGround && moveDir !== 0) {
                fighter.walk(moveDir);
            } else if (fighter.onGround && moveDir === 0 && !fighter.crouching) {
                fighter.vx = 0;
            }
            
            // Punch - unified bindings
            const punchKey = isActionPressed(binds, 'punch', gamepad);
            if (punchKey && !fighter.lastPunchKey) {
                fighter.punch(fighter.crouching);
            }
            fighter.lastPunchKey = punchKey;
            
            // Kick - unified bindings (don't kick if sprinting)
            const kickKey = isActionPressed(binds, 'kick', gamepad) && !gpSprint;
            if (kickKey && !fighter.lastKickKey) {
                fighter.kick(fighter.crouching);
            }
            fighter.lastKickKey = kickKey;
            
            // Interact - unified bindings
            const interactKey = isActionPressed(binds, 'interact', gamepad);
            if (interactKey && !fighter.lastInteractKey) {
                if (fighter.weapon) {
                    // Drop current weapon
                    fighter.dropWeapon();
                } else {
                    // Try to pick up nearby weapon
                    tryPickupWeapon(fighter);
                }
            }
            fighter.lastInteractKey = interactKey;
        }
        
        function tryPickupWeapon(fighter) {
            const pickupRange = 40;
            for (let w of weapons) {
                if (w.onGround && Math.abs(w.x - fighter.x) < pickupRange) {
                    fighter.pickupWeapon(w);
                    return;
                }
            }
        }
        
        function checkAIWeaponPickup() {
            // AI enemies try to pick up weapons if nearby and unarmed
            enemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy.weapon) return;
                if (enemy.stunTimer > 0) return;
                
                const pickupRange = 35;
                for (let w of weapons) {
                    if (w.onGround && Math.abs(w.x - enemy.x) < pickupRange) {
                        // 30% chance per check to pick up (prevents instant grab)
                        if (Math.random() < 0.3) {
                            enemy.pickupWeapon(w);
                        }
                        break;
                    }
                }
            });
        }

        // ==================== GAME LOGIC ====================
        function processAttacks() {
            // Check player attacks (only hit non-traitor enemies)
            if (player.attackTimer > 0 && !player.hasDealtDamage && player.attackTimer > player.attackDuration - 100) {
                const attackType = player.state;
                let hitAny = false;
                
                enemies.forEach(enemy => {
                    if (enemy.turnedTraitor) return; // Don't hurt your allies!
                    if (enemy.health > 0 && checkAttackHit(player, enemy, attackType)) {
                        let damage = calculateDamage(attackType, player.weapon);
                        const knockDir = player.facingRight ? 1 : -1;
                        enemy.takeDamage(damage, knockDir, attackType);
                        hitAny = true;
                        playWeaponHitSound(player.weapon);
                    }
                });
                
                if (hitAny) {
                    player.hasDealtDamage = true; // Prevent multi-hit
                }
            }
            
            // Check enemy attacks (including traitor attacks against their former allies)
            enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                if (enemy.attackTimer > 0 && !enemy.hasDealtDamage && enemy.attackTimer > enemy.attackDuration - 100) {
                    const attackType = enemy.state;
                    
                    if (enemy.turnedTraitor) {
                        // Traitor attacks other enemies (boss and non-traitor minions)
                        enemies.forEach(target => {
                            if (target === enemy) return; // Don't attack self
                            if (target.health <= 0) return;
                            if (target.turnedTraitor) return; // Don't attack fellow traitors
                            
                            if (checkAttackHit(enemy, target, attackType)) {
                                let damage = calculateDamage(attackType, enemy.weapon);
                                const knockDir = enemy.facingRight ? 1 : -1;
                                target.takeDamage(damage, knockDir, attackType);
                                enemy.hasDealtDamage = true;
                                playWeaponHitSound(enemy.weapon);
                            }
                        });
                    } else {
                        // Normal enemy attacks player (and traitors)
                        // Attack player
                        if (checkAttackHit(enemy, player, attackType)) {
                            let damage = calculateDamage(attackType, enemy.weapon);
                            const knockDir = enemy.facingRight ? 1 : -1;
                            player.takeDamage(damage, knockDir, attackType);
                            enemy.hasDealtDamage = true;
                            playWeaponHitSound(enemy.weapon);
                        }
                        // Also attack traitor minions
                        enemies.forEach(target => {
                            if (!target.turnedTraitor) return;
                            if (target.health <= 0) return;
                            
                            if (checkAttackHit(enemy, target, attackType)) {
                                let damage = calculateDamage(attackType, enemy.weapon);
                                const knockDir = enemy.facingRight ? 1 : -1;
                                target.takeDamage(damage, knockDir, attackType);
                                enemy.hasDealtDamage = true;
                                playWeaponHitSound(enemy.weapon);
                            }
                        });
                    }
                }
            });
            
            // Check projectile hits
            processProjectiles();
        }
        
        function calculateDamage(attackType, weapon) {
            let baseDamage;
            switch (attackType) {
                case 'punching': baseDamage = PUNCH_DAMAGE; break;
                case 'lowPunch': baseDamage = LOW_PUNCH_DAMAGE; break;
                case 'jumpPunch': baseDamage = PUNCH_DAMAGE; break;
                case 'kicking': baseDamage = KICK_DAMAGE; break;
                case 'jumpKick': baseDamage = KICK_DAMAGE; break;
                case 'sweeping': baseDamage = SWEEP_DAMAGE; break;
                case 'poleStrike': baseDamage = PUNCH_DAMAGE; break;
                case 'poleSweep': baseDamage = SWEEP_DAMAGE; break;
                default: baseDamage = PUNCH_DAMAGE;
            }
            
            // Weapon damage multiplier
            if (weapon && (attackType === 'punching' || attackType === 'lowPunch' || attackType === 'jumpPunch' || 
                           attackType === 'poleStrike' || attackType === 'poleSweep')) {
                baseDamage *= WEAPON_DAMAGE_MULT;
            }
            
            return baseDamage;
        }
        
        function playWeaponHitSound(weapon) {
            if (!weapon) return;
            switch (weapon.type) {
                case 'sword': SoundFX.swordHit(); break;
                case 'pole': SoundFX.poleHit(); break;
                default: break;
            }
        }
        
        function processProjectiles() {
            projectiles = projectiles.filter(proj => {
                const remove = proj.update(1/60); // Approximate dt
                if (remove) return false;
                
                // Check hit on all fighters
                const projBox = proj.getHitbox();
                const allFighters = [player, ...enemies];
                
                // Determine thrower's allegiance
                const throwerIsPlayerSide = proj.thrower === player || proj.thrower.turnedTraitor;
                
                for (let fighter of allFighters) {
                    // Never damage the thrower
                    if (fighter === proj.thrower) continue;
                    if (fighter.health <= 0) continue;
                    if (fighter.invulnerable) continue;
                    // Skip fighters already hit during this flight
                    if (proj.hitFighters.has(fighter)) continue;
                    
                    // Check allegiance - don't hit allies
                    const targetIsPlayerSide = fighter === player || fighter.turnedTraitor;
                    if (throwerIsPlayerSide === targetIsPlayerSide) continue; // Same team
                    
                    const fBoxes = fighter.getHitboxes();
                    if (rectsOverlap(projBox, fBoxes.head) || rectsOverlap(projBox, fBoxes.body)) {
                        // Hit an enemy!
                        const damage = PUNCH_DAMAGE * WEAPON_DAMAGE_MULT;
                        const knockDir = proj.vx > 0 ? 1 : -1;
                        fighter.takeDamage(damage, knockDir, 'projectile');
                        proj.hitFighters.add(fighter); // Track this fighter as hit
                        
                        if (proj.type === 'star') {
                            SoundFX.starHit();
                            // Star drops to ground at projectile position (not fighter position)
                            proj.weapon.x = proj.x;
                            proj.weapon.y = GROUND_Y;
                            proj.weapon.onGround = true;
                            proj.weapon.owner = null;
                            // Ensure weapon is in weapons array for pickup
                            if (!weapons.includes(proj.weapon)) {
                                weapons.push(proj.weapon);
                            }
                            return false; // Remove projectile
                        } else if (proj.type === 'fan') {
                            SoundFX.fanHit();
                            // Fan returns after hit (continues through, can hit others)
                            proj.returning = true;
                        }
                    }
                }
                
                return true; // Keep projectile
            });
        }

        function checkRoundEnd() {
            if (gameState === 'ko') return;

            // Win if Boss (enemies[0]) is dead
            if (enemies[0].health <= 0) {
                gameState = 'ko';
                koTimer = 2000;
                
                enemies[0].state = 'tripped';
                enemies[0].stunTimer = 9999;
                enemies[0].vx = 0;
                return;
            }

            // Lose if Player is dead
            if (player.health <= 0) {
                gameState = 'ko';
                koTimer = 2000;
                
                player.state = 'tripped';
                player.stunTimer = 9999;
                player.vx = 0;
            }
        }

        function handleKO(dt) {
            koTimer -= dt * 1000;
            if (koTimer <= 0) {
                if (player.health <= 0) {
                    lives--;
                    // Clear surviving traitors when player dies (they don't carry over on retry)
                    survivingTraitors = [];
                    updateHUD();
                    if (lives > 0) {
                        gameState = 'roundEnd';
                        showMessage('TRY AGAIN!', '#ff6b6b');
                        setTimeout(() => {
                            startRound(false); // Stay in same arena when retrying
                        }, 2000);
                    } else {
                        gameState = 'gameOver';
                        showGameOver(false);
                    }
                } else {
                    // Victory - save surviving traitors for next round
                    survivingTraitors = enemies.filter(e => e.turnedTraitor && e.health > 0);
                    
                    // Recover in-flight fan weapons for traitors before arrays are cleared
                    survivingTraitors.forEach(traitor => {
                        if (!traitor.weapon) {
                            // Check if traitor has an in-flight fan projectile
                            const traitorFanProj = projectiles.find(p => p.thrower === traitor && p.type === 'fan');
                            if (traitorFanProj) {
                                traitor.weapon = traitorFanProj.weapon;
                            }
                        }
                    });
                    
                    // Endless mode - proceed to next round
                    gameState = 'roundEnd';
                    showMessage('K.O.!', '#ff6b6b');
                    setTimeout(() => {
                        currentRound++;
                        startRound();
                    }, 2000);
                }
            }
        }

        function showMessage(text, color = '#fff') {
            const overlay = document.getElementById('messageOverlay');
            overlay.textContent = text;
            overlay.style.color = color;
            overlay.style.opacity = '1';
            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 1500);
        }

        function showGameOver(isVictory) {
            const screen = document.getElementById('gameOverScreen');
            const title = document.getElementById('gameOverTitle');
            const msg = document.getElementById('gameOverMsg');
            const roundInfo = document.getElementById('finalRound');
            
            if (isVictory) {
                title.textContent = 'üèÜ CHAMPION! üèÜ';
                title.style.color = '#ffd700';
                msg.textContent = 'You have defeated all opponents!';
            } else {
                title.textContent = 'üíÄ DEFEATED üíÄ';
                title.style.color = '#ff6b6b';
                msg.textContent = `You were defeated by ${enemies[0] ? enemies[0].name : 'Enemy'}`;
            }
            roundInfo.textContent = `Round Reached: ${currentRound}`;
            
            screen.classList.remove('hidden');
        }

        function updateHUD() {
            document.getElementById('playerHealth').style.width = `${player.health}%`;
            document.getElementById('playerStamina').style.width = `${player.stamina}%`;
            document.getElementById('livesDisplay').textContent = `‚ù§Ô∏è x ${lives}`;
            
            // Boss HUD
            if (enemies.length > 0) {
                document.getElementById('enemyHealth').style.width = `${enemies[0].health}%`;
                document.getElementById('enemyStamina').style.width = `${enemies[0].stamina}%`;
                document.getElementById('enemyName').textContent = enemies[0].name;
            }
            
            document.getElementById('roundInfo').textContent = `Round ${currentRound}`;
        }

        function togglePause() {
            const pauseMenu = document.getElementById('pauseMenu');
            if (gameState === 'fighting') {
                gameState = 'paused';
                pauseMenu.classList.remove('hidden');
                pauseMenuSelectedIndex = 0;
                updatePauseMenuSelection();
            } else if (gameState === 'paused') {
                gameState = 'fighting';
                pauseMenu.classList.add('hidden');
            }
        }
        
        let pauseMenuSelectedIndex = 0;
        
        function updatePauseMenuSelection() {
            const buttons = document.querySelectorAll('#pauseMenu .menuBtn');
            buttons.forEach((btn, i) => btn.classList.toggle('selected', i === pauseMenuSelectedIndex));
        }
        
        function navigatePauseMenu(delta) {
            const buttons = document.querySelectorAll('#pauseMenu .menuBtn');
            pauseMenuSelectedIndex = (pauseMenuSelectedIndex + delta + buttons.length) % buttons.length;
            updatePauseMenuSelection();
        }
        
        function activatePauseMenuSelection() {
            const buttons = document.querySelectorAll('#pauseMenu .menuBtn');
            buttons[pauseMenuSelectedIndex]?.click();
        }

        function resolveEnemyCollisions(dt) {
            const minSpacing = 60; // Minimum distance between enemies
            const separationSpeed = 100; // How fast they push apart

            for (let i = 0; i < enemies.length; i++) {
                for (let j = i + 1; j < enemies.length; j++) {
                    const e1 = enemies[i];
                    const e2 = enemies[j];

                    if (e1.health <= 0 || e2.health <= 0) continue;
                    
                    // Only push apart allies (same faction)
                    // Traitors are pushed apart from traitors, boss minions from boss minions
                    if (e1.turnedTraitor !== e2.turnedTraitor) continue;

                    const dx = e1.x - e2.x;
                    const dist = Math.abs(dx);

                    if (dist < minSpacing) {
                        // Push apart
                        const push = (minSpacing - dist) / minSpacing; // 0 to 1 strength
                        const move = separationSpeed * push * dt;
                        
                        if (dx > 0) {
                            e1.x += move;
                            e2.x -= move;
                        } else if (dx < 0) {
                            e1.x -= move;
                            e2.x += move;
                        } else {
                            // Exact overlap, random push
                            e1.x += move;
                            e2.x -= move;
                        }
                    }
                }
            }
        }

        // ==================== GAME LOOP ====================
        // Gamepad tracking for menu navigation
        let lastGpUp = false;
        let lastGpDown = false;
        
        function gameLoop(timestamp) {
            let dt = Math.min((timestamp - lastTime) / 1000, 0.05); // Cap dt to prevent huge jumps
            lastTime = timestamp;
            
            // Gamepad Menu Control
            const gp = getGamepadInput();
            
            // Title screen gamepad navigation
            if (currentScreen === 'title') {
                // D-pad or left stick for menu navigation
                const gpUp = gp.up || gp.dpadUp;
                const gpDown = gp.down || gp.dpadDown;
                
                if (gpUp && !lastGpUp) {
                    updateMenuSelection(-1);
                }
                if (gpDown && !lastGpDown) {
                    updateMenuSelection(1);
                }
                lastGpUp = gpUp;
                lastGpDown = gpDown;
                
                // A button or Start to select
                const gpSelect = (gp.punch && !lastPunchBtn) || (gp.start && !lastStartBtn);
                if (gpSelect) {
                    activateMenuSelection();
                }
            } else if (currentScreen === 'settings') {
                // B button to go back from settings
                if (gp.kick && !lastKickBtn) {
                    showTitleScreen();
                }
            }
            
            // Pause menu gamepad navigation
            if (gameState === 'paused' && currentScreen === 'game') {
                // Navigate with D-pad
                if (gp.dpadUp && !lastGpUp) {
                    navigatePauseMenu(-1);
                }
                if (gp.dpadDown && !lastGpDown) {
                    navigatePauseMenu(1);
                }
                // A button to select
                if (gp.punch && !lastPunchBtn) {
                    activatePauseMenuSelection();
                }
                // B button to resume (like pressing pause again)
                if (gp.kick && !lastKickBtn) {
                    togglePause();
                }
            }
            
            // Action buttons (punch/kick) can dismiss modals
            const gpActionPressed = (gp.punch || gp.kick) && !(lastPunchBtn || lastKickBtn);
            
            if (gpActionPressed && currentScreen === 'game') {
                if (gameState === 'dialog') {
                    advanceDialog();
                } else if (gameState === 'gameOver' || gameState === 'victory') {
                    restartGame();
                }
            }
            lastPunchBtn = gp.punch;
            lastKickBtn = gp.kick;
            
            // Start button for pause/unpause and modals
            if (gp.start && !lastStartBtn && currentScreen === 'game') {
                if (gameState === 'gameOver' || gameState === 'victory') {
                    restartGame();
                } else if (gameState === 'fighting' || gameState === 'paused') {
                    togglePause();
                }
            }
            lastStartBtn = gp.start;

            if (gameState === 'fighting' || gameState === 'ko') {
                // Slow motion during KO
                if (gameState === 'ko') dt *= 0.2;

                // Handle input (only if fighting)
                if (gameState === 'fighting') handlePlayerInput(player);
                
                // Update AI (only if fighting)
                if (gameState === 'fighting') {
                    // Build list of player-faction targets (player + traitor minions)
                    const playerFaction = [player, ...enemies.filter(e => e.turnedTraitor && e.health > 0)];
                    
                    // Find nearest living non-traitor enemy for coordination
                    let nearestEnemy = null;
                    let minDist = Infinity;
                    enemies.forEach(e => {
                        if (e.health > 0 && !e.turnedTraitor) {
                            const d = Math.abs(e.x - player.x);
                            if (d < minDist) { minDist = d; nearestEnemy = e; }
                        }
                    });

                    enemies.forEach(enemy => {
                        if (enemy.health > 0) {
                            // Traitor minions target enemies instead of player
                            if (enemy.turnedTraitor) {
                                // Find nearest non-traitor enemy to attack
                                let traitorTarget = null;
                                let targetDist = Infinity;
                                enemies.forEach(e => {
                                    if (e !== enemy && e.health > 0 && !e.turnedTraitor) {
                                        const d = Math.abs(e.x - enemy.x);
                                        if (d < targetDist) { targetDist = d; traitorTarget = e; }
                                    }
                                });
                                
                                if (traitorTarget) {
                                    // Find nearest traitor to the target for coordination (like boss minions)
                                    let nearestTraitor = null;
                                    let nearestTraitorDist = Infinity;
                                    enemies.forEach(e => {
                                        if (e.turnedTraitor && e.health > 0) {
                                            const d = Math.abs(e.x - traitorTarget.x);
                                            if (d < nearestTraitorDist) {
                                                nearestTraitorDist = d;
                                                nearestTraitor = e;
                                            }
                                        }
                                    });
                                    
                                    const isNearest = (enemy === nearestTraitor);
                                    let overlapDir = 0;
                                    
                                    // Collision avoidance with other traitors
                                    if (!isNearest) {
                                        for (let other of enemies) {
                                            if (other !== enemy && other.turnedTraitor && other.health > 0) {
                                                const dx = enemy.x - other.x;
                                                if (Math.abs(dx) < 60) {
                                                    overlapDir = dx > 0 ? 1 : -1;
                                                    if (dx === 0) overlapDir = Math.random() < 0.5 ? 1 : -1;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    
                                    updateAI(enemy, traitorTarget, dt, isNearest, overlapDir);
                                }
                            } else {
                                // Normal enemy AI - target nearest player-faction character
                                // Find nearest player-faction target for this enemy
                                let aiTarget = player;
                                let aiTargetDist = Math.abs(enemy.x - player.x);
                                playerFaction.forEach(pf => {
                                    if (pf.health > 0) {
                                        const d = Math.abs(enemy.x - pf.x);
                                        if (d < aiTargetDist) {
                                            aiTargetDist = d;
                                            aiTarget = pf;
                                        }
                                    }
                                });
                                
                                const isNearest = (enemy === nearestEnemy);
                                let overlapDir = 0;

                                if (!isNearest) {
                                    for (let other of enemies) {
                                        if (other !== enemy && other.health > 0 && !other.turnedTraitor) {
                                            const dx = enemy.x - other.x;
                                            if (Math.abs(dx) < 60) {
                                                // Move away from the other enemy
                                                overlapDir = dx > 0 ? 1 : -1;
                                                if (dx === 0) overlapDir = Math.random() < 0.5 ? 1 : -1;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                updateAI(enemy, aiTarget, dt, isNearest, overlapDir);
                            }
                        }
                    });
                    
                    // Prevent NPC stacking
                    resolveEnemyCollisions(dt);
                }
                
                // Update fighters
                // Find nearest enemy for player facing (exclude traitors - they're allies!)
                let nearestEnemy = enemies[0];
                let minDist = Infinity;
                enemies.forEach(e => {
                    if (e.health > 0 && !e.turnedTraitor) {
                        const d = Math.abs(e.x - player.x);
                        if (d < minDist) { minDist = d; nearestEnemy = e; }
                    }
                });
                
                player.update(dt, nearestEnemy);
                
                // Build player faction list for enemy facing
                const playerFactionForFacing = [player, ...enemies.filter(e => e.turnedTraitor && e.health > 0)];
                
                enemies.forEach(enemy => {
                    // Determine what this enemy should face
                    let faceTarget = player;
                    if (enemy.turnedTraitor) {
                        // Traitor faces nearest non-traitor enemy
                        let targetDist = Infinity;
                        enemies.forEach(e => {
                            if (e !== enemy && e.health > 0 && !e.turnedTraitor) {
                                const d = Math.abs(e.x - enemy.x);
                                if (d < targetDist) { targetDist = d; faceTarget = e; }
                            }
                        });
                    } else {
                        // Boss/loyal minion faces nearest player-faction character
                        let targetDist = Infinity;
                        playerFactionForFacing.forEach(pf => {
                            if (pf.health > 0) {
                                const d = Math.abs(enemy.x - pf.x);
                                if (d < targetDist) { targetDist = d; faceTarget = pf; }
                            }
                        });
                    }
                    enemy.update(dt, faceTarget);
                });

                // Remove dead minions
                enemies = enemies.filter(e => !(e.isMinion && e.health <= 0 && e.deathTimer > 2));
                
                // Update potions
                potions.forEach(p => p.update(dt));
                
                // Update weapons on ground
                weapons.forEach(w => w.update(dt));
                
                // Track round time and check for timed potion spawns
                if (gameState === 'fighting') {
                    roundTime += dt;
                    checkTimedPotionSpawns();
                    
                    // AI weapon pickup
                    checkAIWeaponPickup();
                }
                
                // Check potion pickup
                if (gameState === 'fighting') checkPotionPickup();
                
                // Process attacks
                if (gameState === 'fighting') processAttacks();
                
                // Check round end
                checkRoundEnd();
                
                // Handle KO timer
                if (gameState === 'ko') handleKO(dt / 0.2); // Pass real time for timer
                
                // Update HUD
                updateHUD();
            }
            
            // Render
            render();
            
            requestAnimationFrame(gameLoop);
        }

        function render() {
            // Clear using logical dimensions (context is scaled)
            ctx.clearRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
            
            // Draw Arena Background
            if (currentArena) currentArena.draw(ctx);
            
            if (!player || enemies.length === 0) return;

            // Draw ground weapons first (behind fighters)
            weapons.forEach(w => w.draw(ctx));
            
            // Draw fighters with z-ordering:
            // 1. Enemy minions (back) - sorted by Y for depth
            // 2. Boss (middle)
            // 3. Traitor minions (in front of boss, behind player)
            // 4. Player (front)
            
            // Separate fighters into layers
            const minions = enemies.filter(e => e.isMinion && !e.turnedTraitor);
            const traitors = enemies.filter(e => e.turnedTraitor);
            const boss = enemies.find(e => !e.isMinion);
            
            // Sort minions and traitors by Y position for depth
            minions.sort((a, b) => a.y - b.y);
            traitors.sort((a, b) => a.y - b.y);
            
            // Draw in z-order: minions (back) -> boss -> traitors -> player (front)
            minions.forEach(f => f.draw(ctx));
            if (boss) boss.draw(ctx);
            traitors.forEach(f => f.draw(ctx));
            player.draw(ctx);
            
            // Draw potions
            potions.forEach(p => p.draw(ctx));
            
            // Draw traitor potion inventory (below player health/stamina area)
            drawTraitorPotionInventory(ctx);
            
            // Draw projectiles (in front of everything)
            projectiles.forEach(proj => proj.draw(ctx));

            // Render dialog speech bubbles on top of everything
            if (gameState === 'dialog') {
                renderDialog();
            }
        }

        // ==================== SCALING LOGIC ====================
        function resizeGame() {
            const container = document.getElementById('gameContainer');
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Game aspect ratio is 960:540 = 16:9
            const gameAspect = 960 / 540;
            const screenAspect = windowWidth / windowHeight;
            
            let scale, rotation;
            
            // Check if rotating would give us a larger game view
            // Normal: fit 960x540 into windowWidth x windowHeight
            // Rotated: fit 960x540 into windowHeight x windowWidth (swap)
            const normalScale = Math.min(windowWidth / 960, windowHeight / 540);
            const rotatedScale = Math.min(windowHeight / 960, windowWidth / 540);
            
            if (rotatedScale > normalScale * 1.1) {
                // Rotating gives significantly more space (10% threshold to avoid unnecessary rotation)
                scale = rotatedScale;
                rotation = 90;
            } else {
                // Normal orientation is fine
                scale = normalScale;
                rotation = 0;
            }
            
            // Apply transform
            container.style.transform = `translate(-50%, -50%) rotate(${rotation}deg) scale(${scale})`;
            
            // Update canvas resolution for sharpness
            const dpr = window.devicePixelRatio || 1;
            const resolutionScale = scale * dpr;
            
            // Only resize if dimensions changed significantly to avoid thrashing
            if (Math.abs(canvas.width - ARENA_WIDTH * resolutionScale) > 1) {
                canvas.width = ARENA_WIDTH * resolutionScale;
                canvas.height = ARENA_HEIGHT * resolutionScale;
                
                // Normalize coordinate system to logical pixels
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(resolutionScale, resolutionScale);
            }
        }

        // ==================== GAME INITIALIZATION ====================
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Initialize title screen canvas
            titleCanvas = document.getElementById('titleCanvas');
            if (titleCanvas) {
                titleCtx = titleCanvas.getContext('2d');
                titleCanvas.width = ARENA_WIDTH;
                titleCanvas.height = ARENA_HEIGHT + 80;
            }
            
            // Load saved control configuration
            loadControlConfig();
            
            // Handle resizing
            window.addEventListener('resize', resizeGame);
            resizeGame();
            
            // Initialize settings UI
            initSettingsUI();
            
            // Title screen menu buttons
            document.getElementById('btnOnePlayer').addEventListener('click', () => {
                startOnePlayerGame();
            });
            
            document.getElementById('btnSettings').addEventListener('click', () => {
                showSettingsScreen();
            });
            
            // Pause menu buttons
            document.getElementById('btnResume').addEventListener('click', () => {
                togglePause();
            });
            
            document.getElementById('btnQuitToTitle').addEventListener('click', () => {
                document.getElementById('pauseMenu').classList.add('hidden');
                gameState = 'title';
                showTitleScreen();
            });
            
            // Event listeners
            document.addEventListener('keydown', (e) => {
                // Debug Sequence - works on ALL screens (title, settings, gameplay)
                if (e.key.length === 1) {
                    debugBuffer += e.key.toLowerCase();
                    if (debugBuffer.length > 5) debugBuffer = debugBuffer.slice(-5);
                    if (debugBuffer === 'debug') {
                        debugMode = !debugMode;
                        showMessage(debugMode ? 'DEBUG MODE ON' : 'DEBUG MODE OFF', '#00ff00');
                        updateDebugTabVisibility();
                        debugBuffer = '';
                    }
                }
                
                // Settings key listening takes priority
                if (currentScreen === 'settings' && handleSettingsKeydown(e)) {
                    return;
                }
                
                // Escape key handling
                if (e.code === 'Escape') {
                    if (currentScreen === 'settings') {
                        showTitleScreen();
                        e.preventDefault();
                        return;
                    }
                }
                
                // Settings screen navigation with arrow keys
                if (currentScreen === 'settings') {
                    const focusedEl = document.activeElement;
                    const isInTabs = focusedEl && focusedEl.classList.contains('settingsTab');
                    const isBackBtn = focusedEl && focusedEl.id === 'btnBackToTitle';
                    
                    // Get all focusable elements in current context
                    const getAllSettingsFocusables = () => {
                        const activePanel = document.querySelector('.settingsPanel.active');
                        const panelFocusables = activePanel ? 
                            Array.from(activePanel.querySelectorAll('[tabindex="0"], button:not(:disabled), a')) : [];
                        const backBtn = document.getElementById('btnBackToTitle');
                        return [...panelFocusables, backBtn];
                    };
                    
                    // Tab navigation
                    if (isInTabs) {
                        const tabs = Array.from(document.querySelectorAll('.settingsTab')).filter(t => t.style.display !== 'none');
                        const currentIdx = tabs.indexOf(focusedEl);
                        
                        if (e.code === 'ArrowUp' && currentIdx > 0) {
                            tabs[currentIdx - 1].focus();
                            e.preventDefault();
                            return;
                        }
                        if (e.code === 'ArrowDown' && currentIdx < tabs.length - 1) {
                            tabs[currentIdx + 1].focus();
                            e.preventDefault();
                            return;
                        }
                        // Right/Enter moves focus into panel content
                        if (e.code === 'ArrowRight' || e.code === 'Enter' || e.code === 'Space') {
                            // Activate the tab first if not already active
                            if (!focusedEl.classList.contains('active')) {
                                focusedEl.click();
                            }
                            const focusables = getAllSettingsFocusables();
                            if (focusables.length > 0) {
                                focusables[0].focus();
                                focusables[0].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                            e.preventDefault();
                            return;
                        }
                    }
                    // Back button navigation
                    else if (isBackBtn) {
                        if (e.code === 'ArrowUp') {
                            const focusables = getAllSettingsFocusables();
                            const backIdx = focusables.indexOf(focusedEl);
                            if (backIdx > 0) {
                                focusables[backIdx - 1].focus();
                                focusables[backIdx - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                            e.preventDefault();
                            return;
                        }
                        if (e.code === 'ArrowLeft') {
                            const activeTab = document.querySelector('.settingsTab.active');
                            if (activeTab) activeTab.focus();
                            e.preventDefault();
                            return;
                        }
                    }
                    // Panel content navigation
                    else if (focusedEl) {
                        const focusables = getAllSettingsFocusables();
                        const currentIdx = focusables.indexOf(focusedEl);
                        
                        if (e.code === 'ArrowUp') {
                            if (currentIdx > 0) {
                                focusables[currentIdx - 1].focus();
                                focusables[currentIdx - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                            e.preventDefault();
                            return;
                        }
                        if (e.code === 'ArrowDown') {
                            if (currentIdx < focusables.length - 1) {
                                focusables[currentIdx + 1].focus();
                                focusables[currentIdx + 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                            e.preventDefault();
                            return;
                        }
                        if (e.code === 'ArrowLeft') {
                            const activeTab = document.querySelector('.settingsTab.active');
                            if (activeTab) activeTab.focus();
                            e.preventDefault();
                            return;
                        }
                    }
                }
                
                // Title screen navigation - use player 1 keybinds
                if (currentScreen === 'title') {
                    const p1Binds = getPlayerKeybinds(1);
                    if (e.code === 'ArrowUp' || isKeyBound(p1Binds, 'up', e.code)) {
                        updateMenuSelection(-1);
                        e.preventDefault();
                        return;
                    }
                    if (e.code === 'ArrowDown' || isKeyBound(p1Binds, 'down', e.code)) {
                        updateMenuSelection(1);
                        e.preventDefault();
                        return;
                    }
                    if (e.code === 'Enter' || e.code === 'Space' || isKeyBound(p1Binds, 'punch', e.code) || isKeyBound(p1Binds, 'kick', e.code)) {
                        activateMenuSelection();
                        e.preventDefault();
                        return;
                    }
                }
                
                // Pause menu navigation
                if (gameState === 'paused') {
                    const p1Binds = getPlayerKeybinds(1);
                    if (e.code === 'ArrowUp' || isKeyBound(p1Binds, 'up', e.code)) {
                        navigatePauseMenu(-1);
                        e.preventDefault();
                        return;
                    }
                    if (e.code === 'ArrowDown' || isKeyBound(p1Binds, 'down', e.code)) {
                        navigatePauseMenu(1);
                        e.preventDefault();
                        return;
                    }
                    if (e.code === 'Enter' || e.code === 'Space' || isKeyBound(p1Binds, 'punch', e.code) || isKeyBound(p1Binds, 'kick', e.code)) {
                        activatePauseMenuSelection();
                        e.preventDefault();
                        return;
                    }
                }
                
                // Modal handling - use configurable keybinds for action keys
                const gameOverScreen = document.getElementById('gameOverScreen');
                const p1Binds = getPlayerKeybinds(1);
                const isActionKey = isKeyBound(p1Binds, 'punch', e.code) || isKeyBound(p1Binds, 'kick', e.code) || 
                                   e.code === 'Enter' || e.code === 'Space';

                // Dialog can be advanced with any key
                if (gameState === 'dialog') {
                    advanceDialog();
                    return;
                }

                if (isActionKey) {
                    if (!gameOverScreen.classList.contains('hidden')) {
                        restartGame();
                        return;
                    }
                }

                // Debug keys - use configurable keybinds
                if (debugMode && gameState === 'fighting') {
                    const dbg = controlConfig.debug;
                    if (e.code === dbg.killAll) {
                        enemies.forEach(enemy => {
                            enemy.health = 0;
                        });
                        showMessage('INSTA-KILL!', '#ff0000');
                    }
                    if (e.code === dbg.oneHp) {
                        enemies.forEach(enemy => {
                            enemy.health = 1;
                        });
                        showMessage('1 HP LEFT!', '#ffff00');
                    }
                    if (e.code === dbg.nextRound) {
                        currentRound++;
                        // Sync arena cycle with round number
                        arenaCycleIndex = (currentRound - 1) % ARENA_CYCLE.length;
                        startRound();
                    }
                    if (e.code === dbg.prevRound) {
                        if (currentRound > 1) {
                            currentRound--;
                            // Sync arena cycle with round number
                            arenaCycleIndex = (currentRound - 1) % ARENA_CYCLE.length;
                            startRound();
                        }
                    }
                    if (e.code === dbg.addLife) {
                        lives++;
                        updateHUD();
                        showMessage(`LIVES: ${lives}`, '#00ff00');
                    }
                    if (e.code === dbg.removeLife) {
                        lives = Math.max(0, lives - 1);
                        updateHUD();
                        showMessage(`LIVES: ${lives}`, '#ff0000');
                    }
                    if (e.code === dbg.invulnOn) {
                        if (player) player.setDebugInvulnerable(true);
                        showMessage('INVULNERABLE', '#00ff00');
                    }
                    if (e.code === dbg.invulnOff) {
                        if (player) player.setDebugInvulnerable(false);
                        showMessage('VULNERABLE', '#ff0000');
                    }
                    if (e.code === dbg.addPotion) {
                        if (traitorPotionInventory < MAX_TRAITOR_POTIONS) {
                            traitorPotionInventory++;
                            showMessage(`POTIONS: ${traitorPotionInventory}`, '#ff00ff');
                        } else {
                            showMessage('POTIONS FULL', '#ff0000');
                        }
                    }
                    if (e.code === dbg.removePotion) {
                        if (traitorPotionInventory > 0) {
                            traitorPotionInventory--;
                            showMessage(`POTIONS: ${traitorPotionInventory}`, '#ff00ff');
                        } else {
                            showMessage('NO POTIONS', '#ff0000');
                        }
                    }
                }

                // Pause toggle - use configurable keybinds only
                const pauseBinds = getPlayerKeybinds(1);
                const pauseBinds2 = getPlayerKeybinds(2);
                if (isKeyBound(pauseBinds, 'pause', e.code) || isKeyBound(pauseBinds2, 'pause', e.code)) {
                    togglePause();
                }

                if (!e.repeat && gameState === 'fighting') {
                    const binds = getPlayerKeybinds(1);
                    if (isKeyBound(binds, 'left', e.code) || isKeyBound(binds, 'right', e.code)) {
                        const now = performance.now();
                        if (lastTapKey === e.code && now - lastTapTime < 300) {
                            if (player) player.isSprinting = true;
                        }
                    }
                }
                keys[e.code] = true;
                keys[e.key] = true;
                // Prevent scrolling
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                const binds = getPlayerKeybinds(1);
                if (isKeyBound(binds, 'left', e.code) || isKeyBound(binds, 'right', e.code)) {
                    lastTapTime = performance.now();
                    lastTapKey = e.code;
                    // Stop sprinting if we release the movement key
                    if (player) player.isSprinting = false;
                }
                keys[e.code] = false;
                keys[e.key] = false;
            });
            
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // Click/tap on canvas to advance dialog
            canvas.addEventListener('click', () => {
                if (gameState === 'dialog') {
                    advanceDialog();
                }
            });

            // Show title screen on start
            showTitleScreen();
            
            // Start loop immediately for gamepad polling
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function startOnePlayerGame() {
            showGameScreen();
            currentRound = 1;
            lives = 5;
            arenaCycleIndex = 0;
            survivingTraitors = []; // Clear army when starting fresh
            traitorPotionInventory = 0; // Clear potion inventory when starting fresh
            player = null; // Clear player so weapon isn't carried over from previous game
            startRound();
            // Note: gameState is set by startRound() based on arena type
            // (either 'dialog' for place arenas or 'fighting' for travel arenas)
            lastTime = performance.now();
        }

        function startRound(advanceArena = true) {
            // Save player's weapon BEFORE clearing arrays
            // Also check for in-flight fan (player.weapon is null while fan is thrown)
            let playerWeapon = player?.weapon;
            if (!playerWeapon && player) {
                // Check if player has an in-flight fan projectile
                const playerFanProj = projectiles.find(p => p.thrower === player && p.type === 'fan');
                if (playerFanProj) {
                    playerWeapon = playerFanProj.weapon;
                }
            }
            
            enemies = [];
            potions = []; // Clear potions on new round
            weapons = []; // Clear weapons on new round
            projectiles = []; // Clear projectiles
            roundTime = 0; // Reset round timer
            leftPotionSpawned = false; // Reset timed spawn flags
            rightPotionSpawned = false;

            // Select Arena from cycle (only advance if winning or starting fresh)
            if (advanceArena) {
                currentArena = getArenaByName(ARENA_CYCLE[arenaCycleIndex]);
                arenaCycleIndex = (arenaCycleIndex + 1) % ARENA_CYCLE.length;
            }

            let bossName, bossColor, bossStyle, bossStats;

            if (currentRound <= 8) {
                const opp = OPPONENTS[currentRound - 1];
                bossName = opp.name;
                bossColor = opp.color;
                bossStyle = opp.style;
                bossStats = opp.stats;
            } else {
                // Seeded Random
                const seed = currentRound * 12345;
                const rng = mulberry32(seed);
                
                const fName = FIRST_NAMES[Math.floor(rng() * FIRST_NAMES.length)];
                const lName = LAST_NAMES[Math.floor(rng() * LAST_NAMES.length)];
                bossName = `${fName} ${lName}`;
                
                // Random Color
                const r = Math.floor(rng() * 200 + 55);
                const g = Math.floor(rng() * 200 + 55);
                const b = Math.floor(rng() * 200 + 55);
                const toHex = (c) => c.toString(16).padStart(2, '0');
                bossColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                
                // Random Style/Stats - Boss stats in 75%-100% range
                const styles = ['defensive', 'aggressive', 'balanced', 'technical', 'evasive', 'master'];
                bossStyle = styles[Math.floor(rng() * styles.length)];
                
                bossStats = {
                    aggression: 0.75 + rng() * 0.25,
                    block: 0.75 + rng() * 0.25,
                    jump: 0.75 + rng() * 0.25,
                    punch: 0.75 + rng() * 0.25,
                    kick: 0.75 + rng() * 0.25,
                    sprint: 0.75 + rng() * 0.25
                };
            }
            
            // Position constants - use walk limits
            const LEFT_BOUND = 60;  // Near left edge (walk limit is 50)
            const RIGHT_BOUND = ARENA_WIDTH - 60;  // Near right edge (walk limit is ARENA_WIDTH - 50)
            const MID_POINT = ARENA_WIDTH / 2;
            const NPC_SPACING = 35;
            
            // Create Boss - position at far right edge
            const bossX = RIGHT_BOUND;
            const boss = new Fighter(bossX, false, bossColor, bossName);
            boss.aiStyle = bossStyle;
            boss.aiStats = bossStats;
            enemies.push(boss);
            
            // Give boss a random weapon (50% chance, higher in later rounds)
            const weaponChance = Math.min(0.8, 0.3 + currentRound * 0.05);
            if (Math.random() < weaponChance) {
                const weaponType = WEAPON_TYPES[Math.floor(Math.random() * WEAPON_TYPES.length)];
                const bossWeapon = new Weapon(weaponType, boss.x, GROUND_Y);
                boss.pickupWeapon(bossWeapon);
                weapons.push(bossWeapon);
            }
            
            // Create Minions (Round 9 starts with 1 minion)
            // Formula: Round 1-8: 0 minions. Round 9-16: 1 minion. Round 17-24: 2 minions.
            const numMinions = Math.floor((currentRound - 1) / 8);
            
            // Helper: ping-pong fan-out positioning
            // Places NPCs nearest to anchor first, bouncing back after reaching limit
            function getPingPongPosition(index, anchorX, towardsMid, spacing, midLimit) {
                // Calculate how many can fit before hitting mid point
                const distToMid = Math.abs(midLimit - anchorX);
                const slotsBeforeMid = Math.floor(distToMid / spacing);
                
                if (index < slotsBeforeMid) {
                    // Still heading towards middle
                    return towardsMid ? anchorX + (index + 1) * spacing : anchorX - (index + 1) * spacing;
                } else {
                    // Bounce back - place behind previous NPCs
                    const bounceIndex = index - slotsBeforeMid;
                    return towardsMid ? anchorX - (bounceIndex + 1) * spacing : anchorX + (bounceIndex + 1) * spacing;
                }
            }
            
            // Position enemy minions with ping-pong from boss towards middle
            for (let i = 0; i < numMinions; i++) {
                const mx = getPingPongPosition(i, bossX, false, NPC_SPACING, MID_POINT);
                // Clamp to valid range (right half for enemies)
                const safeMx = Math.max(MID_POINT + 20, Math.min(RIGHT_BOUND - 20, mx));
                
                const minion = new Fighter(safeMx, false, '#888888', '', true); // isMinion = true
                minion.health = 50; // Minions start at 50% HP
                minion.aiStyle = 'aggressive'; // Minions are usually aggressive fodder
                // Minion stats in 25%-75% range (competent but not elite)
                minion.aiStats = {
                    aggression: 0.25 + Math.random() * 0.5,
                    block: 0.25 + Math.random() * 0.5,
                    jump: 0.25 + Math.random() * 0.5,
                    punch: 0.25 + Math.random() * 0.5,
                    kick: 0.25 + Math.random() * 0.5,
                    sprint: 0.25 + Math.random() * 0.5
                };
                enemies.push(minion);
            }
            
            // Preserve debug invulnerability across rounds
            const hadDebugInvulnerability = player && player.debugInvulnerable;
            player = new Fighter(LEFT_BOUND, true, PLAYER_COLOR, PLAYER_NAME);
            if (debugMode && hadDebugInvulnerability) {
                player.setDebugInvulnerable(true);
            }
            
            // Restore player's weapon from previous round
            if (playerWeapon) {
                player.pickupWeapon(playerWeapon);
                if (!weapons.includes(playerWeapon)) {
                    weapons.push(playerWeapon);
                }
            }
            
            // Restore surviving traitors from previous round (player's army!)
            // Balance: limit traitors to enemy minion count, excess become potions
            if (survivingTraitors.length > 0) {
                const allowedTraitors = Math.min(survivingTraitors.length, numMinions);
                const excessTraitors = survivingTraitors.length - allowedTraitors;
                
                // Convert excess traitors to inventory potions
                if (excessTraitors > 0) {
                    const potionsToAdd = Math.min(excessTraitors, MAX_TRAITOR_POTIONS - traitorPotionInventory);
                    traitorPotionInventory += potionsToAdd;
                    if (potionsToAdd > 0) {
                        showMessage(`+${potionsToAdd} Potion${potionsToAdd > 1 ? 's' : ''} Stored`, '#ff00ff');
                    }
                }
                
                // Only restore allowed number of traitors
                const traitorsToRestore = survivingTraitors.slice(0, allowedTraitors);
                traitorsToRestore.forEach((traitor, i) => {
                    // Reset traitor to 50% health (same as enemy minions) and full stamina
                    traitor.health = 50;
                    traitor.stamina = STAMINA_MAX;
                    traitor.state = 'idle';
                    traitor.stunTimer = 0;
                    traitor.attackTimer = 0;
                    
                    // Position traitors with ping-pong from player towards middle
                    const tx = getPingPongPosition(i, player.x, true, NPC_SPACING, MID_POINT);
                    // Clamp to valid range (left half for player's team)
                    traitor.x = Math.max(LEFT_BOUND + 20, Math.min(MID_POINT - 20, tx));
                    traitor.y = GROUND_Y;
                    traitor.facingRight = true; // Face the enemy
                    
                    // Restore traitor's weapon if they had one
                    if (traitor.weapon) {
                        traitor.weapon.onGround = false;
                        traitor.weapon.owner = traitor;
                        if (!weapons.includes(traitor.weapon)) {
                            weapons.push(traitor.weapon);
                        }
                    }
                    
                    // Add back to enemies array (they're still technically "enemies" for AI purposes)
                    enemies.push(traitor);
                });
                // Clear the surviving traitors list (they're now in the enemies array)
                survivingTraitors = [];
            }
            
            // Use inventory potions to fill up traitor slots at round start
            // This spawns NEW traitors for the player's army, not converting boss minions
            const currentTraitorCount = enemies.filter(e => e.turnedTraitor).length;
            const traitorShortfall = numMinions - currentTraitorCount;
            
            if (traitorShortfall > 0 && traitorPotionInventory > 0) {
                const potionsToUse = Math.min(traitorShortfall, traitorPotionInventory);
                
                for (let i = 0; i < potionsToUse; i++) {
                    traitorPotionInventory--;
                    
                    // Spawn a new traitor fighter on the player's side
                    const traitorIndex = currentTraitorCount + i;
                    // Position with ping-pong from player towards middle
                    const tx = getPingPongPosition(traitorIndex, player.x, true, NPC_SPACING, MID_POINT);
                    const traitorX = Math.max(LEFT_BOUND + 20, Math.min(MID_POINT - 20, tx));
                    
                    const newTraitor = new Fighter(traitorX, false, TRAITOR_COLOR, '', true); // isMinion = true
                    newTraitor.health = 50; // Minions start at 50% HP
                    newTraitor.turnedTraitor = true; // This is what the AI checks for faction!
                    newTraitor.facingRight = true; // Face the enemy
                    newTraitor.aiStyle = 'aggressive';
                    // Traitor stats in 25%-75% range (competent but not elite)
                    newTraitor.aiStats = {
                        aggression: 0.25 + Math.random() * 0.5,
                        block: 0.25 + Math.random() * 0.5,
                        jump: 0.25 + Math.random() * 0.5,
                        punch: 0.25 + Math.random() * 0.5,
                        kick: 0.25 + Math.random() * 0.5,
                        sprint: 0.25 + Math.random() * 0.5
                    };
                    enemies.push(newTraitor);
                }
                
                showMessage(`${potionsToUse} Traitor${potionsToUse > 1 ? 's' : ''} Joined!`, '#4ecdc4');
            }
            
            updateHUD();
            
            // Check if this is a 'place' arena - trigger dialog before fighting
            if (currentArena && currentArena.type === 'place') {
                startDialog();
                showMessage(`Round ${currentRound}: ${bossName}`, bossColor);
            } else {
                // Travel arenas go straight to fighting
                gameState = 'fighting';
                showMessage(`Round ${currentRound}: ${bossName}`, bossColor);
            }
        }

        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            // Return to title screen instead of immediately restarting
            showTitleScreen();
        }

        // Start
        init();
    </script>
    <script src="parental.js" defer></script>
    <script src="assets/js/pwa.js" defer></script>
</body>
</html>
