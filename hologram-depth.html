<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Hologram Card (Depth Map)</title>
  <link rel="icon" type="image/png" sizes="512x512" href="assets/appicons/idle-games-512x512px.png">
  <link rel="apple-touch-icon" href="assets/appicons/icon-192.png">
  <meta name="theme-color" content="#0a0a0f">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      min-height: 100dvh;
      background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, sans-serif;
      color: #fff;
      overflow: hidden;
      perspective: 600px;
    }

    .upload-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 2rem;
      border: 2px dashed rgba(255, 255, 255, 0.3);
      border-radius: 1rem;
      background: rgba(255, 255, 255, 0.05);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .upload-area:hover {
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.1);
    }

    .upload-area.hidden {
      display: none;
    }

    .upload-icon {
      font-size: 3rem;
      opacity: 0.7;
    }

    .upload-text {
      font-size: 1.1rem;
      opacity: 0.8;
    }

    .experimental-badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      background: linear-gradient(135deg, rgba(128, 0, 255, 0.3), rgba(0, 200, 255, 0.3));
      border-radius: 0.25rem;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #file-input {
      display: none;
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 15, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .loading-overlay.visible {
      opacity: 1;
      pointer-events: all;
    }

    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: rgba(128, 100, 255, 0.8);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      margin-top: 1.5rem;
      font-size: 1rem;
      opacity: 0.8;
    }

    .loading-progress {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      opacity: 0.5;
    }

    .card-container {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    .card-container.visible {
      display: flex;
    }

    .card-wrapper {
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease-out;
      cursor: grab;
    }

    .card-wrapper:active {
      cursor: grabbing;
    }

    .canvas-wrapper {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      transform-style: preserve-3d;
      box-shadow: 
        0 25px 50px rgba(0, 0, 0, 0.5),
        0 0 30px rgba(100, 200, 255, 0.2),
        inset 0 0 60px rgba(255, 255, 255, 0.05);
    }

    #three-canvas {
      display: block;
    }

    /* Rainbow shimmer effect */
    .shimmer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.3;
      background: linear-gradient(
        calc(var(--angle, 45deg) + 90deg),
        transparent 0%,
        rgba(255, 255, 255, 0.4) 50%,
        transparent 100%
      );
      background-size: 200% 200%;
      background-position: var(--shimmer-x, 0%) var(--shimmer-y, 0%);
      border-radius: 12px;
    }

    /* Specular highlight */
    .specular {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(
        ellipse 40% 30% at var(--spec-x, 50%) var(--spec-y, 30%),
        rgba(255, 255, 255, 0.3) 0%,
        transparent 100%
      );
      opacity: 0.5;
      border-radius: 12px;
    }

    /* Card edge glow */
    .edge-glow {
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 14px;
      pointer-events: none;
      background: linear-gradient(
        calc(var(--angle, 45deg)),
        rgba(255, 100, 200, 0.5),
        rgba(100, 200, 255, 0.5),
        rgba(200, 255, 100, 0.5),
        rgba(255, 100, 200, 0.5)
      );
      background-size: 300% 300%;
      background-position: var(--bg-pos-x, 50%) var(--bg-pos-y, 50%);
      z-index: -1;
      filter: blur(4px);
      opacity: 0.6;
    }



    .controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
      text-decoration: none;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-back {
      background: rgba(255, 255, 255, 0.05);
      font-size: 0.9rem;
    }

    .instructions {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.85rem;
      opacity: 0.5;
      text-align: center;
      pointer-events: none;
    }

    .error-message {
      background: rgba(255, 50, 50, 0.2);
      border: 1px solid rgba(255, 50, 50, 0.4);
      padding: 1rem 1.5rem;
      border-radius: 0.5rem;
      max-width: 400px;
      text-align: center;
    }

    @media (max-width: 480px) {
      .btn {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="upload-area" id="upload-area">
    <div class="upload-icon">üì∏</div>
    <div class="upload-text">Tap to choose an image</div>
    <div class="upload-text" style="font-size: 0.85rem; opacity: 0.6;">PNG, JPG, JPEG, or WebP</div>
    <div class="experimental-badge">üß™ Experimental Depth Map</div>
  </div>
  <input type="file" id="file-input" accept="image/png,image/jpeg,image/jpg,image/webp">

  <div class="loading-overlay" id="loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loading-text">Loading depth model...</div>
    <div class="loading-progress" id="loading-progress"></div>
  </div>

  <div class="card-container" id="card-container">
    <div class="card-wrapper" id="card-wrapper">
      <div class="edge-glow"></div>
      <div class="canvas-wrapper" id="canvas-wrapper">
        <canvas id="three-canvas"></canvas>
        <div class="shimmer"></div>
        <div class="specular"></div>
      </div>
    </div>
    
    <div class="controls">
      <button class="btn" id="change-btn">Change Image</button>
      <button class="btn" id="reset-btn">Reset Tilt</button>
      <a href="hologram.html" class="btn btn-back">‚Üê Standard Mode</a>
    </div>
  </div>

  <div class="instructions" id="instructions">Move your finger or mouse to tilt the card</div>

  <script type="module">
    import * as THREE from './assets/vendor/three/three.module.js';
    import { pipeline, env } from './assets/vendor/transformers/transformers.min.js';

    // Configure transformers.js to use local models cache
    env.allowLocalModels = false;
    env.useBrowserCache = true;

    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const cardContainer = document.getElementById('card-container');
    const canvas = document.getElementById('three-canvas');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');
    const loadingProgress = document.getElementById('loading-progress');
    const changeBtn = document.getElementById('change-btn');
    const resetBtn = document.getElementById('reset-btn');
    const instructions = document.getElementById('instructions');
    const cardWrapper = document.getElementById('card-wrapper');

    let depthEstimator = null;
    let scene, camera, renderer, mesh, logoMesh, cardGroup;
    let isInteracting = false;
    let currentTiltX = 0, currentTiltY = 0;
    let targetTiltX = 0, targetTiltY = 0;
    let lastInteractionTime = Date.now();
    let idleTime = 0;
    let _lastFrameTime = null;
    // FPS limiter: cap to maxFPS
    const maxFPS = 25;
    const minFrameTimeMs = 1000 / maxFPS; // ms per frame
    let _lastRenderTime = 0;

    // Device orientation smoothing / hysteresis state
    let orientationSmoothedX = 0, orientationSmoothedY = 0;
    let orientationActive = false;
    let orientationLastUpdateTime = 0;
    const orientationSmoothingAlpha = 0.22; // lower = smoother, higher = more responsive
    const orientationThreshold = 0.6; // degrees; ignore smaller changes
    const orientationActiveTimeout = 3000; // ms to keep orientation considered active
    // Immediate nudge settings (apply partial blend toward smoothed orientation)
    const immediateBlend = 0.25; // how strongly to nudge before full activation
    const immediateNudgeThreshold = 0.4; // degrees difference from current target to nudge
    // Confirmation / inactivity timings
    let orientationCandidateSince = 0;
    let orientationInactiveSince = 0;
    let prevOrientationSmoothedX = 0, prevOrientationSmoothedY = 0;
    const orientationConfirmTime = 220; // ms of sustained movement before activating
    const orientationInactiveTime = 900; // ms of sustained quiet before deactivating

    const canvasWrapper = document.getElementById('canvas-wrapper');
    let canvasWidth, canvasHeight;

    // Three.js setup
    function initThree(width, height) {
      const aspect = width / height;
      canvasWidth = Math.min(window.innerWidth * 0.85, 400);
      canvasHeight = canvasWidth / aspect;

      scene = new THREE.Scene();
      
      // Create a group to hold both meshes - rotating the group keeps their relative positions
      cardGroup = new THREE.Group();
      scene.add(cardGroup);
      
      // Use orthographic-like perspective for card feel
      camera = new THREE.PerspectiveCamera(30, aspect, 0.1, 100);
      // Position camera so scaled mesh fills view (accounting for 92% scale)
      camera.position.z = 1.75;

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(canvasWidth, canvasHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x0a0a12, 1);
    }

    // Create displaced mesh from image and depth map
    function createHologramMesh(imageTexture, depthData, depthWidth, depthHeight, imageAspect) {
      console.log(`Creating mesh: depthWidth=${depthWidth}, depthHeight=${depthHeight}, depthData.length=${depthData.length}, aspect=${imageAspect}`);
      
      // Scale mesh UP so edges are always clipped by card wrapper
      // This ensures users never see the mesh boundaries - it looks infinite
      const meshScale = 1.26;
      
      // Subdivided plane geometry (higher segments -> smaller triangles -> smoother surface)
      // Create a 3x tiled plane so we can mirror topology around the central tile
      const baseSegments = 512;
      const tiles = 3;
      const segmentsX = baseSegments * tiles;
      const segmentsY = baseSegments * tiles;
      const geometry = new THREE.PlaneGeometry(imageAspect * meshScale * tiles, meshScale * tiles, segmentsX, segmentsY);

      // Modify UVs so they span across -1..2 (three tiles) allowing mirrored repeat sampling
      const uvs = geometry.attributes.uv;
      for (let i = 0; i < uvs.count; i++) {
        const u0 = uvs.getX(i);
        const v0 = uvs.getY(i);
        // Expand range to cover three tiles and shift so center tile maps to 0..1
        const uGlobal = u0 * tiles - 1.0; // maps 0..1 to -1..2
        const vGlobal = v0 * tiles - 1.0;
        uvs.setXY(i, uGlobal, vGlobal);
      }
      uvs.needsUpdate = true;
      
      // Displace vertices by depth
      const positions = geometry.attributes.position;
      // uvs already defined above and represent global UVs spanning -1..2
      const uvsAttr = geometry.attributes.uv;

      // Compute normalized depth range (0..1) so we scale displacement based on actual depth contrast
      let normMin = 1.0, normMax = 0.0;
      for (let i = 0; i < depthData.length; i++) {
        const v = depthData[i];
        if (!isNaN(v) && isFinite(v)) {
          normMin = Math.min(normMin, v);
          normMax = Math.max(normMax, v);
        }
      }
      if (!isFinite(normMin)) normMin = 0.0;
      if (!isFinite(normMax)) normMax = 1.0;
      const normRange = Math.max(0.0, normMax - normMin);

      // Determine physical mesh size (world units) and take the smallest dimension
      const meshWidth = imageAspect * meshScale;
      const meshHeight = meshScale;
      const smallestDim = Math.min(meshWidth, meshHeight);

      // Choose a base factor for how deep the effect should be relative to the smallest dimension.
      // Multiply by the normalized depth range so maps with little contrast don't produce huge displacement.
      const baseFactor = 0.7; // tunable ‚Äî larger = deeper (doubled per request)
      let displacementScale = smallestDim * baseFactor * normRange;

      // Clamp to reasonable bounds so we always have some depth but never a ridiculous amount
      const minDepthFrac = 0.05; // at least 5% of smallest dimension
      const maxDepthFrac = 0.6;  // at most 60% of smallest dimension
      displacementScale = Math.max(displacementScale, smallestDim * minDepthFrac);
      displacementScale = Math.min(displacementScale, smallestDim * maxDepthFrac);

      // Track sample statistics for debugging
      let sampledDepthMin = 1, sampledDepthMax = 0;
      let validSamples = 0;

      // Helper to map a global UV coordinate to a mirrored local coordinate in [0,1]
      function mirroredLocalCoord(u) {
        // tile index
        let tile = Math.floor(u);
        let local = u - tile;
        // parity (0 = normal, 1 = mirrored)
        const parity = ((tile % 2) + 2) % 2;
        if (parity === 1) local = 1.0 - local;
        // clamp
        if (local < 0) local = 0;
        if (local > 1) local = 1;
        return local;
      }

      for (let i = 0; i < positions.count; i++) {
        const uGlobal = uvsAttr.getX(i);
        const vGlobal = uvsAttr.getY(i);

        // Map to mirrored local UVs in [0,1]
        const uLocal = mirroredLocalCoord(uGlobal);
        const vLocal = mirroredLocalCoord(vGlobal);

        // Sample depth at mirrored UV coordinates with bounds checking
        const px = Math.min(Math.max(Math.floor(uLocal * depthWidth), 0), depthWidth - 1);
        const py = Math.min(Math.max(Math.floor((1 - vLocal) * depthHeight), 0), depthHeight - 1);
        const depthIndex = py * depthWidth + px;

        // Get depth value with fallback
        let depth = depthData[depthIndex];
        if (depth === undefined || isNaN(depth)) {
          depth = 0.5; // neutral depth
        } else {
          sampledDepthMin = Math.min(sampledDepthMin, depth);
          sampledDepthMax = Math.max(sampledDepthMax, depth);
          validSamples++;
        }

        // Displace Z based on depth - scale to visible 3D effect
        // depth 0 = far (negative Z), depth 1 = near (positive Z)
        const displacement = (depth - 0.5) * displacementScale;
        positions.setZ(i, isNaN(displacement) ? 0 : displacement);
      }

      console.log(`Depth sampling: ${validSamples}/${positions.count} valid, sampled range: ${sampledDepthMin.toFixed(3)} to ${sampledDepthMax.toFixed(3)}, displacementScale=${displacementScale.toFixed(4)}`);
      
      // Mark position attribute as needing update
      positions.needsUpdate = true;
      // Apply cliff-tucking: detect large z-differences between adjacent vertices
      // and nudge vertices toward the cliff to reduce stretching artifacts.
      // Parameters:
      // - only apply when edge delta >= 10% of total depth range
      // - strength increases linearly above that threshold
      // - nearer vertex is nudged by s*delta (toward far), far vertex nudged by 2*s*delta (toward near)
      
      // Gather z values and basic stats
      let minZ = Infinity, maxZ = -Infinity;
      const zVals = new Float32Array(positions.count);
      for (let i = 0; i < positions.count; i++) {
        const z = positions.getZ(i);
        zVals[i] = z;
        minZ = Math.min(minZ, z);
        maxZ = Math.max(maxZ, z);
      }

      const depthRange = Math.max(1e-6, maxZ - minZ);
      const cliffThreshold = 0.10 * depthRange; // 10% of total depth
      const sMax = 0.25; // max per-edge normalized strength (keeps adjustments < ~75% of delta)

      const verticesX = segmentsX + 1;
      const verticesY = segmentsY + 1;
      const adjustments = new Float32Array(positions.count);

      // Process horizontal edges (each edge once)
      for (let y = 0; y < verticesY; y++) {
        for (let x = 0; x < verticesX - 1; x++) {
          const a = y * verticesX + x;
          const b = a + 1;
          const za = zVals[a];
          const zb = zVals[b];
          const delta = za - zb;
          const absDelta = Math.abs(delta);
          if (absDelta < cliffThreshold) continue;
          const cliffPercent = absDelta / depthRange;
          const norm = Math.max(0, (cliffPercent - 0.10) / 0.90);
          const s = norm * sMax;
          if (delta > 0) {
            // a is near, b is far
            adjustments[a] += -s * delta; // bring near slightly toward far
            adjustments[b] += s * delta * 2; // bring far more toward near
          } else {
            // b is near, a is far
            adjustments[a] += s * (-delta) * 2;
            adjustments[b] += -s * (-delta);
          }
        }
      }

      // Process vertical edges (each edge once)
      for (let y = 0; y < verticesY - 1; y++) {
        for (let x = 0; x < verticesX; x++) {
          const a = y * verticesX + x;
          const b = a + verticesX;
          const za = zVals[a];
          const zb = zVals[b];
          const delta = za - zb;
          const absDelta = Math.abs(delta);
          if (absDelta < cliffThreshold) continue;
          const cliffPercent = absDelta / depthRange;
          const norm = Math.max(0, (cliffPercent - 0.10) / 0.90);
          const s = norm * sMax;
          if (delta > 0) {
            // a is near, b is far
            adjustments[a] += -s * delta;
            adjustments[b] += s * delta * 2;
          } else {
            adjustments[a] += s * (-delta) * 2;
            adjustments[b] += -s * (-delta);
          }
        }
      }

      // Apply accumulated adjustments
      let appliedMaxAdj = 0;
      for (let i = 0; i < positions.count; i++) {
        if (adjustments[i] !== 0) {
          const newZ = zVals[i] + adjustments[i];
          appliedMaxAdj = Math.max(appliedMaxAdj, Math.abs(adjustments[i]));
          positions.setZ(i, newZ);
        }
      }

      positions.needsUpdate = true;
      geometry.computeVertexNormals();
      console.log(`Mesh Z displacement: min=${minZ.toFixed(3)}, max=${maxZ.toFixed(3)}, range=${(maxZ-minZ).toFixed(3)}, appliedMaxAdj=${appliedMaxAdj.toFixed(4)}`);
      
      // Custom shader material for holographic effect
      // Mimics the CSS approach from hologram.html: desaturated base + color blend overlay
      const material = new THREE.ShaderMaterial({
        uniforms: {
          map: { value: imageTexture },
          tiltX: { value: 0 },
          tiltY: { value: 0 },
          time: { value: 0 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          void main() {
            vUv = uv;
            vNormal = normalMatrix * normal;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D map;
          uniform float tiltX;
          uniform float tiltY;
          uniform float time;
          
          varying vec2 vUv;
          varying vec3 vNormal;
          varying vec3 vPosition;
          
          // Color blend mode (like CSS mix-blend-mode: color)
          vec3 blendColor(vec3 base, vec3 blend) {
            // Get luminance from base, hue/sat from blend
            float baseLum = dot(base, vec3(0.299, 0.587, 0.114));
            float blendLum = dot(blend, vec3(0.299, 0.587, 0.114));
            float lumDiff = baseLum - blendLum;
            vec3 result = blend + lumDiff;
            // Clamp to valid range
            float minC = min(min(result.r, result.g), result.b);
            float maxC = max(max(result.r, result.g), result.b);
            if (minC < 0.0) result = baseLum + ((result - baseLum) * baseLum / (baseLum - minC));
            if (maxC > 1.0) result = baseLum + ((result - baseLum) * (1.0 - baseLum) / (maxC - baseLum));
            return result;
          }
          
          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }
          
          void main() {
            // Sample texture
            vec3 texColor = texture2D(map, vUv).rgb;
            
            // Desaturate base image (like CSS grayscale(0.7) contrast(0.8) brightness(0.95))
            float lum = dot(texColor, vec3(0.299, 0.587, 0.114));
            vec3 desaturated = mix(texColor, vec3(lum), 0.7);
            desaturated = (desaturated - 0.5) * 0.85 + 0.5;
            desaturated *= 0.95;
            
            // Smooth view angle calculation using dot products (no discontinuities)
            // Simulate light reflecting off diffraction grating - hue depends on angle
            vec3 viewDir = normalize(vec3(tiltX * 0.02, tiltY * 0.02, 1.0));
            
            // Use smooth functions of tilt for hue - no atan discontinuities
            // Map tilt to 0-1 range smoothly using sigmoid-like curves
            float tiltMagnitude = length(vec2(tiltX, tiltY)) / 35.0; // normalize to ~0-1
            // Center tiltPhase at 0 when no tilt - reduced divisor for more color range
            float tiltPhase = (tiltX + tiltY) / 50.0; // more sensitive to small tilts
            
            // Depth affects the viewing angle to this point
            // Points closer to camera (higher z) are viewed more directly
            float depthAngleShift = vPosition.z * 0.5;
            
            // Smooth hue based on view geometry - GREEN (0.33) at center when no tilt
            // Tilt shifts through cyan/blue (positive) or yellow/red (negative)
            float surfacePhase = (vUv.x - 0.5) * 0.2 + (vUv.y - 0.5) * 0.15;
            float hue = 0.33 + tiltPhase * 1.0 + depthAngleShift + surfacePhase;
            hue = fract(hue); // keep in 0-1
            
            // Saturation varies subtly with tilt magnitude
            float sat = 0.6 + tiltMagnitude * 0.2;
            
            vec3 tintColor = hsv2rgb(vec3(hue, sat, 0.65));
            
            // Apply color blend (preserves luminance, adds hue)
            vec3 holoColor = blendColor(desaturated, tintColor);
            
            // Subtle foil shimmer - smooth variation
            float shimmer = sin(vUv.x * 8.0 + vUv.y * 6.0 + tiltPhase * 4.0 + time * 0.5) * 0.5 + 0.5;
            vec3 foilColor = hsv2rgb(vec3(fract(hue + shimmer * 0.1), 0.5, 0.25));
            holoColor += foilColor * 0.12;
            
            // Fresnel edge highlight (reduced - card overlay handles main specular)
            float fresnel = pow(1.0 - max(dot(vNormal, viewDir), 0.0), 3.0);
            vec3 fresnelColor = hsv2rgb(vec3(fract(hue + 0.2), 0.6, 1.0));
            holoColor += fresnelColor * fresnel * 0.04;
            
            // Minimal specular - just subtle depth highlights, card overlay has main specular
            vec3 lightDir = normalize(vec3(-tiltX * 0.3, -tiltY * 0.3, 1.0));
            float spec = pow(max(dot(reflect(-lightDir, vNormal), viewDir), 0.0), 64.0);
            holoColor += vec3(1.0) * spec * 0.05;
            
            gl_FragColor = vec4(holoColor, 1.0);
          }
        `,
        transparent: false
      });
      
      mesh = new THREE.Mesh(geometry, material);
      cardGroup.add(mesh);
    }

    // Create logo pattern mesh that floats in front of the image mesh
    function createLogoMesh(imageAspect) {
      const meshScale = 1.26; // Match the image mesh scale
      // Logo z must be >= max depth of image mesh
      // Image mesh depth: (depth - 0.5) * 0.25, so z ranges -0.125 to +0.125
      // Place logo just beyond the max: 0.15 (local z, rotates with mesh)
      const logoZ = 0.15;
      
      // Create plane geometry for logo (same size as image mesh)
      const geometry = new THREE.PlaneGeometry(imageAspect * meshScale, meshScale);
      
      // Create logo pattern texture using canvas
      const patternSize = 320; // Higher res for crisp logos
      const patternCanvas = document.createElement('canvas');
      patternCanvas.width = patternSize * 2;
      patternCanvas.height = patternSize * 2;
      const ctx = patternCanvas.getContext('2d');
      
      // Tile the pattern - spacing doubled for less busy look
      const tileSize = 160; // Spacing between tiles
      const shapeSize = 80;  // Keep shape size same as before
      for (let y = 0; y < patternCanvas.height; y += tileSize) {
        for (let x = 0; x < patternCanvas.width; x += tileSize) {
          drawLogoTile(ctx, x, y, shapeSize, tileSize);
        }
      }
      
      const logoTexture = new THREE.CanvasTexture(patternCanvas);
      logoTexture.wrapS = THREE.RepeatWrapping;
      logoTexture.wrapT = THREE.RepeatWrapping;
      logoTexture.repeat.set(imageAspect * 2.5, 2.5); // Tile density
      
      // Shader material for holographic logo effect - uses same color formula as image
      const logoMaterial = new THREE.ShaderMaterial({
        uniforms: {
          map: { value: logoTexture },
          tiltX: { value: 0 },
          tiltY: { value: 0 },
          time: { value: 0 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPosition;
          void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D map;
          uniform float tiltX;
          uniform float tiltY;
          uniform float time;
          varying vec2 vUv;
          varying vec3 vPosition;
          
          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }
          
          // Color blend mode (like CSS mix-blend-mode: color)
          vec3 blendColor(vec3 base, vec3 blend) {
            float baseLum = dot(base, vec3(0.299, 0.587, 0.114));
            float blendLum = dot(blend, vec3(0.299, 0.587, 0.114));
            float lumDiff = baseLum - blendLum;
            vec3 result = blend + lumDiff;
            float minC = min(min(result.r, result.g), result.b);
            float maxC = max(max(result.r, result.g), result.b);
            if (minC < 0.0) result = baseLum + ((result - baseLum) * baseLum / (baseLum - minC));
            if (maxC > 1.0) result = baseLum + ((result - baseLum) * (1.0 - baseLum) / (maxC - baseLum));
            return result;
          }
          
          void main() {
            vec4 texColor = texture2D(map, vUv);
            
            // Only render where there's logo content (alpha > 0)
            if (texColor.a < 0.1) discard;
            
            // EXACT SAME COLOR FORMULA AS IMAGE MESH
            // Smooth view angle calculation
            vec3 viewDir = normalize(vec3(tiltX * 0.02, tiltY * 0.02, 1.0));
            
            float tiltMagnitude = length(vec2(tiltX, tiltY)) / 35.0;
            float tiltPhase = (tiltX + tiltY) / 50.0; // more sensitive to match image mesh
            
            // Logo is at fixed depth "above" the image - use constant depth offset
            // This represents the logo being on a separate layer in front
            float depthAngleShift = 0.15 * 0.5; // Fixed depth for logo layer (matches logoZ)
            
            // Match image mesh hue formula - GREEN (0.33) at center
            float surfacePhase = (vUv.x - 0.5) * 0.2 + (vUv.y - 0.5) * 0.15;
            float hue = 0.33 + tiltPhase * 1.0 + depthAngleShift + surfacePhase;
            hue = fract(hue);
            
            float sat = 0.6 + tiltMagnitude * 0.2;
            vec3 tintColor = hsv2rgb(vec3(hue, sat, 0.65));
            
            // Desaturate logo base
            float lum = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
            vec3 desaturated = mix(texColor.rgb, vec3(lum), 0.5);
            
            // Apply color blend
            vec3 holoColor = blendColor(desaturated, tintColor);
            
            // Subtle foil shimmer
            float shimmer = sin(vUv.x * 8.0 + vUv.y * 6.0 + tiltPhase * 4.0 + time * 0.5) * 0.5 + 0.5;
            vec3 foilColor = hsv2rgb(vec3(fract(hue + shimmer * 0.1), 0.5, 0.25));
            holoColor += foilColor * 0.12;
            
            // Fresnel (flat plane normal is 0,0,1)
            vec3 normal = vec3(0.0, 0.0, 1.0);
            float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);
            vec3 fresnelColor = hsv2rgb(vec3(fract(hue + 0.2), 0.6, 1.0));
            holoColor += fresnelColor * fresnel * 0.15;
            
            // Specular highlight
            vec3 lightDir = normalize(vec3(-tiltX * 0.3, -tiltY * 0.3, 1.0));
            float spec = pow(max(dot(reflect(-lightDir, normal), viewDir), 0.0), 64.0);
            holoColor += vec3(1.0) * spec * 0.3;
            
            gl_FragColor = vec4(holoColor, texColor.a * 0.75);
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.NormalBlending
      });
      
      logoMesh = new THREE.Mesh(geometry, logoMaterial);
      logoMesh.position.z = logoZ;
      cardGroup.add(logoMesh);
    }
    
    // Draw a single logo tile
    function drawLogoTile(ctx, x, y, size, tileSize) {
      ctx.save();
      ctx.translate(x, y);
      
      // Metallic grey gradient
      const gradient = ctx.createLinearGradient(0, 0, size, size);
      gradient.addColorStop(0, '#6a6a6a');
      gradient.addColorStop(0.25, '#8a8a8a');
      gradient.addColorStop(0.5, '#999999');
      gradient.addColorStop(0.75, '#7a7a7a');
      gradient.addColorStop(1, '#666666');
      
      // Rainbow edge gradient
      const edgeGradient = ctx.createLinearGradient(0, 0, size, size);
      edgeGradient.addColorStop(0, '#b36699');
      edgeGradient.addColorStop(0.25, '#66b399');
      edgeGradient.addColorStop(0.5, '#6666b3');
      edgeGradient.addColorStop(0.75, '#b39966');
      edgeGradient.addColorStop(1, '#b36699');
      
      // Star at corner of tile
      ctx.save();
      ctx.translate(size * 0.25, size * 0.25);
      ctx.scale(0.3, 0.3);
      ctx.beginPath();
      // 5-point star
      for (let i = 0; i < 5; i++) {
        const outerAngle = (i * 72 - 90) * Math.PI / 180;
        const innerAngle = ((i * 72) + 36 - 90) * Math.PI / 180;
        const outerX = 40 + Math.cos(outerAngle) * 35;
        const outerY = 40 + Math.sin(outerAngle) * 35;
        const innerX = 40 + Math.cos(innerAngle) * 15;
        const innerY = 40 + Math.sin(innerAngle) * 15;
        if (i === 0) ctx.moveTo(outerX, outerY);
        else ctx.lineTo(outerX, outerY);
        ctx.lineTo(innerX, innerY);
      }
      ctx.closePath();
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = edgeGradient;
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();
      
      // Circle with checkmark at center between stars
      // Star is at size*0.25, next star at tileSize + size*0.25
      // Midpoint: tileSize/2 + size*0.25
      const circleOffset = tileSize * 0.5 + size * 0.25;
      ctx.save();
      ctx.translate(circleOffset, circleOffset);
      ctx.scale(0.22, 0.22);
      ctx.beginPath();
      ctx.arc(50, 50, 30, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.strokeStyle = edgeGradient;
      ctx.lineWidth = 4;
      ctx.stroke();
      // Checkmark
      ctx.beginPath();
      ctx.moveTo(35, 50);
      ctx.lineTo(45, 60);
      ctx.lineTo(65, 40);
      ctx.strokeStyle = edgeGradient;
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
      ctx.restore();
      
      ctx.restore();
    }

    // File upload handling
    uploadArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileSelect);
    changeBtn.addEventListener('click', () => fileInput.click());
    resetBtn.addEventListener('click', resetTilt);

    // Drag and drop
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.8)';
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.style.borderColor = 'rgba(255, 255, 255, 0.3)';
      const file = e.dataTransfer.files[0];
      if (file && file.type.match(/image\/(png|jpeg|jpg|webp)/)) {
        processImage(file);
      }
    });

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (file) {
        processImage(file);
      }
    }

    async function processImage(file) {
      loadingOverlay.classList.add('visible');
      loadingText.textContent = 'Loading image...';
      loadingProgress.textContent = '';

      try {
        // Load image
        const imageUrl = URL.createObjectURL(file);
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = imageUrl;
        });

        // Resize for processing (max 512px for performance)
        const maxSize = 512;
        let width = img.width;
        let height = img.height;
        if (width > maxSize || height > maxSize) {
          if (width > height) {
            height = Math.round(height * maxSize / width);
            width = maxSize;
          } else {
            width = Math.round(width * maxSize / height);
            height = maxSize;
          }
        }

        // Create canvas for resized image
        const imgCanvas = document.createElement('canvas');
        imgCanvas.width = width;
        imgCanvas.height = height;
        const ctx = imgCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);

        // Load depth estimator if not already loaded
        if (!depthEstimator) {
          loadingText.textContent = 'Loading depth model...';
          loadingProgress.textContent = 'This may take a minute on first load';
          
          depthEstimator = await pipeline('depth-estimation', 'Xenova/depth-anything-small-hf', {
            progress_callback: (progress) => {
              if (progress.status === 'downloading') {
                const pct = progress.progress ? Math.round(progress.progress) : 0;
                loadingProgress.textContent = `Downloading: ${pct}%`;
              } else if (progress.status === 'loading') {
                loadingProgress.textContent = 'Initializing model...';
              }
            }
          });
        }

        // Estimate depth
        loadingText.textContent = 'Estimating depth...';
        loadingProgress.textContent = 'Analyzing image structure';
        
        const depthResult = await depthEstimator(imgCanvas.toDataURL());
        
        // Log full depth result structure for debugging
        console.log('Depth result structure:', {
          predicted_depth: {
            dims: depthResult.predicted_depth.dims,
            type: depthResult.predicted_depth.type,
            dataLength: depthResult.predicted_depth.data?.length
          }
        });
        
        const depthData = depthResult.predicted_depth.data;

        // Normalize depth data to 0-1, skipping NaN values
        let minDepth = Infinity, maxDepth = -Infinity;
        for (let i = 0; i < depthData.length; i++) {
          const val = depthData[i];
          if (!isNaN(val) && isFinite(val)) {
            minDepth = Math.min(minDepth, val);
            maxDepth = Math.max(maxDepth, val);
          }
        }
        // Fallback if all values are NaN
        if (!isFinite(minDepth)) minDepth = 0;
        if (!isFinite(maxDepth)) maxDepth = 1;
        const depthRange = (maxDepth - minDepth) || 1;
        
        console.log(`Depth stats: min=${minDepth.toFixed(3)}, max=${maxDepth.toFixed(3)}, range=${depthRange.toFixed(3)}`);
        
        const normalizedDepth = new Float32Array(depthData.length);
        for (let i = 0; i < depthData.length; i++) {
          const val = depthData[i];
          if (!isNaN(val) && isFinite(val)) {
            normalizedDepth[i] = (val - minDepth) / depthRange;
          } else {
            normalizedDepth[i] = 0.5; // neutral depth for invalid values
          }
        }

        // Get depth map dimensions from tensor dims array [height, width]
        const depthDims = depthResult.predicted_depth.dims;
        const depthHeight = depthDims[0];
        const depthWidth = depthDims[1];
        console.log(`Depth map: ${depthWidth}x${depthHeight} (tensor dims: ${depthDims}), Image: ${width}x${height}`);
        
        // Log normalized depth stats
        let normMin = 1, normMax = 0;
        for (let i = 0; i < normalizedDepth.length; i++) {
          normMin = Math.min(normMin, normalizedDepth[i]);
          normMax = Math.max(normMax, normalizedDepth[i]);
        }
        console.log(`Normalized depth: min=${normMin.toFixed(3)}, max=${normMax.toFixed(3)}`);

        // Initialize Three.js
        loadingText.textContent = 'Creating 3D hologram...';
        loadingProgress.textContent = '';
        
        const imageAspect = width / height;
        initThree(width, height);
        
        // Create texture from image
        const texture = new THREE.Texture(imgCanvas);
        texture.needsUpdate = true;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        
        // Create the displaced mesh
        createHologramMesh(texture, normalizedDepth, depthWidth, depthHeight, imageAspect);
        
        // Create logo pattern mesh in front
        createLogoMesh(imageAspect);

        // Show the result
        uploadArea.classList.add('hidden');
        loadingOverlay.classList.remove('visible');
        cardContainer.classList.add('visible');
        instructions.style.display = 'block';
        
        // Start animation
        resetTilt();
        requestAnimationFrame(animate);

        // Cleanup
        URL.revokeObjectURL(imageUrl);

      } catch (error) {
        console.error('Error processing image:', error);
        loadingOverlay.classList.remove('visible');
        
        // Show error
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.innerHTML = `
          <p><strong>Error:</strong> ${error.message || 'Failed to process image'}</p>
          <p style="margin-top: 0.5rem; font-size: 0.85rem; opacity: 0.7;">
            Try <a href="hologram.html" style="color: #8af;">standard mode</a> instead.
          </p>
        `;
        document.body.appendChild(errorDiv);
      }
    }

    function resetTilt() {
      targetTiltX = 0;
      targetTiltY = 0;
    }

    function animate(timestamp) {
      if (!mesh) {
        requestAnimationFrame(animate);
        return;
      }

      // FPS limiting: skip render/update if we're running faster than maxFPS
      if (_lastRenderTime && (timestamp - _lastRenderTime) < minFrameTimeMs) {
        requestAnimationFrame(animate);
        return;
      }

      if (!_lastFrameTime) _lastFrameTime = timestamp;
      const dt = Math.min(0.05, (timestamp - _lastFrameTime) / 1000);
      _lastFrameTime = timestamp;
      _lastRenderTime = timestamp;

      // Smooth lerp towards target
      const lerpSpeed = 10;
      const lerpFactor = 1 - Math.exp(-lerpSpeed * dt);
      currentTiltX += (targetTiltX - currentTiltX) * lerpFactor;
      currentTiltY += (targetTiltY - currentTiltY) * lerpFactor;

      // Clamp tilt
      currentTiltX = Math.max(-25, Math.min(25, currentTiltX));
      currentTiltY = Math.max(-25, Math.min(25, currentTiltY));

      // Rotate the entire card group - both meshes rotate together as one unit
      // This preserves their relative z-positions during rotation
      cardGroup.rotation.y = currentTiltX * Math.PI / 180;
      cardGroup.rotation.x = currentTiltY * Math.PI / 180;

      // Apply 3D transform to card wrapper with perspective distortion
      // skewX/skewY create the widening near edge / narrowing far edge effect
      const skewX = currentTiltY * 0.08;
      const skewY = -currentTiltX * 0.08;
      const scaleX = 1 + Math.abs(currentTiltX) * 0.003;
      const scaleY = 1 + Math.abs(currentTiltY) * 0.003;
      
      cardWrapper.style.transform = `
        perspective(800px)
        rotateY(${currentTiltX}deg)
        rotateX(${-currentTiltY}deg)
        skew(${skewX}deg, ${skewY}deg)
        scale(${scaleX}, ${scaleY})
      `;
      
      // Update CSS custom properties for sheen effects
      const angle = Math.atan2(currentTiltY, currentTiltX) * 180 / Math.PI;
      const bgPosX = 50 + currentTiltX * 2;
      const bgPosY = 50 + currentTiltY * 2;
      const specX = 50 - currentTiltX * 1.5;
      const specY = 30 - currentTiltY * 1.5;
      const shimmerX = 50 + currentTiltX * 3;
      const shimmerY = 50 + currentTiltY * 3;
      
      canvasWrapper.style.setProperty('--angle', `${angle}deg`);
      canvasWrapper.style.setProperty('--bg-pos-x', `${bgPosX}%`);
      canvasWrapper.style.setProperty('--bg-pos-y', `${bgPosY}%`);
      canvasWrapper.style.setProperty('--spec-x', `${specX}%`);
      canvasWrapper.style.setProperty('--spec-y', `${specY}%`);
      canvasWrapper.style.setProperty('--shimmer-x', `${shimmerX}%`);
      canvasWrapper.style.setProperty('--shimmer-y', `${shimmerY}%`);

      // Update shader uniforms for image mesh
      mesh.material.uniforms.tiltX.value = currentTiltX;
      mesh.material.uniforms.tiltY.value = currentTiltY;
      mesh.material.uniforms.time.value = timestamp * 0.001;

      // Update shader uniforms for logo mesh
      if (logoMesh) {
        logoMesh.material.uniforms.tiltX.value = currentTiltX;
        logoMesh.material.uniforms.tiltY.value = currentTiltY;
        logoMesh.material.uniforms.time.value = timestamp * 0.001;
      }

      // Idle animation
      // Decay orientation activity flag if no recent orientation updates
      if (orientationActive && (Date.now() - orientationLastUpdateTime) > orientationActiveTimeout) {
        orientationActive = false;
      }

      // Idle animation (only when not interacting and orientation is not actively driving the target)
      if (cardContainer.classList.contains('visible') && !isInteracting && !orientationActive) {
        const timeSinceInteraction = Date.now() - lastInteractionTime;
        if (timeSinceInteraction > 3000) {
          idleTime += dt * 1.0;
          targetTiltX = Math.sin(idleTime) * 8;
          targetTiltY = Math.cos(idleTime * 0.7) * 6;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Mouse interaction
    document.addEventListener('mousemove', (e) => {
      if (!cardContainer.classList.contains('visible')) return;
      lastInteractionTime = Date.now();
      
      const rect = canvas.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      
      const normalizedX = deltaX / (window.innerWidth / 2);
      const normalizedY = deltaY / (window.innerHeight / 2);
      
      targetTiltX = normalizedX * 20;
      targetTiltY = normalizedY * 20;
    });

    // Touch interaction
    let touchStartX = 0, touchStartY = 0;
    let touchTiltX = 0, touchTiltY = 0;

    cardContainer.addEventListener('touchstart', (e) => {
      isInteracting = true;
      lastInteractionTime = Date.now();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchTiltX = currentTiltX;
      touchTiltY = currentTiltY;
    }, { passive: true });

    document.addEventListener('touchmove', (e) => {
      if (!isInteracting || !cardContainer.classList.contains('visible')) return;
      lastInteractionTime = Date.now();
      
      const touch = e.touches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      
      targetTiltX = touchTiltX + deltaX * 0.15;
      targetTiltY = touchTiltY + deltaY * 0.15;
    }, { passive: true });

    document.addEventListener('touchend', () => {
      isInteracting = false;
    });

    cardContainer.addEventListener('contextmenu', (e) => e.preventDefault());

    // Device orientation with smoothing + hysteresis to avoid jitter
    if (window.DeviceOrientationEvent) {
      let hasOrientationPermission = false;

      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        document.body.addEventListener('click', async () => {
          if (hasOrientationPermission) return;
          try {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission === 'granted') {
              hasOrientationPermission = true;
              enableDeviceOrientation();
            }
          } catch (err) {
            console.log('Device orientation permission denied');
          }
        }, { once: true });
      } else {
        enableDeviceOrientation();
      }

      function enableDeviceOrientation() {
        window.addEventListener('deviceorientation', (e) => {
          if (!cardContainer.classList.contains('visible') || isInteracting) return;

          const beta = e.beta || 0;
          const gamma = e.gamma || 0;

          // Reduce raw sensitivity slightly and compute desired values
          const desiredX = gamma * 0.35;
          const desiredY = (beta - 45) * 0.35;

          // Low-pass filter the sensor input
          prevOrientationSmoothedX = orientationSmoothedX;
          prevOrientationSmoothedY = orientationSmoothedY;
          orientationSmoothedX = orientationSmoothedX + (desiredX - orientationSmoothedX) * orientationSmoothingAlpha;
          orientationSmoothedY = orientationSmoothedY + (desiredY - orientationSmoothedY) * orientationSmoothingAlpha;

          // How much the smoothed orientation changed this frame
          const deltaOrient = Math.max(Math.abs(orientationSmoothedX - prevOrientationSmoothedX), Math.abs(orientationSmoothedY - prevOrientationSmoothedY));

          const now = Date.now();

          // If orientation mode is already active, continuously drive the target
          if (orientationActive) {
            targetTiltX = orientationSmoothedX;
            targetTiltY = orientationSmoothedY;
            orientationLastUpdateTime = now;
            orientationInactiveSince = 0;
            orientationCandidateSince = 0;
            return;
          }

          // Compute difference between smoothed orientation and current target
          const diffToTarget = Math.max(Math.abs(orientationSmoothedX - targetTiltX), Math.abs(orientationSmoothedY - targetTiltY));

          // If the smoothed orientation differs from the current target by a meaningful amount,
          // apply a small immediate nudge so the user sees responsiveness even before full activation.
          if (diffToTarget > immediateNudgeThreshold) {
            targetTiltX = targetTiltX * (1 - immediateBlend) + orientationSmoothedX * immediateBlend;
            targetTiltY = targetTiltY * (1 - immediateBlend) + orientationSmoothedY * immediateBlend;
            lastInteractionTime = now; // treat as activity to suppress idle
          }

          // If movement exceeds threshold, start/continue candidate timer (for full activation)
          if (deltaOrient > orientationThreshold) {
            if (!orientationCandidateSince) orientationCandidateSince = now;
            // If movement is sustained for confirm time, activate orientation-driven mode
            if ((now - orientationCandidateSince) >= orientationConfirmTime) {
              orientationActive = true;
              orientationInactiveSince = 0;
              // Immediately apply smoothed orientation as target
              targetTiltX = orientationSmoothedX;
              targetTiltY = orientationSmoothedY;
              orientationLastUpdateTime = now;
              lastInteractionTime = now; // pause idle
            }
          } else {
            // Movement below threshold: reset candidate and no activation
            orientationCandidateSince = 0;
          }
        });
      }
    }
  </script>

  <script src="parental.js" defer></script>
  <script src="assets/js/pwa.js" defer></script>
</body>
</html>
