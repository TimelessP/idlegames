<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#e6dfcf" />
  <title>Space Trader</title>
  <meta name="description" content="Showcase of mechanical/retro console components built with semantic HTML and CSS only." />
  <link rel="icon" href="favicon.ico" />
  <style>
    :root {
      --panel-bg: #e6dfcf;
      --panel-rim: #8f897a;
      --panel-shadow: rgba(0,0,0,0.35);
      --panel-pad: 20px;   /* base padding inside panel */
      --panel-pad-safe: 36px; /* doubled so content never touches rivets */

      --keycap: #2b2b2b;
      --keycap-2: #1f1f1f;
      --keycap-3: #3a3a3a;
      --key-text: #efefef;

      --amber: #ffbf00;
      --amber-dim: #e5aa00;
      --amber-deep: #7a4d00;

      --ink: #1a1a1a; /* black ink labels on panel */
      
      color-scheme: light;
    }

    * { box-sizing: border-box; }
    
    html {
      background-color: var(--panel-bg);
    }
    
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: linear-gradient(180deg, #cfc7b6, #d6cfbe 40%, #cfc7b6);
      color: #111;
      /* space for sticky title bar + top safe area */
      padding-top: calc(64px + env(safe-area-inset-top));
      /* Extend under system UI (notches/gesture areas) */
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }

    /* Sticky title bar */
    .title-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      background: var(--panel-bg);
      border-bottom: 2px solid var(--panel-rim);
      box-shadow: 0 4px 12px var(--panel-shadow);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      z-index: 1000;
      /* Extend to cover safe area at top */
      padding-top: env(safe-area-inset-top);
      padding-left: calc(24px + env(safe-area-inset-left));
      padding-right: calc(24px + env(safe-area-inset-right));
      /* Adjust height to include safe area */
      height: calc(64px + env(safe-area-inset-top));
    }
    .title-bar h1 {
      font-size: 22px;
      margin: 0;
      color: var(--ink);
      letter-spacing: 0.02em;
    }
    .title-bar .toggle {
      flex-shrink: 0;
    }

    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; display: grid; gap: 16px; }
    h1, h2 { margin: 0; }
    h1 { font-size: 22px; }
    h2 { font-size: 16px; color: #333; }

    /* Inset metal panel: surface flush, border seam looks cut-in */
    .panel {
      position: relative;
      background: var(--panel-bg);
      border-radius: 14px;
      border: 2px solid var(--panel-rim);
      padding: var(--panel-pad-safe);
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.2),            /* enamel sheen */
        inset 0 12px 20px rgba(0,0,0,0.10),               /* shallow emboss */
        0 6px 18px var(--panel-shadow);                   /* cast shadow */
    }
    /* Inset border seam into the flush surface */
    .panel::before {
      content: "";
      position: absolute; inset: 6px;
      border-radius: 10px;
      box-shadow: inset 0 0 0 2px var(--panel-rim), inset 0 8px 14px rgba(0,0,0,0.12);
      pointer-events: none;
    }
    /* Flathead screws in four corners; content padding ensures no overlap */
    .panel .rivet {
      position: absolute; width: 16px; height: 16px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #9aa7b4, #647482);
      border: 1px solid #3c4b57;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.25), 0 2px 3px rgba(0,0,0,0.35);
    }
    /* Flathead slot (narrow rectangle) */
    .panel .rivet::after {
      content: "";
      position: absolute;
      left: 50%; top: 50%;
      width: 10px; height: 2px;
      background: linear-gradient(90deg, rgba(0,0,0,0.3), rgba(0,0,0,0.8), rgba(0,0,0,0.3));
      transform: translate(-50%, -50%);
      box-shadow: inset 0 1px 0 rgba(0,0,0,0.6);
    }
    .panel .rivet.tl { top: 10px; left: 10px; }
    .panel .rivet.tl::after { transform: translate(-50%, -50%) rotate(-45deg); }
    .panel .rivet.tr { top: 10px; right: 10px; }
    .panel .rivet.tr::after { transform: translate(-50%, -50%) rotate(45deg); }
    .panel .rivet.bl { bottom: 10px; left: 10px; }
    .panel .rivet.bl::after { transform: translate(-50%, -50%) rotate(45deg); }
    .panel .rivet.br { bottom: 10px; right: 10px; }
    .panel .rivet.br::after { transform: translate(-50%, -50%) rotate(-45deg); }

    .section { display: grid; gap: 10px; }
    .row { display: grid; grid-template-columns: repeat(2, minmax(220px, 1fr)); gap: 14px; align-items: start; }
    .row > * { min-width: 0; }
    @media (max-width: 720px){ .row { grid-template-columns: 1fr; } }

    /* Cockpit panel sticky behavior */
    .cockpit-panel {
      position: sticky;
      top: -1px; /* Stick just below viewport top */
      z-index: 100;
      transition: box-shadow 0.3s ease, background 0.3s ease;
    }
    
    /* When not pinned, disable sticky */
    .cockpit-panel.unpinned {
      position: relative;
      z-index: 1;
    }
    
    /* Enhanced shadow and slight background change when stuck at top */
    .cockpit-panel.stuck {
      background: linear-gradient(180deg, 
        rgba(255, 255, 255, 0.08),
        var(--panel-bg) 20%
      );
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.25),
        inset 0 12px 20px rgba(0,0,0,0.10),
        0 12px 32px rgba(0,0,0,0.4); /* Stronger shadow when floating */
    }

    .label { color: var(--ink); font-weight: 700; letter-spacing: .02em; margin-bottom: 8px; }

    /* Charcoal button with recessed hole on press */
    .btn {
      display: inline-block;
      background: linear-gradient(180deg, var(--keycap-3), var(--keycap-2));
      color: var(--key-text);
      border: 2px solid #000;
      border-bottom-color: #000;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 800; letter-spacing: .02em; text-align: center;
      box-shadow: 0 3px 0 #000, 0 8px 16px rgba(0,0,0,.35);
      cursor: pointer; user-select: none;
      position: relative;
    }
    /* Recessed hole appears under key when pressed */
    .btn::after {
      content: "";
      position: absolute; inset: 6px; border-radius: 8px;
      background: linear-gradient(180deg, #0b0b0b, #151515);
      box-shadow: inset 0 6px 10px rgba(0,0,0,.6);
      opacity: 0; transition: opacity .06s ease;
      z-index: -1; /* sit beneath key */
    }
    .btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #000, 0 4px 10px rgba(0,0,0,.25); }
    .btn:active::after { opacity: 1; }
    /* Disabled button state - physical appearance unchanged, just non-functional */
    .btn:disabled,
    .btn.disabled {
      pointer-events: none;
    }

    /* Toggle (semantic checkbox) */
    .toggle { display: inline-flex; gap: 8px; align-items: center; color: var(--ink); font-weight: 600; }
    .toggle input { position: absolute; inline-size: 1px; block-size: 1px; overflow: hidden; clip-path: inset(50%); white-space: nowrap; border: 0; padding: 0; }
    .toggle .track {
      width: 64px; height: 28px; border-radius: 8px;
      background: #d1cab8; border: 2px solid var(--panel-rim);
      box-shadow: inset 0 0 10px rgba(0,0,0,.15);
      position: relative;
    }
    .toggle .thumb {
      position: absolute; top: 50%; left: 2px; width: 26px; height: 22px; border-radius: 6px;
      transform: translateY(-50%);
      background: linear-gradient(180deg,#3a3a3a, #232323); border: 2px solid #111; box-shadow: 0 2px 0 #000;
      transition: left .2s ease;
    }
    .toggle input:checked + .track .thumb { left: 34px; }
    /* Disabled toggle - physical appearance unchanged, just non-functional */
    .toggle input:disabled + .track {
      pointer-events: none;
    }

    /* Rotary dial knob (CSS variables) - interactive via hidden slider */
    .dial {
      --size: 120px;                  /* knob outer size */
      --start-angle: -120deg;         /* start of arc */
      --end-angle: 120deg;            /* end of arc */
      --steps: 12;                    /* number of discrete steps */
      --value: 6;                     /* current step index (0..steps) */
      --step-angle: calc((var(--end-angle) - var(--start-angle)) / var(--steps));
      width: var(--size); height: var(--size); position: relative; cursor: pointer;
      margin: 16px 16px 40px 16px;  /* extra space for graduations and label below */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: none;
      -webkit-touch-callout: none; /* Disable iOS callout */
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
    }
    /* Prevent text selection on all child elements */
    .dial * {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
    }
    /* Hidden slider drives the dial */
    .dial input[type="range"] {
      position: absolute; inset: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;
      touch-action: none; /* Prevent touch gestures on the slider itself */
    }
    /* Step marks ring (around knob) - only within start/end range */
    .dial .marks {
      position: absolute; inset: 0; border-radius: 50%;
      background:
        /* draw ticks only within active range */
        repeating-conic-gradient(from var(--start-angle),
          #0000 0 calc(var(--step-angle) - 1deg),
          rgba(0,0,0,.6) calc(var(--step-angle) - 1deg) var(--step-angle)
        );
      /* Mask to show only start-angle to end-angle arc */
      mask:
        conic-gradient(from var(--start-angle),
          #000 0 calc(var(--end-angle) - var(--start-angle)),
          #0000 calc(var(--end-angle) - var(--start-angle)) 360deg
        ),
        radial-gradient(circle at 50% 50%, #0000 calc(50% - 6px), #000 0);
      mask-composite: intersect;
      -webkit-mask:
        conic-gradient(from var(--start-angle),
          #000 0 calc(var(--end-angle) - var(--start-angle)),
          #0000 calc(var(--end-angle) - var(--start-angle)) 360deg
        ),
        radial-gradient(circle at 50% 50%, #0000 calc(50% - 6px), #000 0);
      -webkit-mask-composite: source-in;
      pointer-events: none;
    }
    /* Static shadow layer (doesn't rotate with knob) */
    .dial .shadow {
      position: absolute; inset: 12px; border-radius: 50%;
      box-shadow: 0 8px 16px rgba(0,0,0,.35);
      pointer-events: none;
      z-index: 1;
    }
    /* Knob face with grooves (rotates) */
    .dial .knob {
      position: absolute; inset: 12px; border-radius: 50%;
      background:
        repeating-conic-gradient(from 0deg, rgba(255,255,255,0.06) 0 10deg, rgba(0,0,0,0.05) 10deg 20deg),
        radial-gradient(circle at 50% 45%, #4b4b4b, #222 65%);
      border: 2px solid #101010; box-shadow: inset 0 2px 6px rgba(255,255,255,.06);
      pointer-events: none;
      transition: transform .1s ease;
      z-index: 2;
    }
    /* Notch */
    .dial .knob::after {
      content: ""; position: absolute; left: 50%; top: 8px; width: 4px; height: 14px; border-radius: 2px;
      background: #fff; transform: translateX(-50%);
      pointer-events: none;
    }
    /* Compute angle from value within [start,end] and rotate entire knob */
    .dial { --angle: calc(var(--start-angle) + var(--value) * var(--step-angle)); }
    .dial .knob { transform: rotate(var(--angle)); }
    .dial .cap { position: absolute; inset: 34px; border-radius: 50%; background: radial-gradient(circle at 50% 45%, #333, #111); box-shadow: inset 0 2px 6px rgba(0,0,0,.6); pointer-events: none; z-index: 3; }
    .dial .legend { position: absolute; left: 0; right: 0; top: 100%; margin-top: 8px; text-align: center; color: var(--ink); font-size: 12px; font-weight: 700; pointer-events: none; }
    /* Disabled dial state - physical appearance unchanged, just non-functional */
    .dial input:disabled {
      pointer-events: none;
    }

    /* Amber terminal screen */
    .crt {
      background: radial-gradient(120% 180% at 50% 8%, rgba(255,255,255,0.08), transparent 40%),
                  linear-gradient(180deg, #2a1600, #211100 50%, #140a00),
                  linear-gradient(180deg, var(--amber-deep), #1b0f00);
      border: 2px solid #3a2b15; border-radius: 10px; padding: 12px;
      color: var(--amber);
      text-shadow: 0 0 6px rgba(255, 191, 0, 0.65);
      box-shadow: inset 0 0 35px rgba(255,191,0,0.1), 0 3px 12px var(--panel-shadow);
      font-family: "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-variant-numeric: lining-nums;
      letter-spacing: .02em;
      overflow-x: auto;
      min-width: 0;
    }
    .crt pre, .crt code { margin: 0; white-space: pre-wrap; }

    /* Cockpit viewing window */
    .window {
      position: relative; 
      padding: 20px;  /* outer frame padding */
      background: linear-gradient(180deg, #5a5a52, #3e3e38);  /* metal frame */
      border-radius: 16px;
      border: 2px solid #2a2a26;
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.15),  /* frame highlight */
        inset 0 0 20px rgba(0,0,0,0.3),        /* frame depth */
        0 4px 0 #2a2a26,                        /* depth step */
        0 8px 16px rgba(0,0,0,0.3);            /* cast shadow */
    }
    /* Viewport (actual viewing area) */
    .window .viewport {
      position: relative; height: 220px; border-radius: 8px; overflow: hidden;
      background: linear-gradient(180deg, #000814, #000408);
      box-shadow: 
        inset 0 0 0 3px #1a1a1a,               /* inner bezel */
        inset 0 0 30px rgba(0,0,0,.8);         /* recessed depth */
    }
    
    /* Warp burst overlay - hidden by default, shown during warp phase */
    .window .viewport .warp-burst {
      position: absolute;
      inset: 0;
      display: none; /* Hidden by default */
      pointer-events: none;
    }
    
    .window .viewport .warp-burst.active {
      display: block;
    }
    
    .window .viewport .warp-burst svg {
      width: 100%;
      height: 100%;
    }
    
    .window .viewport .warp-burst .star-streak {
      filter: blur(0.5px) drop-shadow(0 0 3px currentColor);
      mix-blend-mode: screen; /* Additive blending for glow */
    }
    
    /* Starfield will be generated dynamically via JavaScript */
    
    /* Figure-8 movement for starfield - identical to planet movement */
    @keyframes starfieldFigureEight {
      0% { transform: translate(0, 0); }
      12.5% { transform: translate(40px, -20px); }
      25% { transform: translate(60px, 0); }
      37.5% { transform: translate(40px, 20px); }
      50% { transform: translate(0, 0); }
      62.5% { transform: translate(-40px, 20px); }
      75% { transform: translate(-60px, 0); }
      87.5% { transform: translate(-40px, -20px); }
      100% { transform: translate(0, 0); }
    }
    
    /* Gentle star twinkling animation */
    @keyframes starfieldTwinkle {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }
    
    .window .glass {
      position: absolute; inset: 0; border-radius: 10px; pointer-events: none;
      background:
        radial-gradient(100% 60% at 50% 0%, rgba(255,255,255,.18), transparent 40%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      mix-blend-mode: screen;
    }
    .window .planet {
      position: absolute; 
      left: 50%; 
      top: 50%; 
      width: 140px; 
      height: 140px; 
      margin-left: -70px; /* Half of width to center */
      margin-top: -70px; /* Half of height to center */
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #4488cc, #1155aa 60%, #001a44);
      box-shadow: 0 0 40px rgba(68,136,204,.35);
      animation: planetFigureEight 120s ease-in-out infinite;
    }
    .window .moon {
      display: none; /* Hidden - not rendering moons */
    }
    
    /* Figure-8 (lemniscate) path animation - smooth and continuous with pixel-based movement */
    @keyframes planetFigureEight {
      0% { transform: translate(0, 0); }
      12.5% { transform: translate(40px, -20px); }
      25% { transform: translate(60px, 0); }
      37.5% { transform: translate(40px, 20px); }
      50% { transform: translate(0, 0); }
      62.5% { transform: translate(-40px, 20px); }
      75% { transform: translate(-60px, 0); }
      87.5% { transform: translate(-40px, -20px); }
      100% { transform: translate(0, 0); }
    }
    
    /* Travel animation: Departure phase - planet and stars move down (ship goes up) */
    @keyframes travelDeparture {
      0% { transform: translate(0, 0); }
      100% { transform: translate(0, 300px); }
    }
    
    /* Travel animation: Arrival phase - planet grows from small to normal size */
    @keyframes travelArrival {
      0% { 
        transform: translate(0, -300px) scale(0.01);
        opacity: 0;
      }
      50% {
        opacity: 1;
      }
      100% { 
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
    }
    
    @keyframes moon { from { transform: translateX(0); } to { transform: translateX(-40%); } }

    /* Slider (range) with stamped groove */
    .slider-wrap { color: var(--ink); font-weight: 700; }
    .slider-labels { display: flex; justify-content: space-between; font-size: 12px; margin-top: 6px; color: var(--ink); }
    input[type="range"].slider {
      -webkit-appearance: none; appearance: none; width: 100%; height: 28px; background: transparent; margin: 0; cursor: pointer;
    }
    /* track as stamped groove */
    .slider::-webkit-slider-runnable-track {
      height: 8px; border-radius: 6px; border: 1px solid #585247;
      background: linear-gradient(180deg, #1a1a1a, #0e0e0e);
      box-shadow: inset 0 4px 8px rgba(0,0,0,.6);
    }
    .slider::-moz-range-track {
      height: 8px; border-radius: 6px; border: 1px solid #585247;
      background: linear-gradient(180deg, #1a1a1a, #0e0e0e);
      box-shadow: inset 0 4px 8px rgba(0,0,0,.6);
    }
    /* thumb as charcoal puck */
    .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -10px; width: 28px; height: 28px; border-radius: 50%; background: linear-gradient(180deg,#3a3a3a,#252525); border: 2px solid #111; box-shadow: 0 2px 0 #000; }
    .slider::-moz-range-thumb { width: 28px; height: 28px; border-radius: 50%; background: linear-gradient(180deg,#3a3a3a,#252525); border: 2px solid #111; box-shadow: 0 2px 0 #000; }

    /* Fuel meter (semantic progress, styled as analog gauge) */
    .gauge {
      --size: 220px;             /* overall diameter of the circle (we show the top half) */
      --thickness: 18px;         /* ring thickness of the arc */
      --value: 35;               /* 0..100 (maps left->right across the top semicircle) */
      --start: 180deg;           /* start at left */
      --sweep: 180deg;           /* show top semicircle from left (180) to right (360) */
      --end: calc(var(--start) + var(--sweep));
      /* Custom zone boundaries (0-100%) and colors */
      --zone1-start: 0;          /* first zone start % */
      --zone1-end: 20;           /* first zone end % */
      --zone1-color: #8a2020;    /* first zone color (default red) */
      --zone2-start: 20;         /* second zone start % */
      --zone2-end: 60;           /* second zone end % */
      --zone2-color: #c8c8c0;    /* second zone color (default ivory) */
      --zone3-start: 60;         /* third zone start % */
      --zone3-end: 100;          /* third zone end % */
      --zone3-color: #5a8a5a;    /* third zone color (default green) */
      position: relative;
      width: calc(var(--size) + 32px);  /* add padding around component */
      padding: 16px 16px 12px 16px;     /* reduced bottom padding for label space */
      margin: 6px auto 0;
      background: #e8e6dc;               /* brighter desaturated white backing */
      border-radius: 14px 14px 10px 10px;
      border: 2px solid #8a8578;
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.3),  /* top highlight */
        0 4px 0 #7a7568,                       /* depth step */
        0 8px 16px rgba(0,0,0,0.25);          /* cast shadow */
    }
    /* Hide semantic progress bar but keep it for accessibility */
    .gauge progress {
      position: absolute; width: 1px; height: 1px; overflow: hidden; clip-path: inset(50%); white-space: nowrap; border: 0; padding: 0;
    }
    /* Face/dial container (holds all gauge elements) */
    .gauge .face {
      position: relative;
      width: var(--size);
      height: calc(var(--size)/2 + 16px);
      margin: 0 auto 14px;  /* more space below for label */
    }
    /* Label below the needle pivot */
    .gauge .gauge-label {
      text-align: center;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: var(--ink);
      margin: 0 12px;
      opacity: 0.75;
    }
    /* Min/max value labels at arc ends */
    .gauge .gauge-min,
    .gauge .gauge-max {
      position: absolute;
      bottom: -2px;
      font-size: 9px;
      font-weight: 600;
      color: var(--ink);
      opacity: 0.6;
      font-family: "Intel One Mono", ui-monospace, monospace;
      pointer-events: none;
    }
    .gauge .gauge-min {
      left: 8px;
    }
    .gauge .gauge-max {
      right: 8px;
    }
    /* Glass hemisphere with rim */
    .gauge .glass {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background: radial-gradient(100% 60% at 50% 0%, rgba(255,255,255,.12), transparent 50%);
      border: 2px solid #3c3c3c; border-bottom: none;
      box-shadow: inset 0 0 20px rgba(255,255,255,.06);
      pointer-events: none; z-index: 4;
    }
    /* Color zone arc (behind glass) */
    .gauge .arc {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background:
        /* Paint the TOP semicircle: 0deg (left) -> 180deg (right) with bottom-center origin matching ticks */
        conic-gradient(from -90deg at 50% 100%,
          /* zone 1: start% .. end% */
          var(--zone1-color) calc(var(--sweep) * (var(--zone1-start)/100)) calc(var(--sweep) * (var(--zone1-end)/100)),
          /* zone 2: start% .. end% */
          var(--zone2-color) calc(var(--sweep) * (var(--zone2-start)/100)) calc(var(--sweep) * (var(--zone2-end)/100)),
          /* zone 3: start% .. end% */
          var(--zone3-color) calc(var(--sweep) * (var(--zone3-start)/100)) calc(var(--sweep) * (var(--zone3-end)/100)),
          /* rest transparent */
          #0000 calc(var(--sweep) * (var(--zone3-end)/100)) 360deg
        );
      /* show only the top half of the circle */
      clip-path: polygon(0 100%, 0 0, 100% 0, 100% 100%);
      /* create ring band at needle radius (just outside ticks) */
      mask:
        radial-gradient(circle at 50% 100%,
          #0000 calc(50% - var(--thickness) - 6px),
          #000 calc(50% - var(--thickness) - 6px) calc(50% - var(--thickness) + 6px),
          #0000 calc(50% - var(--thickness) + 6px)
        );
      z-index: 0;
    }
    /* Minor radial tick marks (short) pointing to center */
    .gauge .ticks-minor {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background:
        repeating-conic-gradient(from -90deg at 50% 100%,
          /* 36 ticks across 180deg -> 5deg per tick cycle */
          #0000 0 4.4deg,
          rgba(0,0,0,.75) 4.4deg 5deg
        );
      clip-path: polygon(0 100%, 0 0, 100% 0, 100% 100%);
      /* place ticks at needle tip radius (outer edge) */
      mask:
        radial-gradient(circle at 50% 100%,
          #0000 calc(50% - 10px),
          #000 calc(50% - 10px) calc(50% - 2px),
          #0000 calc(50% - 2px)
        );
      z-index: 1;
    }
    /* Major radial tick marks (longer, bolder) every 30deg */
    .gauge .ticks-major {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background:
        repeating-conic-gradient(from -90deg at 50% 100%,
          #0000 0 28.4deg,
          rgba(0,0,0,.95) 28.4deg 30deg
        );
      clip-path: polygon(0 100%, 0 0, 100% 0, 100% 100%);
      /* place ticks at needle tip radius, longer than minor ticks */
      mask:
        radial-gradient(circle at 50% 100%,
          #0000 calc(50% - 16px),
          #000 calc(50% - 16px) calc(50% - 2px),
          #0000 calc(50% - 2px)
        );
      z-index: 2;
    }
    /* Needle pointing from center (0% = left, 100% = right) */
    .gauge .needle {
      position: absolute; left: 50%; bottom: 0; width: 6px; height: calc(var(--size)/2 - var(--thickness) - 6px);
      background: linear-gradient(180deg, #222, #111);
      transform-origin: 50% 100%;
      transform: translateX(-50%) rotate(calc(var(--sweep) * (var(--value)/100) - 90deg));
      box-shadow: 0 0 6px rgba(0,0,0,.5);
      z-index: 3;
    }
    /* Center hub/rivet */
    .gauge .hub {
      position: absolute; left: 50%; bottom: 0; width: 14px; height: 14px;
      transform: translate(-50%, 50%); border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #444, #1a1a1a);
      border: 2px solid #000;
      box-shadow: inset 0 2px 4px rgba(255,255,255,.08), 0 2px 4px rgba(0,0,0,.4);
      z-index: 5;
    }

    /* Terminal-like input (visual) */
    .term-input {
      background: linear-gradient(180deg, #2a1600, #140a00);
      border: 2px solid #3a2b15; border-radius: 8px; padding: 10px 12px;
      color: var(--amber); text-shadow: 0 0 6px rgba(255,191,0,.5);
      font-family: "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      caret-color: var(--amber);
      outline: none;
      box-shadow: inset 0 0 35px rgba(255,191,0,0.08);
    }
    .term-input::placeholder { color: rgba(255,191,0,0.6); }
    /* Optional blinking block cue at right edge (for demo only) */
    .term-input.block-cursor { position: relative; }
    .term-input.block-cursor::after {
      content: ""; position: absolute; right: 12px; top: 50%; width: .6em; height: 1.1em; transform: translateY(-50%);
      background: rgba(255,191,0,0.85); box-shadow: 0 0 8px rgba(255,191,0,.5);
      animation: blink 1s steps(1,end) infinite; opacity: .9;
      pointer-events: none;
    }
    @keyframes blink { 0%, 50% { opacity: .0 } 50.01%, 100% { opacity: .9 } }

    .grid-2 { display: grid; grid-template-columns: repeat(2, minmax(140px, 1fr)); gap: 12px; }
    @media (max-width: 720px){ .grid-2 { grid-template-columns: 1fr; } }

    /* Cargo slot - physical storage slot with optional crate */
    .cargo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
    }
    .cargo-slot {
      position: relative;
      aspect-ratio: 1;
      background: linear-gradient(135deg, #0e0e0e, #1a1a1a 50%, #0e0e0e);
      border: 2px solid #3a3a38;
      border-radius: 8px;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.8), inset 0 2px 4px rgba(0,0,0,0.6);
      overflow: hidden;
      cursor: grab;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .cargo-slot.full:active {
      cursor: grabbing;
    }
    .cargo-slot.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }
    .cargo-slot.drag-over {
      border-color: #8b7d52;
      box-shadow: inset 0 0 20px rgba(139, 125, 82, 0.3), 0 0 20px rgba(139, 125, 82, 0.4);
      transform: scale(1.05);
    }
    /* Inspect slot - special styling with pulsing question mark */
    .cargo-slot.inspect-slot {
      cursor: default;
      border-color: #4a7ba7;
      background: linear-gradient(135deg, #0e1a1f, #1a2a30 50%, #0e1a1f);
    }
    .cargo-slot.inspect-slot * {
      pointer-events: none !important; /* Ensure ALL children don't interfere with drag-drop */
    }
    /* Disable pseudo-elements for inspect slot to prevent dragleave issues */
    .cargo-slot.inspect-slot::before,
    .cargo-slot.inspect-slot::after {
      display: none !important;
    }
    .cargo-slot.inspect-slot.drag-over {
      border-color: #6ba3d4;
      box-shadow: inset 0 0 20px rgba(107, 163, 212, 0.4), 0 0 20px rgba(107, 163, 212, 0.5);
    }
    .cargo-slot.inspect-slot .cargo-label {
      animation: pulse-question 2s ease-in-out infinite;
    }
    @keyframes pulse-question {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 0.4; }
    }
    /* Empty slot has darker appearance with subtle depth lines */
    .cargo-slot.empty::before {
      content: "";
      position: absolute;
      inset: 8px;
      border: 1px dashed #2a2a28;
      border-radius: 4px;
      opacity: 0.3;
    }
    /* Full slot contains a metallic crate */
    .cargo-slot.full {
      background: linear-gradient(135deg, #4a4a46, #5e5e58 50%, #4a4a46);
      box-shadow: inset 0 0 10px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.4);
    }
    /* Crate structure - outer square border */
    .cargo-slot.full::before {
      content: "";
      position: absolute;
      inset: 6px;
      border: 3px solid #2a2a28;
      border-radius: 4px;
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.15),
        inset 0 0 8px rgba(0,0,0,0.4);
    }
    /* Crate X-cross structure from corners */
    .cargo-slot.full::after {
      content: "";
      position: absolute;
      inset: 6px;
      background:
        /* diagonal line top-left to bottom-right */
        linear-gradient(135deg, 
          transparent calc(50% - 2px),
          rgba(42, 42, 40, 0.4) calc(50% - 2px),
          rgba(26, 26, 26, 0.4) 50%,
          rgba(42, 42, 40, 0.4) calc(50% + 2px),
          transparent calc(50% + 2px)
        ),
        /* diagonal line top-right to bottom-left */
        linear-gradient(45deg,
          transparent calc(50% - 2px),
          rgba(42, 42, 40, 0.4) calc(50% - 2px),
          rgba(26, 26, 26, 0.4) 50%,
          rgba(42, 42, 40, 0.4) calc(50% + 2px),
          transparent calc(50% + 2px)
        );
      box-shadow: inset 0 0 8px rgba(0,0,0,0.15);
    }
    
    /* Cargo type label painted on crate */
    .cargo-slot .cargo-label {
      pointer-events: none; /* Don't interfere with drag-and-drop */
      user-select: none;
    }
    
    .cargo-slot.full .cargo-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', monospace;
      font-size: 56px;
      font-weight: 900;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: -2px;
      z-index: 100;
    }

    /* Teleportation effect - glittery cyan/white sparkles */
    .cargo-slot.teleporting {
      animation: teleport-pulse 0.3s ease-in-out infinite;
      position: relative;
    }
    .cargo-slot.teleporting::before {
      animation: teleport-sparkle 0.5s ease-in-out infinite;
    }
    @keyframes teleport-pulse {
      0%, 100% {
        box-shadow: 
          inset 0 0 20px rgba(0,255,255,0.6),
          0 0 20px rgba(0,255,255,0.4),
          0 0 40px rgba(0,255,255,0.2);
        filter: brightness(1.3);
      }
      50% {
        box-shadow: 
          inset 0 0 30px rgba(255,255,255,0.8),
          0 0 30px rgba(255,255,255,0.6),
          0 0 60px rgba(0,255,255,0.4);
        filter: brightness(1.6);
      }
    }
    @keyframes teleport-sparkle {
      0%, 100% {
        opacity: 0.5;
        transform: scale(0.95);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
    }
  </style>
</head>
<body>
  <!-- Sticky Title Bar -->
  <div class="title-bar">
    <h1>Space Trader</h1>
    <label class="toggle">
      <input type="checkbox" id="fullscreen-toggle">
      <span class="track"><span class="thumb"></span></span>
      <span>FULLSCREEN</span>
    </label>
  </div>

  <div class="wrap">
    <!-- Cockpit Window -->
    <section class="panel section cockpit-panel">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h2 class="label" style="margin-bottom: 0;">Cockpit Window</h2>
        <label class="toggle" style="font-size: 11px;">
          <input type="checkbox" id="cockpit-pin-toggle">
          <span class="track"><span class="thumb"></span></span>
          <span>PIN</span>
        </label>
      </div>
      <div class="window">
        <div class="viewport">
          <div class="warp-burst"></div>
          <div class="planet"></div>
          <div class="moon"></div>
          <div class="glass"></div>
        </div>
      </div>
    </section>

    <!-- Navigation -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Navigation</h2>
      <div class="row">
        <div>
          <div class="label">Star Chart</div>
          <div class="crt nav-screen">
            <pre>Solar system: Boda
> Mercury
  Venus
  Earth
  Mars
  Jupiter
  Saturn
  Uranus
  Neptune</pre>
          </div>
        </div>
        <div>
          <div class="label">Cursor Control</div>
          <div style="display:flex; justify-content: center;">
            <div class="dial" style="--steps: 8; --start-angle: 0deg; --end-angle: 315deg; --value: 0;">
              <input type="range" min="0" max="8" step="1" value="0" oninput="this.parentElement.style.setProperty('--value', this.value)">
              <div class="marks"></div>
              <div class="shadow"></div>
              <div class="knob"></div>
              <div class="cap"></div>
              <div class="legend">NAVIGATE</div>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Navigation Actions</div>
          <div class="grid-2">
            <button type="button" class="btn">CURRENT LOC</button>
            <button type="button" class="btn">SYSTEM MAP</button>
            <button type="button" class="btn">GALAXY MAP</button>
            <button type="button" class="btn">BEGIN TRAVEL</button>
          </div>
        </div>
        <div>
          <div class="label">Power</div>
          <label class="toggle">
            <input type="checkbox" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Fuel -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Fuel</h2>
      <div class="row">
        <div>
          <div class="label">Fuel Level</div>
          <div class="gauge" style="--value: 28; --zone1-end: 25; --zone2-start: 25; --zone2-end: 60; --zone3-start: 60;">
            <progress max="100" value="28" aria-label="Fuel level">280 L</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">1000</span>
            </div>
            <div class="gauge-label">FUEL (L)</div>
          </div>
        </div>
        <div>
          <div class="label">Refueling Station</div>
          <div class="crt">
            <pre>Current credits: 123456â‚µ
Cost to refuel : 234â‚µ</pre>
          </div>
          <button type="button" class="btn" style="margin-top: 12px; width: 100%;">REFUEL</button>
        </div>
      </div>
    </section>

    <!-- Batteries -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Batteries</h2>
      <div class="row">
        <div>
          <div class="label">Battery A Charge</div>
          <div class="gauge" style="--value: 72; --zone1-end: 20; --zone2-start: 20; --zone2-end: 50; --zone3-start: 50;">
            <progress max="100" value="72" aria-label="Battery A charge level">72%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">2k</span>
            </div>
            <div class="gauge-label">BATTERY A (Wh)</div>
          </div>
        </div>
        <div>
          <div class="label">Battery B Charge</div>
          <div class="gauge" style="--value: 58; --zone1-end: 20; --zone2-start: 20; --zone2-end: 50; --zone3-start: 50;">
            <progress max="100" value="58" aria-label="Battery B charge level">58%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">2k</span>
            </div>
            <div class="gauge-label">BATTERY B (Wh)</div>
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Bus A</div>
          <label class="toggle">
            <input type="checkbox" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
        <div>
          <div class="label">Bus B</div>
          <label class="toggle">
            <input type="checkbox" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Solar Panels -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Solar Panels</h2>
      <div class="row">
        <div>
          <div class="label">Charge Current</div>
          <div class="gauge" style="--value: 45; --zone1-end: 10; --zone1-color: #c8c8c0; --zone2-start: 10; --zone2-end: 30; --zone2-color: #c8c8c0; --zone3-start: 30; --zone3-color: #5a8a5a;">
            <progress max="100" value="45" aria-label="Solar charge current">45%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">12.6k</span>
            </div>
            <div class="gauge-label">CHARGE (W)</div>
          </div>
        </div>
        <div>
          <div class="label">Power Draw</div>
          <div class="gauge" style="--value: 38; --zone1-end: 40; --zone1-color: #5a8a5a; --zone2-start: 40; --zone2-end: 70; --zone2-color: #c8c8c0; --zone3-start: 70; --zone3-color: #8a2020;">
            <progress max="100" value="38" aria-label="Ship power consumption">38%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">24k</span>
            </div>
            <div class="gauge-label">DRAW (W)</div>
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Panel Control</div>
          <div class="slider-wrap">
            <input type="range" min="0" max="2" step="1" class="slider" value="1">
            <div class="slider-labels"><span>RETRACT</span><span>STOP</span><span>EXTEND</span></div>
          </div>
        </div>
        <div>
          <div class="label">Bus Connection</div>
          <label class="toggle">
            <input type="checkbox" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>CONNECTED</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Trader Comms -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Trader Comms</h2>
      <div class="row">
        <div>
          <div class="label">Power</div>
          <label class="toggle">
            <input type="checkbox" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
        <div>
          <div class="label">Mode</div>
          <label class="toggle">
            <input type="checkbox">
            <span class="track"><span class="thumb"></span></span>
            <span>BUYING / SELLING</span>
          </label>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Trade Details</div>
          <div class="crt">
            <pre>SELLING (page 1 of 5)
Trader: Captain Fingers
Ship  : Top Banana
Type  : Food
Crates remaining   : 5
Crates demand      : 2
Price per crate    : 250â‚µ
Profit (loss) delta: 12â‚µ
Current credits    : 123456â‚µ
Standing: Neutral</pre>
          </div>
        </div>
        <div>
          <div class="label">Trade Actions</div>
          <div class="grid-2">
            <button type="button" class="btn">PREVIOUS PAGE</button>
            <button type="button" class="btn">NEXT PAGE</button>
            <button type="button" class="btn">HAGGLE</button>
            <button type="button" class="btn">TRADE</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Cargo Hold -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Cargo Hold</h2>
      
      <!-- Crate Info Database -->
      <div style="display: grid; grid-template-columns: 80px 1fr; gap: 12px; margin-bottom: 16px;">
        <div>
          <div class="label" style="margin-bottom: 4px; font-size: 10px;">INSPECT</div>
          <div class="cargo-slot empty inspect-slot" id="inspect-slot">
            <div class="cargo-label" style="font-size: 72px; opacity: 0.2;">?</div>
          </div>
        </div>
        <div>
          <div class="label" style="margin-bottom: 4px; font-size: 10px;">CRATE INFO DATABASE</div>
          <div class="crt" style="padding: 8px;">
            <pre id="inspect-terminal" style="font-size: 11px; line-height: 1.4;">&nbsp;
&nbsp;
&nbsp;
&nbsp;</pre>
          </div>
        </div>
      </div>
      
      <div class="cargo-grid">
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
      </div>
    </section>

    <!-- New Game Controls -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">New Game</h2>
      <div class="row">
        <div>
          <div class="label">Safety Lock</div>
          <label class="toggle">
            <input type="checkbox" id="new-game-arm">
            <span class="track"><span class="thumb"></span></span>
            <span>ARMED / SAFE</span>
          </label>
        </div>
        <div>
          <div class="label">Reset Game</div>
          <button type="button" class="btn" id="new-game-btn" disabled style="width: 100%; opacity: 0.5;">NEW GAME</button>
        </div>
      </div>
      <div class="row">
        <div>
          <div class="label">Auto-Save Status</div>
          <div class="crt">
            <pre id="save-status">Last saved: Never
Auto-save  : Active</pre>
          </div>
        </div>
      </div>
    </section>

    <!-- About -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">About Space Trader</h2>
      <div style="display: grid; gap: 12px;">
        <div class="card">
          <div style="font-size: 14px; line-height: 1.6;">
            <div style="margin-bottom: 12px;">
              <strong style="font-size: 16px; color: var(--ink);">Space Trader v2.0.0</strong>
            </div>
            <div style="margin-bottom: 8px;">
              Created by <strong>Timeless Prototype</strong> and <strong>Claude Sonnet 4.5</strong>
            </div>
            <div style="margin-bottom: 16px; color: var(--ink); opacity: 0.8;">
              An idle space trading game with realistic power management, procedural generation, and retro industrial aesthetics.
            </div>
            <div style="margin-bottom: 12px;">
              <strong>Features:</strong>
            </div>
            <ul style="margin: 0 0 16px 20px; padding: 0; color: var(--ink); opacity: 0.9;">
              <li>âš¡ Realistic battery and solar panel systems</li>
              <li>ðŸŒŸ Procedurally generated planets and star systems</li>
              <li>ðŸš€ Cinematic warp travel animations</li>
              <li>ðŸ“¦ Dynamic cargo trading with NPC traders</li>
              <li>ðŸŽ® Physical control panel aesthetics</li>
              <li>ðŸ’¾ Auto-save system</li>
            </ul>
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--panel-rim);">
              <div style="margin-bottom: 8px; font-weight: 600;">Support the Developer:</div>
              <a href="https://buymeacoffee.com/timelessp" target="_blank" rel="noopener noreferrer" aria-label="Buy me a coffee">
                <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 45px; width: auto; display: block; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);" />
              </a>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // ============================================================================
    // EVENT BUS - Central event management system
    // ============================================================================
    class EventBus {
      constructor() {
        this.listeners = new Map();
      }

      /**
       * Subscribe to an event
       * @param {string} eventName - Name of the event to listen for
       * @param {Function} callback - Function to call when event fires
       * @param {Object} context - Optional context (this) for the callback
       * @returns {Function} Unsubscribe function
       */
      on(eventName, callback, context = null) {
        if (!this.listeners.has(eventName)) {
          this.listeners.set(eventName, []);
        }
        
        const listener = { callback, context };
        this.listeners.get(eventName).push(listener);
        
        // Return unsubscribe function
        return () => this.off(eventName, callback);
      }

      /**
       * Subscribe to an event (one-time only)
       */
      once(eventName, callback, context = null) {
        const unsubscribe = this.on(eventName, (...args) => {
          unsubscribe();
          callback.apply(context, args);
        }, context);
        return unsubscribe;
      }

      /**
       * Unsubscribe from an event
       */
      off(eventName, callback) {
        if (!this.listeners.has(eventName)) return;
        
        const listeners = this.listeners.get(eventName);
        const index = listeners.findIndex(l => l.callback === callback);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
        
        if (listeners.length === 0) {
          this.listeners.delete(eventName);
        }
      }

      /**
       * Emit an event to all subscribers
       * @param {string} eventName - Name of the event
       * @param {*} data - Data to pass to listeners
       */
      emit(eventName, data = null) {
        if (!this.listeners.has(eventName)) return;
        
        const listeners = this.listeners.get(eventName);
        listeners.forEach(({ callback, context }) => {
          try {
            callback.call(context, data);
          } catch (error) {
            console.error(`Error in event listener for '${eventName}':`, error);
          }
        });
      }

      /**
       * Clear all listeners for an event, or all events
       */
      clear(eventName = null) {
        if (eventName) {
          this.listeners.delete(eventName);
        } else {
          this.listeners.clear();
        }
      }
    }

    // Global event bus instance
    const eventBus = new EventBus();

    // ============================================================================
    // SAVE/LOAD SYSTEM
    // ============================================================================
    class SaveSystem {
      constructor() {
        this.SAVE_KEY = 'space-trader-v2';
        this.AUTO_SAVE_INTERVAL = 5000; // Auto-save every 5 seconds
        this.lastSaveTime = null;
        this.autoSaveEnabled = true;
        this.autoSaveTimer = null;
      }

      /**
       * Serialize game state to JSON
       */
      serializeGameState() {
        return {
          version: 2,
          timestamp: Date.now(),
          batteries: batterySystem.batteries.map(b => ({
            id: b.id,
            maxCapacity: b.maxCapacity,
            currentCharge: b.currentCharge,
            maxDischargeRate: b.maxDischargeRate,
            maxChargeRate: b.maxChargeRate,
            efficiency: b.efficiency,
            health: b.health,
            connectedToBus: b.connectedToBus,
            temperature: b.temperature,
            cycleCount: b.cycleCount,
            enabled: b.enabled
          })),
          solar: {
            panelState: solarSystem.panelState,
            extension: solarSystem.extension,
            sunlightIntensity: solarSystem.sunlightIntensity,
            connectedToBus: solarSystem.connectedToBus
          },
          fuel: {
            currentFuel: fuelSystem.currentFuel,
            credits: fuelSystem.credits
          },
          navigation: {
            x: navigationSystem.currentX,
            y: navigationSystem.currentY,
            planetIndex: navigationSystem.currentPlanetIndex,
            viewMode: navigationSystem.viewMode,
            cursorIndex: navigationSystem.cursorIndex
          },
          power: {
            activeSystems: Array.from(powerSystem.activeSystems)
          },
          trading: {
            cargo: tradingSystem.cargo.map(item => item ? {
              id: item.id,
              type: item.type,
              purchasePrice: item.purchasePrice,
              slotIndex: item.slotIndex
            } : null),
            nextCargoId: tradingSystem.nextCargoId
          }
        };
      }

      /**
       * Deserialize game state from JSON
       */
      deserializeGameState(data) {
        if (!data || data.version !== 2) {
          console.warn('Invalid or incompatible save data');
          return null;
        }

        return data;
      }

      /**
       * Save game state to localStorage
       */
      save() {
        try {
          const gameState = this.serializeGameState();
          localStorage.setItem(this.SAVE_KEY, JSON.stringify(gameState));
          this.lastSaveTime = Date.now();
          eventBus.emit('game:saved', { timestamp: this.lastSaveTime });
          console.log('ðŸ’¾ Game saved');
          return true;
        } catch (error) {
          console.error('Failed to save game:', error);
          eventBus.emit('game:save-failed', { error });
          return false;
        }
      }

      /**
       * Load game state from localStorage
       */
      load() {
        try {
          const savedData = localStorage.getItem(this.SAVE_KEY);
          if (!savedData) {
            console.log('No saved game found');
            return null;
          }

          const gameState = JSON.parse(savedData);
          const validatedState = this.deserializeGameState(gameState);
          
          if (validatedState) {
            console.log('ðŸ“‚ Game loaded');
            eventBus.emit('game:loaded', { timestamp: gameState.timestamp });
            return validatedState;
          }
          
          return null;
        } catch (error) {
          console.error('Failed to load game:', error);
          eventBus.emit('game:load-failed', { error });
          return null;
        }
      }

      /**
       * Delete saved game
       */
      deleteSave() {
        try {
          localStorage.removeItem(this.SAVE_KEY);
          this.lastSaveTime = null;
          console.log('ðŸ—‘ï¸ Save deleted');
          eventBus.emit('game:save-deleted', {});
          return true;
        } catch (error) {
          console.error('Failed to delete save:', error);
          return false;
        }
      }

      /**
       * Check if a save exists
       */
      hasSave() {
        return localStorage.getItem(this.SAVE_KEY) !== null;
      }

      /**
       * Start auto-save timer
       */
      startAutoSave() {
        if (this.autoSaveTimer) {
          clearInterval(this.autoSaveTimer);
        }

        this.autoSaveEnabled = true;
        this.autoSaveTimer = setInterval(() => {
          if (this.autoSaveEnabled) {
            this.save();
          }
        }, this.AUTO_SAVE_INTERVAL);

        console.log(`ðŸ”„ Auto-save started (every ${this.AUTO_SAVE_INTERVAL / 1000}s)`);
      }

      /**
       * Stop auto-save timer
       */
      stopAutoSave() {
        if (this.autoSaveTimer) {
          clearInterval(this.autoSaveTimer);
          this.autoSaveTimer = null;
        }
        this.autoSaveEnabled = false;
        console.log('â¸ï¸ Auto-save stopped');
      }

      /**
       * Get formatted last save time
       */
      getLastSaveTimeFormatted() {
        if (!this.lastSaveTime) {
          return 'Never';
        }

        const now = Date.now();
        const diff = now - this.lastSaveTime;
        
        if (diff < 60000) {
          return 'Just now';
        } else if (diff < 3600000) {
          const mins = Math.floor(diff / 60000);
          return `${mins} min${mins !== 1 ? 's' : ''} ago`;
        } else {
          return new Date(this.lastSaveTime).toLocaleTimeString();
        }
      }
    }

    // Create save system instance
    const saveSystem = new SaveSystem();

    // ============================================================================
    // PROCEDURAL GENERATION - Seeded RNG and name generators
    // ============================================================================
    
    /**
     * Seeded random number generator class (from version 1)
     * Provides consistent random values with next(), nextInt(), and choice()
     */
    class SeededRNG {
      constructor(seed = 12345) {
        this.seed = seed;
      }
      
      next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
      }
      
      nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
      }
      
      choice(array) {
        return array[Math.floor(this.next() * array.length)];
      }
    }

    /**
     * Seeded pseudo-random number generator (Mulberry32)
     * Returns consistent results for same seed
     */
    function seededRandom(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    /**
     * Generate solar system name based on grid position
     * Uses consonant-vowel patterns with varying lengths
     */
    function generateSolarSystemName(x, y) {
      const seed = (x * 73856093) ^ (y * 19349663);
      const rng = seededRandom(seed);
      
      const consonants = 'BCDFGHJKLMNPQRSTVWXZ';
      const vowels = 'AEIOU';
      
      // Determine name length (2-4 syllables = 4-8 characters)
      const syllables = Math.floor(rng() * 3) + 2; // 2-4 syllables
      let name = '';
      
      for (let i = 0; i < syllables; i++) {
        // Each syllable: consonant + vowel
        name += consonants[Math.floor(rng() * consonants.length)];
        name += vowels[Math.floor(rng() * vowels.length)].toLowerCase();
      }
      
      // Capitalize first letter
      return name.charAt(0).toUpperCase() + name.slice(1);
    }

    /**
     * Generate planet name (version 1 style with seeding on x, y, planetIndex)
     * Uses consonant-vowel patterns with optional suffixes
     */
    function generatePlanetName(x, y, planetIndex) {
      // XOR can produce 0, which breaks the RNG. Add 1 to ensure non-zero seed.
      let seed = (x * 73856093) ^ (y * 19349663) ^ (planetIndex * 83492791);
      seed = Math.abs(seed) + 1; // Ensure positive and non-zero
      const rng = new SeededRNG(seed);
      
      const C = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'];
      const V = ['a','e','i','o','u','y'];
      const len = rng.nextInt(2, 3);
      let s = '';
      for (let i = 0; i < len; i++) { 
        const cIndex = Math.floor(rng.next() * C.length);
        const vIndex = Math.floor(rng.next() * V.length);
        s += C[cIndex] + V[vIndex]; 
      }
      const suffixes = ['-I', '-II', '', '', '', ' Prime'];
      const sIndex = Math.floor(rng.next() * suffixes.length);
      return s.charAt(0).toUpperCase() + s.slice(1) + suffixes[sIndex];
    }

    /**
     * Generate planet names for a solar system
     * Based on Roman, Greek, and mythological naming conventions
     */
    function generatePlanetNames(x, y, count) {
      const names = [];
      for (let i = 0; i < count; i++) {
        names.push(generatePlanetName(x, y, i));
      }
      return names;
    }

    /**
     * Get planet color based on type (seeded on x, y, planetIndex)
     */
    function getPlanetColor(x, y, planetIndex) {
      // XOR can produce 0, which breaks the RNG. Add 1 to ensure non-zero seed.
      let seed = (x * 73856093) ^ (y * 19349663) ^ (planetIndex * 83492791);
      seed = Math.abs(seed) + 1; // Ensure positive and non-zero
      const rng = new SeededRNG(seed);
      
      const planetTypes = ['Rocky', 'Gas Giant', 'Ice World', 'Desert', 'Ocean', 'Volcanic'];
      const typeIndex = Math.floor(rng.next() * planetTypes.length);
      const type = planetTypes[typeIndex];
      
      const colors = {
        'Rocky': ['#8B4513', '#CD853F', '#A0522D'],
        'Gas Giant': ['#4169E1', '#6495ED', '#87CEEB'],
        'Ice World': ['#E0FFFF', '#B0E0E6', '#F0F8FF'],
        'Desert': ['#DAA520', '#F4A460', '#CD853F'],
        'Ocean': ['#008B8B', '#20B2AA', '#48D1CC'],
        'Volcanic': ['#DC143C', '#B22222', '#8B0000']
      };
      
      const colorOptions = colors[type];
      const colorIndex = Math.floor(rng.next() * colorOptions.length);
      
      return {
        type,
        color: colorOptions[colorIndex]
      };
    }

    /**
     * Darken a color by a factor (0.0 - 1.0)
     */
    function darkenColor(color, factor = 0.4) {
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      const darkR = Math.floor(r * factor);
      const darkG = Math.floor(g * factor);
      const darkB = Math.floor(b * factor);
      
      return `#${darkR.toString(16).padStart(2, '0')}${darkG.toString(16).padStart(2, '0')}${darkB.toString(16).padStart(2, '0')}`;
    }

    /**
     * Get number of planets in a solar system (1-8)
     */
    function getPlanetCount(x, y) {
      const seed = (x * 73856093) ^ (y * 19349663) + 54321;
      const rng = seededRandom(seed);
      return Math.floor(rng() * 8) + 1; // 1-8 planets
    }

    /**
     * Get neighboring solar systems (only at even coordinates)
     * Returns array of {x, y, name, distance} sorted by distance
     */
    function getNeighboringSystems(currentX, currentY, maxDistance = 8) {
      const neighbors = [];
      
      for (let dx = -maxDistance; dx <= maxDistance; dx += 2) {
        for (let dy = -maxDistance; dy <= maxDistance; dy += 2) {
          // Skip if both offsets are 0 (current system)
          if (dx === 0 && dy === 0) continue;
          
          const x = currentX + dx;
          const y = currentY + dy;
          
          // Only include systems at even coordinates
          if (x % 2 !== 0 || y % 2 !== 0) continue;
          
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= maxDistance) {
            neighbors.push({
              x,
              y,
              name: generateSolarSystemName(x, y),
              distance: distance.toFixed(1)
            });
          }
        }
      }
      
      // Sort by distance
      neighbors.sort((a, b) => parseFloat(a.distance) - parseFloat(b.distance));
      
      // Limit to 8 nearest
      return neighbors.slice(0, 8);
    }

    // ============================================================================
    // NAVIGATION SYSTEM - Galaxy and solar system navigation
    // ============================================================================
    
    class NavigationSystem {
      constructor() {
        this.currentX = 0;
        this.currentY = 0;
        this.currentPlanetIndex = 0; // Which planet we're at (0 = closest to sun)
        this.viewMode = 'system'; // 'system' or 'galaxy'
        this.cursorIndex = 0;
        this.traveling = false;
        this.travelStartTime = 0;
        this.travelDuration = 10; // 10 seconds
        this.travelTarget = null;
        this.fuelCostPerUnit = 10; // 10 liters per distance unit
      }

      /**
       * Get current solar system info
       */
      getCurrentSystem() {
        const name = generateSolarSystemName(this.currentX, this.currentY);
        const planetCount = getPlanetCount(this.currentX, this.currentY);
        const planets = generatePlanetNames(this.currentX, this.currentY, planetCount);
        
        return {
          x: this.currentX,
          y: this.currentY,
          name,
          planetCount,
          planets
        };
      }

      /**
       * Get sun strength based on current planet index
       * Planet 0 (closest) = 100%, Planet 7 (farthest) = 20%
       */
      getSunStrength() {
        const system = this.getCurrentSystem();
        const maxIndex = system.planetCount - 1;
        
        // Linear interpolation: 100% at index 0, 20% at max index
        if (maxIndex === 0) return 1.0; // Single planet system = 100%
        
        const strength = 1.0 - (this.currentPlanetIndex / maxIndex) * 0.8;
        return Math.max(0.2, Math.min(1.0, strength));
      }

      /**
       * Get neighboring systems for galaxy map
       */
      getGalaxyMap() {
        return getNeighboringSystems(this.currentX, this.currentY);
      }

      /**
       * Switch between system and galaxy view
       */
      setViewMode(mode) {
        this.viewMode = mode;
        this.cursorIndex = 0;
        eventBus.emit('navigation:view-changed', { mode });
      }

      /**
       * Show current location (system map with cursor on current planet)
       */
      showCurrentLocation() {
        this.viewMode = 'system';
        this.cursorIndex = this.currentPlanetIndex;
        eventBus.emit('navigation:view-changed', { mode: 'system' });
      }

      /**
       * Move cursor up/down in list
       */
      moveCursor(direction) {
        const items = this.viewMode === 'system' 
          ? this.getCurrentSystem().planets 
          : this.getGalaxyMap();
        
        if (direction === 'up') {
          this.cursorIndex = Math.max(0, this.cursorIndex - 1);
        } else if (direction === 'down') {
          this.cursorIndex = Math.min(items.length - 1, this.cursorIndex + 1);
        }
        
        eventBus.emit('navigation:cursor-moved', { index: this.cursorIndex });
      }

      /**
       * Set cursor to specific position (from dial)
       */
      setCursor(index) {
        const items = this.viewMode === 'system' 
          ? this.getCurrentSystem().planets 
          : this.getGalaxyMap();
        
        this.cursorIndex = Math.max(0, Math.min(items.length - 1, index));
        eventBus.emit('navigation:cursor-moved', { index: this.cursorIndex });
      }

      /**
       * Show travel blocked message in navigation terminal for 5 seconds
       */
      showTravelBlockedMessage(message) {
        const lines = message.split('\n');
        
        // Store original state so we can restore it
        if (!this.blockedMessageTimeout) {
          this.savedViewMode = this.viewMode;
          this.savedCursorIndex = this.cursorIndex;
        }
        
        // Set a flag to show blocked message
        this.showingBlockedMessage = true;
        this.blockedMessageLines = lines;
        
        // Clear any existing timeout
        if (this.blockedMessageTimeout) {
          clearTimeout(this.blockedMessageTimeout);
        }
        
        // Update UI immediately
        eventBus.emit('navigation:update-ui');
        
        // Restore after 5 seconds
        this.blockedMessageTimeout = setTimeout(() => {
          this.showingBlockedMessage = false;
          this.blockedMessageLines = null;
          this.blockedMessageTimeout = null;
          eventBus.emit('navigation:update-ui');
        }, 5000);
      }

      /**
       * Start travel to selected destination
       */
      beginTravel() {
        if (this.traveling) {
          return { success: false, message: 'Already traveling!' };
        }

        // Check solar panel safety requirements
        const safetyIssues = [];
        
        // Check if solar panels are fully retracted (extension must be 0)
        if (solarSystem.extension > 0) {
          safetyIssues.push('Panels extended');
        }
        
        // Check if solar panels are stopped (panelState must be 1)
        // 0=retracting, 1=stopped, 2=extending
        if (solarSystem.panelState !== 1) {
          safetyIssues.push('Panels moving');
        }
        
        // Check if solar panels are disconnected from bus
        if (solarSystem.connectedToBus) {
          safetyIssues.push('Panels connected');
        }
        
        // If there are safety issues, show them and prevent travel
        if (safetyIssues.length > 0) {
          const message = 'BLOCKED:\n' + safetyIssues.map(issue => `â€¢ ${issue}`).join('\n');
          this.showTravelBlockedMessage(message);
          return { success: false, message };
        }

        if (this.viewMode === 'system') {
          // Travel to a planet in current system
          const system = this.getCurrentSystem();
          if (this.cursorIndex >= system.planets.length) {
            return { success: false, message: 'Invalid planet!' };
          }
          
          if (this.cursorIndex === this.currentPlanetIndex) {
            return { success: false, message: 'Already at this planet!' };
          }
          
          const targetIndex = this.cursorIndex;
          const targetPlanet = system.planets[targetIndex];
          const distance = Math.abs(targetIndex - this.currentPlanetIndex);
          const fuelNeeded = distance * 0.5; // 0.5L per planet distance
          const travelTime = distance * 2.0; // 2 seconds per planet hop
          
          if (fuelSystem.currentFuel < fuelNeeded) {
            return { success: false, message: 'Insufficient fuel!' };
          }
          
          // Start planet travel
          this.traveling = true;
          this.travelStartTime = performance.now() / 1000;
          this.travelDuration = travelTime;
          this.travelTarget = {
            type: 'planet',
            planetIndex: targetIndex,
            planetName: targetPlanet,
            distance: distance,
            fuelUsed: fuelNeeded,
            initialFuel: fuelSystem.currentFuel
          };
          
          eventBus.emit('navigation:travel-started', { 
            type: 'planet',
            target: targetPlanet, 
            distance,
            fuelCost: fuelNeeded,
            travelTime
          });
          
          return { success: true, type: 'planet', planetIndex: targetIndex, distance, fuelNeeded };
        } else {
          // Travel to another solar system
          const neighbors = this.getGalaxyMap();
          if (neighbors.length === 0 || this.cursorIndex >= neighbors.length) {
            return { success: false, message: 'No destination!' };
          }

          const target = neighbors[this.cursorIndex];
          const fuelCost = Math.ceil(parseFloat(target.distance) * this.fuelCostPerUnit);
          const travelTime = parseFloat(target.distance) * 1.5; // 1.5 seconds per unit distance

          if (fuelSystem.currentFuel < fuelCost) {
            return { success: false, message: 'Insufficient fuel!' };
          }

          // Start travel
          this.traveling = true;
          this.travelStartTime = performance.now() / 1000;
          this.travelDuration = travelTime;
          this.travelTarget = target;
          
          eventBus.emit('navigation:travel-started', { type: 'system', target, fuelCost, travelTime });
          
          return { success: true, type: 'system', fuelCost, target };
        }
      }

      /**
       * Update travel progress
       */
      update(deltaTime) {
        if (!this.traveling) return;

        const currentTime = performance.now() / 1000;
        const elapsed = currentTime - this.travelStartTime;
        const progress = Math.min(elapsed / this.travelDuration, 1.0);

        if (progress >= 1.0) {
          // Travel complete
          if (this.travelTarget.type === 'planet') {
            // Planet travel complete
            const fuelCost = this.travelTarget.fuelUsed;
            fuelSystem.consumeFuel(fuelCost);
            
            this.currentPlanetIndex = this.travelTarget.planetIndex;
            this.traveling = false;
            this.cursorIndex = this.currentPlanetIndex; // Move cursor to current planet
            
            // Update sun strength based on new planet
            const sunStrength = this.getSunStrength();
            solarSystem.updateSunlight(sunStrength);
            
            eventBus.emit('navigation:travel-complete', { 
              type: 'planet',
              planetIndex: this.currentPlanetIndex,
              planetName: this.travelTarget.planetName,
              fuelUsed: fuelCost,
              sunStrength
            });
          } else {
            // System travel complete
            const fuelCost = Math.ceil(parseFloat(this.travelTarget.distance) * this.fuelCostPerUnit);
            fuelSystem.consumeFuel(fuelCost);
            
            this.currentX = this.travelTarget.x;
            this.currentY = this.travelTarget.y;
            
            // Arrive at outermost planet
            const system = this.getCurrentSystem();
            this.currentPlanetIndex = system.planetCount - 1;
            
            this.traveling = false;
            this.cursorIndex = 0;
            this.viewMode = 'system'; // Return to system view
            
            // Update sun strength based on arrival planet
            const sunStrength = this.getSunStrength();
            solarSystem.updateSunlight(sunStrength);
            
            eventBus.emit('navigation:travel-complete', { 
              type: 'system',
              x: this.currentX, 
              y: this.currentY,
              planetIndex: this.currentPlanetIndex,
              fuelUsed: fuelCost,
              sunStrength
            });
          }
        } else {
          // Travel in progress - consume fuel gradually for planet travel
          if (this.travelTarget.type === 'planet') {
            const fuelPerSecond = this.travelTarget.fuelUsed / this.travelDuration;
            const fuelToConsume = fuelPerSecond * deltaTime;
            fuelSystem.currentFuel = Math.max(0, fuelSystem.currentFuel - fuelToConsume);
          }
          
          eventBus.emit('navigation:travel-progress', { progress, elapsed });
        }
      }

      /**
       * Get system status
       */
      getStatus() {
        return {
          position: { x: this.currentX, y: this.currentY },
          planetIndex: this.currentPlanetIndex,
          system: this.getCurrentSystem(),
          viewMode: this.viewMode,
          cursorIndex: this.cursorIndex,
          traveling: this.traveling,
          sunStrength: this.getSunStrength()
        };
      }
    }

    // Create navigation system
    const navigationSystem = new NavigationSystem();

    // ============================================================================
    // COMPONENT BASE CLASS
    // ============================================================================
    class Component {
      constructor(name) {
        this.name = name;
        this.enabled = true;
      }

      update(deltaTime) {
        // Override in subclasses
      }

      destroy() {
        // Override in subclasses for cleanup
      }
    }

    // ============================================================================
    // BATTERY COMPONENT
    // ============================================================================
    class Battery extends Component {
      constructor(id, config = {}) {
        super(`Battery_${id}`);
        
        this.id = id;
        this.maxCapacity = config.maxCapacity || 2000; // Wh (watt-hours) - sized for 10min charge
        this.currentCharge = config.initialCharge || this.maxCapacity * 0.7;
        this.maxDischargeRate = config.maxDischargeRate || 1000; // W (watts)
        this.maxChargeRate = config.maxChargeRate || 12600; // W (watts) - can accept full solar
        this.efficiency = config.efficiency || 0.95; // 95% efficient
        this.health = config.health || 100; // 0-100%
        this.connectedToBus = config.connectedToBus !== undefined ? config.connectedToBus : true;
        this.temperature = config.temperature || 20; // Celsius
        this.cycleCount = config.cycleCount || 0;
        
        // Teleportation energy tracking
        this.teleportEnergyDrawn = 0;
        
        // Degradation parameters
        this.degradationRate = 0.0001; // per cycle
        this.optimalTempMin = 15;
        this.optimalTempMax = 25;
      }

      /**
       * Get charge percentage (0-100)
       */
      getChargePercentage() {
        return (this.currentCharge / this.maxCapacity) * 100;
      }

      /**
       * Get effective capacity based on health
       */
      getEffectiveCapacity() {
        return this.maxCapacity * (this.health / 100);
      }

      /**
       * Attempt to draw power from the battery
       * @param {number} watts - Power to draw in watts
       * @param {number} deltaTime - Time step in seconds
       * @returns {number} Actual power drawn
       */
      draw(watts, deltaTime) {
        if (!this.connectedToBus || !this.enabled) {
          return 0;
        }

        // During teleportation, allow higher discharge rates (capacitor assist)
        const maxRate = powerSystem.teleportInProgress ? watts : this.maxDischargeRate;
        
        // Limit by max discharge rate
        const actualWatts = Math.min(watts, maxRate);
        
        // Calculate energy in watt-hours for this time step
        const energyRequested = (actualWatts * deltaTime) / 3600;
        
        // Can't draw more than current charge
        const energyDrawn = Math.min(energyRequested, this.currentCharge);
        
        // Track teleportation energy if teleport is in progress
        if (powerSystem.teleportInProgress) {
          this.teleportEnergyDrawn += energyDrawn;
        }
        
        // Update charge
        const previousCharge = this.currentCharge;
        this.currentCharge = Math.max(0, this.currentCharge - energyDrawn);
        
        // Emit events for charge level changes
        this.checkChargeThresholds(previousCharge);
        
        // Apply degradation from discharge
        this.applyDegradation(deltaTime);
        
        // Return actual watts drawn
        return (energyDrawn / deltaTime) * 3600;
      }

      /**
       * Attempt to charge the battery
       * @param {number} watts - Power to charge with in watts
       * @param {number} deltaTime - Time step in seconds
       * @returns {number} Actual power accepted
       */
      charge(watts, deltaTime) {
        if (!this.connectedToBus || !this.enabled) {
          // Debug: Log why we're rejecting charge
          if (Math.random() < 0.01) { // Log 1% of the time to avoid spam
            console.log(`[CHARGE REJECTED] Battery ${this.id}: connectedToBus=${this.connectedToBus}, enabled=${this.enabled}`);
          }
          return 0;
        }

        const effectiveCapacity = this.getEffectiveCapacity();
        const availableCapacity = effectiveCapacity - this.currentCharge;
        
        if (availableCapacity <= 0) {
          return 0; // Already full
        }

        // Limit by max charge rate
        const actualWatts = Math.min(watts, this.maxChargeRate);
        
        // Calculate energy in watt-hours for this time step
        // Power (W) Ã— Time (s) / 3600 (s/h) = Energy (Wh)
        const energyOffered = (actualWatts * deltaTime) / 3600;
        
        // Apply efficiency loss
        const energyAccepted = Math.min(energyOffered * this.efficiency, availableCapacity);
        
        // Update charge
        const previousCharge = this.currentCharge;
        this.currentCharge = Math.min(effectiveCapacity, this.currentCharge + energyAccepted);
        
        // Debug logging (remove later)
        if (Math.random() < 0.001) { // Log occasionally
          console.log(`[CHARGE DEBUG] Battery ${this.id}: watts=${watts.toFixed(1)}W, dt=${deltaTime.toFixed(4)}s, energy=${energyOffered.toFixed(4)}Wh, accepted=${energyAccepted.toFixed(4)}Wh, charge=${previousCharge.toFixed(1)}â†’${this.currentCharge.toFixed(1)}Wh`);
        }
        
        // Emit events for charge level changes
        this.checkChargeThresholds(previousCharge);
        
        // Apply degradation from charging
        this.applyDegradation(deltaTime * 0.5); // Charging causes less degradation
        
        // Return actual watts accepted (accounting for efficiency)
        return (energyAccepted / this.efficiency) * 3600 / deltaTime;
      }

      /**
       * Check for threshold crossings and emit events
       */
      checkChargeThresholds(previousCharge) {
        const currentPercent = this.getChargePercentage();
        const previousPercent = (previousCharge / this.maxCapacity) * 100;

        // Critical low (5%)
        if (previousPercent > 5 && currentPercent <= 5) {
          eventBus.emit('battery:critical', { battery: this });
        }

        // Low (20%)
        if (previousPercent > 20 && currentPercent <= 20) {
          eventBus.emit('battery:low', { battery: this });
        }

        // Empty (0%)
        if (previousPercent > 0 && currentPercent <= 0) {
          eventBus.emit('battery:depleted', { battery: this });
        }

        // Full (100%)
        if (previousPercent < 100 && currentPercent >= 100) {
          eventBus.emit('battery:full', { battery: this });
        }

        // General charge change
        eventBus.emit('battery:charge-changed', { battery: this, previousPercent, currentPercent });
      }

      /**
       * Apply degradation over time
       */
      applyDegradation(deltaTime) {
        // Temperature-based degradation
        let tempFactor = 1.0;
        if (this.temperature < this.optimalTempMin) {
          tempFactor = 1.2;
        } else if (this.temperature > this.optimalTempMax) {
          tempFactor = 1.5;
        }

        // Apply degradation
        const degradation = this.degradationRate * tempFactor * (deltaTime / 3600);
        this.health = Math.max(0, this.health - degradation);

        // Update cycle count (rough approximation)
        this.cycleCount += (deltaTime / 3600) / 24; // Assume 1 cycle per day of operation

        if (this.health < 50 && this.health > 49.9) {
          eventBus.emit('battery:degraded', { battery: this });
        }
      }

      /**
       * Connect battery to main bus
       */
      connectToBus() {
        if (!this.connectedToBus) {
          this.connectedToBus = true;
          eventBus.emit('battery:connected', { battery: this });
        }
      }

      /**
       * Disconnect battery from main bus
       */
      disconnectFromBus() {
        if (this.connectedToBus) {
          this.connectedToBus = false;
          eventBus.emit('battery:disconnected', { battery: this });
        }
      }

      /**
       * Toggle bus connection
       */
      toggleBus() {
        if (this.connectedToBus) {
          this.disconnectFromBus();
        } else {
          this.connectToBus();
        }
        
        // Debug logging
        console.log(`[BUS TOGGLE] Battery ${this.id}: connectedToBus=${this.connectedToBus}, enabled=${this.enabled}`);
      }

      /**
       * Get status object for display
       */
      getStatus() {
        return {
          id: this.id,
          charge: this.currentCharge,
          chargePercent: this.getChargePercentage(),
          maxCapacity: this.maxCapacity,
          effectiveCapacity: this.getEffectiveCapacity(),
          health: this.health,
          connected: this.connectedToBus,
          enabled: this.enabled,
          temperature: this.temperature,
          cycleCount: this.cycleCount
        };
      }
    }

    // ============================================================================
    // POWER BUS SYSTEM - Main power distribution
    // ============================================================================
    class PowerBus {
      constructor() {
        this.currentDraw = 0; // Current power being drawn (watts)
        this.currentSupply = 0; // Current power being supplied (watts)
        this.voltage = 48; // Bus voltage (volts)
        this.maxCurrent = 500; // Max current (amps)
      }

      /**
       * Get maximum power capacity of the bus
       */
      getMaxPower() {
        return this.voltage * this.maxCurrent; // 24000W = 24kW
      }

      /**
       * Get bus utilization percentage
       */
      getUtilization() {
        return Math.min(100, (this.currentDraw / this.getMaxPower()) * 100);
      }

      /**
       * Check if power demand can be met
       */
      canSupply(watts) {
        return watts <= this.getMaxPower();
      }
    }

    // Create main power bus
    const mainBus = new PowerBus();

    // ============================================================================
    // SOLAR PANEL SYSTEM
    // ============================================================================
    class SolarPanelSystem {
      constructor() {
        this.panelState = 1; // 0=retracted, 1=stopped, 2=extended
        this.extension = 0.5; // 0.0 to 1.0 (0% to 100% extended)
        this.extensionSpeed = 0.1; // Extension/retraction rate per second
        this.maxPowerOutput = 12600; // Watts at full extension (sized for exactly 10min battery charge)
        this.currentOutput = 0; // Current power generation
        this.efficiency = 0.85; // 85% efficient
        this.temperature = 20; // Celsius
        this.connectedToBus = true; // Whether panels are connected to main bus
        
        // Physical specifications (two 33mÂ² arrays = 66mÂ² total, ~165kg total mass)
        this.panelArea = 66; // mÂ² - total deployed area
        this.panelMass = 165; // kg - total mass of both panel arrays
        
        // Motor power consumption (realistic for 165kg solar arrays)
        // Based on: deployment actuators (~25W), control electronics (~10W), 
        // structural locks (~20W), motors (~5W), sensors (~5W), friction losses (~35W)
        this.motorBasePower = 100; // Watts baseline when extending/retracting
        this.currentMotorDraw = 0; // Current motor power draw
        
        // Sunlight intensity (simulated)
        // TODO: Later this will vary by distance from local sun/planet
        this.sunlightIntensity = 1.0; // 0.0 to 1.0 (currently full sun for testing)
      }

      /**
       * Get current power output based on extension and conditions
       */
      getPowerOutput() {
        if (!this.connectedToBus) {
          return 0; // No power if not connected to bus
        }
        // Power scales with extension percentage and sunlight
        const output = this.maxPowerOutput * this.extension * this.sunlightIntensity * this.efficiency;
        return Math.max(0, output);
      }

      /**
       * Get motor power draw - motors draw power when moving
       */
      getMotorDraw() {
        // Motors only draw power when extending or retracting
        if (this.panelState === 1) {
          return 0; // Stopped, no motor draw
        }

        // Check if we have power available to run motors
        // Motors can run if:
        // 1. At least one battery is connected to bus, OR
        // 2. Solar panels are connected and partially extended (generating power)
        
        const hasBatteryPower = batterySystem.getConnectedBatteries().length > 0;
        const hasSolarPower = this.connectedToBus && this.extension > 0;
        
        if (!hasBatteryPower && !hasSolarPower) {
          return 0; // No power source available
        }

        // Calculate base motor power with realistic load variation
        // Power increases with extension due to moment arm (torque = force Ã— distance)
        // At 0% extension: 60W (initial deployment, structural locks releasing)
        // At 50% extension: 100W (baseline)
        // At 100% extension: 140W (maximum moment arm, highest torque required)
        const loadFactor = 0.6 + (0.8 * this.extension); // 0.6 to 1.4
        const basePower = this.motorBasePower * loadFactor;

        // If only solar power, voltage is lower, motors run slower
        // Calculate effective voltage based on available power
        let effectiveVoltage = mainBus.voltage;
        
        if (!hasBatteryPower && hasSolarPower) {
          // Running on solar alone - voltage drops based on solar output
          const solarOutput = this.getPowerOutput();
          effectiveVoltage = Math.min(mainBus.voltage, (solarOutput / basePower) * mainBus.voltage);
        }

        // Motor speed scales with voltage (power = nominal * (V/V_nominal)^2)
        const voltageRatio = effectiveVoltage / mainBus.voltage;
        return basePower * Math.pow(voltageRatio, 2);
      }

      /**
       * Set panel control state
       * @param {number} state - 0=retract, 1=stop, 2=extend
       */
      setPanelState(state) {
        this.panelState = state;
        eventBus.emit('solar:state-changed', { state: this.panelState });
      }

      /**
       * Update panel extension based on current state
       */
      update(deltaTime) {
        // Calculate motor draw first
        this.currentMotorDraw = this.getMotorDraw();

        // Extension/retraction speed scales with motor power
        let effectiveSpeed = this.extensionSpeed;
        if (this.currentMotorDraw < this.motorPower) {
          // Slower movement at reduced power
          effectiveSpeed *= Math.sqrt(this.currentMotorDraw / this.motorPower);
        }

        if (this.panelState === 0) {
          // Retracting
          this.extension = Math.max(0, this.extension - effectiveSpeed * deltaTime);
          if (this.extension <= 0) {
            eventBus.emit('solar:fully-retracted', {});
          }
        } else if (this.panelState === 2) {
          // Extending
          this.extension = Math.min(1, this.extension + effectiveSpeed * deltaTime);
          if (this.extension >= 1) {
            eventBus.emit('solar:fully-extended', {});
          }
        }
        // State 1 = stopped, no change

        // Calculate current output
        this.currentOutput = this.getPowerOutput();
      }

      /**
       * Simulate sunlight changes (day/night cycle, distance from star, etc.)
       */
      updateSunlight(intensity) {
        this.sunlightIntensity = Math.max(0, Math.min(1, intensity));
      }

      /**
       * Get status
       */
      getStatus() {
        return {
          state: this.panelState,
          extension: this.extension,
          extensionPercent: this.extension * 100,
          currentOutput: this.currentOutput,
          maxOutput: this.maxPowerOutput,
          sunlightIntensity: this.sunlightIntensity,
          temperature: this.temperature
        };
      }
    }

    // Create solar panel system
    const solarSystem = new SolarPanelSystem();

    // ============================================================================
    // POWER MANAGEMENT SYSTEM
    // ============================================================================
    class PowerManagementSystem {
      constructor() {
        this.baseLoad = 50; // Base power consumption (life support, computers, etc.)
        this.systemLoads = {
          navigation: 250, // Star tracking cameras (40W), database (25W), GPUs (150W), interfaces (10W), cooling (25W)
          sensors: 15,
          communications: 10,
          lifeSupportExtra: 30,
          traderComms: 800 // High-power radio, signal processing, AI translation, computing
        };
        this.activeSystems = new Set(['navigation', 'sensors', 'communications']);
        
        // Teleportation state
        this.teleportInProgress = false;
        this.teleportStartTime = 0;
        this.teleportDuration = 3.0; // 3 seconds to complete teleportation
        this.teleportPowerDraw = 12000; // 12 kW during teleportation (12kW Ã— 3s / 3600 = 10Wh per second Ã— 3s = 30Wh... wait)
        // Actually: 100Wh over 3 seconds = 33.33Wh per second = 120,000W
        // Let's use 10 seconds for more dramatic effect: 100Wh / 10s = 10Wh/s = 36,000W
        this.teleportTotalEnergy = 100; // Wh total
      }

      /**
       * Calculate total power draw from all systems
       */
      getTotalDraw() {
        let total = this.baseLoad;
        
        // Add active system loads
        this.activeSystems.forEach(system => {
          total += this.systemLoads[system] || 0;
        });
        
        // Add solar panel motor draw
        total += solarSystem.currentMotorDraw;
        
        // Add teleportation draw if active
        if (this.teleportInProgress) {
          // Convert Wh to W for the duration
          total += (this.teleportTotalEnergy / this.teleportDuration) * 3600; // Wh â†’ W
        }
        
        return total;
      }

      /**
       * Enable a system
       */
      enableSystem(systemName) {
        this.activeSystems.add(systemName);
        eventBus.emit('power:system-enabled', { system: systemName });
        console.log(`âš¡ System '${systemName}' enabled (${this.systemLoads[systemName]}W)`);
      }

      /**
       * Disable a system
       */
      disableSystem(systemName) {
        this.activeSystems.delete(systemName);
        eventBus.emit('power:system-disabled', { system: systemName });
        console.log(`âš¡ System '${systemName}' disabled`);
      }

      /**
       * Check if power is available to run systems
       * Returns true if solar is connected or any battery is connected with charge
       */
      isPowerAvailable() {
        // Check if solar panel is connected and producing power
        // Use getPowerOutput() instead of currentOutput to get real-time calculation
        if (solarSystem.connectedToBus && solarSystem.getPowerOutput() > 0) {
          return true;
        }
        
        // Check if any battery is connected with available charge
        const connectedBatteries = batterySystem.getConnectedBatteries();
        for (const battery of connectedBatteries) {
          if (battery.currentCharge > 10) { // At least 10Wh available
            return true;
          }
        }
        
        return false;
      }

      /**
       * Start teleportation sequence
       * @param {string} eventName - Name of the event
       * @param {number} energyWh - Energy required in watt-hours
       * @returns {boolean} - True if started, false if insufficient power or already in progress
       */
      startTeleportation(eventName, energyWh) {
        if (this.teleportInProgress) {
          console.warn('âš ï¸ Teleportation already in progress');
          return false;
        }

        // Check if we have connected batteries with enough charge
        // Teleportation requires battery power (solar can't provide the burst power needed)
        const connectedBatteries = batterySystem.getConnectedBatteries();
        const availablePower = connectedBatteries.reduce((sum, b) => sum + b.currentCharge, 0);
        
        if (connectedBatteries.length === 0) {
          console.error(`âŒ Cannot ${eventName}: No batteries connected to bus`);
          eventBus.emit('power:teleport-failed', { event: eventName, required: energyWh, available: 0, reason: 'No batteries connected' });
          return false;
        }
        
        if (availablePower < energyWh) {
          console.error(`âŒ Insufficient power for ${eventName}: need ${energyWh}Wh, have ${availablePower.toFixed(1)}Wh`);
          eventBus.emit('power:teleport-failed', { event: eventName, required: energyWh, available: availablePower });
          return false;
        }

        this.teleportInProgress = true;
        this.teleportStartTime = performance.now() / 1000; // Convert to seconds
        this.teleportTotalEnergy = energyWh;
        
        console.log(`ðŸŒ€ ${eventName} initiated: ${energyWh}Wh over ${this.teleportDuration}s (${((energyWh / this.teleportDuration) * 3600).toFixed(0)}W)`);
        eventBus.emit('power:teleport-started', { event: eventName, energy: energyWh, duration: this.teleportDuration });
        
        return true;
      }

      /**
       * Update power draw on the main bus and handle teleportation
       */
      update(deltaTime) {
        // Check if teleportation is complete
        if (this.teleportInProgress) {
          const currentTime = performance.now() / 1000;
          const elapsed = currentTime - this.teleportStartTime;
          
          if (elapsed >= this.teleportDuration) {
            this.teleportInProgress = false;
            const totalEnergyDrawn = batterySystem.batteries.reduce((sum, b) => sum + b.teleportEnergyDrawn, 0);
            console.log(`âœ… Teleportation complete! Total energy consumed: ${totalEnergyDrawn.toFixed(1)}Wh`);
            // Per-battery breakdown (to verify only connected batteries drained)
            batterySystem.batteries.forEach(b => {
              if (b.teleportEnergyDrawn > 0.0001) {
                console.log(`   â€¢ Battery ${b.id} drained ${b.teleportEnergyDrawn.toFixed(3)}Wh during teleport (connected=${b.connectedToBus}, enabled=${b.enabled})`);
              } else {
                console.log(`   â€¢ Battery ${b.id} drained ~0Wh during teleport (connected=${b.connectedToBus}, enabled=${b.enabled})`);
              }
            });
            
            // Reset tracking
            batterySystem.batteries.forEach(b => b.teleportEnergyDrawn = 0);
            
            eventBus.emit('power:teleport-complete', {});
          }
        }

        mainBus.currentDraw = this.getTotalDraw();
      }
    }

    // Create power management system
    const powerSystem = new PowerManagementSystem();

    // ============================================================================
    // FUEL SYSTEM - Manages fuel tank and credits
    // ============================================================================
    class FuelSystem {
      constructor() {
        this.maxCapacity = 1000; // Liters
        this.currentFuel = 280; // Start at 28%
        this.refuelCostPerLiter = 1; // 1 credit per liter
        this.credits = 10000; // Starting credits
      }

      /**
       * Get fuel percentage
       */
      getFuelPercentage() {
        return (this.currentFuel / this.maxCapacity) * 100;
      }

      /**
       * Calculate cost to refuel to max
       */
      getRefuelCost() {
        const fuelNeeded = this.maxCapacity - this.currentFuel;
        return Math.ceil(fuelNeeded * this.refuelCostPerLiter);
      }

      /**
       * Attempt to refuel the tank
       * @returns {Object} Result with success flag and message
       */
      refuel() {
        const cost = this.getRefuelCost();
        
        if (this.currentFuel >= this.maxCapacity) {
          return { success: false, message: 'Tank already full!' };
        }
        
        if (this.credits < cost) {
          return { success: false, message: 'Insufficient credits!' };
        }
        
        // Deduct credits and fill tank
        this.credits -= cost;
        this.currentFuel = this.maxCapacity;
        
        eventBus.emit('fuel:refueled', { cost, credits: this.credits });
        
        return { success: true, message: `Refueled! -${cost}â‚µ` };
      }

      /**
       * Use fuel (for travel, not implemented yet)
       */
      consumeFuel(amount) {
        this.currentFuel = Math.max(0, this.currentFuel - amount);
        eventBus.emit('fuel:consumed', { amount, remaining: this.currentFuel });
      }

      /**
       * Get system status
       */
      getStatus() {
        return {
          currentFuel: this.currentFuel,
          maxCapacity: this.maxCapacity,
          fuelPercentage: this.getFuelPercentage(),
          credits: this.credits,
          refuelCost: this.getRefuelCost()
        };
      }
    }

    // Create fuel system
    const fuelSystem = new FuelSystem();

    // ============================================================================
    // TRADING SYSTEM - Manages cargo, traders, and economy
    // ============================================================================
    class TradingSystem {
      constructor() {
        this.cargoCapacity = 20; // 20 slots matching UI
        this.cargo = new Array(this.cargoCapacity).fill(null); // Cargo slots (null = empty)
        this.nextCargoId = 1; // For unique IDs
        
        // Current trader session
        this.currentTrader = null;
        this.currentPage = 0;
        this.isBuying = true; // true = we're buying from trader, false = we're selling to trader
        this.lastHaggleResult = null; // Track last haggle for display
        
        // Offer prices for selling mode - maps cargoId -> current offer price
        this.offerPrices = {}; // When selling, track trader's offer for each cargo item
        
        // Cargo types and their base price ranges (based on fuel @ 1â‚µ/L)
        this.cargoTypes = {
          'Food': { min: 150, max: 300, color: '#8fbc8f', code: 'FD' },
          'Medical Supplies': { min: 200, max: 400, color: '#ff6b6b', code: 'MD' },
          'Electronics': { min: 300, max: 500, color: '#4dabf7', code: 'EL' },
          'Rare Metals': { min: 400, max: 700, color: '#ffd43b', code: 'RM' },
          'Fuel Cells': { min: 250, max: 450, color: '#ff922b', code: 'FC' },
          'Textiles': { min: 100, max: 200, color: '#cc5de8', code: 'TX' },
          'Machinery': { min: 350, max: 600, color: '#868e96', code: 'MC' },
          'Gems': { min: 500, max: 1000, color: '#f783ac', code: 'GM' },
          'Spices': { min: 180, max: 350, color: '#d9480f', code: 'SP' },
          'Art Objects': { min: 600, max: 1200, color: '#845ef7', code: 'AO' },
          'Weapons': { min: 400, max: 800, color: '#343a40', code: 'WP' },
          'Tools': { min: 150, max: 300, color: '#74c0fc', code: 'TL' },
          'Computers': { min: 450, max: 750, color: '#4c6ef5', code: 'CP' },
          'Biomatter': { min: 200, max: 400, color: '#51cf66', code: 'BM' },
          'Alien Artifacts': { min: 800, max: 1500, color: '#be4bdb', code: 'AA' }
        };
        
        // Trader name components
        this.traderTitles = ['Captain', 'Commander', 'Admiral', 'Merchant', 'Trader', 'Baron', 'Duchess'];
        this.traderNames = ['Fingers', 'Rex', 'Nova', 'Blaze', 'Storm', 'Hawk', 'Viper', 'Phoenix', 
                            'Drake', 'Wolf', 'Fox', 'Raven', 'Steel', 'Iron', 'Gold', 'Silver'];
        this.shipAdjectives = ['Stellar', 'Cosmic', 'Void', 'Star', 'Galactic', 'Nebula', 'Solar',
                               'Quantum', 'Astral', 'Celestial', 'Orbital', 'Lunar', 'Deep'];
        this.shipNouns = ['Wanderer', 'Seeker', 'Voyager', 'Explorer', 'Drifter', 'Nomad', 'Pioneer',
                          'Runner', 'Hauler', 'Trader', 'Merchant', 'Cruiser', 'Clipper', 'Banana'];
      }

      /**
       * Simple hash function to generate seed from location coordinates
       * Uses a modified FNV-1a hash algorithm for better distribution
       */
      hashLocation(x, y, planetIndex) {
        // FNV-1a hash with 32-bit
        let hash = 2166136261; // FNV offset basis
        
        // Hash x coordinate
        hash ^= x & 0xff;
        hash = Math.imul(hash, 16777619); // FNV prime
        hash ^= (x >> 8) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (x >> 16) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (x >> 24) & 0xff;
        hash = Math.imul(hash, 16777619);
        
        // Hash y coordinate
        hash ^= y & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (y >> 8) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (y >> 16) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (y >> 24) & 0xff;
        hash = Math.imul(hash, 16777619);
        
        // Hash planet index
        hash ^= planetIndex & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (planetIndex >> 8) & 0xff;
        hash = Math.imul(hash, 16777619);
        
        // Convert to unsigned 32-bit integer
        return hash >>> 0;
      }

      /**
       * Seeded random number generator (mulberry32)
       * Returns a function that generates random numbers 0-1 based on seed
       */
      seededRandom(seed) {
        return function() {
          seed = (seed + 0x6D2B79F5) | 0;
          let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);
          t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      /**
       * Generate a new trader with seeded random inventory based on location
       * Each planet gets consistent trader name and demands
       */
      generateNewTrader() {
        // Get current location from navigation system
        const x = navigationSystem.currentX;
        const y = navigationSystem.currentY;
        const planetIndex = navigationSystem.currentPlanetIndex;
        
        // Create seed from hashed location (one unique trader per planet)
        const seed = this.hashLocation(x, y, planetIndex);
        const rng = this.seededRandom(seed);
        
        // Generate trader identity (seeded)
        const title = this.traderTitles[Math.floor(rng() * this.traderTitles.length)];
        const name = this.traderNames[Math.floor(rng() * this.traderNames.length)];
        const adjective = this.shipAdjectives[Math.floor(rng() * this.shipAdjectives.length)];
        const noun = this.shipNouns[Math.floor(rng() * this.shipNouns.length)];
        
        const availableTypes = Object.keys(this.cargoTypes);
        
        // Shuffle cargo types using seeded random
        const shuffled = [...availableTypes];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        
        // Generate items they're SELLING (2-4 items with quantity 1-5) - seeded
        const sellInventory = [];
        const sellCount = 2 + Math.floor(rng() * 3); // 2-4 items
        
        for (let i = 0; i < sellCount; i++) {
          const type = shuffled[i];
          const priceRange = this.cargoTypes[type];
          const quantity = 1 + Math.floor(rng() * 5); // 1-5 units
          const basePrice = priceRange.min + rng() * (priceRange.max - priceRange.min);
          
          sellInventory.push({
            type,
            quantity,
            basePrice: Math.round(basePrice),
            currentPrice: Math.round(basePrice) // Will be modified by haggling
          });
        }
        
        // Generate items they're BUYING (demand) - 6 different types with quantities
        const demandList = [];
        const demandCount = 6; // Always 6 demands
        const demandStartIndex = sellCount; // Don't overlap with sell items
        
        for (let i = 0; i < demandCount && (demandStartIndex + i) < shuffled.length; i++) {
          const type = shuffled[demandStartIndex + i];
          const quantity = 1 + Math.floor(Math.random() * 10); // Random 1-10 (not seeded)
          demandList.push({ type, quantity });
        }
        
        this.currentTrader = {
          name: `${title} ${name}`,
          ship: `${adjective} ${noun}`,
          personality: ['Friendly', 'Suspicious', 'Greedy', 'Honest', 'Eccentric'][Math.floor(rng() * 5)],
          haggleSkill: 1 + Math.floor(rng() * 10), // 1-10
          inventory: sellInventory, // Items they're selling
          demand: demandList, // Item types they want to buy with quantities
          reputation: 50 + Math.floor(rng() * 50) // 50-100 for neutral-good
        };
        
        this.currentPage = 0;
        this.lastHaggleResult = null;
        
        // Generate offer prices for all cargo items that match trader's demand
        this.offerPrices = {};
        this.cargo.forEach(item => {
          if (item && demandList.some(d => d.type === item.type)) {
            const priceRange = this.cargoTypes[item.type];
            const offerPrice = Math.round(priceRange.min + Math.random() * (priceRange.max - priceRange.min));
            this.offerPrices[item.id] = offerPrice;
          }
        });
      }

      /**
       * Haggle with current trader
       * Returns { success: boolean, priceChange: number, message: string }
       */
      haggle() {
        if (!this.currentTrader) {
          return { success: false, priceChange: 0, message: 'No active trader!' };
        }
        
        const currentItem = this.getCurrentItem();
        if (!currentItem) {
          return { success: false, priceChange: 0, message: 'No item to haggle!' };
        }
        
        // Initialize haggle tracking for this item if needed
        if (!currentItem.haggleAttempts) {
          currentItem.haggleAttempts = 0;
          currentItem.totalHaggleChange = 0;
        }
        
        // Maximum 3 haggle attempts per item
        if (currentItem.haggleAttempts >= 3) {
          return { 
            success: false, 
            priceChange: 0, 
            message: 'Trader won\'t negotiate further!' 
          };
        }
        
        // Haggle success chance decreases with each attempt
        // Base: 60% -> 45% -> 30%
        const baseChance = 60 - (currentItem.haggleAttempts * 15);
        const traderModifier = this.currentTrader.haggleSkill * 3; // 3-30 penalty
        const successChance = Math.max(10, baseChance - traderModifier);
        
        const playerRoll = Math.random() * 100;
        const success = playerRoll < successChance;
        
        currentItem.haggleAttempts++;
        
        if (this.isBuying) {
          // Buying from trader - try to reduce their price
          const basePrice = currentItem.basePrice;
          const currentPrice = currentItem.currentPrice;
          
          if (success) {
            // Success: reduce price by 5-15%
            const changePercent = 0.05 + Math.random() * 0.10;
            const priceChange = Math.round(currentPrice * changePercent);
            currentItem.currentPrice = Math.max(Math.round(basePrice * 0.5), currentPrice - priceChange);
            currentItem.totalHaggleChange -= priceChange;
            this.lastHaggleResult = { success: true, priceChange };
            
            return { 
              success: true, 
              priceChange, 
              message: `Success! Price reduced by ${priceChange}â‚µ` 
            };
          } else {
            // Failure: price increases slightly (2-5%)
            const changePercent = 0.02 + Math.random() * 0.03;
            const priceChange = Math.round(currentPrice * changePercent);
            currentItem.currentPrice = currentPrice + priceChange;
            currentItem.totalHaggleChange += priceChange;
            this.lastHaggleResult = { success: false, priceChange };
            
            return { 
              success: false, 
              priceChange, 
              message: `Failed! Price increased by ${priceChange}â‚µ` 
            };
          }
        } else {
          // Selling to trader - try to increase their offer
          const currentOfferPrice = this.offerPrices[currentItem.id] || 0;
          
          if (success) {
            // Success: increase offer by 5-15%
            const changePercent = 0.05 + Math.random() * 0.10;
            const priceChange = Math.round(currentOfferPrice * changePercent);
            this.offerPrices[currentItem.id] = currentOfferPrice + priceChange;
            currentItem.totalHaggleChange += priceChange;
            this.lastHaggleResult = { success: true, priceChange };
            
            return { 
              success: true, 
              priceChange, 
              message: `Success! Offer increased by ${priceChange}â‚µ` 
            };
          } else {
            // Failure: offer decreases slightly (2-5%)
            const changePercent = 0.02 + Math.random() * 0.03;
            const priceChange = Math.round(currentOfferPrice * changePercent);
            this.offerPrices[currentItem.id] = Math.max(1, currentOfferPrice - priceChange);
            currentItem.totalHaggleChange -= priceChange;
            this.lastHaggleResult = { success: false, priceChange };
            
            return { 
              success: false, 
              priceChange, 
              message: `Failed! Offer reduced by ${priceChange}â‚µ` 
            };
          }
        }
      }

      /**
       * Execute a trade (buy or sell)
       */
      executeTrade() {
        if (!this.currentTrader) {
          return { success: false, message: 'No active trader!' };
        }
        
        if (this.isBuying) {
          // We're buying from trader
          if (!this.currentTrader.inventory || this.currentTrader.inventory.length === 0) {
            return { success: false, message: 'Trader has no inventory!' };
          }
          
          if (this.currentPage >= this.currentTrader.inventory.length) {
            this.currentPage = 0;
          }
          
          const currentItem = this.currentTrader.inventory[this.currentPage];
          if (!currentItem) {
            return { success: false, message: 'No items available!' };
          }
          
          const cost = currentItem.currentPrice;
          
          if (fuelSystem.credits < cost) {
            return { success: false, message: `Insufficient credits! Need ${cost}â‚µ, have ${fuelSystem.credits}â‚µ` };
          }
          
          // Find empty cargo slot
          const emptySlotIndex = this.cargo.findIndex(slot => slot === null);
          if (emptySlotIndex === -1) {
            return { success: false, message: 'Cargo hold full!' };
          }
          
          // Execute purchase
          fuelSystem.credits -= cost;
          currentItem.quantity -= 1;
          
          // Add to cargo
          const cargoItem = {
            id: this.nextCargoId++,
            type: currentItem.type,
            purchasePrice: cost,
            slotIndex: emptySlotIndex
          };
          this.cargo[emptySlotIndex] = cargoItem;
          
          // Remove item from trader inventory if quantity reaches 0
          if (currentItem.quantity <= 0) {
            this.currentTrader.inventory.splice(this.currentPage, 1);
            // Adjust current page if needed
            if (this.currentPage >= this.currentTrader.inventory.length && this.currentPage > 0) {
              this.currentPage--;
            }
          }
          
          console.log(`âœ… Purchased ${cargoItem.type} for ${cost}â‚µ`);
          return { success: true, message: `Purchased ${cargoItem.type} for ${cost}â‚µ` };
          
        } else {
          // We're selling to trader
          if (this.getCargoCount() === 0) {
            return { success: false, message: 'No cargo to sell!' };
          }
          
          // Get current cargo item
          const ourCargoItems = this.cargo.filter(item => item !== null);
          
          if (this.currentPage >= ourCargoItems.length) {
            return { success: false, message: 'Invalid selection!' };
          }
          
          const cargoToSell = ourCargoItems[this.currentPage];
          
          // Check if trader wants this item
          if (this.currentTrader?.demand && this.currentTrader.demand.length > 0) {
            if (!this.currentTrader.demand.some(d => d.type === cargoToSell.type)) {
              return { success: false, message: `Trader doesn't want ${cargoToSell.type}!` };
            }
          }
          
          const salePrice = this.getSellingPrice(cargoToSell);
          const profit = salePrice - cargoToSell.purchasePrice;
          
          // Execute sale
          fuelSystem.credits += salePrice;
          this.cargo[cargoToSell.slotIndex] = null;
          
          // Adjust current page if needed after sale
          const remainingCargoCount = this.getCargoCount();
          if (remainingCargoCount === 0) {
            this.currentPage = 0;
          } else if (this.currentPage >= remainingCargoCount) {
            this.currentPage = remainingCargoCount - 1;
          }
          
          return { 
            success: true, 
            message: `Sold ${cargoToSell.type} for ${salePrice}â‚µ (${profit > 0 ? '+' : ''}${profit}â‚µ)` 
          };
        }
      }

      /**
       * Calculate selling price for a cargo item
       * Uses the current offer price from offerPrices map
       */
      getSellingPrice(cargoItem) {
        // Return the trader's current offer price for this cargo item
        return this.offerPrices[cargoItem.id] || 0;
      }

      /**
       * Get current item (buying from trader) or cargo (selling to trader)
       */
      getCurrentItem() {
        if (this.isBuying) {
          // Buying from trader - show their inventory
          return this.currentTrader?.inventory[this.currentPage] || null;
        } else {
          // Selling to trader - show ALL our cargo (one per page)
          const ourCargo = this.cargo.filter(item => item !== null);
          return ourCargo[this.currentPage] || null;
        }
      }

      /**
       * Navigate to next page
       */
      nextPage() {
        if (this.isBuying) {
          const maxIndex = Math.max(0, (this.currentTrader?.inventory.length || 0) - 1);
          this.currentPage = Math.min(this.currentPage + 1, maxIndex);
        } else {
          const maxIndex = Math.max(0, this.getCargoCount() - 1);
          this.currentPage = Math.min(this.currentPage + 1, maxIndex);
        }
        this.lastHaggleResult = null; // Reset haggle on page change
      }

      /**
       * Navigate to previous page
       */
      prevPage() {
        this.currentPage = Math.max(0, this.currentPage - 1);
        this.lastHaggleResult = null; // Reset haggle on page change
      }

      /**
       * Get maximum page count (for display purposes)
       */
      getMaxPage() {
        if (this.isBuying) {
          return this.currentTrader?.inventory.length || 0;
        } else {
          return this.getCargoCount();
        }
      }

      /**
       * Set trading mode (buying/selling)
       */
      setMode(isBuying) {
        if (this.isBuying !== isBuying) {
          this.isBuying = isBuying;
          this.currentPage = 0;
          this.lastHaggleResult = null;
          // Generate new trader when switching modes
          this.generateNewTrader();
        }
      }

      /**
       * Get count of cargo items
       */
      getCargoCount() {
        return this.cargo.filter(item => item !== null).length;
      }

      /**
       * Get cargo items as array
       */
      getCargoItems() {
        return this.cargo.filter(item => item !== null);
      }

      /**
       * Generate starting cargo for new game (5 random items)
       */
      generateStartingCargo() {
        // Clear existing cargo
        this.cargo = new Array(this.cargoCapacity).fill(null);
        this.nextCargoId = 1;
        
        // Generate 5 random cargo items
        const availableTypes = Object.keys(this.cargoTypes);
        
        for (let i = 0; i < 5; i++) {
          // Pick random cargo type
          const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
          const priceRange = this.cargoTypes[type];
          
          // Purchase price is somewhere in the range (simulating we bought it previously)
          const purchasePrice = Math.round(priceRange.min + Math.random() * (priceRange.max - priceRange.min));
          
          // Add to cargo in slot i
          this.cargo[i] = {
            id: this.nextCargoId++,
            type,
            purchasePrice,
            slotIndex: i
          };
        }
        
        console.log('ðŸ“¦ Generated 5 starting cargo items');
      }

      /**
       * Swap cargo items between two slots
       * @param {number} fromIndex - Source slot index
       * @param {number} toIndex - Destination slot index
       */
      swapCargo(fromIndex, toIndex) {
        // Validate indices
        if (fromIndex < 0 || fromIndex >= this.cargoCapacity || 
            toIndex < 0 || toIndex >= this.cargoCapacity) {
          return false;
        }
        
        // Swap the items
        const temp = this.cargo[fromIndex];
        this.cargo[fromIndex] = this.cargo[toIndex];
        this.cargo[toIndex] = temp;
        
        // Update slot indices if items exist
        if (this.cargo[fromIndex]) {
          this.cargo[fromIndex].slotIndex = fromIndex;
        }
        if (this.cargo[toIndex]) {
          this.cargo[toIndex].slotIndex = toIndex;
        }
        
        console.log(`ðŸ“¦ Swapped cargo: slot ${fromIndex} â†” slot ${toIndex}`);
        return true;
      }

      /**
       * Get status for display
       */
      getStatus() {
        const currentItem = this.getCurrentItem();
        const maxPage = this.getMaxPage();
        
        return {
          trader: this.currentTrader,
          isBuying: this.isBuying,
          currentPage: this.currentPage,
          maxPage,
          currentItem,
          cargoCount: this.getCargoCount(),
          cargoCapacity: this.cargoCapacity,
          lastHaggleResult: this.lastHaggleResult
        };
      }
    }

    // Create trading system
    const tradingSystem = new TradingSystem();

    // ============================================================================
    // BATTERY SYSTEM - Manages all batteries
    // ============================================================================
    class BatterySystem {
      constructor() {
        this.batteries = [];
        this.totalPowerDraw = 0;
        this.totalPowerCharge = 0;
        this.setupEventListeners();
      }

      /**
       * Add a battery to the system
       */
      addBattery(config) {
        const id = String.fromCharCode(65 + this.batteries.length); // A, B, C, etc.
        const battery = new Battery(id, config);
        this.batteries.push(battery);
        eventBus.emit('battery:added', { battery });
        return battery;
      }

      /**
       * Get battery by ID
       */
      getBattery(id) {
        return this.batteries.find(b => b.id === id);
      }

      /**
       * Get all connected batteries
       */
      getConnectedBatteries() {
        return this.batteries.filter(b => b.connectedToBus && b.enabled);
      }

      /**
       * Get total available power from all connected batteries
       */
      getTotalAvailablePower() {
        return this.getConnectedBatteries().reduce((sum, b) => {
          return sum + b.currentCharge;
        }, 0);
      }

      /**
       * Get total capacity
       */
      getTotalCapacity() {
        return this.batteries.reduce((sum, b) => {
          return sum + b.getEffectiveCapacity();
        }, 0);
      }

      /**
       * Get average charge percentage across all batteries
       */
      getAverageCharge() {
        if (this.batteries.length === 0) return 0;
        const total = this.batteries.reduce((sum, b) => sum + b.getChargePercentage(), 0);
        return total / this.batteries.length;
      }

      /**
       * Draw power from the battery system
       * Distributes load across connected batteries proportionally
       */
      drawPower(watts, deltaTime) {
        const connectedBatteries = this.getConnectedBatteries();
        
        if (connectedBatteries.length === 0) {
          eventBus.emit('power:no-batteries', { requested: watts });
          return 0;
        }

        // Calculate total available charge
        const totalCharge = connectedBatteries.reduce((sum, b) => sum + b.currentCharge, 0);
        
        if (totalCharge <= 0) {
          eventBus.emit('power:depleted', { requested: watts });
          return 0;
        }

        let totalDrawn = 0;

        // Distribute load proportionally based on current charge
        connectedBatteries.forEach(battery => {
          const proportion = battery.currentCharge / totalCharge;
          const requestedFromBattery = watts * proportion;
          const actualDrawn = battery.draw(requestedFromBattery, deltaTime);
          totalDrawn += actualDrawn;
        });

        this.totalPowerDraw = totalDrawn;

        // Check if we couldn't meet demand
        if (totalDrawn < watts * 0.9) { // Allow 10% tolerance
          eventBus.emit('power:insufficient', { 
            requested: watts, 
            actual: totalDrawn,
            deficit: watts - totalDrawn
          });
        }

        return totalDrawn;
      }

      /**
       * Charge batteries from available power
       * Distributes charging across connected batteries
       */
      chargeBatteries(watts, deltaTime) {
        const connectedBatteries = this.getConnectedBatteries();
        
        // Debug: Log which batteries are connected
        if (Math.random() < 0.01) { // Log 1% of the time
          console.log(`[CHARGE SYSTEM] Connected batteries: [${connectedBatteries.map(b => `${b.id}(${b.connectedToBus})`).join(', ')}]`);
        }
        
        if (connectedBatteries.length === 0) {
          return 0;
        }

        // Find batteries that can accept charge
        const chargingBatteries = connectedBatteries.filter(b => {
          return b.currentCharge < b.getEffectiveCapacity();
        });

        if (chargingBatteries.length === 0) {
          return 0; // All batteries full
        }

        let totalAccepted = 0;

        // Distribute charge evenly
        const wattsPerBattery = watts / chargingBatteries.length;
        
        chargingBatteries.forEach(battery => {
          const actualAccepted = battery.charge(wattsPerBattery, deltaTime);
          totalAccepted += actualAccepted;
        });

        this.totalPowerCharge = totalAccepted;

        return totalAccepted;
      }

      /**
       * Update all batteries
       */
      update(deltaTime) {
        this.batteries.forEach(battery => {
          if (battery.enabled) {
            battery.update(deltaTime);
          }
        });

        // Check for system-wide power failure
        const availablePower = this.getTotalAvailablePower();
        if (availablePower <= 0 && this.getConnectedBatteries().length > 0) {
          eventBus.emit('power:system-failure', { system: 'batteries' });
        }
      }

      /**
       * Setup event listeners for system-level responses
       */
      setupEventListeners() {
        // Example: Log critical battery events
        eventBus.on('battery:critical', (data) => {
          console.warn(`ðŸ”‹ Battery ${data.battery.id} is critically low!`);
        });

        eventBus.on('battery:depleted', (data) => {
          console.error(`ðŸ”‹ Battery ${data.battery.id} is depleted!`);
        });

        eventBus.on('power:system-failure', (data) => {
          console.error(`âš ï¸ POWER SYSTEM FAILURE: ${data.system}`);
        });
      }

      /**
       * Get system status
       */
      getStatus() {
        return {
          batteries: this.batteries.map(b => b.getStatus()),
          totalCapacity: this.getTotalCapacity(),
          totalAvailable: this.getTotalAvailablePower(),
          averageCharge: this.getAverageCharge(),
          connectedCount: this.getConnectedBatteries().length,
          totalCount: this.batteries.length,
          currentDraw: this.totalPowerDraw,
          currentCharge: this.totalPowerCharge
        };
      }
    }

    // ============================================================================
    // GAME INITIALIZATION
    // ============================================================================
    
    // Create battery system
    const batterySystem = new BatterySystem();

    /**
     * Initialize a new game with default values
     */
    function initializeNewGame() {
      console.log('ðŸŽ® Initializing new game...');

      // Clear existing batteries
      batterySystem.batteries = [];

      // Add two batteries with NEW specifications (2000 Wh, 10-min charge time)
      batterySystem.addBattery({
        maxCapacity: 2000,
        initialCharge: 1400, // 70%
        maxChargeRate: 12600, // Can accept full solar output
        maxDischargeRate: 1000,
        connectedToBus: true
      });

      batterySystem.addBattery({
        maxCapacity: 2000,
        initialCharge: 1160, // 58%
        maxChargeRate: 12600, // Can accept full solar output
        maxDischargeRate: 1000,
        connectedToBus: true
      });

      // Reset solar panels (NEW specifications)
      solarSystem.panelState = 1; // Stopped
      solarSystem.extension = 0.5; // 50% extended
      solarSystem.sunlightIntensity = 1.0; // 100% sunlight (full sun strength for testing)
      solarSystem.connectedToBus = true; // Connected to main bus

      // Reset power systems
      powerSystem.activeSystems = new Set(['navigation', 'sensors', 'communications']);

      // Reset navigation system to starting position
      navigationSystem.currentX = 0;
      navigationSystem.currentY = 0;
      navigationSystem.currentPlanetIndex = 0;
      navigationSystem.viewMode = 'system';
      navigationSystem.cursorIndex = 0;
      navigationSystem.traveling = false;
      navigationSystem.travelStartTime = 0;
      navigationSystem.travelTarget = null;
      
      // Update sun strength for starting planet
      const sunStrength = navigationSystem.getSunStrength();
      solarSystem.updateSunlight(sunStrength);

      // Reset fuel system
      fuelSystem.currentFuel = 280; // Start with 280L fuel (28%)
      fuelSystem.credits = 10000; // Starting credits

      // Initialize trading system with starting cargo
      tradingSystem.generateStartingCargo();

      // Update all UI
      updateAllUI();

      // Save the new game state
      saveSystem.save();
      
      eventBus.emit('game:new-game', {});
      console.log('âœ… New game initialized');
    }

    /**
     * Load game from saved state
     */
    function loadGameFromSave(saveData) {
      console.log('ðŸ“‚ Loading game from save...');

      // Clear existing batteries
      batterySystem.batteries = [];

      // Restore batteries
      if (saveData.batteries) {
        saveData.batteries.forEach(batteryData => {
          const battery = new Battery(batteryData.id, {
            maxCapacity: batteryData.maxCapacity,
            initialCharge: batteryData.currentCharge,
            maxDischargeRate: batteryData.maxDischargeRate,
            maxChargeRate: batteryData.maxChargeRate,
            efficiency: batteryData.efficiency,
            health: batteryData.health,
            connectedToBus: batteryData.connectedToBus,
            temperature: batteryData.temperature,
            cycleCount: batteryData.cycleCount
          });
          battery.enabled = batteryData.enabled;
          batterySystem.batteries.push(battery);
        });
      }

      // Restore solar panels
      if (saveData.solar) {
        solarSystem.panelState = saveData.solar.panelState;
        solarSystem.extension = saveData.solar.extension;
        solarSystem.sunlightIntensity = saveData.solar.sunlightIntensity;
        solarSystem.connectedToBus = saveData.solar.connectedToBus !== undefined ? saveData.solar.connectedToBus : true;
      }

      // Restore fuel system
      if (saveData.fuel) {
        fuelSystem.currentFuel = saveData.fuel.currentFuel;
        fuelSystem.credits = saveData.fuel.credits;
      }

      // Restore navigation
      if (saveData.navigation) {
        navigationSystem.currentX = saveData.navigation.x;
        navigationSystem.currentY = saveData.navigation.y;
        navigationSystem.currentPlanetIndex = saveData.navigation.planetIndex || 0;
        navigationSystem.viewMode = saveData.navigation.viewMode || 'system';
        navigationSystem.cursorIndex = saveData.navigation.cursorIndex || 0;
        
        // Update sun strength based on loaded planet
        const sunStrength = navigationSystem.getSunStrength();
        solarSystem.updateSunlight(sunStrength);
      }

      // Restore power systems
      if (saveData.power) {
        powerSystem.activeSystems = new Set(saveData.power.activeSystems);
      }

      // Restore trading/cargo
      if (saveData.trading) {
        tradingSystem.cargo = new Array(tradingSystem.cargoCapacity).fill(null);
        if (saveData.trading.cargo) {
          saveData.trading.cargo.forEach((item, index) => {
            if (item) {
              tradingSystem.cargo[index] = {
                id: item.id,
                type: item.type,
                purchasePrice: item.purchasePrice,
                slotIndex: item.slotIndex
              };
            }
          });
        }
        if (saveData.trading.nextCargoId) {
          tradingSystem.nextCargoId = saveData.trading.nextCargoId;
        }
      }

      // Update all UI
      updateAllUI();

      // Set last save time
      saveSystem.lastSaveTime = saveData.timestamp;

      eventBus.emit('game:loaded', { timestamp: saveData.timestamp });
      console.log('âœ… Game loaded from save');
    }

    /**
     * Update all UI elements from current game state
     */
    function updateAllUI() {
      // Update all batteries
      batterySystem.batteries.forEach(battery => {
        updateBatteryUI(battery);
        updateBatteryToggleUI(battery);
      });

      // Update solar panel UI
      updateSolarPanelUI();
      updatePowerDrawUI();
      
      // Update Fuel UI
      updateFuelUI();
      
      // Update Navigation UI
      updateNavigationUI();
      
      // Update Trader Comms UI
      updateTraderCommsUI();

      // Update other UI elements here
      updateSaveStatusUI();
    }

    function updateFuelUI() {
      const fuelSection = document.querySelectorAll('.panel')[2]; // Fuel panel (index 2)
      const fuelGauge = fuelSection.querySelector('.gauge');
      const fuelTerminal = fuelSection.querySelector('.crt pre');
      
      if (fuelGauge) {
        const fuelPercent = fuelSystem.getFuelPercentage();
        fuelGauge.style.setProperty('--value', fuelPercent.toFixed(1));
      }
      
      if (fuelTerminal) {
        const refuelCost = fuelSystem.getRefuelCost();
        fuelTerminal.textContent = `Current credits: ${fuelSystem.credits}â‚µ\nCost to refuel : ${refuelCost}â‚µ`;
      }
    }

    function updateNavigationUI() {
      const navigationSection = document.querySelectorAll('.panel')[1]; // Navigation panel (index 1)
      const navTerminal = navigationSection.querySelector('.crt pre');
      const navDial = navigationSection.querySelector('.dial input');
      const navPowerToggle = navigationSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const navButtons = navigationSection.querySelectorAll('.btn');
      
      const isNavigationEnabled = powerSystem.activeSystems.has('navigation');
      const isPowerAvailable = powerSystem.isPowerAvailable();
      const isPowered = isNavigationEnabled && isPowerAvailable;
      
      if (navPowerToggle) {
        navPowerToggle.checked = isNavigationEnabled;
        // Disable toggle if no power available
        navPowerToggle.disabled = !isPowerAvailable;
      }

      if (navTerminal) {
        if (!isPowered) {
          // Power off or no power available: clear screen but keep 9 lines
          const lines = [];
          for (let i = 0; i < 9; i++) {
            lines.push('\u00A0'); // Non-breaking space
          }
          navTerminal.textContent = lines.join('\n');
        } else if (navigationSystem.showingBlockedMessage) {
          // Show travel blocked message (always 9 lines)
          const lines = [];
          navigationSystem.blockedMessageLines.forEach(line => {
            lines.push(line);
          });
          // Pad to exactly 9 lines with non-breaking spaces
          while (lines.length < 9) lines.push('\u00A0');
          navTerminal.textContent = lines.slice(0, 9).join('\n');
        } else {
          // Power on: show normal navigation info
          const system = navigationSystem.getCurrentSystem();
          let lines = [];
          
          if (navigationSystem.traveling) {
            // Show travel progress (always 9 lines)
            const currentTime = performance.now() / 1000;
            const elapsed = currentTime - navigationSystem.travelStartTime;
            const progress = Math.min((elapsed / navigationSystem.travelDuration) * 100, 100);
            const target = navigationSystem.travelTarget;
            const remaining = Math.max(0, navigationSystem.travelDuration - elapsed);
            
            if (navigationSystem.travelTarget.type === 'planet') {
              // Traveling to planet in same system
              lines.push(`Moving to: ${target.planetName}`);
              lines.push(`Progress: ${progress.toFixed(0)}%`);
              lines.push('\u00A0');
              lines.push(`${'='.repeat(Math.floor(progress / 5))}${' '.repeat(20 - Math.floor(progress / 5))}`);
              lines.push('\u00A0');
              lines.push(`ETA: ${remaining.toFixed(1)}s`);
              lines.push(`Fuel: ${target.fuelUsed.toFixed(1)}L`);
              lines.push('\u00A0');
              lines.push('\u00A0');
            } else {
              // Traveling to another system
              lines.push(`Traveling to: ${target.name}`);
              lines.push(`Distance: ${target.distance} units`);
              lines.push(`Progress: ${progress.toFixed(0)}%`);
              lines.push('\u00A0');
              lines.push(`${'='.repeat(Math.floor(progress / 5))}${' '.repeat(20 - Math.floor(progress / 5))}`);
              lines.push('\u00A0');
              lines.push(`ETA: ${remaining.toFixed(1)}s`);
              lines.push('\u00A0');
              lines.push('\u00A0');
            }
          } else if (navigationSystem.viewMode === 'system') {
            // Show planet list (always 9 lines)
            lines.push(`Solar system: ${system.name}`);
            system.planets.forEach((planet, i) => {
              const cursor = i === navigationSystem.cursorIndex ? '> ' : '  ';
              const current = i === navigationSystem.currentPlanetIndex ? 'â—' : '';
              lines.push(`${cursor}${planet} ${current}`);
            });
            // Pad to exactly 9 lines with non-breaking spaces
            while (lines.length < 9) lines.push('\u00A0'); // Non-breaking space
          } else {
            // Show neighboring systems - galaxy map (always 9 lines)
            lines.push(`Galaxy Map - ${system.name}`);
            const neighbors = navigationSystem.getGalaxyMap();
            neighbors.forEach((neighbor, i) => {
              if (i < 8) {
                const cursor = i === navigationSystem.cursorIndex ? '> ' : '  ';
                lines.push(`${cursor}${neighbor.name} (${neighbor.distance})`);
              }
            });
            // Pad to exactly 9 lines with non-breaking spaces
            while (lines.length < 9) lines.push('\u00A0'); // Non-breaking space
          }
          
          // Ensure exactly 9 lines
          navTerminal.textContent = lines.slice(0, 9).join('\n');
        }
      }

      // Disable/enable buttons based on power state
      if (navButtons) {
        navButtons.forEach(button => {
          button.disabled = !isPowered;
          if (!isPowered) {
            button.classList.add('disabled');
          } else {
            button.classList.remove('disabled');
          }
        });
      }

      // Disable/enable dial based on power state
      if (navDial) {
        navDial.disabled = !isPowered;
        if (isPowered) {
          navDial.value = navigationSystem.cursorIndex;
          navDial.parentElement.style.setProperty('--value', navigationSystem.cursorIndex);
        }
      }

      // Update planet visual
      updatePlanetVisual();
    }

    /**
     * Update the planet visual in the viewport based on current location
     */
    function updatePlanetVisual() {
      const planetElement = document.querySelector('.window .planet');
      if (!planetElement) return;

      const system = navigationSystem.getCurrentSystem();
      const planetIndex = navigationSystem.currentPlanetIndex;
      
      // Get planet color based on seeded generation
      const planetInfo = getPlanetColor(
        navigationSystem.currentX, 
        navigationSystem.currentY, 
        planetIndex
      );
      
      const baseColor = planetInfo.color;
      const darkColor = darkenColor(baseColor, 0.4);
      const darkestColor = darkenColor(baseColor, 0.1);
      
      // Apply beautiful gradient like version 1
      planetElement.style.background = `radial-gradient(circle at 30% 30%, ${baseColor}, ${darkColor} 60%, ${darkestColor})`;
      planetElement.style.boxShadow = `0 0 40px ${baseColor}44`;
      
      // Update starfield
      updateStarfield(navigationSystem.currentX, navigationSystem.currentY, planetIndex);
    }

    /**
     * Generate a procedural starfield based on location
     */
    function updateStarfield(x, y, planetIndex) {
      const viewport = document.querySelector('.window .viewport');
      if (!viewport) return;
      
      // Generate seed from location
      let seed = (x * 73856093) ^ (y * 19349663) ^ (planetIndex * 83492791);
      seed = Math.abs(seed) + 1;
      const rng = new SeededRNG(seed);
      
      // Generate 50-80 stars for a rich starfield
      const starCount = rng.nextInt(50, 80);
      const starGradients = [];
      const starSizes = [];
      
      for (let i = 0; i < starCount; i++) {
        const x = rng.next() * 100; // 0-100%
        const y = rng.next() * 100; // 0-100%
        const size = rng.nextInt(1, 3); // 1-3px
        const brightness = 0.6 + (rng.next() * 0.4); // 0.6-1.0
        
        starGradients.push(`radial-gradient(${size}px ${size}px at ${x.toFixed(1)}% ${y.toFixed(1)}%, rgba(255,255,255,${brightness.toFixed(2)}), transparent)`);
        starSizes.push('200% 200%');
      }
      
      // Create CSS for ::before pseudo-element
      const styleId = 'starfield-style';
      let styleEl = document.getElementById(styleId);
      if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = styleId;
        document.head.appendChild(styleEl);
      }
      
      styleEl.textContent = `
        .window .viewport::before {
          content: '';
          position: absolute;
          inset: -50%;
          background: ${starGradients.join(',\n        ')};
          background-size: ${starSizes.join(', ')};
          background-repeat: repeat;
          animation: 
            starfieldFigureEight 120s ease-in-out infinite,
            starfieldTwinkle 8s ease-in-out infinite;
          pointer-events: none;
        }
      `;
    }

    /**
     * Travel Animation System
     * Manages the cinematic travel sequence:
     * 1. Departure: Planet/stars move down (ship goes up)
     * 2. Warp: Burst effect during travel
     * 3. Arrival: New planet grows into view
     */
    const travelAnimationSystem = {
      isAnimating: false,
      travelDuration: 0,
      warpAnimationFrame: null,
      
      /**
       * Generate procedural warp streaks emanating from center
       */
      generateWarpStreaks(warpBurst, streakCount = 60) {
        // Clear existing content
        warpBurst.innerHTML = '';
        
        // Create SVG
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 400 220'); // Match viewport aspect ratio
        
        // Store streaks data for continuous spawning
        svg.dataset.centerX = '200';
        svg.dataset.centerY = '110';
        svg.dataset.nextSpawnTime = '0';
        svg.dataset.streakIdCounter = '0';
        
        warpBurst.appendChild(svg);
      },
      
      /**
       * Create a single new warp streak at the center
       */
      createWarpStreak(svg, angle, rng) {
        const centerX = parseFloat(svg.dataset.centerX);
        const centerY = parseFloat(svg.dataset.centerY);
        
        const speed = 150 + rng.next() * 200; // Pixels per second
        const length = 30 + rng.next() * 50; // 30-80 units long
        const width = 0.8 + rng.next() * 1.8; // Vary thickness
        
        // Create polygon element
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polygon.setAttribute('class', 'star-streak');
        
        // Color: cyan-white spectrum for hyperspace feel
        const brightness = 0.6 + rng.next() * 0.4;
        const cyan = Math.floor(150 + brightness * 105); // 150-255
        const white = Math.floor(200 + brightness * 55); // 200-255
        const color = `rgb(${cyan}, ${white}, 255)`;
        
        polygon.setAttribute('fill', color);
        polygon.setAttribute('opacity', 0.5 + brightness * 0.3);
        
        // Store animation data
        polygon.dataset.angle = angle;
        polygon.dataset.speed = speed;
        polygon.dataset.length = length;
        polygon.dataset.innerWidth = width * 0.3;
        polygon.dataset.outerWidth = width * 1.5;
        polygon.dataset.currentDist = '0'; // Start at center
        polygon.dataset.birthTime = performance.now();
        
        svg.appendChild(polygon);
        return polygon;
      },
      
      /**
       * Update a streak's visual position
       */
      updateStreakPosition(streak, centerX, centerY) {
        const angle = parseFloat(streak.dataset.angle);
        const currentDist = parseFloat(streak.dataset.currentDist);
        const length = parseFloat(streak.dataset.length);
        const innerWidth = parseFloat(streak.dataset.innerWidth);
        const outerWidth = parseFloat(streak.dataset.outerWidth);
        
        const startDist = currentDist;
        const endDist = currentDist + length;
        
        const startX = centerX + Math.cos(angle) * startDist;
        const startY = centerY + Math.sin(angle) * startDist;
        const endX = centerX + Math.cos(angle) * endDist;
        const endY = centerY + Math.sin(angle) * endDist;
        
        const perpAngle = angle + Math.PI / 2;
        
        // Inner edge (near center/tail of streak)
        const x1 = startX + Math.cos(perpAngle) * innerWidth;
        const y1 = startY + Math.sin(perpAngle) * innerWidth;
        const x2 = startX - Math.cos(perpAngle) * innerWidth;
        const y2 = startY - Math.sin(perpAngle) * innerWidth;
        
        // Outer edge (far from center/head of streak)
        const x3 = endX - Math.cos(perpAngle) * outerWidth;
        const y3 = endY - Math.sin(perpAngle) * outerWidth;
        const x4 = endX + Math.cos(perpAngle) * outerWidth;
        const y4 = endY + Math.sin(perpAngle) * outerWidth;
        
        streak.setAttribute('points', `${x1},${y1} ${x2},${y2} ${x3},${y3} ${x4},${y4}`);
        
        // Fade in when spawning, fade out when leaving viewport
        let opacity = parseFloat(streak.getAttribute('opacity'));
        if (startDist < 10) {
          // Fade in
          opacity *= (startDist / 10);
        } else if (startDist > 250) {
          // Fade out as leaving viewport
          opacity *= Math.max(0, 1 - ((startDist - 250) / 100));
        }
        streak.setAttribute('opacity', opacity);
      },
      
      /**
       * Animate warp streaks radiating outward continuously
       */
      animateWarpStreaks(warpBurst) {
        const svg = warpBurst.querySelector('svg');
        if (!svg) return;
        
        const centerX = parseFloat(svg.dataset.centerX);
        const centerY = parseFloat(svg.dataset.centerY);
        const maxDist = 350; // Distance beyond which streaks are removed
        
        let lastTime = performance.now();
        const rng = new SeededRNG(Date.now()); // Random for varied angles
        let nextSpawnTime = 0;
        const spawnInterval = 80; // Spawn new streak every 80ms
        
        const animate = () => {
          const currentTime = performance.now();
          const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
          lastTime = currentTime;
          
          const streaks = svg.querySelectorAll('.star-streak');
          
          // Update existing streaks
          const streaksToRemove = [];
          streaks.forEach(streak => {
            const speed = parseFloat(streak.dataset.speed);
            let currentDist = parseFloat(streak.dataset.currentDist);
            
            // Move streak outward
            currentDist += speed * deltaTime;
            streak.dataset.currentDist = currentDist;
            
            // Update visual position
            this.updateStreakPosition(streak, centerX, centerY);
            
            // Mark for removal if too far
            if (currentDist > maxDist) {
              streaksToRemove.push(streak);
            }
          });
          
          // Remove old streaks
          streaksToRemove.forEach(streak => streak.remove());
          
          // Spawn new streaks periodically
          nextSpawnTime -= deltaTime * 1000;
          if (nextSpawnTime <= 0) {
            // Spawn a batch of 2-4 streaks at random angles
            const batchSize = 2 + Math.floor(rng.next() * 3);
            for (let i = 0; i < batchSize; i++) {
              const angle = rng.next() * Math.PI * 2; // Random angle
              this.createWarpStreak(svg, angle, rng);
            }
            nextSpawnTime = spawnInterval;
          }
          
          if (this.isAnimating && warpBurst.classList.contains('active')) {
            this.warpAnimationFrame = requestAnimationFrame(animate);
          }
        };
        
        animate();
      },
      
      /**
       * Start travel animation sequence
       */
      startTravelAnimation(durationSeconds) {
        this.isAnimating = true;
        this.travelDuration = durationSeconds;
        
        const planetElement = document.querySelector('.window .planet');
        const viewport = document.querySelector('.window .viewport');
        const warpBurst = document.querySelector('.window .viewport .warp-burst');
        
        if (!planetElement || !viewport || !warpBurst) return;
        
        // Calculate timing for each phase
        const departureDuration = Math.min(1.5, durationSeconds * 0.2); // 20% of travel or max 1.5s
        const warpDuration = durationSeconds - (departureDuration * 2); // Middle section
        const arrivalDuration = departureDuration; // Same as departure
        
        // Phase 1: Departure - planet and stars move down
        this.runDeparturePhase(planetElement, viewport, departureDuration);
        
        // Phase 2: Warp burst - starts after departure
        setTimeout(() => {
          this.runWarpPhase(planetElement, warpBurst, viewport, warpDuration);
        }, departureDuration * 1000);
        
        // Phase 3: Arrival - new planet grows in (handled by travel-complete event)
      },
      
      /**
       * Departure phase: Planet and stars exit downward
       */
      runDeparturePhase(planetElement, viewport, duration) {
        // Stop the normal figure-8 animation
        planetElement.style.animation = 'none';
        
        // Apply departure animation to both planet and starfield
        planetElement.style.animation = `travelDeparture ${duration}s ease-in forwards`;
        
        // Also animate starfield via dynamic CSS update
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (!styleEl) {
          styleEl = document.createElement('style');
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
        
        styleEl.textContent = `
          .window .viewport::before {
            animation: travelDeparture ${duration}s ease-in forwards !important;
          }
        `;
      },
      
      /**
       * Warp phase: Show burst effect, hide planet
       */
      runWarpPhase(planetElement, warpBurst, viewport, duration) {
        // Hide planet during warp
        planetElement.style.opacity = '0';
        
        // Generate warp streaks
        this.generateWarpStreaks(warpBurst, 60);
        
        // Show warp burst overlay
        warpBurst.classList.add('active');
        
        // Start animating the streaks
        this.animateWarpStreaks(warpBurst);
        
        // Hide starfield during warp by modifying its opacity
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (styleEl) {
          styleEl.textContent = `
            .window .viewport::before {
              opacity: 0 !important;
            }
          `;
        }
      },
      
      /**
       * Arrival phase: New planet grows into view, resume normal animations
       */
      runArrivalPhase(planetElement, warpBurst, viewport, duration) {
        // Stop warp animation
        if (this.warpAnimationFrame) {
          cancelAnimationFrame(this.warpAnimationFrame);
          this.warpAnimationFrame = null;
        }
        
        // Hide warp burst
        warpBurst.classList.remove('active');
        
        // Update planet visual for new location BEFORE animating it in
        updatePlanetVisual();
        
        // Animate planet growing in from small/above
        planetElement.style.opacity = '1';
        planetElement.style.animation = `travelArrival ${duration}s ease-out forwards`;
        
        // Fade starfield back in with arrival
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (styleEl) {
          styleEl.textContent = `
            .window .viewport::before {
              animation: travelArrival ${duration}s ease-out forwards !important;
            }
          `;
        }
        
        // After arrival completes, resume normal figure-8 idle animation
        setTimeout(() => {
          this.resumeIdleAnimation(planetElement);
        }, duration * 1000);
      },
      
      /**
       * Resume normal idle figure-8 animation
       */
      resumeIdleAnimation(planetElement) {
        this.isAnimating = false;
        
        // Resume planet's figure-8 idle animation
        planetElement.style.animation = 'planetFigureEight 120s ease-in-out infinite';
        
        // Resume starfield's figure-8 idle animation
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (styleEl) {
          styleEl.remove(); // Remove override, let normal styles take over
        }
      }
    };

    function updateTraderCommsUI() {
      const traderCommsSection = document.querySelectorAll('.panel')[5]; // Trader Comms panel
      const traderCommsPowerToggle = traderCommsSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const tradeDetailsDisplay = traderCommsSection.querySelector('.crt pre');
      
      const isTraderCommsEnabled = powerSystem.activeSystems.has('traderComms');
      const isPowerAvailable = powerSystem.isPowerAvailable();
      const isPowered = isTraderCommsEnabled && isPowerAvailable;
      
      // Update power toggle
      if (traderCommsPowerToggle) {
        traderCommsPowerToggle.checked = isTraderCommsEnabled;
        traderCommsPowerToggle.disabled = !isPowerAvailable; // Disable toggle if no power
      }
      
      // Update terminals based on power state
      if (!isPowered) {
        // Powered off - clear terminal
        if (tradeDetailsDisplay) {
          tradeDetailsDisplay.textContent = '\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0'; // 10 nbsp lines
        }
      } else {
        // Powered on - show trade details
        const status = tradingSystem.getStatus();
        
        if (!status.trader) {
          // No trader yet - pad to 10 lines
          const lines = [];
          lines.push('No trader signal detected...');
          lines.push('Enable comms to scan for traders.');
          while (lines.length < 10) lines.push('\u00A0');
          
          if (tradeDetailsDisplay) {
            tradeDetailsDisplay.textContent = lines.join('\n');
          }
        } else {
          // Show current trade details
          const currentItem = status.currentItem;
          const mode = status.isBuying ? 'BUYING' : 'SELLING';
          
          // Show page info, handle empty inventory/cargo
          let page = '';
          if (status.maxPage === 0) {
            page = status.isBuying ? '(sold out)' : '(no cargo)';
          } else {
            page = `(page ${status.currentPage + 1} of ${status.maxPage})`;
          }
          
          const lines = [];
          lines.push(`${mode} ${page}`);
          lines.push(`Trader: ${status.trader.name}`);
          lines.push(`Ship  : ${status.trader.ship}`);
          lines.push(`Mood  : ${status.trader.personality}`);
          
          if (currentItem) {
            if (status.isBuying) {
              // Buying from trader
              lines.push('');
              lines.push(`Item  : ${currentItem.type}`);
              lines.push(`Qty   : ${currentItem.quantity}`);
              lines.push(`Price : ${currentItem.currentPrice}â‚µ`);
              lines.push(`Credits: ${fuelSystem.credits}â‚µ`);
            } else {
              // Selling to trader - show our cargo with trader's offer
              const offerPrice = tradingSystem.getSellingPrice(currentItem);
              const profit = offerPrice - currentItem.purchasePrice;
              
              // Check if trader wants this item
              const demandItem = status.trader.demand && status.trader.demand.find(d => d.type === currentItem.type);
              
              lines.push('');
              lines.push(`Item  : ${currentItem.type}`);
              lines.push(`Bought: ${currentItem.purchasePrice}â‚µ`);
              
              if (demandItem) {
                lines.push(`Offer : ${offerPrice}â‚µ`);
                lines.push(`Profit: ${profit > 0 ? '+' : ''}${profit}â‚µ`);
                lines.push(`Demand: ${demandItem.quantity} units`);
                lines.push(`Credits: ${fuelSystem.credits}â‚µ`);
              } else {
                lines.push(`Offer : NO DEMAND`);
                lines.push(`Status: Won't buy this`);
                lines.push(`Credits: ${fuelSystem.credits}â‚µ`);
              }
            }
          } else {
            lines.push('');
            if (status.isBuying) {
              // Check if trader had inventory but it's all sold out
              if (status.trader.inventory && status.trader.inventory.length === 0) {
                lines.push('Trader is sold out!');
                lines.push('');
                lines.push('All inventory purchased.');
                lines.push('Try another planet or');
                lines.push('toggle to SELL mode.');
              } else {
                lines.push('No items available');
              }
            } else {
              // Show what trader wants when we have no matching cargo
              lines.push('Trader wants:');
              if (status.trader.demand && status.trader.demand.length > 0) {
                status.trader.demand.forEach(demandItem => {
                  if (lines.length < 10) {
                    lines.push(`  - ${demandItem.type} (${demandItem.quantity})`);
                  }
                });
              } else {
                lines.push('  (nothing specific)');
              }
            }
          }
          
          // Pad to exactly 10 lines
          while (lines.length < 10) lines.push('\u00A0');
          
          if (tradeDetailsDisplay) {
            tradeDetailsDisplay.textContent = lines.slice(0, 10).join('\n');
          }
        }
      }
      
      // Update cargo hold display
      updateCargoHoldUI();
    }
    
    function updateCargoHoldUI() {
      const cargoSection = document.querySelectorAll('.panel')[6]; // Cargo Hold panel
      const cargoSlots = cargoSection.querySelectorAll('.cargo-grid .cargo-slot'); // Only grid slots, not inspect slot
      
      // Update cargo slots based on tradingSystem.cargo
      cargoSlots.forEach((slot, index) => {
        if (index < tradingSystem.cargo.length) {
          const cargoItem = tradingSystem.cargo[index];
          if (cargoItem) {
            slot.classList.remove('empty');
            slot.classList.add('full');
            // Set color based on cargo type
            const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
            if (typeInfo && typeInfo.color) {
              slot.style.background = typeInfo.color;
            }
            
            // Add cargo label if not already present
            let label = slot.querySelector('.cargo-label');
            if (!label) {
              label = document.createElement('div');
              label.className = 'cargo-label';
              slot.appendChild(label);
            }
            label.textContent = typeInfo ? typeInfo.code : '??';
            
            // Make slot draggable
            slot.setAttribute('draggable', 'true');
          } else {
            slot.classList.remove('full');
            slot.classList.add('empty');
            slot.style.background = '';
            // Remove cargo label
            const label = slot.querySelector('.cargo-label');
            if (label) {
              label.remove();
            }
            
            // Empty slots can receive drops but aren't draggable
            slot.setAttribute('draggable', 'false');
          }
        }
      });
    }

    // Subscribe to battery events for UI updates
    eventBus.on('battery:charge-changed', (data) => {
      updateBatteryUI(data.battery);
    });

    eventBus.on('battery:connected', (data) => {
      console.log(`ðŸ”Œ Battery ${data.battery.id} connected to main bus`);
      updateBatteryToggleUI(data.battery);
    });

    eventBus.on('battery:disconnected', (data) => {
      console.log(`ðŸ”Œ Battery ${data.battery.id} disconnected from main bus`);
      updateBatteryToggleUI(data.battery);
    });

    // Subscribe to navigation events
    eventBus.on('navigation:travel-started', (data) => {
      // Start the cinematic travel animation
      const travelTime = data.travelTime || data.target.time || 5; // Use provided time or default
      travelAnimationSystem.startTravelAnimation(travelTime);
      console.log(`ðŸš€ Travel started to ${data.target.name || data.target} | Duration: ${travelTime.toFixed(1)}s`);
    });
    
    eventBus.on('navigation:travel-complete', (data) => {
      // Run arrival animation before updating UI
      const planetElement = document.querySelector('.window .planet');
      const warpBurst = document.querySelector('.window .viewport .warp-burst');
      const viewport = document.querySelector('.window .viewport');
      
      if (planetElement && warpBurst && viewport) {
        const arrivalDuration = Math.min(1.5, travelAnimationSystem.travelDuration * 0.2);
        travelAnimationSystem.runArrivalPhase(planetElement, warpBurst, viewport, arrivalDuration);
      }
      
      const system = navigationSystem.getCurrentSystem();
      const planet = system.planets[data.planetIndex];
      console.log(`ðŸŒŸ Arrived at ${system.name} > ${planet} (${data.x}, ${data.y})`);
      console.log(`   Fuel used: ${data.fuelUsed}L | Sun strength: ${(data.sunStrength * 100).toFixed(0)}%`);
      updateNavigationUI();
      updateFuelUI();
      
      // Generate new trader if Trader Comms is enabled
      if (powerSystem.activeSystems.has('traderComms')) {
        tradingSystem.generateNewTrader();
        updateTraderCommsUI();
        console.log('ðŸ“¡ New trader signal detected at this location');
      }
    });

    eventBus.on('navigation:planet-changed', (data) => {
      console.log(`ðŸª Moved to ${data.planetName} | Sun strength: ${(data.sunStrength * 100).toFixed(0)}%`);
      updateNavigationUI();
      
      // Generate new trader if Trader Comms is enabled
      if (powerSystem.activeSystems.has('traderComms')) {
        tradingSystem.generateNewTrader();
        updateTraderCommsUI();
        console.log('ðŸ“¡ New trader signal detected at this location');
      }
    });

    eventBus.on('navigation:view-changed', (data) => {
      updateNavigationUI();
    });

    eventBus.on('navigation:update-ui', () => {
      updateNavigationUI();
    });

    // Subscribe to save/load events
    eventBus.on('game:saved', (data) => {
      updateSaveStatusUI();
    });

    eventBus.on('game:loaded', (data) => {
      updateSaveStatusUI();
      console.log(`ðŸ“‚ Game loaded from ${new Date(data.timestamp).toLocaleString()}`);
    });

    eventBus.on('game:new-game', (data) => {
      updateSaveStatusUI();
    });

    // ============================================================================
    // UI UPDATE FUNCTIONS
    // ============================================================================
    
    function updateBatteryUI(battery) {
      // Update gauge value (scoped to Batteries panel to avoid index drift)
      const gaugeIndex = battery.id.charCodeAt(0) - 65; // A=0, B=1
      const batteriesPanel = document.querySelectorAll('.panel')[3]; // Batteries panel
      if (!batteriesPanel) return;
      const panelGauges = batteriesPanel.querySelectorAll('.gauge');
      // Expect two gauges within the Batteries panel: A then B
      const targetGauge = panelGauges[gaugeIndex];
      if (targetGauge) {
        const chargePercent = battery.getChargePercentage();
        // Use one decimal for smoother gauge updates
        targetGauge.style.setProperty('--value', chargePercent.toFixed(1));

        const progress = targetGauge.querySelector('progress');
        if (progress) {
          // Display actual charge in Wh
          const chargeWh = Math.round(battery.currentCharge);
          progress.value = Math.round(chargePercent);
          progress.textContent = `${chargeWh} Wh`;
        }
      }
    }

    function updateBatteryToggleUI(battery) {
      const toggleIndex = battery.id.charCodeAt(0) - 65;
      const batterySection = document.querySelectorAll('.panel')[3]; // Batteries panel
      const toggles = batterySection.querySelectorAll('.toggle input[type="checkbox"]');
      
      if (toggles[toggleIndex]) {
        toggles[toggleIndex].checked = battery.connectedToBus;
      }
    }

    function updateSolarPanelUI() {
      const solarSection = document.querySelectorAll('.panel')[4]; // Solar Panels panel
      const slider = solarSection.querySelector('.slider');
      const busToggle = solarSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      
      if (slider) {
        slider.value = solarSystem.panelState;
      }

      if (busToggle) {
        busToggle.checked = solarSystem.connectedToBus;
      }

      // Update charge gauge (solar power generation)
      const gauges = document.querySelectorAll('.gauge');
      const chargeGauge = gauges[3]; // First gauge in solar panel section
      
      if (chargeGauge) {
        const chargePercent = (solarSystem.currentOutput / solarSystem.maxPowerOutput) * 100;
        // Use decimal for smooth gauge movement
        chargeGauge.style.setProperty('--value', chargePercent.toFixed(1));
        
        const progress = chargeGauge.querySelector('progress');
        if (progress) {
          // Display actual power output in watts
          const powerW = Math.round(solarSystem.currentOutput);
          progress.value = Math.round(chargePercent);
          progress.textContent = `${powerW} W`;
        }
      }
    }

    function updatePowerDrawUI() {
      const gauges = document.querySelectorAll('.gauge');
      const drawGauge = gauges[4]; // Second gauge in solar panel section
      
      if (drawGauge) {
        // Only show draw if we have power supply available
        // If no batteries and no solar, we can't supply power
        const hasPower = batterySystem.getConnectedBatteries().length > 0 || 
                        (solarSystem.connectedToBus && solarSystem.extension > 0);
        
        const totalDraw = hasPower ? powerSystem.getTotalDraw() : 0;
        const drawPercent = (totalDraw / mainBus.getMaxPower()) * 100;
        // Use decimal for smooth gauge movement
        drawGauge.style.setProperty('--value', drawPercent.toFixed(1));
        
        const progress = drawGauge.querySelector('progress');
        if (progress) {
          // Display actual power draw in watts
          const powerW = Math.round(totalDraw);
          progress.value = Math.round(drawPercent);
          progress.textContent = `${powerW} W`;
        }
      }
    }

    function updateSaveStatusUI() {
      const saveStatusEl = document.getElementById('save-status');
      if (saveStatusEl) {
        const lastSaved = saveSystem.getLastSaveTimeFormatted();
        const autoSaveStatus = saveSystem.autoSaveEnabled ? 'Active' : 'Disabled';
        saveStatusEl.textContent = `Last saved: ${lastSaved}\nAuto-save  : ${autoSaveStatus}`;
      }
    }

    // ============================================================================
    // WIRE UP UI CONTROLS
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', () => {
      // Try to load saved game, otherwise start new game
      const savedGame = saveSystem.load();
      if (savedGame) {
        loadGameFromSave(savedGame);
      } else {
        initializeNewGame();
      }

      // Generate trader if Trader Comms is enabled on page load
      if (powerSystem.activeSystems.has('traderComms')) {
        tradingSystem.generateNewTrader();
        updateTraderCommsUI(); // Update UI to show the trader
      }

      // Start auto-save
      saveSystem.startAutoSave();

      // Wire up battery bus toggles
      const batterySection = document.querySelectorAll('.panel')[3]; // Batteries panel
      const toggles = batterySection.querySelectorAll('.toggle input[type="checkbox"]');
      
      toggles.forEach((toggle, index) => {
        const batteryId = String.fromCharCode(65 + index); // A, B
        const battery = batterySystem.getBattery(batteryId);
        
        if (battery) {
          // Initialize toggle state
          toggle.checked = battery.connectedToBus;
          
          // Handle toggle changes
          toggle.addEventListener('change', () => {
            battery.toggleBus();
            updateNavigationUI(); // Check power availability immediately
            updateTraderCommsUI(); // Update Trader Comms UI immediately
          });
        }
      });

      // Wire up solar panel slider
      const solarSection = document.querySelectorAll('.panel')[4]; // Solar Panels panel
      const solarSlider = solarSection.querySelector('.slider');
      const solarBusToggle = solarSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      
      if (solarSlider) {
        // Initialize slider state
        solarSlider.value = solarSystem.panelState;
        
        // Handle slider changes
        solarSlider.addEventListener('input', () => {
          solarSystem.setPanelState(parseInt(solarSlider.value));
        });
      }

      if (solarBusToggle) {
        // Initialize toggle state
        solarBusToggle.checked = solarSystem.connectedToBus;
        
        // Handle toggle changes
        solarBusToggle.addEventListener('change', () => {
          solarSystem.connectedToBus = solarBusToggle.checked;
          console.log(`ðŸ”Œ Solar panels ${solarSystem.connectedToBus ? 'connected to' : 'disconnected from'} main bus`);
          updateNavigationUI(); // Check power availability immediately
          updateTraderCommsUI(); // Update Trader Comms UI immediately
        });
      }

      // Wire up Navigation Power toggle
      const navigationSection = document.querySelectorAll('.panel')[1]; // Navigation panel (index 1)
      const navigationPowerToggle = navigationSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const navButtons = navigationSection.querySelectorAll('.btn');
      const navDial = navigationSection.querySelector('.dial input');
      
      if (navigationPowerToggle) {
        // Initialize toggle state
        const isNavigationActive = powerSystem.activeSystems.has('navigation');
        navigationPowerToggle.checked = isNavigationActive;
        
        // Handle toggle changes
        navigationPowerToggle.addEventListener('change', () => {
          if (navigationPowerToggle.checked) {
            // Check if power is available before enabling
            if (!powerSystem.isPowerAvailable()) {
              console.warn('âš ï¸ Cannot enable Navigation: No power available');
              navigationPowerToggle.checked = false;
              return;
            }
            powerSystem.enableSystem('navigation');
            console.log('ðŸ§­ Navigation system ONLINE (250W)');
          } else {
            powerSystem.disableSystem('navigation');
            console.log('ðŸ§­ Navigation system OFFLINE');
          }
          updateNavigationUI(); // Update UI immediately on power change
        });
      }

      // Wire up navigation buttons
      if (navButtons.length >= 4) {
        // CURRENT LOC button
        navButtons[0].addEventListener('click', () => {
          if (navigationSystem.traveling) return;
          navigationSystem.showCurrentLocation();
          updateNavigationUI();
          const system = navigationSystem.getCurrentSystem();
          const planet = system.planets[navigationSystem.currentPlanetIndex];
          console.log(`ðŸ“ Current location: ${system.name} > ${planet} (${navigationSystem.currentX}, ${navigationSystem.currentY})`);
        });

        // SYSTEM MAP button
        navButtons[1].addEventListener('click', () => {
          if (navigationSystem.traveling) return;
          navigationSystem.setViewMode('system');
          updateNavigationUI();
          console.log('ðŸ—ºï¸ Showing system map');
        });

        // GALAXY MAP button
        navButtons[2].addEventListener('click', () => {
          if (navigationSystem.traveling) return;
          navigationSystem.setViewMode('galaxy');
          updateNavigationUI();
          console.log('ðŸŒŒ Showing galaxy map');
        });

        // BEGIN TRAVEL button
        navButtons[3].addEventListener('click', () => {
          const result = navigationSystem.beginTravel();
          
          if (!result.success) {
            console.warn(`ðŸš€ ${result.message}`);
          } else {
            if (result.type === 'planet') {
              const system = navigationSystem.getCurrentSystem();
              const planet = system.planets[result.planetIndex];
              const sunStrength = navigationSystem.getSunStrength();
              console.log(`ðŸª Moved to ${planet} (sun strength: ${(sunStrength * 100).toFixed(0)}%)`);
            } else {
              console.log(`ðŸš€ Traveling to ${result.target.name} (${result.fuelCost}L fuel)`);
            }
            updateNavigationUI();
          }
        });
      }

      // Wire up navigation dial
      if (navDial) {
        navDial.addEventListener('input', () => {
          if (navigationSystem.traveling) return;
          const index = parseInt(navDial.value);
          navigationSystem.setCursor(index);
          updateNavigationUI();
        });
        
        // Prevent context menu on long press (mobile)
        const dialContainer = navDial.closest('.dial');
        if (dialContainer) {
          dialContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
          });
          
          // Also prevent on the input itself
          navDial.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
          });
          
          // Prevent long-press text selection on touch devices
          dialContainer.addEventListener('touchstart', (e) => {
            // Don't prevent default as we need the touch to work
            // Just mark that we're interacting
          }, { passive: true });
        }
      }

      // Wire up Refuel button
      const fuelSection = document.querySelectorAll('.panel')[2]; // Fuel panel (index 2)
      const refuelButton = fuelSection.querySelector('.btn');
      const fuelTerminal = fuelSection.querySelector('.crt pre');
      
      if (refuelButton) {
        refuelButton.addEventListener('click', () => {
          const result = fuelSystem.refuel();
          
          if (result.success) {
            console.log(`â›½ ${result.message}`);
            updateFuelUI();
          } else {
            console.warn(`â›½ ${result.message}`);
            
            // Show error message in terminal temporarily
            if (fuelTerminal) {
              const originalText = fuelTerminal.textContent;
              fuelTerminal.textContent = `Current credits: ${fuelSystem.credits}â‚µ\n${result.message}`;
              
              // Restore after 5 seconds
              setTimeout(() => {
                updateFuelUI();
              }, 5000);
            }
          }
        });
      }

      // Wire up Trader Comms controls
      const traderCommsSection = document.querySelectorAll('.panel')[5]; // Trader Comms panel
      const traderCommsPowerToggle = traderCommsSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const traderCommsModeToggle = traderCommsSection.querySelectorAll('.toggle input[type="checkbox"]')[1];
      const tradeButtons = traderCommsSection.querySelectorAll('.btn');
      const prevPageBtn = tradeButtons[0]; // PREVIOUS PAGE
      const nextPageBtn = tradeButtons[1]; // NEXT PAGE
      const haggleBtn = tradeButtons[2]; // HAGGLE
      const tradeBtn = tradeButtons[3]; // TRADE
      
  // Get cargo hold elements (grid slots only, exclude the Inspect slot)
  const cargoSection = document.querySelectorAll('.panel')[6]; // Cargo Hold panel
  const cargoSlots = cargoSection.querySelectorAll('.cargo-grid .cargo-slot'); // Only grid slots, not inspect slot
      
      if (traderCommsPowerToggle) {
        // Initialize toggle state
        const isCommsActive = powerSystem.activeSystems.has('traderComms');
        traderCommsPowerToggle.checked = isCommsActive;
        
        // Handle toggle changes
        traderCommsPowerToggle.addEventListener('change', () => {
          if (traderCommsPowerToggle.checked) {
            // Check if power is available before enabling
            if (!powerSystem.isPowerAvailable()) {
              console.warn('âš ï¸ Cannot enable Trader Comms: No power available');
              traderCommsPowerToggle.checked = false; // Revert toggle
              return;
            }
            powerSystem.enableSystem('traderComms');
            // Generate new trader when power turned on
            tradingSystem.generateNewTrader();
            console.log('ðŸ“¡ Trader Comms ONLINE - Scanning for traders...');
          } else {
            powerSystem.disableSystem('traderComms');
            console.log('ðŸ“¡ Trader Comms OFFLINE');
          }
          updateTraderCommsUI(); // Update UI immediately
        });
      }
      
      if (traderCommsModeToggle) {
        // Initialize mode (checked = SELLING, unchecked = BUYING)
        traderCommsModeToggle.checked = !tradingSystem.isBuying;
        
        traderCommsModeToggle.addEventListener('change', () => {
          const newMode = !traderCommsModeToggle.checked; // unchecked = buying
          tradingSystem.setMode(newMode);
          console.log(`ðŸ”„ Switched to ${newMode ? 'BUYING' : 'SELLING'} mode`);
          updateTraderCommsUI();
        });
      }
      
      if (prevPageBtn) {
        prevPageBtn.addEventListener('click', () => {
          if (!powerSystem.activeSystems.has('traderComms')) return;
          tradingSystem.prevPage();
          updateTraderCommsUI();
        });
      }
      
      if (nextPageBtn) {
        nextPageBtn.addEventListener('click', () => {
          if (!powerSystem.activeSystems.has('traderComms')) return;
          tradingSystem.nextPage();
          updateTraderCommsUI();
        });
      }
      
      if (haggleBtn) {
        haggleBtn.addEventListener('click', () => {
          if (!powerSystem.activeSystems.has('traderComms')) {
            console.warn('âš ï¸ Trader Comms must be ONLINE to haggle');
            return;
          }
          
          const result = tradingSystem.haggle();
          console.log(`ðŸ’¬ Haggle: ${result.message}`);
          updateTraderCommsUI();
        });
      }
      
      if (tradeBtn) {
        tradeBtn.addEventListener('click', () => {
          // Check if Trader Comms is online
          if (!powerSystem.activeSystems.has('traderComms')) {
            console.warn('âš ï¸ Trader Comms must be ONLINE to trade');
            return;
          }

          // Check if teleportation already in progress
          if (powerSystem.teleportInProgress) {
            console.warn('âš ï¸ Teleportation already in progress, please wait...');
            return;
          }

          // Pre-validate the trade before starting teleportation
          const isBuying = tradingSystem.isBuying;
          
          if (isBuying) {
            // Buying - check if there's actually an item to buy
            if (!tradingSystem.currentTrader?.inventory || tradingSystem.currentTrader.inventory.length === 0) {
              console.warn('âš ï¸ Trader has no inventory!');
              return;
            }
            
            // Validate page bounds
            if (tradingSystem.currentPage >= tradingSystem.currentTrader.inventory.length) {
              console.warn(`âš ï¸ Invalid page ${tradingSystem.currentPage}, inventory has ${tradingSystem.currentTrader.inventory.length} items`);
              tradingSystem.currentPage = Math.max(0, tradingSystem.currentTrader.inventory.length - 1);
              updateTraderCommsUI();
              return;
            }
            
            const currentItem = tradingSystem.currentTrader.inventory[tradingSystem.currentPage];
            if (!currentItem) {
              console.warn('âš ï¸ No item at current page!');
              return;
            }
          } else {
            // Selling - check if trader wants the item
            const currentItem = tradingSystem.getCurrentItem();
            if (currentItem && tradingSystem.currentTrader?.demand) {
              const traderWantsItem = tradingSystem.currentTrader.demand.some(d => d.type === currentItem.type);
              if (!traderWantsItem) {
                console.warn(`âš ï¸ Trader doesn't want ${currentItem.type}!`);
                return; // Exit without starting teleportation
              }
            }
          }

          // Start teleportation sequence (5% of one battery = 100 Wh over 3 seconds)
          const teleportEnergy = 100; // Wh (5% of 2000 Wh battery)
          const success = powerSystem.startTeleportation('Cargo Teleportation', teleportEnergy);
          
          if (success) {
            console.log(`ðŸ“¦ Trade initiated! Teleporting cargo...`);
            
            // Find the cargo slot to animate
            let targetSlot = null;
            
            if (isBuying) {
              // Buying - find first empty slot
              targetSlot = Array.from(cargoSlots).find(slot => slot.classList.contains('empty'));
            } else {
              // Selling - find the slot of the current cargo item
              const currentItem = tradingSystem.getCurrentItem();
              if (currentItem) {
                targetSlot = cargoSlots[currentItem.slotIndex];
              }
            }
            
            // Add teleportation visual effect
            if (targetSlot) {
              targetSlot.classList.add('teleporting');
            }
            
            // After teleportation completes, execute trade
            const completeHandler = () => {
              // Remove teleporting effect
              if (targetSlot) {
                targetSlot.classList.remove('teleporting');
              }
              
              // Execute the trade
              const tradeResult = tradingSystem.executeTrade();
              
              if (tradeResult.success) {
                console.log(`âœ… ${tradeResult.message}`);
              } else {
                console.warn(`âš ï¸ ${tradeResult.message}`);
              }
              
              // Update UI
              updateTraderCommsUI();
              updateFuelUI(); // Update credits display
              
              // Clean up event listener
              eventBus.off('power:teleport-complete', completeHandler);
            };
            
            eventBus.once('power:teleport-complete', completeHandler);
          } else {
            console.warn('âš ï¸ Trade failed: Insufficient power for teleportation');
          }
        });
      }

      // Wire up new game controls
      const newGameArm = document.getElementById('new-game-arm');
      const newGameBtn = document.getElementById('new-game-btn');

      if (newGameArm && newGameBtn) {
        // Handle arm toggle
        newGameArm.addEventListener('change', () => {
          if (newGameArm.checked) {
            // Armed
            newGameBtn.disabled = false;
            newGameBtn.style.opacity = '1';
            newGameBtn.style.background = 'linear-gradient(180deg, #8a2020, #5a1010)';
            newGameBtn.style.color = '#fff';
          } else {
            // Safe
            newGameBtn.disabled = true;
            newGameBtn.style.opacity = '0.5';
            newGameBtn.style.background = 'linear-gradient(180deg, var(--keycap-3), var(--keycap-2))';
            newGameBtn.style.color = 'var(--key-text)';
          }
        });

        // Handle new game button
        newGameBtn.addEventListener('click', () => {
          if (!newGameArm.checked) return;

          // Delete save
          saveSystem.deleteSave();
          
          // Initialize new game
          initializeNewGame();
          
          // Disarm the button
          newGameArm.checked = false;
          newGameBtn.disabled = true;
          newGameBtn.style.opacity = '0.5';
          newGameBtn.style.background = 'linear-gradient(180deg, var(--keycap-3), var(--keycap-2))';
          newGameBtn.style.color = 'var(--key-text)';
          
          // Scroll to top
          window.scrollTo({ top: 0, behavior: 'smooth' });
          
          console.log('ðŸŽ® New game started!');
        });
      }

      // ============================================================================
      // CARGO DRAG-AND-DROP HANDLERS (Mouse + Touch Support)
      // ============================================================================
      
      const cargoHoldSection = document.querySelectorAll('.panel')[6]; // Cargo Hold panel
      const cargoHoldSlots = cargoHoldSection.querySelectorAll('.cargo-grid .cargo-slot'); // Only grid slots, not inspect slot
      
  let draggedSlotIndex = null;
  let lastDraggedIndex = null; // Fallback for mouse synthetic drop
      let touchDraggedSlot = null;
      let touchClone = null;
      
      cargoHoldSlots.forEach((slot, index) => {
        // ===== MOUSE DRAG HANDLERS =====
        
        // Drag start
        slot.addEventListener('dragstart', (e) => {
          // Only allow dragging if slot is full
          if (!slot.classList.contains('full')) {
            e.preventDefault();
            return;
          }
          
          draggedSlotIndex = index;
          lastDraggedIndex = index; // track last dragged index for fallback
          slot.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', index.toString());
          console.log(`ðŸ“¦ Drag start: slot ${index}`);
        });
        
        // Drag end
        slot.addEventListener('dragend', (e) => {
          slot.classList.remove('dragging');
          // Defer clearing to allow other dragend listeners to read the value
          setTimeout(() => { draggedSlotIndex = null; }, 0);
          console.log(`ðŸ“¦ Drag end`);
        });
        
        // Drag over (allow drop)
        slot.addEventListener('dragover', (e) => {
          e.preventDefault(); // Allow drop
          e.dataTransfer.dropEffect = 'move';
          
          if (draggedSlotIndex !== null && draggedSlotIndex !== index) {
            slot.classList.add('drag-over');
          }
        });
        
        // Drag enter
        slot.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (draggedSlotIndex !== null && draggedSlotIndex !== index) {
            slot.classList.add('drag-over');
          }
        });
        
        // Drag leave
        slot.addEventListener('dragleave', (e) => {
          slot.classList.remove('drag-over');
        });
        
        // Drop
        slot.addEventListener('drop', (e) => {
          e.preventDefault();
          slot.classList.remove('drag-over');
          
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = index;
          
          console.log(`ðŸ“¦ Drop on slot ${toIndex} from slot ${fromIndex}`);
          
          if (fromIndex !== toIndex) {
            // Perform the swap
            tradingSystem.swapCargo(fromIndex, toIndex);
            
            // Update UI
            updateCargoHoldUI();
            
            // Save the game after swap
            saveSystem.save();
          }
        });
        
        // ===== TOUCH DRAG HANDLERS =====
        
        slot.addEventListener('touchstart', (e) => {
          // Only allow dragging if slot is full
          if (!slot.classList.contains('full')) {
            return;
          }
          
          e.preventDefault(); // Prevent scrolling while dragging
          draggedSlotIndex = index;
          touchDraggedSlot = slot;
          slot.classList.add('dragging');
          
          // Create a visual clone that follows the finger
          touchClone = slot.cloneNode(true);
          touchClone.style.position = 'fixed';
          touchClone.style.pointerEvents = 'none';
          touchClone.style.opacity = '0.8';
          touchClone.style.zIndex = '10000';
          touchClone.style.width = slot.offsetWidth + 'px';
          touchClone.style.height = slot.offsetHeight + 'px';
          
          const touch = e.touches[0];
          touchClone.style.left = (touch.clientX - slot.offsetWidth / 2) + 'px';
          touchClone.style.top = (touch.clientY - slot.offsetHeight / 2) + 'px';
          
          document.body.appendChild(touchClone);
          console.log(`ðŸ“± Touch start: slot ${index}`);
        });
        
        slot.addEventListener('touchmove', (e) => {
          if (!touchClone) return;
          
          e.preventDefault(); // Prevent scrolling
          const touch = e.touches[0];
          
          // Move the clone with the finger
          touchClone.style.left = (touch.clientX - touchClone.offsetWidth / 2) + 'px';
          touchClone.style.top = (touch.clientY - touchClone.offsetHeight / 2) + 'px';
          
          // Find what element is under the finger
          touchClone.style.display = 'none';
          const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
          touchClone.style.display = 'block';
          
          // Remove drag-over from all slots
          cargoHoldSlots.forEach(s => s.classList.remove('drag-over'));
          const inspectSlot = document.getElementById('inspect-slot');
          if (inspectSlot) inspectSlot.classList.remove('drag-over');
          
          // Add drag-over to the element below if it's a valid drop target
          if (elementBelow) {
            const targetSlot = elementBelow.closest('.cargo-slot');
            if (targetSlot && targetSlot !== touchDraggedSlot) {
              targetSlot.classList.add('drag-over');
            }
          }
        });
        
        slot.addEventListener('touchend', (e) => {
          if (!touchClone) return;
          
          e.preventDefault();
          const touch = e.changedTouches[0];
          
          // Find what element is under the finger
          touchClone.style.display = 'none';
          const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
          
          // Clean up
          if (touchClone && touchClone.parentNode) {
            touchClone.parentNode.removeChild(touchClone);
          }
          touchClone = null;
          
          if (touchDraggedSlot) {
            touchDraggedSlot.classList.remove('dragging');
          }
          
          // Remove drag-over from all slots
          cargoHoldSlots.forEach(s => s.classList.remove('drag-over'));
          const inspectSlotEl = document.getElementById('inspect-slot');
          if (inspectSlotEl) inspectSlotEl.classList.remove('drag-over');
          
          console.log(`ðŸ“± Touch end at slot ${index}`);
          
          // Handle the drop
          if (elementBelow) {
            const targetSlot = elementBelow.closest('.cargo-slot');
            
            if (targetSlot) {
              // Check if it's the inspect slot
              if (targetSlot.id === 'inspect-slot') {
                console.log(`ðŸ“± Dropped on inspect slot`);
                // Inspect the cargo
                const cargoItem = tradingSystem.cargo[draggedSlotIndex];
                if (cargoItem) {
                  const inspectTerminal = document.getElementById('inspect-terminal');
                  const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
                  
                  // Update inspect slot visual
                  targetSlot.classList.remove('empty');
                  targetSlot.classList.add('full');
                  targetSlot.style.background = typeInfo.color;
                  
                  let label = targetSlot.querySelector('.cargo-label');
                  if (label) {
                    label.textContent = typeInfo.code;
                    label.style.fontSize = '56px';
                    label.style.opacity = '0.4';
                    label.style.animation = 'none';
                  }
                  
                  // Update terminal
                  if (inspectTerminal) {
                    const lines = [];
                    lines.push(`Type: ${cargoItem.type}`);
                    lines.push(`Code: ${typeInfo.code}`);
                    lines.push(`Purchase Price: ${cargoItem.purchasePrice}â‚µ`);
                    lines.push(`Slot: ${draggedSlotIndex + 1} of ${tradingSystem.cargoCapacity}`);
                    
                    while (lines.length < 4) {
                      lines.push('\u00A0');
                    }
                    
                    inspectTerminal.textContent = lines.slice(0, 4).join('\n');
                    console.log(`ðŸ” Inspecting cargo: ${cargoItem.type} from slot ${draggedSlotIndex}`);
                  }
                }
              } else {
                // Regular cargo slot - swap
                const targetIndex = Array.from(cargoHoldSlots).indexOf(targetSlot);
                
                if (targetIndex !== -1 && targetIndex !== draggedSlotIndex) {
                  console.log(`ðŸ“± Swapping slot ${draggedSlotIndex} with slot ${targetIndex}`);
                  tradingSystem.swapCargo(draggedSlotIndex, targetIndex);
                  updateCargoHoldUI();
                  saveSystem.save();
                }
              }
            }
          }
          
          draggedSlotIndex = null;
          touchDraggedSlot = null;
        });
        
        slot.addEventListener('touchcancel', (e) => {
          // Clean up on cancel
          if (touchClone && touchClone.parentNode) {
            touchClone.parentNode.removeChild(touchClone);
          }
          touchClone = null;
          
          if (touchDraggedSlot) {
            touchDraggedSlot.classList.remove('dragging');
          }
          
          cargoHoldSlots.forEach(s => s.classList.remove('drag-over'));
          const inspectSlotEl = document.getElementById('inspect-slot');
          if (inspectSlotEl) inspectSlotEl.classList.remove('drag-over');
          
          draggedSlotIndex = null;
          touchDraggedSlot = null;
          console.log(`ðŸ“± Touch cancelled`);
        });
      });

      // ============================================================================
      // INSPECT SLOT DRAG-AND-DROP HANDLER (Mouse Only - Touch handled above)
      // ============================================================================
      
      const inspectSlot = document.getElementById('inspect-slot');
      const inspectTerminal = document.getElementById('inspect-terminal');
      
      console.log(`ðŸ” Inspect slot found:`, inspectSlot);
      console.log(`ðŸ” Inspect terminal found:`, inspectTerminal);
      
      if (inspectSlot && inspectTerminal) {
        // Add a capture phase listener to debug
        document.addEventListener('drop', (e) => {
          console.log(`ðŸ” CAPTURE: Drop event anywhere on document`, e.target);
          if (inspectSlot.contains(e.target) || e.target === inspectSlot) {
            console.log(`ðŸ” CAPTURE: Drop event IS over inspect slot area!`);
          }
        }, true); // Capture phase
        
        // Also add a global drop listener to see ALL drops
        window.addEventListener('drop', (e) => {
          console.log(`ðŸŒ WINDOW: Drop event detected`, e.target);
        });
        
        let dragEnterCounter = 0; // Track nested drag enter/leave
        let lastDragOverTime = 0; // Track last dragover
        let isOverInspectSlot = false; // Track if we've been over inspect slot recently
        
        // Drag over (allow drop)
        inspectSlot.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation(); // Stop it from bubbling to parent
          
          // Always set dropEffect even if draggedSlotIndex is null
          e.dataTransfer.dropEffect = 'copy';
          
          lastDragOverTime = Date.now();
          isOverInspectSlot = true; // Mark that we're actively over the slot
          
          if (draggedSlotIndex !== null) {
            inspectSlot.classList.add('drag-over');
          }
        });
        
        // Drag enter
        inspectSlot.addEventListener('dragenter', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragEnterCounter++;
          
          if (draggedSlotIndex !== null) {
            inspectSlot.classList.add('drag-over');
            console.log(`ðŸ” Drag entered inspect slot (counter: ${dragEnterCounter})`);
          }
        });
        
        // Drag leave - use counter to track nested enter/leave
        inspectSlot.addEventListener('dragleave', (e) => {
          e.stopPropagation();
          dragEnterCounter--;
          
          // Only remove drag-over when counter reaches 0 AND we're not actively dragging over
          if (dragEnterCounter <= 0) {
            dragEnterCounter = 0;
            // Don't immediately clear isOverInspectSlot - let dragend handle cleanup
            // This prevents race condition where dragleave fires right before drop
            const timeSinceDragover = Date.now() - lastDragOverTime;
            // Do not clear isOverInspectSlot here; keep until dragend decides
            if (timeSinceDragover > 300) { // only remove highlight if user clearly moved away
              inspectSlot.classList.remove('drag-over');
              console.log(`ðŸ” Drag left inspect slot (counter: ${dragEnterCounter}, time: ${timeSinceDragover}ms)`);
            } else {
              console.log(`ðŸ” Dragleave too soon after dragover (${timeSinceDragover}ms), keeping drop zone active`);
            }
          } else {
            console.log(`ðŸ” Dragleave on child (counter: ${dragEnterCounter}, ignoring)`);
          }
        });
        
        // Also clear drag-over on dragend of cargo slots
        cargoHoldSlots.forEach(slot => {
          slot.addEventListener('dragend', () => {
            const timeSinceLastDragover = Date.now() - lastDragOverTime;
            // Capture BEFORE it gets cleared; fallback to lastDraggedIndex if needed
            const capturedDraggedIndex = (draggedSlotIndex !== null ? draggedSlotIndex : lastDraggedIndex);
            console.log(`ðŸ“¦ Dragend - time since last dragover: ${timeSinceLastDragover}ms, counter: ${dragEnterCounter}, isOver: ${isOverInspectSlot}, draggedIndex: ${capturedDraggedIndex}`);
            
            // If we were recently over the inspect slot, trigger a synthetic drop
            if (isOverInspectSlot && timeSinceLastDragover < 250 && capturedDraggedIndex !== null) {
              console.log(`ðŸ” SYNTHETIC DROP: Was over inspect slot when released (${timeSinceLastDragover}ms ago), manually triggering inspection`);
              
              const cargoItem = tradingSystem.cargo[capturedDraggedIndex];
              if (cargoItem) {
                const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
                
                // Update inspect slot visual
                inspectSlot.classList.remove('empty');
                inspectSlot.classList.add('full');
                inspectSlot.style.background = typeInfo.color;
                
                let label = inspectSlot.querySelector('.cargo-label');
                if (label) {
                  label.textContent = typeInfo.code;
                  label.style.fontSize = '56px';
                  label.style.opacity = '0.4';
                  label.style.animation = 'none';
                }
                
                // Update terminal
                const lines = [];
                lines.push(`Type: ${cargoItem.type}`);
                lines.push(`Code: ${typeInfo.code}`);
                lines.push(`Purchase Price: ${cargoItem.purchasePrice}â‚µ`);
                lines.push(`Slot: ${capturedDraggedIndex + 1} of ${tradingSystem.cargoCapacity}`);
                
                while (lines.length < 4) {
                  lines.push('\u00A0');
                }
                
                inspectTerminal.textContent = lines.slice(0, 4).join('\n');
                console.log(`ðŸ” Synthetic inspection complete: ${cargoItem.type} from slot ${capturedDraggedIndex}`);
              }
            }
            
            inspectSlot.classList.remove('drag-over');
            dragEnterCounter = 0; // Reset counter
            isOverInspectSlot = false; // Reset flag
          });
        });
        
        // Drop - inspect the cargo without moving it
        inspectSlot.addEventListener('drop', (e) => {
          console.log(`ðŸ” DROP EVENT HANDLER CALLED!`, e);
          e.preventDefault();
          e.stopPropagation(); // Stop event from bubbling
          inspectSlot.classList.remove('drag-over');
          
          console.log(`ðŸ” DROP EVENT FIRED ON INSPECT SLOT`);
          console.log(`ðŸ” Event target:`, e.target);
          console.log(`ðŸ” Current target:`, e.currentTarget);
          
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          console.log(`ðŸ” From index: ${fromIndex}`);
          
          const cargoItem = tradingSystem.cargo[fromIndex];
          console.log(`ðŸ” Cargo item:`, cargoItem);
          
          if (cargoItem) {
            // Update inspect slot visual
            const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
            inspectSlot.classList.remove('empty');
            inspectSlot.classList.add('full');
            inspectSlot.style.background = typeInfo.color;
            
            // Update cargo label
            let label = inspectSlot.querySelector('.cargo-label');
            if (label) {
              label.textContent = typeInfo.code;
              label.style.fontSize = '56px';
              label.style.opacity = '0.4';
              label.style.animation = 'none';
            }
            
            // Update terminal with cargo info (always keep 4 lines)
            const lines = [];
            lines.push(`Type: ${cargoItem.type}`);
            lines.push(`Code: ${typeInfo.code}`);
            lines.push(`Purchase Price: ${cargoItem.purchasePrice}â‚µ`);
            lines.push(`Slot: ${fromIndex + 1} of ${tradingSystem.cargoCapacity}`);
            
            // Ensure exactly 4 lines (pad with non-breaking spaces if needed)
            while (lines.length < 4) {
              lines.push('\u00A0'); // Non-breaking space
            }
            
            inspectTerminal.textContent = lines.slice(0, 4).join('\n');
            
            console.log(`ðŸ” Inspecting cargo: ${cargoItem.type} from slot ${fromIndex}`);
            console.log(`ðŸ” Terminal updated with:`, lines);
          } else {
            console.log(`ðŸ” No cargo item at index ${fromIndex}`);
          }
        });
        
        console.log(`ðŸ” Inspect slot handlers attached`);
      } else {
        console.error(`ðŸ” Inspect slot or terminal not found!`);
      }

      // Update save status UI periodically
      setInterval(updateSaveStatusUI, 1000);
    });

    // ============================================================================
    // GAME LOOP
    // ============================================================================
    
    let lastTime = performance.now();
    const TARGET_FPS = 60;
    const FRAME_TIME = 1000 / TARGET_FPS;
    let frameCounter = 0;

    function gameLoop(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;
      frameCounter++;

      // Update all systems
      solarSystem.update(deltaTime);
      powerSystem.update(deltaTime);
      batterySystem.update(deltaTime);
      navigationSystem.update(deltaTime);

      // Check power availability and auto-disable systems if no power
      if (!powerSystem.isPowerAvailable()) {
        // No power available - force disable navigation if it's on
        if (powerSystem.activeSystems.has('navigation')) {
          powerSystem.disableSystem('navigation');
          updateNavigationUI(); // Update UI to reflect power toggle off
          console.warn('âš ï¸ Navigation auto-disabled: No power available');
        }
        // Force disable trader comms if it's on
        if (powerSystem.activeSystems.has('traderComms')) {
          powerSystem.disableSystem('traderComms');
          updateTraderCommsUI(); // Update UI to reflect power toggle off
          console.warn('âš ï¸ Trader Comms auto-disabled: No power available');
        }
      }

      // Power flow management
      const solarPower = solarSystem.currentOutput;
      const systemDraw = powerSystem.getTotalDraw();
      
      // Calculate power balance
      const powerBalance = solarPower - systemDraw;
      
      // Debug logging every 5 seconds (300 frames at 60fps)
      if (frameCounter % 300 === 0) {
        const motorDraw = solarSystem.currentMotorDraw;
        const teleportDraw = powerSystem.teleportInProgress ? ((powerSystem.teleportTotalEnergy / powerSystem.teleportDuration) * 3600) : 0;
        const baseDraw = systemDraw - motorDraw - teleportDraw;
        
        // Break down base draw into components
        const baseLoad = powerSystem.baseLoad;
        let systemsBreakdown = [];
        powerSystem.activeSystems.forEach(system => {
          const load = powerSystem.systemLoads[system] || 0;
          systemsBreakdown.push(`${system}:${load}W`);
        });
        
        let drawBreakdown = `Base: ${baseLoad}W`;
        if (systemsBreakdown.length > 0) {
          drawBreakdown += ` + Systems: [${systemsBreakdown.join(', ')}]`;
        }
        if (motorDraw > 0) drawBreakdown += ` + Motor: ${motorDraw.toFixed(1)}W`;
        if (teleportDraw > 0) drawBreakdown += ` + TELEPORT: ${teleportDraw.toFixed(0)}W`;
        drawBreakdown += ` = ${systemDraw.toFixed(1)}W`;
        
        console.log(`[POWER] Solar: ${solarPower.toFixed(1)}W | ${drawBreakdown} | Balance: ${powerBalance.toFixed(1)}W`);
        console.log(`[BATTERY] A: ${batterySystem.batteries[0]?.currentCharge.toFixed(1)}Wh (${batterySystem.batteries[0]?.getChargePercentage().toFixed(1)}%) | B: ${batterySystem.batteries[1]?.currentCharge.toFixed(1)}Wh (${batterySystem.batteries[1]?.getChargePercentage().toFixed(1)}%)`);
        console.log(`[SOLAR] Extension: ${(solarSystem.extension * 100).toFixed(1)}% | State: ${['RETRACT', 'STOP', 'EXTEND'][solarSystem.panelState]} | Bus: ${solarSystem.connectedToBus ? 'CONNECTED' : 'DISCONNECTED'}`);
        
        if (powerSystem.teleportInProgress) {
          const elapsed = (performance.now() / 1000) - powerSystem.teleportStartTime;
          const remaining = powerSystem.teleportDuration - elapsed;
          console.log(`[TELEPORT] In progress: ${remaining.toFixed(1)}s remaining`);
        }
      }
      
      if (powerBalance > 0) {
        // Surplus power - charge batteries
        const actualCharged = batterySystem.chargeBatteries(powerBalance, deltaTime);
        mainBus.currentSupply = solarPower;
        
        // Debug charging
        if (frameCounter % 300 === 0) {
          const connectedBats = batterySystem.getConnectedBatteries();
          console.log(`[CHARGING] Offered: ${powerBalance.toFixed(1)}W | Accepted: ${actualCharged.toFixed(1)}W | dt: ${deltaTime.toFixed(4)}s | Connected: [${connectedBats.map(b => b.id).join(', ')}]`);
        }
      } else if (powerBalance < 0) {
        // Deficit - draw from batteries
        const deficit = Math.abs(powerBalance);
        const actualDrawn = batterySystem.drawPower(deficit, deltaTime);
        mainBus.currentSupply = solarPower + actualDrawn;
        
        // Check if we couldn't meet demand
        if (actualDrawn < deficit * 0.9) {
          // Power shortage!
          // In future: trigger brownout, disable non-critical systems
        }
      } else {
        // Perfect balance (rare)
        mainBus.currentSupply = solarPower;
      }

      // Update UI at 10 Hz (every 6 frames at 60 FPS)
      if (frameCounter % 6 === 0) {
        updateSolarPanelUI();
        updatePowerDrawUI();
        
        // Update battery UI if charge changed significantly
        batterySystem.batteries.forEach(battery => {
          updateBatteryUI(battery);
        });

        // Update navigation UI (especially during travel)
        if (navigationSystem.traveling) {
          updateNavigationUI();
        }
      }

      // Continue loop
      requestAnimationFrame(gameLoop);
    }

    // Start game loop
    requestAnimationFrame(gameLoop);

    // ============================================================================
    // DEBUG HELPERS (remove in production)
    // ============================================================================
    
    // Expose to window for debugging
    window.DEBUG = {
      eventBus,
      batterySystem,
      saveSystem,
      solarSystem,
      powerSystem,
      fuelSystem,
      navigationSystem,
      mainBus,
      getBatteryStatus: () => batterySystem.getStatus(),
      getSolarStatus: () => solarSystem.getStatus(),
      getFuelStatus: () => fuelSystem.getStatus(),
      getNavigationStatus: () => navigationSystem.getStatus(),
      getPowerStatus: () => ({
        draw: powerSystem.getTotalDraw(),
        supply: mainBus.currentSupply,
        balance: mainBus.currentSupply - powerSystem.getTotalDraw(),
        busUtilization: mainBus.getUtilization()
      }),
      getSaveData: () => saveSystem.serializeGameState(),
      forceSave: () => saveSystem.save(),
      forceLoad: () => {
        const data = saveSystem.load();
        if (data) loadGameFromSave(data);
        return data;
      },
      clearSave: () => saveSystem.deleteSave(),
      newGame: () => initializeNewGame(),
      setSunlight: (intensity) => solarSystem.updateSunlight(intensity),
      addCredits: (amount) => {
        fuelSystem.credits += amount;
        updateFuelUI();
        console.log(`ðŸ’° Added ${amount}â‚µ. New balance: ${fuelSystem.credits}â‚µ`);
      },
      teleportTo: (x, y) => {
        navigationSystem.currentX = x;
        navigationSystem.currentY = y;
        updateNavigationUI();
        console.log(`ðŸŒ€ Teleported to (${x}, ${y})`);
      }
    };

    console.log('[INIT] Space Trader systems initialized');
    console.log('[SAVE] Auto-save enabled (every 5 seconds)');
    console.log('[DEBUG] Use window.DEBUG to inspect systems');
    console.log('[DEBUG] Commands:');
    console.log('   DEBUG.getBatteryStatus() - Battery system status');
    console.log('   DEBUG.getSolarStatus() - Solar panel status');
    console.log('   DEBUG.getFuelStatus() - Fuel and credits status');
    console.log('   DEBUG.getNavigationStatus() - Current location and navigation state');
    console.log('   DEBUG.getPowerStatus() - Power flow status');
    console.log('   DEBUG.getSaveData() - Current save data');
    console.log('   DEBUG.forceSave() - Save immediately');
    console.log('   DEBUG.forceLoad() - Reload from save');
    console.log('   DEBUG.clearSave() - Delete save');
    console.log('   DEBUG.newGame() - Start new game');
    console.log('   DEBUG.setSunlight(0.5) - Set sunlight intensity (0-1)');
    console.log('   DEBUG.addCredits(1000) - Add credits');
    console.log('   DEBUG.teleportTo(2, -4) - Teleport to coordinates');
    console.log('');
    console.log('[POWER] Solar panels at FULL SUN strength (100%) for testing');
    console.log('[POWER] Extend panels to CHARGE batteries | Retract to DRAIN batteries');
    console.log('[TIP] Toggle Battery Bus A/B to control which batteries power the ship');
    console.log('[TIP] Use GALAXY MAP to see neighboring systems, then BEGIN TRAVEL to jump');

    // ============================================================================
    // FULLSCREEN TOGGLE
    // ============================================================================
    
    const fullscreenToggle = document.getElementById('fullscreen-toggle');
    
    fullscreenToggle.addEventListener('change', function() {
      if (this.checked) {
        // Request fullscreen with navigation UI hidden (immersive mode)
        const docEl = document.documentElement;
        
        if (docEl.requestFullscreen) {
          docEl.requestFullscreen({ navigationUI: "hide" }).catch(err => {
            console.log('Fullscreen request failed:', err);
          });
        } else if (docEl.webkitRequestFullscreen) {
          docEl.webkitRequestFullscreen();
        } else if (docEl.msRequestFullscreen) {
          docEl.msRequestFullscreen();
        }
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
    });

    // Listen for fullscreen changes (e.g., user pressing ESC or swiping up nav)
    document.addEventListener('fullscreenchange', syncFullscreenToggle);
    document.addEventListener('webkitfullscreenchange', syncFullscreenToggle);
    document.addEventListener('msfullscreenchange', syncFullscreenToggle);

    function syncFullscreenToggle() {
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      fullscreenToggle.checked = isFullscreen;
    }

    // ============================================================================
    // COCKPIT PIN TOGGLE
    // ============================================================================
    
    const cockpitPinToggle = document.getElementById('cockpit-pin-toggle');
    const cockpitPanel = document.querySelector('.cockpit-panel');
    
    // Initialize as unpinned (unchecked by default)
    cockpitPinToggle.checked = false;
    cockpitPanel.classList.add('unpinned');
    
    cockpitPinToggle.addEventListener('change', function() {
      if (this.checked) {
        // Pin the cockpit (enable sticky)
        cockpitPanel.classList.remove('unpinned');
      } else {
        // Unpin the cockpit (disable sticky)
        cockpitPanel.classList.add('unpinned');
        cockpitPanel.classList.remove('stuck'); // Remove stuck styling
      }
    });
    
    // Use Intersection Observer to detect when panel is stuck at top
    // This adds enhanced shadow when the panel is floating
    const observerOptions = {
      threshold: [1],
      rootMargin: '-1px 0px 0px 0px' // Offset by top position
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        // When the panel is NOT fully intersecting (i.e., it's stuck at top)
        if (!entry.isIntersecting && cockpitPinToggle.checked) {
          cockpitPanel.classList.add('stuck');
        } else {
          cockpitPanel.classList.remove('stuck');
        }
      });
    }, observerOptions);
    
    // Create a sentinel element just before the cockpit panel to observe
    const sentinel = document.createElement('div');
    sentinel.style.height = '1px';
    sentinel.style.marginBottom = '-1px';
    sentinel.style.pointerEvents = 'none';
    cockpitPanel.parentNode.insertBefore(sentinel, cockpitPanel);
    observer.observe(sentinel);
    
    // ============================================================================
    // PREVENT CONTEXT MENU ON ALL DIALS (MOBILE LONG-PRESS)
    // ============================================================================
    
    document.querySelectorAll('.dial').forEach(dial => {
      // Prevent context menu
      dial.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      // Also prevent on child elements
      dial.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }, true); // Use capture phase
    });
    
  </script>
</body>
</html>
