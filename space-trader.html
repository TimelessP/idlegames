<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#e6dfcf" />
  <title>Space Trader</title>
  <meta name="description" content="Showcase of mechanical/retro console components built with semantic HTML and CSS only." />
  <link rel="icon" href="favicon.ico" />
  <style>
    :root {
      --panel-bg: #e6dfcf;
      --panel-rim: #8f897a;
      --panel-shadow: rgba(0,0,0,0.35);
      --panel-pad: 20px;   /* base padding inside panel */
      --panel-pad-safe: 36px; /* doubled so content never touches rivets */

      --keycap: #2b2b2b;
      --keycap-2: #1f1f1f;
      --keycap-3: #3a3a3a;
      --key-text: #efefef;

      --amber: #ffbf00;
      --amber-dim: #e5aa00;
      --amber-deep: #7a4d00;

      --ink: #1a1a1a; /* black ink labels on panel */
      
      color-scheme: light;
    }

    * { box-sizing: border-box; }
    
    html {
      background-color: var(--panel-bg);
    }
    
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: linear-gradient(180deg, #cfc7b6, #d6cfbe 40%, #cfc7b6);
      color: #111;
      /* space for sticky title bar + top safe area */
      padding-top: calc(64px + env(safe-area-inset-top));
      /* Extend under system UI (notches/gesture areas) */
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }

    /* Sticky title bar */
    .title-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      background: var(--panel-bg);
      border-bottom: 2px solid var(--panel-rim);
      box-shadow: 0 4px 12px var(--panel-shadow);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      z-index: 1000;
      /* Extend to cover safe area at top */
      padding-top: env(safe-area-inset-top);
      padding-left: calc(24px + env(safe-area-inset-left));
      padding-right: calc(24px + env(safe-area-inset-right));
      /* Adjust height to include safe area */
      height: calc(64px + env(safe-area-inset-top));
    }
    .title-bar h1 {
      font-size: 22px;
      margin: 0;
      color: var(--ink);
      letter-spacing: 0.02em;
    }
    .title-controls {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .title-bar .toggle {
      flex-shrink: 0;
    }

    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; display: grid; gap: 16px; }
    h1, h2 { margin: 0; }
    h1 { font-size: 22px; }
    h2 { font-size: 16px; color: #333; }

    /* Inset metal panel: surface flush, border seam looks cut-in */
    .panel {
      position: relative;
      background: var(--panel-bg);
      border-radius: 14px;
      border: 2px solid var(--panel-rim);
      padding: var(--panel-pad-safe);
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.2),            /* enamel sheen */
        inset 0 12px 20px rgba(0,0,0,0.10),               /* shallow emboss */
        0 6px 18px var(--panel-shadow);                   /* cast shadow */
    }
    /* Inset border seam into the flush surface */
    .panel::before {
      content: "";
      position: absolute; inset: 6px;
      border-radius: 10px;
      box-shadow: inset 0 0 0 2px var(--panel-rim), inset 0 8px 14px rgba(0,0,0,0.12);
      pointer-events: none;
    }
    /* Flathead screws in four corners; content padding ensures no overlap */
    .panel .rivet {
      position: absolute; width: 16px; height: 16px; border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #9aa7b4, #647482);
      border: 1px solid #3c4b57;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.25), 0 2px 3px rgba(0,0,0,0.35);
    }
    /* Flathead slot (narrow rectangle) */
    .panel .rivet::after {
      content: "";
      position: absolute;
      left: 50%; top: 50%;
      width: 10px; height: 2px;
      background: linear-gradient(90deg, rgba(0,0,0,0.3), rgba(0,0,0,0.8), rgba(0,0,0,0.3));
      transform: translate(-50%, -50%);
      box-shadow: inset 0 1px 0 rgba(0,0,0,0.6);
    }
    .panel .rivet.tl { top: 10px; left: 10px; }
    .panel .rivet.tl::after { transform: translate(-50%, -50%) rotate(-45deg); }
    .panel .rivet.tr { top: 10px; right: 10px; }
    .panel .rivet.tr::after { transform: translate(-50%, -50%) rotate(45deg); }
    .panel .rivet.bl { bottom: 10px; left: 10px; }
    .panel .rivet.bl::after { transform: translate(-50%, -50%) rotate(45deg); }
    .panel .rivet.br { bottom: 10px; right: 10px; }
    .panel .rivet.br::after { transform: translate(-50%, -50%) rotate(-45deg); }

    .section { display: grid; gap: 10px; }
    .row { display: grid; grid-template-columns: repeat(2, minmax(220px, 1fr)); gap: 14px; align-items: start; }
    .row > * { min-width: 0; }
    @media (max-width: 720px){ .row { grid-template-columns: 1fr; } }

    /* Cockpit panel sticky behavior */
    .cockpit-panel {
      position: sticky;
      top: -1px; /* Stick just below viewport top */
      z-index: 100;
      transition: box-shadow 0.3s ease, background 0.3s ease;
    }
    
    /* When not pinned, disable sticky */
    .cockpit-panel.unpinned {
      position: relative;
      z-index: 1;
    }
    
    /* Enhanced shadow and slight background change when stuck at top */
    .cockpit-panel.stuck {
      background: linear-gradient(180deg, 
        rgba(255, 255, 255, 0.08),
        var(--panel-bg) 20%
      );
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.25),
        inset 0 12px 20px rgba(0,0,0,0.10),
        0 12px 32px rgba(0,0,0,0.4); /* Stronger shadow when floating */
    }

    .label { color: var(--ink); font-weight: 700; letter-spacing: .02em; margin-bottom: 8px; }

    /* Charcoal button with recessed hole on press */
    .btn {
      display: inline-block;
      background: linear-gradient(180deg, var(--keycap-3), var(--keycap-2));
      color: var(--key-text);
      border: 2px solid #000;
      border-bottom-color: #000;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 800; letter-spacing: .02em; text-align: center;
      box-shadow: 0 3px 0 #000, 0 8px 16px rgba(0,0,0,.35);
      cursor: pointer; user-select: none;
      position: relative;
    }
    /* Recessed hole appears under key when pressed */
    .btn::after {
      content: "";
      position: absolute; inset: 6px; border-radius: 8px;
      background: linear-gradient(180deg, #0b0b0b, #151515);
      box-shadow: inset 0 6px 10px rgba(0,0,0,.6);
      opacity: 0; transition: opacity .06s ease;
      z-index: -1; /* sit beneath key */
    }
    .btn:active { transform: translateY(2px); box-shadow: 0 1px 0 #000, 0 4px 10px rgba(0,0,0,.25); }
    .btn:active::after { opacity: 1; }
    /* Disabled button state - physical appearance unchanged, just non-functional */
    .btn:disabled,
    .btn.disabled {
      pointer-events: none;
    }

    .btn.btn-full {
      width: 100%;
    }

    .btn.btn-safe {
      opacity: 0.55;
      filter: saturate(0.75);
    }
    .btn.btn-safe:disabled {
      opacity: 0.55;
    }

    .btn.btn-armed {
      background: linear-gradient(180deg, #ffb347, #ff6a00);
      color: #1a0e00;
      border-color: #ff8c00;
      box-shadow: 0 0 24px rgba(255, 140, 0, 0.45), 0 0 10px rgba(255, 197, 110, 0.65);
      animation: btn-armed-glow 2.4s ease-in-out infinite;
    }

    @keyframes btn-armed-glow {
      0%, 100% {
        filter: brightness(1);
        box-shadow: 0 0 24px rgba(255, 140, 0, 0.45), 0 0 10px rgba(255, 197, 110, 0.65);
      }
      50% {
        filter: brightness(1.1);
        box-shadow: 0 0 32px rgba(255, 170, 0, 0.65), 0 0 16px rgba(255, 219, 140, 0.75);
      }
    }

    /* Toggle (semantic checkbox) */
    .toggle { display: inline-flex; gap: 8px; align-items: center; color: var(--ink); font-weight: 600; }
    .toggle .toggle-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .toggle .toggle-label-text {
      text-transform: inherit;
    }
    .toggle .toggle-icon {
      display: none;
      width: 18px;
      height: 18px;
      position: relative;
      border-radius: 4px;
      flex-shrink: 0;
      align-items: center;
      justify-content: center;
    }
    .toggle .toggle-icon::before,
    .toggle .toggle-icon::after {
      content: "";
      position: absolute;
      pointer-events: none;
    }
    .toggle .toggle-icon--theme {
      border-radius: 50%;
      background: #111;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }
    .toggle .toggle-icon--theme::before {
      inset: -4px;
      border-radius: 50%;
      border: 2px solid rgba(0, 0, 0, 0.45);
      opacity: 0.35;
    }
    .toggle .toggle-icon--theme::after {
      content: none;
    }
    .toggle .toggle-icon--fullscreen {
      background: #111;
      border: 1px solid rgba(0, 0, 0, 0.75);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.2), 0 1px 2px rgba(0,0,0,0.25);
    }
    .toggle .toggle-icon--fullscreen::before,
    .toggle .toggle-icon--fullscreen::after {
      width: 6px;
      height: 6px;
      border: 2px solid rgba(0, 0, 0, 0.85);
      border-radius: 2px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
    }
    .toggle .toggle-icon--fullscreen::before {
      top: 2px;
      left: 2px;
      border-right: none;
      border-bottom: none;
    }
    .toggle .toggle-icon--fullscreen::after {
      bottom: 2px;
      right: 2px;
      border-left: none;
      border-top: none;
    }
    .toggle input { position: absolute; inline-size: 1px; block-size: 1px; overflow: hidden; clip-path: inset(50%); white-space: nowrap; border: 0; padding: 0; }
    .toggle .track {
      width: 64px; height: 28px; border-radius: 8px;
      background: #d1cab8; border: 2px solid var(--panel-rim);
      box-shadow: inset 0 0 10px rgba(0,0,0,.15);
      position: relative;
    }
    .toggle .thumb {
      position: absolute; top: 50%; left: 2px; width: 26px; height: 22px; border-radius: 6px;
      transform: translateY(-50%);
      background: linear-gradient(180deg,#3a3a3a, #232323); border: 2px solid #111; box-shadow: 0 2px 0 #000;
      transition: left .2s ease;
    }
    .toggle input:checked + .track .thumb { left: 34px; }
    /* Disabled toggle - physical appearance unchanged, just non-functional */
    .toggle input:disabled + .track {
      pointer-events: none;
    }

    /* Rotary dial knob (CSS variables) - interactive via hidden slider */
    .dial {
      --size: 120px;                  /* knob outer size */
      --start-angle: -120deg;         /* start of arc */
      --end-angle: 120deg;            /* end of arc */
      --steps: 12;                    /* number of discrete steps */
      --value: 6;                     /* current step index (0..steps) */
      --step-angle: calc((var(--end-angle) - var(--start-angle)) / var(--steps));
      width: var(--size); height: var(--size); position: relative; cursor: pointer;
      margin: 16px 16px 40px 16px;  /* extra space for graduations and label below */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: none;
      -webkit-touch-callout: none; /* Disable iOS callout */
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
    }
    /* Prevent text selection on all child elements */
    .dial * {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
    }
    /* Hidden slider drives the dial */
    .dial input[type="range"] {
      position: absolute; inset: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; z-index: 10;
      touch-action: none; /* Prevent touch gestures on the slider itself */
    }
    /* Step marks ring (around knob) - only within start/end range */
    .dial .marks {
      position: absolute; inset: 0; border-radius: 50%;
      background:
        /* draw ticks only within active range */
        repeating-conic-gradient(from var(--start-angle),
          #0000 0 calc(var(--step-angle) - 1deg),
          rgba(0,0,0,.6) calc(var(--step-angle) - 1deg) var(--step-angle)
        );
      /* Mask to show only start-angle to end-angle arc */
      mask:
        conic-gradient(from var(--start-angle),
          #000 0 calc(var(--end-angle) - var(--start-angle)),
          #0000 calc(var(--end-angle) - var(--start-angle)) 360deg
        ),
        radial-gradient(circle at 50% 50%, #0000 calc(50% - 6px), #000 0);
      mask-composite: intersect;
      -webkit-mask:
        conic-gradient(from var(--start-angle),
          #000 0 calc(var(--end-angle) - var(--start-angle)),
          #0000 calc(var(--end-angle) - var(--start-angle)) 360deg
        ),
        radial-gradient(circle at 50% 50%, #0000 calc(50% - 6px), #000 0);
      -webkit-mask-composite: source-in;
      pointer-events: none;
    }
    /* Static shadow layer (doesn't rotate with knob) */
    .dial .shadow {
      position: absolute; inset: 12px; border-radius: 50%;
      box-shadow: 0 8px 16px rgba(0,0,0,.35);
      pointer-events: none;
      z-index: 1;
    }
    /* Knob face with grooves (rotates) */
    .dial .knob {
      position: absolute; inset: 12px; border-radius: 50%;
      background:
        repeating-conic-gradient(from 0deg, rgba(255,255,255,0.06) 0 10deg, rgba(0,0,0,0.05) 10deg 20deg),
        radial-gradient(circle at 50% 45%, #4b4b4b, #222 65%);
      border: 2px solid #101010; box-shadow: inset 0 2px 6px rgba(255,255,255,.06);
      pointer-events: none;
      transition: transform .1s ease;
      z-index: 2;
    }
    /* Notch */
    .dial .knob::after {
      content: ""; position: absolute; left: 50%; top: 8px; width: 4px; height: 14px; border-radius: 2px;
      background: #fff; transform: translateX(-50%);
      pointer-events: none;
    }
    /* Compute angle from value within [start,end] and rotate entire knob */
    .dial { --angle: calc(var(--start-angle) + var(--value) * var(--step-angle)); }
    .dial .knob { transform: rotate(var(--angle)); }
    .dial .cap { position: absolute; inset: 34px; border-radius: 50%; background: radial-gradient(circle at 50% 45%, #333, #111); box-shadow: inset 0 2px 6px rgba(0,0,0,.6); pointer-events: none; z-index: 3; }
    .dial .legend { position: absolute; left: 0; right: 0; top: 100%; margin-top: 8px; text-align: center; color: var(--ink); font-size: 12px; font-weight: 700; pointer-events: none; }
    /* Disabled dial state - physical appearance unchanged, just non-functional */
    .dial input:disabled {
      pointer-events: none;
    }

    /* Amber terminal screen */
    .crt {
      background: radial-gradient(120% 180% at 50% 8%, rgba(255,255,255,0.08), transparent 40%),
                  linear-gradient(180deg, #2a1600, #211100 50%, #140a00),
                  linear-gradient(180deg, var(--amber-deep), #1b0f00);
      border: 2px solid #3a2b15; border-radius: 10px; padding: 12px;
      color: var(--amber);
      text-shadow: 0 0 6px rgba(255, 191, 0, 0.65);
      box-shadow: inset 0 0 35px rgba(255,191,0,0.1), 0 3px 12px var(--panel-shadow);
      font-family: "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-variant-numeric: lining-nums;
      letter-spacing: .02em;
      overflow-x: auto;
      min-width: 0;
    }
    .crt pre, .crt code { margin: 0; white-space: pre-wrap; }

    /* Cockpit viewing window */
    .window {
      position: relative; 
      padding: 20px;  /* outer frame padding */
      background: linear-gradient(180deg, #5a5a52, #3e3e38);  /* metal frame */
      border-radius: 16px;
      border: 2px solid #2a2a26;
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.15),  /* frame highlight */
        inset 0 0 20px rgba(0,0,0,0.3),        /* frame depth */
        0 4px 0 #2a2a26,                        /* depth step */
        0 8px 16px rgba(0,0,0,0.3);            /* cast shadow */
    }
    /* Viewport (actual viewing area) */
    .window .viewport {
      position: relative; height: 220px; border-radius: 8px; overflow: hidden;
      background: linear-gradient(180deg, #000814, #000408);
      box-shadow: 
        inset 0 0 0 3px #1a1a1a,               /* inner bezel */
        inset 0 0 30px rgba(0,0,0,.8);         /* recessed depth */
    }
    
    /* Warp burst overlay - hidden by default, shown during warp phase */
    .window .viewport .warp-burst {
      position: absolute;
      inset: 0;
      display: none; /* Hidden by default */
      pointer-events: none;
    }
    
    .window .viewport .warp-burst.active {
      display: block;
    }
    
    .window .viewport .warp-burst svg {
      width: 100%;
      height: 100%;
    }
    
    .window .viewport .warp-burst .star-streak {
      filter: blur(0.5px) drop-shadow(0 0 3px currentColor);
      mix-blend-mode: screen; /* Additive blending for glow */
    }
    
    /* Starfield will be generated dynamically via JavaScript */
    
    /* Figure-8 movement for starfield - identical to planet movement */
    @keyframes starfieldFigureEight {
      0% { transform: translate(0, 0); }
      12.5% { transform: translate(40px, -20px); }
      25% { transform: translate(60px, 0); }
      37.5% { transform: translate(40px, 20px); }
      50% { transform: translate(0, 0); }
      62.5% { transform: translate(-40px, 20px); }
      75% { transform: translate(-60px, 0); }
      87.5% { transform: translate(-40px, -20px); }
      100% { transform: translate(0, 0); }
    }
    
    /* Gentle star twinkling animation */
    @keyframes starfieldTwinkle {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }
    
    .window .glass {
      position: absolute; inset: 0; border-radius: 10px; pointer-events: none;
      background:
        radial-gradient(100% 60% at 50% 0%, rgba(255,255,255,.18), transparent 40%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      mix-blend-mode: screen;
    }
    
    .window .planet {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 140px;
      height: 140px;
      margin-left: -70px; /* Half of width to center */
      margin-top: -70px; /* Half of height to center */
      border-radius: 50%;
      background: transparent;
      box-shadow: none;
      /* Sprite removed; element serves as a placeholder for sizing only */
      animation: none;
    }
    .window .moon {
      display: none; /* Hidden - not rendering moons */
    }
    
    /* Figure-8 (lemniscate) path animation - smooth and continuous with pixel-based movement */
    @keyframes planetFigureEight {
      0% { transform: translate(0, 0); }
      12.5% { transform: translate(40px, -20px); }
      25% { transform: translate(60px, 0); }
      37.5% { transform: translate(40px, 20px); }
      50% { transform: translate(0, 0); }
      62.5% { transform: translate(-40px, 20px); }
      75% { transform: translate(-60px, 0); }
      87.5% { transform: translate(-40px, -20px); }
      100% { transform: translate(0, 0); }
    }
    
    /* Travel animation: Departure phase - planet and stars move down (ship goes up) */
    @keyframes travelDeparture {
      0% { transform: translate(0, 0); }
      100% { transform: translate(0, 300px); }
    }
    
    /* Travel animation: Arrival phase - planet grows from small to normal size */
    @keyframes travelArrival {
      0% { 
        transform: translate(0, -300px) scale(0.01);
        opacity: 0;
      }
      50% {
        opacity: 1;
      }
      100% { 
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
    }
    
    @keyframes moon { from { transform: translateX(0); } to { transform: translateX(-40%); } }

    /* Slider (range) with stamped groove */
    .slider-wrap { color: var(--ink); font-weight: 700; }
    .slider-labels { display: flex; justify-content: space-between; font-size: 12px; margin-top: 6px; color: var(--ink); }
    input[type="range"].slider {
      -webkit-appearance: none; appearance: none; width: 100%; height: 28px; background: transparent; margin: 0; cursor: pointer;
    }
    /* track as stamped groove */
    .slider::-webkit-slider-runnable-track {
      height: 8px; border-radius: 6px; border: 1px solid #585247;
      background: linear-gradient(180deg, #1a1a1a, #0e0e0e);
      box-shadow: inset 0 4px 8px rgba(0,0,0,.6);
    }
    .slider::-moz-range-track {
      height: 8px; border-radius: 6px; border: 1px solid #585247;
      background: linear-gradient(180deg, #1a1a1a, #0e0e0e);
      box-shadow: inset 0 4px 8px rgba(0,0,0,.6);
    }
    /* thumb as charcoal puck */
    .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -10px; width: 28px; height: 28px; border-radius: 50%; background: linear-gradient(180deg,#3a3a3a,#252525); border: 2px solid #111; box-shadow: 0 2px 0 #000; }
    .slider::-moz-range-thumb { width: 28px; height: 28px; border-radius: 50%; background: linear-gradient(180deg,#3a3a3a,#252525); border: 2px solid #111; box-shadow: 0 2px 0 #000; }
    input[type="range"].slider:disabled {
      cursor: not-allowed;
      filter: saturate(0.45) brightness(0.85);
    }
    input[type="range"].slider:disabled::-webkit-slider-thumb {
      background: linear-gradient(180deg, #2b2b2b, #1a1a1a);
      border-color: #222;
      box-shadow: none;
    }
    input[type="range"].slider:disabled::-moz-range-thumb {
      background: linear-gradient(180deg, #2b2b2b, #1a1a1a);
      border-color: #222;
      box-shadow: none;
    }

    /* Fuel meter (semantic progress, styled as analog gauge) */
    .gauge {
      --size: 220px;             /* overall diameter of the circle (we show the top half) */
      --thickness: 18px;         /* ring thickness of the arc */
      --value: 35;               /* 0..100 (maps left->right across the top semicircle) */
      --start: 180deg;           /* start at left */
      --sweep: 180deg;           /* show top semicircle from left (180) to right (360) */
      --end: calc(var(--start) + var(--sweep));
      /* Custom zone boundaries (0-100%) and colors */
      --zone1-start: 0;          /* first zone start % */
      --zone1-end: 20;           /* first zone end % */
      --zone1-color: #8a2020;    /* first zone color (default red) */
      --zone2-start: 20;         /* second zone start % */
      --zone2-end: 60;           /* second zone end % */
      --zone2-color: #c8c8c0;    /* second zone color (default ivory) */
      --zone3-start: 60;         /* third zone start % */
      --zone3-end: 100;          /* third zone end % */
      --zone3-color: #5a8a5a;    /* third zone color (default green) */
      position: relative;
      width: calc(var(--size) + 32px);  /* add padding around component */
      padding: 16px 16px 12px 16px;     /* reduced bottom padding for label space */
      margin: 6px auto 0;
      background: #e8e6dc;               /* brighter desaturated white backing */
      border-radius: 14px 14px 10px 10px;
      border: 2px solid #8a8578;
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.3),  /* top highlight */
        0 4px 0 #7a7568,                       /* depth step */
        0 8px 16px rgba(0,0,0,0.25);          /* cast shadow */
    }
    /* Hide semantic progress bar but keep it for accessibility */
    .gauge progress {
      position: absolute; width: 1px; height: 1px; overflow: hidden; clip-path: inset(50%); white-space: nowrap; border: 0; padding: 0;
    }
    /* Face/dial container (holds all gauge elements) */
    .gauge .face {
      position: relative;
      width: var(--size);
      height: calc(var(--size)/2 + 16px);
      margin: 0 auto 14px;  /* more space below for label */
    }
    /* Label below the needle pivot */
    .gauge .gauge-label {
      text-align: center;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: var(--ink);
      margin: 0 12px;
      opacity: 0.75;
    }
    /* Min/max value labels at arc ends */
    .gauge .gauge-min,
    .gauge .gauge-max {
      position: absolute;
      bottom: -2px;
      font-size: 9px;
      font-weight: 600;
      color: var(--ink);
      opacity: 0.6;
      font-family: "Intel One Mono", ui-monospace, monospace;
      pointer-events: none;
    }
    .gauge .gauge-min {
      left: 8px;
    }
    .gauge .gauge-max {
      right: 8px;
    }
    /* Glass hemisphere with rim */
    .gauge .glass {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background: radial-gradient(100% 60% at 50% 0%, rgba(255,255,255,.12), transparent 50%);
      border: 2px solid #3c3c3c; border-bottom: none;
      box-shadow: inset 0 0 20px rgba(255,255,255,.06);
      pointer-events: none; z-index: 4;
    }
    /* Color zone arc (behind glass) */
    .gauge .arc {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background:
        /* Paint the TOP semicircle: 0deg (left) -> 180deg (right) with bottom-center origin matching ticks */
        conic-gradient(from -90deg at 50% 100%,
          /* zone 1: start% .. end% */
          var(--zone1-color) calc(var(--sweep) * (var(--zone1-start)/100)) calc(var(--sweep) * (var(--zone1-end)/100)),
          /* zone 2: start% .. end% */
          var(--zone2-color) calc(var(--sweep) * (var(--zone2-start)/100)) calc(var(--sweep) * (var(--zone2-end)/100)),
          /* zone 3: start% .. end% */
          var(--zone3-color) calc(var(--sweep) * (var(--zone3-start)/100)) calc(var(--sweep) * (var(--zone3-end)/100)),
          /* rest transparent */
          #0000 calc(var(--sweep) * (var(--zone3-end)/100)) 360deg
        );
      /* show only the top half of the circle */
      clip-path: polygon(0 100%, 0 0, 100% 0, 100% 100%);
      /* create ring band at needle radius (just outside ticks) */
      mask:
        radial-gradient(circle at 50% 100%,
          #0000 calc(50% - var(--thickness) - 6px),
          #000 calc(50% - var(--thickness) - 6px) calc(50% - var(--thickness) + 6px),
          #0000 calc(50% - var(--thickness) + 6px)
        );
      z-index: 0;
    }
    /* Minor radial tick marks (short) pointing to center */
    .gauge .ticks-minor {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background:
        repeating-conic-gradient(from -90deg at 50% 100%,
          /* 36 ticks across 180deg -> 5deg per tick cycle */
          #0000 0 4.4deg,
          rgba(0,0,0,.75) 4.4deg 5deg
        );
      clip-path: polygon(0 100%, 0 0, 100% 0, 100% 100%);
      /* place ticks at needle tip radius (outer edge) */
      mask:
        radial-gradient(circle at 50% 100%,
          #0000 calc(50% - 10px),
          #000 calc(50% - 10px) calc(50% - 2px),
          #0000 calc(50% - 2px)
        );
      z-index: 1;
    }
    /* Major radial tick marks (longer, bolder) every 30deg */
    .gauge .ticks-major {
      position: absolute; inset: 0; border-radius: 50% 50% 0 0;
      background:
        repeating-conic-gradient(from -90deg at 50% 100%,
          #0000 0 28.4deg,
          rgba(0,0,0,.95) 28.4deg 30deg
        );
      clip-path: polygon(0 100%, 0 0, 100% 0, 100% 100%);
      /* place ticks at needle tip radius, longer than minor ticks */
      mask:
        radial-gradient(circle at 50% 100%,
          #0000 calc(50% - 16px),
          #000 calc(50% - 16px) calc(50% - 2px),
          #0000 calc(50% - 2px)
        );
      z-index: 2;
    }
    /* Needle pointing from center (0% = left, 100% = right) */
    .gauge .needle {
      position: absolute; left: 50%; bottom: 0; width: 6px; height: calc(var(--size)/2 - var(--thickness) - 6px);
      background: linear-gradient(180deg, #222, #111);
      transform-origin: 50% 100%;
      transform: translateX(-50%) rotate(calc(var(--sweep) * (var(--value)/100) - 90deg));
      box-shadow: 0 0 6px rgba(0,0,0,.5);
      z-index: 3;
    }
    /* Center hub/rivet */
    .gauge .hub {
      position: absolute; left: 50%; bottom: 0; width: 14px; height: 14px;
      transform: translate(-50%, 50%); border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #444, #1a1a1a);
      border: 2px solid #000;
      box-shadow: inset 0 2px 4px rgba(255,255,255,.08), 0 2px 4px rgba(0,0,0,.4);
      z-index: 5;
    }

    /* Terminal-like input (visual) */
    .term-input {
      background: linear-gradient(180deg, #2a1600, #140a00);
      border: 2px solid #3a2b15; border-radius: 8px; padding: 10px 12px;
      color: var(--amber); text-shadow: 0 0 6px rgba(255,191,0,.5);
      font-family: "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      caret-color: var(--amber);
      outline: none;
      box-shadow: inset 0 0 35px rgba(255,191,0,0.08);
    }
    .term-input::placeholder { color: rgba(255,191,0,0.6); }
    /* Optional blinking block cue at right edge (for demo only) */
    .term-input.block-cursor { position: relative; }
    .term-input.block-cursor::after {
      content: ""; position: absolute; right: 12px; top: 50%; width: .6em; height: 1.1em; transform: translateY(-50%);
      background: rgba(255,191,0,0.85); box-shadow: 0 0 8px rgba(255,191,0,.5);
      animation: blink 1s steps(1,end) infinite; opacity: .9;
      pointer-events: none;
    }
    @keyframes blink { 0%, 50% { opacity: .0 } 50.01%, 100% { opacity: .9 } }

  .grid-2 { display: grid; grid-template-columns: repeat(2, minmax(140px, 1fr)); gap: 12px; }
  @media (max-width: 720px){ .grid-2 { grid-template-columns: 1fr; } }
  /* 3-column grid utility for scanner controls when adding an extra button */
  .grid-3 { display: grid; grid-template-columns: repeat(3, minmax(120px, 1fr)); gap: 12px; }
  @media (max-width: 720px){ .grid-3 { grid-template-columns: 1fr; } }

  /* Responsive cargo info layout */
  .cargo-info-grid {
    display: grid;
    grid-template-columns: 80px 80px minmax(0, 1fr);
    gap: 12px;
    margin-bottom: 16px;
    align-items: start;
  }
    .cargo-info-grid > div {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .cargo-info-grid .cargo-slot {
      width: 100%;
      min-width: 0;
    }
    @media (max-width: 580px) {
      .cargo-info-grid {
        grid-template-columns: repeat(2, minmax(80px, 1fr));
        grid-auto-rows: auto;
      }
      .cargo-info-grid > div:nth-child(2) {
        justify-self: stretch;
      }
      .cargo-info-grid > div:last-child {
        grid-column: 1 / -1;
        width: 100%;
      }
    }

  @media (max-width: 540px) and (orientation: portrait) {
    .title-controls {
      gap: 12px;
    }
    .title-controls .toggle .toggle-label-text {
      display: none;
    }
    .title-controls .toggle .toggle-icon {
      display: inline-flex;
    }
  }

    .trader-ship-holo {
      position: relative;
      width: 100%;
      min-height: 190px;
      border-radius: 10px;
      border: 2px solid #3a2b15;
      background:
        radial-gradient(120% 180% at 50% 8%, rgba(255, 255, 255, 0.08), transparent 40%),
        linear-gradient(180deg, #2a1600, #211100 50%, #140a00),
        linear-gradient(180deg, var(--amber-deep), #1b0f00);
      box-shadow:
        inset 0 0 35px rgba(255,191,0,0.12),
        0 3px 12px var(--panel-shadow);
      color: var(--amber);
      font-family: "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      letter-spacing: 0.02em;
      text-shadow: 0 0 6px rgba(255,191,0,0.5);
      overflow: hidden;
    }
    .trader-ship-holo::before,
    .trader-ship-holo::after,
    .ship-holo-label {
      font-family: "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .trader-ship-holo canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .trader-ship-holo::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255, 191, 0, 0.16),
          rgba(255, 191, 0, 0.16) 2px,
          rgba(255, 191, 0, 0.0) 2px,
          rgba(255, 191, 0, 0.0) 4px
        );
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.45;
      animation: holo-scan 5.6s linear infinite;
    }
    @keyframes holo-scan {
      from { transform: translateY(-4px); }
      to { transform: translateY(4px); }
    }
    .trader-ship-holo.offline canvas {
      opacity: 0;
    }
    .trader-ship-holo.offline::after {
      content: "";
    }
    .trader-ship-holo.scanning::after {
      content: "SCANNING...";
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      letter-spacing: 0.24em;
      color: rgba(255, 200, 80, 0.6);
      text-shadow: 0 0 10px rgba(255, 191, 0, 0.35);
      pointer-events: none;
    }
    .trader-ship-holo.scanning canvas {
      opacity: 0;
    }
    .ship-holo-label {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 10px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(255, 208, 100, 0.82);
      text-shadow: 0 0 14px rgba(255, 191, 0, 0.45);
      pointer-events: none;
      mix-blend-mode: screen;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .ship-actions-label { margin-top: 12px; }

    /* Cargo slot - physical storage slot with optional crate */
    .cargo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
    }
    .cargo-slot {
      position: relative;
      aspect-ratio: 1;
      background: linear-gradient(135deg, #0e0e0e, #1a1a1a 50%, #0e0e0e);
      border: 2px solid #3a3a38;
      border-radius: 8px;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.8), inset 0 2px 4px rgba(0,0,0,0.6);
      overflow: hidden;
      cursor: grab;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .cargo-slot.full:active {
      cursor: grabbing;
    }
    .cargo-slot.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }
    .cargo-slot.drag-over {
      border-color: #8b7d52;
      box-shadow: inset 0 0 20px rgba(139, 125, 82, 0.3), 0 0 20px rgba(139, 125, 82, 0.4);
      transform: scale(1.05);
    }
    /* Inspect slot - special styling with pulsing question mark */
    .cargo-slot.inspect-slot {
      cursor: default;
      border-color: #4a7ba7;
      background: linear-gradient(135deg, #0e1a1f, #1a2a30 50%, #0e1a1f);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .cargo-slot.inspect-slot * {
      pointer-events: none !important; /* Ensure ALL children don't interfere with drag-drop */
    }
    /* Disable pseudo-elements for inspect slot to prevent dragleave issues */
    .cargo-slot.inspect-slot::before,
    .cargo-slot.inspect-slot::after {
      display: none !important;
    }
    .cargo-slot.inspect-slot.drag-over {
      border-color: #6ba3d4;
      box-shadow: inset 0 0 20px rgba(107, 163, 212, 0.4), 0 0 20px rgba(107, 163, 212, 0.5);
    }
    .cargo-slot.inspect-slot .cargo-label {
      animation: pulse-question 2s ease-in-out infinite;
      /* Ensure the question mark is visually centered */
      line-height: 1;
      text-align: center;
    }
    @keyframes pulse-question {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 0.4; }
    }

    /* Refuel slot - special styling with pulsing lightning bolt */
    .cargo-slot.refuel-slot {
      cursor: default;
      border-color: #7ba74a;
      background: linear-gradient(135deg, #0e1f0e, #1a301a 50%, #0e1f0e);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .cargo-slot.refuel-slot * {
      pointer-events: none !important;
    }
    .cargo-slot.refuel-slot::before,
    .cargo-slot.refuel-slot::after {
      display: none !important;
    }
    .cargo-slot.refuel-slot.drag-over {
      border-color: #a3d46b;
      box-shadow: inset 0 0 20px rgba(163, 212, 107, 0.4), 0 0 20px rgba(163, 212, 107, 0.5);
    }
    .cargo-slot.refuel-slot .cargo-label {
      animation: pulse-energy 1.5s ease-in-out infinite;
      line-height: 1;
      text-align: center;
    }
    @keyframes pulse-energy {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.1); }
    }

    /* Empty slot has darker appearance with subtle depth lines */
    .cargo-slot.empty::before {
      content: "";
      position: absolute;
      inset: 8px;
      border: 1px dashed #2a2a28;
      border-radius: 4px;
      opacity: 0.3;
    }
    /* Full slot contains a metallic crate */
    .cargo-slot.full {
      background: linear-gradient(135deg, #4a4a46, #5e5e58 50%, #4a4a46);
      box-shadow: inset 0 0 10px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.4);
      /* Create a local stacking context so label can sit above X without affecting global stacking */
      z-index: 0;
    }
    /* Crate structure - outer square border */
    .cargo-slot.full::before {
      content: "";
      position: absolute;
      inset: 6px;
      border: 3px solid #2a2a28;
      border-radius: 4px;
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.15),
        inset 0 0 8px rgba(0,0,0,0.4);
    }
    /* Crate X-cross structure from corners */
    .cargo-slot.full::after {
      content: "";
      position: absolute;
      inset: 6px;
      background:
        /* diagonal line top-left to bottom-right */
        linear-gradient(135deg, 
          transparent calc(50% - 2px),
          rgba(42, 42, 40, 0.4) calc(50% - 2px),
          rgba(26, 26, 26, 0.4) 50%,
          rgba(42, 42, 40, 0.4) calc(50% + 2px),
          transparent calc(50% + 2px)
        ),
        /* diagonal line top-right to bottom-left */
        linear-gradient(45deg,
          transparent calc(50% - 2px),
          rgba(42, 42, 40, 0.4) calc(50% - 2px),
          rgba(26, 26, 26, 0.4) 50%,
          rgba(42, 42, 40, 0.4) calc(50% + 2px),
          transparent calc(50% + 2px)
        );
      box-shadow: inset 0 0 8px rgba(0,0,0,0.15);
      /* Ensure the X sits below the label within the slot */
      z-index: 0;
    }
    
    /* Cargo type label painted on crate */
    .cargo-slot .cargo-label {
      pointer-events: none; /* Don't interfere with drag-and-drop */
      user-select: none;
    }
    
    .cargo-slot.full .cargo-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Orbitron', monospace;
      font-size: 56px;
      font-weight: 900;
      color: rgba(255, 255, 255, 0.4);
      letter-spacing: -2px;
      /* Above crate X but confined to the slot */
      z-index: 1;
    }

    /* Teleportation effect - glittery cyan/white sparkles */
    .cargo-slot.teleporting {
      animation: teleport-pulse 0.3s ease-in-out infinite;
      position: relative;
    }
    .cargo-slot.teleporting::before {
      animation: teleport-sparkle 0.5s ease-in-out infinite;
    }
    @keyframes teleport-pulse {
      0%, 100% {
        box-shadow: 
          inset 0 0 20px rgba(0,255,255,0.6),
          0 0 20px rgba(0,255,255,0.4),
          0 0 40px rgba(0,255,255,0.2);
        filter: brightness(1.3);
      }
      50% {
        box-shadow: 
          inset 0 0 30px rgba(255,255,255,0.8),
          0 0 30px rgba(255,255,255,0.6),
          0 0 60px rgba(0,255,255,0.4);
        filter: brightness(1.6);
      }
    }
    @keyframes teleport-sparkle {
      0%, 100% {
        opacity: 0.5;
        transform: scale(0.95);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
    }

    .gauge-led-strip,
    .gauge-led-scale {
      display: none;
    }

    /* Dark theme overrides */
    html[data-theme="dark"] {
      color-scheme: dark;
      background-color: #05070d;
      --panel-bg: rgba(6, 14, 24, 0.95);
      --panel-rim: rgba(46, 143, 255, 0.55);
      --panel-shadow: rgba(13, 46, 84, 0.55);
      --keycap: #0b223b;
      --keycap-2: #071629;
      --keycap-3: #14385f;
      --key-text: #02101c;
      --ink: #7fc6ff;
      --zone1-color: rgba(255, 82, 134, 0.98);
      --zone2-color: rgba(156, 235, 255, 0.98);
      --zone3-color: rgba(112, 255, 188, 0.98);
    }
    html[data-theme="dark"] body {
      background: radial-gradient(110% 140% at 50% 0%, rgba(48, 138, 255, 0.12), transparent 65%), linear-gradient(180deg, #05070d 0%, #020306 55%, #05070d 100%);
      color: #b8d8ff;
    }
    html[data-theme="dark"] .title-bar {
      background: rgba(4, 12, 22, 0.92);
      border-bottom-color: rgba(46, 143, 255, 0.35);
      box-shadow: 0 0 24px rgba(46, 143, 255, 0.35);
    }
    html[data-theme="dark"] .title-bar h1 {
      color: #7fc6ff;
      text-shadow: 0 0 14px rgba(74, 182, 255, 0.65);
    }
    html[data-theme="dark"] .title-controls .toggle .toggle-label-text {
      color: #7fc6ff;
    }
    html[data-theme="dark"] .wrap {
      color: inherit;
    }
    html[data-theme="dark"] .panel {
      background: linear-gradient(180deg, rgba(6, 14, 24, 0.95), rgba(2, 6, 12, 0.98));
      border: 2px solid rgba(46, 143, 255, 0.6);
      box-shadow: 0 0 38px rgba(46, 143, 255, 0.28);
    }
    html[data-theme="dark"] .panel::before {
      border-radius: 12px;
      inset: 4px;
      box-shadow: inset 0 0 0 1px rgba(46, 143, 255, 0.35), 0 0 24px rgba(46, 143, 255, 0.25);
    }
    html[data-theme="dark"] .panel .rivet {
      background: radial-gradient(circle at 50% 40%, #343842, #111418 75%);
      border-color: #05080d;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08), 0 0 6px rgba(0,0,0,0.9);
    }
    html[data-theme="dark"] .panel .rivet::after {
      background: linear-gradient(180deg, #000, #000);
      box-shadow: none;
    }
    html[data-theme="dark"] .label,
    html[data-theme="dark"] h2 {
      color: #7fc6ff;
      text-shadow: 0 0 12px rgba(74, 182, 255, 0.6);
    }
    html[data-theme="dark"] h1 {
      color: inherit;
    }
    html[data-theme="dark"] .btn {
      background: radial-gradient(circle at 50% 40%, rgba(74, 182, 255, 0.85), rgba(27, 78, 138, 0.95));
      color: #02101c;
      border: 2px solid rgba(74, 182, 255, 0.8);
      box-shadow: 0 0 22px rgba(74, 182, 255, 0.5);
    }
    html[data-theme="dark"] .btn.btn-safe {
      color: rgba(127, 198, 255, 0.75);
    }
    html[data-theme="dark"] .btn::after {
      background: rgba(0, 0, 0, 0.55);
      box-shadow: inset 0 6px 12px rgba(0, 0, 0, 0.55);
    }
    html[data-theme="dark"] .btn:active {
      transform: none;
      background: radial-gradient(circle at 50% 40%, rgba(130, 236, 255, 0.95), rgba(32, 98, 162, 0.95));
      border-color: rgba(130, 236, 255, 0.85);
      box-shadow: 0 0 30px rgba(130, 236, 255, 0.75), 0 0 18px rgba(74, 182, 255, 0.65);
    }
    html[data-theme="dark"] .btn:active::after {
      opacity: 0;
    }
    html[data-theme="dark"] .btn.btn-armed {
      background: radial-gradient(circle at 50% 50%, rgba(255, 190, 80, 0.95), rgba(255, 110, 0, 0.95));
      color: #1a0e00;
      border-color: rgba(255, 168, 66, 0.95);
      box-shadow: 0 0 30px rgba(255, 170, 0, 0.55), 0 0 18px rgba(255, 210, 120, 0.7);
    }
    html[data-theme="dark"] .toggle {
      color: #7fc6ff;
      text-shadow: 0 0 10px rgba(74, 182, 255, 0.5);
    }
    html[data-theme="dark"] .toggle .track {
      background: rgba(6, 18, 34, 0.9);
      border: 2px solid rgba(74, 182, 255, 0.6);
      box-shadow: inset 0 0 14px rgba(74, 182, 255, 0.35), 0 0 18px rgba(74, 182, 255, 0.35);
    }
    html[data-theme="dark"] .toggle .toggle-icon--fullscreen {
      background: linear-gradient(135deg, rgba(74, 182, 255, 0.18), rgba(130, 236, 255, 0.32));
      border: 1px solid rgba(130, 236, 255, 0.7);
      box-shadow: 0 0 10px rgba(74, 182, 255, 0.55);
    }
    html[data-theme="dark"] .toggle .toggle-icon--fullscreen::before,
    html[data-theme="dark"] .toggle .toggle-icon--fullscreen::after {
      border-color: rgba(170, 240, 255, 0.9);
      box-shadow: 0 0 6px rgba(74, 182, 255, 0.6);
    }
    html[data-theme="dark"] .toggle .track::before {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: 14px;
      border: 1px solid rgba(74, 182, 255, 0.25);
      box-shadow: 0 0 24px rgba(74, 182, 255, 0.4);
      pointer-events: none;
    }
    html[data-theme="dark"] .toggle .thumb {
      background: radial-gradient(circle at 50% 50%, rgba(130, 236, 255, 0.9), rgba(24, 70, 120, 0.9));
      border: 2px solid rgba(130, 236, 255, 0.85);
      box-shadow: 0 0 16px rgba(74, 182, 255, 0.6);
    }
    html[data-theme="dark"] .toggle input:not(:checked) + .track {
      background: rgba(4, 12, 22, 0.9);
      box-shadow: inset 0 0 10px rgba(40, 100, 160, 0.35), 0 0 12px rgba(40, 100, 160, 0.25);
    }
    html[data-theme="dark"] .toggle input:not(:checked) + .track .thumb {
      background: radial-gradient(circle at 50% 45%, rgba(8, 20, 36, 0.95), rgba(2, 8, 14, 0.95));
      border: 2px solid rgba(38, 90, 150, 0.85);
      box-shadow: 0 0 6px rgba(38, 90, 150, 0.45);
    }
    html[data-theme="dark"] .toggle .toggle-icon--theme {
      background: radial-gradient(circle at 50% 50%, rgba(130, 236, 255, 0.95), rgba(24, 70, 120, 0.9));
      box-shadow: 0 0 16px rgba(74, 182, 255, 0.75);
    }
    html[data-theme="dark"] .toggle .toggle-icon--theme::before {
      border-color: rgba(130, 236, 255, 0.65);
      opacity: 0.6;
      box-shadow: 0 0 20px rgba(74, 182, 255, 0.65);
    }
    html[data-theme="dark"] .toggle .toggle-icon--theme::after {
      content: "";
      inset: 32% 12%;
      border-radius: 999px;
      background: rgba(204, 247, 255, 0.5);
      opacity: 0.7;
      filter: blur(1px);
    }
    html[data-theme="dark"] .dial {
      width: 100%;
      max-width: none;
      margin: 8px 0 0;
      padding: 0;
      background: none;
      border: 0;
      border-radius: 0;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
      touch-action: pan-x;
    }
    html[data-theme="dark"] .dial input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      opacity: 1;
      position: relative;
      inset: auto;
      width: 100%;
      height: 32px;
      cursor: pointer;
      touch-action: pan-x;
      margin: 0;
    }
    html[data-theme="dark"] .dial .marks,
    html[data-theme="dark"] .dial .shadow,
    html[data-theme="dark"] .dial .knob,
    html[data-theme="dark"] .dial .cap {
      display: none !important;
    }
    html[data-theme="dark"] .dial .legend {
      order: 1;
      margin: 0;
      position: static;
      top: auto;
      left: auto;
      right: auto;
      color: rgba(127, 198, 255, 0.75);
      font-size: 11px;
      letter-spacing: 0.18em;
      text-align: center;
      text-transform: uppercase;
      text-shadow: 0 0 8px rgba(74, 182, 255, 0.45);
    }
    html[data-theme="dark"] .dial input[type="range"]::-webkit-slider-runnable-track {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(74, 182, 255, 0.85) 0%, rgba(74, 182, 255, 0.85) var(--slider-fill, var(--fill, 0%)), rgba(6, 20, 36, 0.85) var(--slider-fill, var(--fill, 0%)), rgba(6, 20, 36, 0.85) 100%);
      border: 1px solid rgba(74, 182, 255, 0.6);
      box-shadow: 0 0 18px rgba(74, 182, 255, 0.45);
    }
    html[data-theme="dark"] .dial input[type="range"]::-moz-range-track {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(74, 182, 255, 0.85) 0%, rgba(74, 182, 255, 0.85) var(--slider-fill, var(--fill, 0%)), rgba(6, 20, 36, 0.85) var(--slider-fill, var(--fill, 0%)), rgba(6, 20, 36, 0.85) 100%);
      border: 1px solid rgba(74, 182, 255, 0.6);
      box-shadow: 0 0 18px rgba(74, 182, 255, 0.45);
    }
    html[data-theme="dark"] .dial input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, rgba(130, 236, 255, 0.95), rgba(24, 70, 120, 0.9));
      border: 2px solid rgba(130, 236, 255, 0.85);
      box-shadow: 0 0 22px rgba(74, 182, 255, 0.65);
      margin-top: -7px;
    }
    html[data-theme="dark"] .dial input[type="range"]::-moz-range-thumb {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, rgba(130, 236, 255, 0.95), rgba(24, 70, 120, 0.9));
      border: 2px solid rgba(130, 236, 255, 0.85);
      box-shadow: 0 0 22px rgba(74, 182, 255, 0.65);
    }
    html[data-theme="dark"] .dial input[type="range"]:disabled {
      cursor: not-allowed;
      filter: saturate(0.45) brightness(0.88);
    }
    html[data-theme="dark"] .dial input[type="range"]:disabled::-webkit-slider-thumb {
      background: radial-gradient(circle at 50% 50%, rgba(46, 90, 130, 0.65), rgba(12, 30, 50, 0.95));
      border-color: rgba(66, 120, 170, 0.65);
      box-shadow: 0 0 12px rgba(46, 143, 255, 0.3);
    }
    html[data-theme="dark"] .dial input[type="range"]:disabled::-moz-range-thumb {
      background: radial-gradient(circle at 50% 50%, rgba(46, 90, 130, 0.65), rgba(12, 30, 50, 0.95));
      border-color: rgba(66, 120, 170, 0.65);
      box-shadow: 0 0 12px rgba(46, 143, 255, 0.3);
    }
    html[data-theme="dark"] .slider-wrap {
      color: #7fc6ff;
      text-shadow: 0 0 10px rgba(74, 182, 255, 0.45);
    }
    html[data-theme="dark"] input[type="range"].slider {
      --slider-fill: 0%;
      height: 32px;
      cursor: pointer;
      margin-top: 8px;
      touch-action: pan-x;
    }
    html[data-theme="dark"] input[type="range"].slider::-webkit-slider-runnable-track {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(74, 182, 255, 0.85) 0%, rgba(74, 182, 255, 0.85) var(--slider-fill, 0%), rgba(6, 20, 36, 0.85) var(--slider-fill, 0%), rgba(6, 20, 36, 0.85) 100%);
      border: 1px solid rgba(74, 182, 255, 0.6);
      box-shadow: 0 0 18px rgba(74, 182, 255, 0.45);
    }
    html[data-theme="dark"] input[type="range"].slider::-moz-range-track {
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(74, 182, 255, 0.85) 0%, rgba(74, 182, 255, 0.85) var(--slider-fill, 0%), rgba(6, 20, 36, 0.85) var(--slider-fill, 0%), rgba(6, 20, 36, 0.85) 100%);
      border: 1px solid rgba(74, 182, 255, 0.6);
      box-shadow: 0 0 18px rgba(74, 182, 255, 0.45);
    }
    html[data-theme="dark"] input[type="range"].slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, rgba(130, 236, 255, 0.95), rgba(24, 70, 120, 0.9));
      border: 2px solid rgba(130, 236, 255, 0.85);
      box-shadow: 0 0 22px rgba(74, 182, 255, 0.65);
      margin-top: -7px;
    }
    html[data-theme="dark"] input[type="range"].slider::-moz-range-thumb {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, rgba(130, 236, 255, 0.95), rgba(24, 70, 120, 0.9));
      border: 2px solid rgba(130, 236, 255, 0.85);
      box-shadow: 0 0 22px rgba(74, 182, 255, 0.65);
    }
    html[data-theme="dark"] input[type="range"].slider:disabled {
      cursor: not-allowed;
      filter: saturate(0.6);
    }
    html[data-theme="dark"] input[type="range"].slider:disabled::-webkit-slider-thumb {
      background: radial-gradient(circle at 50% 50%, rgba(46, 90, 130, 0.65), rgba(12, 30, 50, 0.95));
      border-color: rgba(66, 120, 170, 0.65);
      box-shadow: 0 0 12px rgba(46, 143, 255, 0.3);
    }
    html[data-theme="dark"] input[type="range"].slider:disabled::-moz-range-thumb {
      background: radial-gradient(circle at 50% 50%, rgba(46, 90, 130, 0.65), rgba(12, 30, 50, 0.95));
      border-color: rgba(66, 120, 170, 0.65);
      box-shadow: 0 0 12px rgba(46, 143, 255, 0.3);
    }
    html[data-theme="dark"] .gauge {
      background: linear-gradient(180deg, rgba(6, 14, 24, 0.92), rgba(2, 6, 12, 0.96));
      border: 1px solid rgba(46, 143, 255, 0.4);
      border-radius: 14px;
      box-shadow: 0 0 28px rgba(46, 143, 255, 0.26);
      padding: 18px 20px 20px;
      width: 100%;
      margin: 6px 0 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    html[data-theme="dark"] .gauge .face {
      display: none !important;
    }
    html[data-theme="dark"] .gauge-label {
      color: #7fc6ff;
      text-shadow: 0 0 10px rgba(74, 182, 255, 0.6);
      letter-spacing: 0.16em;
      font-size: 12px;
      margin-top: 4px;
      text-align: center;
    }
    html[data-theme="dark"] .gauge-led-strip {
      position: relative;
      display: block;
      height: 30px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(4, 10, 18, 0.94), rgba(2, 6, 12, 0.99));
      border: 1px solid rgba(46, 143, 255, 0.48);
      overflow: hidden;
      box-shadow: inset 0 0 24px rgba(46, 143, 255, 0.32);
    }
    html[data-theme="dark"] .gauge-led-strip::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(120% 180% at 15% 50%, rgba(74, 182, 255, 0.28), transparent 62%);
      pointer-events: none;
      opacity: 0.55;
    }
    html[data-theme="dark"] .gauge-led-strip::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: calc(var(--led-value, 0) * 1%);
      background:
        linear-gradient(90deg,
          var(--led-color, rgba(112, 255, 188, 0.98)) 0%,
          var(--led-color, rgba(112, 255, 188, 0.98)) 15%,
          var(--led-color-boost, rgba(170, 255, 220, 1)) 50%,
          var(--led-color, rgba(112, 255, 188, 0.98)) 85%,
          var(--led-color, rgba(112, 255, 188, 0.98)) 100%);
      box-shadow: 0 0 42px var(--led-color-boost, rgba(170, 255, 220, 0.9));
      filter: saturate(1.28);
      border-radius: inherit;
      transition: width 140ms ease-out;
    }
    html[data-theme="dark"] .gauge-led-scale {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      font-weight: 600;
      color: rgba(127, 198, 255, 0.7);
      letter-spacing: 0.12em;
      margin-top: 8px;
      padding: 0 2px;
      font-family: "Intel One Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    html[data-theme="dark"] .crt {
      background: radial-gradient(140% 200% at 50% 0%, rgba(74, 182, 255, 0.24), transparent 55%), #02040a;
      border: 1px solid rgba(46, 143, 255, 0.4);
      color: #7fd6ff;
      text-shadow: 0 0 12px rgba(74, 182, 255, 0.6);
      box-shadow: inset 0 0 26px rgba(46, 143, 255, 0.28), 0 0 26px rgba(46, 143, 255, 0.28);
    }
    html[data-theme="dark"] .scanner-camera {
      background: radial-gradient(140% 200% at 50% 0%, rgba(74, 182, 255, 0.18), transparent 58%), #02040a;
      border: 1px solid rgba(46, 143, 255, 0.32);
      color: #7fd6ff;
      text-shadow: none;
      box-shadow: inset 0 0 20px rgba(46, 143, 255, 0.22);
    }
    html[data-theme="dark"] .crt pre,
    html[data-theme="dark"] .crt code {
      color: inherit;
    }
    html[data-theme="dark"] .term-input {
      background: #02040a;
      border: 1px solid rgba(46, 143, 255, 0.45);
      color: #7fd6ff;
      text-shadow: 0 0 8px rgba(74, 182, 255, 0.6);
      box-shadow: inset 0 0 24px rgba(46, 143, 255, 0.28);
    }
    html[data-theme="dark"] .term-input::placeholder {
      color: rgba(127, 214, 255, 0.6);
    }
    html[data-theme="dark"] .term-input.block-cursor::after {
      background: rgba(130, 236, 255, 0.85);
      box-shadow: 0 0 12px rgba(74, 182, 255, 0.7);
    }
    html[data-theme="dark"] .trader-ship-holo {
      background: radial-gradient(140% 200% at 50% 0%, rgba(74, 182, 255, 0.22), transparent 60%), #02040a;
      border: 1px solid rgba(46, 143, 255, 0.4);
      color: #7fd6ff;
      box-shadow: inset 0 0 32px rgba(46, 143, 255, 0.3), 0 0 30px rgba(46, 143, 255, 0.26);
    }
    html[data-theme="dark"] .trader-ship-holo::before {
      display: none;
    }
    html[data-theme="dark"] .trader-ship-holo.scanning::after {
      color: rgba(127, 198, 255, 0.7);
      text-shadow: 0 0 12px rgba(74, 182, 255, 0.58);
    }
    html[data-theme="dark"] .ship-holo-label {
      color: rgba(127, 214, 255, 0.85);
      text-shadow: 0 0 14px rgba(74, 182, 255, 0.55);
    }
    html[data-theme="dark"] .cargo-slot {
      background: linear-gradient(135deg, #04080f, #081322 60%, #04080f);
      border: 1px solid rgba(46, 143, 255, 0.35);
      box-shadow: inset 0 0 20px rgba(46, 143, 255, 0.25), 0 0 20px rgba(46, 143, 255, 0.25);
    }
    html[data-theme="dark"] .cargo-slot.empty::before {
      border-color: rgba(74, 182, 255, 0.35);
      opacity: 0.4;
    }
    html[data-theme="dark"] .cargo-slot.drag-over {
      border-color: rgba(106, 203, 255, 0.9);
      box-shadow: inset 0 0 24px rgba(106, 203, 255, 0.45), 0 0 26px rgba(106, 203, 255, 0.45);
    }
    html[data-theme="dark"] .cargo-slot.inspect-slot {
      border-color: rgba(106, 203, 255, 0.6);
      background: linear-gradient(135deg, #041224, #092544 60%, #041224);
    }
    html[data-theme="dark"] .cargo-slot.inspect-slot.drag-over {
      border-color: rgba(143, 220, 255, 0.85);
      box-shadow: inset 0 0 28px rgba(143, 220, 255, 0.45), 0 0 28px rgba(143, 220, 255, 0.45);
    }
    html[data-theme="dark"] .cargo-slot.full {
      background: linear-gradient(135deg, #4a4a46, #5e5e58 50%, #4a4a46);
      border: 2px solid #3a3a38;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.4);
    }
    html[data-theme="dark"] .cargo-slot.full::before {
      border: 3px solid #2a2a28;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.15), inset 0 0 8px rgba(0,0,0,0.4);
    }
    html[data-theme="dark"] .cargo-slot.full::after {
      background:
        linear-gradient(135deg,
          transparent calc(50% - 2px),
          rgba(42, 42, 40, 0.4) calc(50% - 2px),
          rgba(26, 26, 26, 0.4) 50%,
          rgba(42, 42, 40, 0.4) calc(50% + 2px),
          transparent calc(50% + 2px)
        ),
        linear-gradient(45deg,
          transparent calc(50% - 2px),
          rgba(42, 42, 40, 0.4) calc(50% - 2px),
          rgba(26, 26, 26, 0.4) 50%,
          rgba(42, 42, 40, 0.4) calc(50% + 2px),
          transparent calc(50% + 2px)
        );
      box-shadow: inset 0 0 8px rgba(0,0,0,0.15);
    }
    html[data-theme="dark"] .window {
      background: linear-gradient(180deg, rgba(8, 18, 30, 0.95), rgba(2, 6, 12, 0.95));
      border: 1px solid rgba(46, 143, 255, 0.4);
      box-shadow: 0 0 26px rgba(46, 143, 255, 0.22);
    }
    html[data-theme="dark"] .window .viewport {
      background: radial-gradient(100% 120% at 50% 0%, rgba(74, 182, 255, 0.18), rgba(2, 6, 12, 1) 70%);
      box-shadow: inset 0 0 28px rgba(46, 143, 255, 0.25);
    }
    html[data-theme="dark"] .window .glass {
      background: linear-gradient(180deg, rgba(74, 182, 255, 0.18), rgba(74, 182, 255, 0.05));
    }
    html[data-theme="dark"] .grid-2 span,
    html[data-theme="dark"] .grid-3 span {
      color: inherit;
    }
  </style>
</head>
<body>
  <!-- Sticky Title Bar -->
  <div class="title-bar">
    <h1>Space Trader</h1>
    <div class="title-controls">
      <label class="toggle" for="theme-toggle">
        <input type="checkbox" id="theme-toggle" aria-label="Toggle dark mode">
        <span class="track"><span class="thumb"></span></span>
        <span class="toggle-label">
          <span class="toggle-icon toggle-icon--theme" aria-hidden="true"></span>
          <span class="toggle-label-text">DARK MODE</span>
        </span>
      </label>
      <label class="toggle" for="fullscreen-toggle">
        <input type="checkbox" id="fullscreen-toggle" aria-label="Toggle fullscreen mode">
        <span class="track"><span class="thumb"></span></span>
        <span class="toggle-label">
          <span class="toggle-icon toggle-icon--fullscreen" aria-hidden="true"></span>
          <span class="toggle-label-text">FULLSCREEN</span>
        </span>
      </label>
    </div>
  </div>

  <div class="wrap">
    <!-- Cockpit Window -->
    <section class="panel section cockpit-panel">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h2 class="label" style="margin-bottom: 0;">Cockpit Window</h2>
        <label class="toggle" style="font-size: 11px;">
          <input type="checkbox" id="cockpit-pin-toggle">
          <span class="track"><span class="thumb"></span></span>
          <span>PIN</span>
        </label>
      </div>
      <div class="window">
        <div class="viewport">
          <div class="warp-burst"></div>
          <div class="planet"></div>
          <div class="moon"></div>
          <div class="glass"></div>
        </div>
      </div>
    </section>

    

    <!-- Navigation -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Navigation</h2>
      <div class="row">
        <div>
          <div class="label">Star Chart</div>
          <div class="crt nav-screen">
            <pre>Solar system: Boda
> Mercury
  Venus
  Earth
  Mars
  Jupiter
  Saturn
  Uranus
  Neptune</pre>
          </div>
        </div>
        <div>
          <div class="label">Cursor Control</div>
          <div style="display:flex; justify-content: center;">
            <div class="dial" style="--steps: 8; --start-angle: 0deg; --end-angle: 315deg; --value: 0; --fill: 0%;">
              <input type="range" min="0" max="8" step="1" value="0">
              <div class="marks"></div>
              <div class="shadow"></div>
              <div class="knob"></div>
              <div class="cap"></div>
              <div class="legend">NAVIGATE</div>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Navigation Actions</div>
          <div class="grid-2">
            <button type="button" class="btn">CURRENT LOC</button>
            <button type="button" class="btn">SYSTEM MAP</button>
            <button type="button" class="btn">GALAXY MAP</button>
            <button type="button" class="btn">BEGIN TRAVEL</button>
          </div>
        </div>
        <div>
          <div class="label">Power</div>
          <label class="toggle">
            <input type="checkbox" id="navigation-power-toggle" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Fuel -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Fuel</h2>
      <div class="row">
        <div>
          <div class="label">Fuel Level</div>
          <div class="gauge" style="--value: 28; --zone1-end: 25; --zone2-start: 25; --zone2-end: 60; --zone3-start: 60;">
            <progress max="100" value="28" aria-label="Fuel level">280 L</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">1000</span>
            </div>
            <div class="gauge-label">FUEL (L)</div>
          </div>
        </div>
        <div>
          <div class="label">Refueling Station</div>
          <div class="crt">
            <pre>Current credits: 123456₵
Cost to refuel : 234₵</pre>
          </div>
          <button type="button" class="btn btn-full" style="margin-top: 12px;">REFUEL</button>
        </div>
      </div>
    </section>

    <!-- Batteries -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Batteries</h2>
      <div class="row">
        <div>
          <div class="label">Battery A Charge</div>
          <div class="gauge" style="--value: 72; --zone1-end: 20; --zone2-start: 20; --zone2-end: 50; --zone3-start: 50;">
            <progress max="100" value="72" aria-label="Battery A charge level">72%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">2k</span>
            </div>
            <div class="gauge-label">BATTERY A (Wh)</div>
          </div>
        </div>
        <div>
          <div class="label">Battery B Charge</div>
          <div class="gauge" style="--value: 58; --zone1-end: 20; --zone2-start: 20; --zone2-end: 50; --zone3-start: 50;">
            <progress max="100" value="58" aria-label="Battery B charge level">58%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">2k</span>
            </div>
            <div class="gauge-label">BATTERY B (Wh)</div>
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Bus A</div>
          <label class="toggle">
            <input type="checkbox" id="battery-bus-a-toggle" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
        <div>
          <div class="label">Bus B</div>
          <label class="toggle">
            <input type="checkbox" id="battery-bus-b-toggle" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Solar Panels -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Solar Panels</h2>
      <div class="row">
        <div>
          <div class="label">Charge Current</div>
          <div class="gauge" style="--value: 45; --zone1-end: 10; --zone1-color: #c8c8c0; --zone2-start: 10; --zone2-end: 30; --zone2-color: #c8c8c0; --zone3-start: 30; --zone3-color: #5a8a5a;">
            <progress max="100" value="45" aria-label="Solar charge current">45%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">12.6k</span>
            </div>
            <div class="gauge-label">CHARGE (W)</div>
          </div>
        </div>
        <div>
          <div class="label">Power Draw</div>
          <div class="gauge" style="--value: 38; --zone1-end: 40; --zone1-color: #5a8a5a; --zone2-start: 40; --zone2-end: 70; --zone2-color: #c8c8c0; --zone3-start: 70; --zone3-color: #8a2020;">
            <progress max="100" value="38" aria-label="Ship power consumption">38%</progress>
            <div class="face">
              <div class="arc"></div>
              <div class="ticks-minor"></div>
              <div class="ticks-major"></div>
              <div class="needle"></div>
              <div class="glass"></div>
              <div class="hub"></div>
              <span class="gauge-min">0</span>
              <span class="gauge-max">24k</span>
            </div>
            <div class="gauge-label">DRAW (W)</div>
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Panel Control</div>
          <div class="slider-wrap">
            <input type="range" min="0" max="2" step="1" class="slider" value="1">
            <div class="slider-labels"><span>RETRACT</span><span>STOP</span><span>EXTEND</span></div>
          </div>
        </div>
        <div>
          <div class="label">Bus Connection</div>
          <label class="toggle">
            <input type="checkbox" id="solar-bus-toggle" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>CONNECTED</span>
          </label>
        </div>
      </div>
    </section>

    <!-- Trader Comms -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Trader Comms</h2>
      <div class="row">
        <div>
          <div class="label">Power</div>
          <label class="toggle">
            <input type="checkbox" id="trader-power-toggle" checked>
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
        <div>
          <div class="label">Mode</div>
          <label class="toggle">
            <input type="checkbox" id="trader-mode-toggle">
            <span class="track"><span class="thumb"></span></span>
            <span>BUYING / SELLING</span>
          </label>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Trade Details</div>
          <div class="crt">
            <pre>SELLING (page 1 of 5)
Trader: Captain Fingers
Ship  : Top Banana
Type  : Food
Crates remaining   : 5
Crates demand      : 2
Price per crate    : 250₵
Profit (loss) delta: 12₵
Current credits    : 123456₵
Standing: Neutral</pre>
          </div>
        </div>
        <div>
          <div class="label">Ship Visual</div>
          <div class="trader-ship-holo offline" id="trader-ship-viewport">
            <div class="ship-holo-label" id="trader-ship-name"></div>
          </div>
          <div class="label ship-actions-label">Trade Actions</div>
          <div class="grid-2">
            <button type="button" class="btn">PREVIOUS PAGE</button>
            <button type="button" class="btn">NEXT PAGE</button>
            <button type="button" class="btn">HAGGLE</button>
            <button type="button" class="btn">TRADE</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Cargo Hold -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Cargo Hold</h2>
      
      <!-- Crate Info Database -->
      <div class="cargo-info-grid">
        <div>
          <div class="label" style="margin-bottom: 4px; font-size: 10px;">INSPECT</div>
          <div class="cargo-slot empty inspect-slot" id="inspect-slot">
            <div class="cargo-label" style="font-size: 72px; opacity: 0.2;">?</div>
          </div>
        </div>
        <div>
          <div class="label" style="margin-bottom: 4px; font-size: 10px;">REFUEL</div>
          <div class="cargo-slot empty refuel-slot" id="refuel-slot">
            <div class="cargo-label" style="font-size: 48px; opacity: 0.3;">⚡</div>
          </div>
        </div>
        <div>
          <div class="label" style="margin-bottom: 4px; font-size: 10px;">CRATE INFO DATABASE</div>
          <div class="crt" style="padding: 8px;">
            <pre id="inspect-terminal" style="font-size: 11px; line-height: 1.4;">&nbsp;
&nbsp;
&nbsp;
&nbsp;</pre>
          </div>
        </div>
      </div>
      
      <div class="cargo-grid">
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
        <div class="cargo-slot empty"></div>
      </div>
    </section>

    <!-- Scanner -->
    <section class="panel section" id="scanner-panel">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">Scanner</h2>

      <div class="row">
        <div>
          <div class="label">Power</div>
          <label class="toggle">
            <input type="checkbox" id="scanner-power-toggle">
            <span class="track"><span class="thumb"></span></span>
            <span>ONLINE</span>
          </label>
        </div>
        <div>
          <div class="label">Controls</div>
          <div class="grid-3">
            <button type="button" class="btn" id="scanner-scan-btn" disabled>SCAN</button>
            <button type="button" class="btn" id="scanner-capture-btn" disabled>EXPORT PHOTO</button>
            <button type="button" class="btn" id="scanner-infographic-btn" disabled>EXPORT INFOGRAPHIC</button>
          </div>
        </div>
      </div>

      <div class="row">
        <div>
          <div class="label">Camera View</div>
          <div class="crt scanner-camera" style="position:relative; min-height: 140px; display:flex; align-items:center; justify-content:center;">
            <div id="scanner-viewport" style="position:relative; width: 160px; height: 160px;">
              <div class="planet" id="scanner-planet" style="position:absolute; inset:0; margin:0; width:100%; height:100%; border-radius:50%; background:#123; overflow:visible;"></div>
            </div>
          </div>
        </div>
        <div>
          <div class="label">Scan Results</div>
          <div class="crt" style="padding:8px;">
            <pre id="scanner-terminal" style="font-size: 11px; line-height: 1.4; min-height: 140px;"></pre>
          </div>
        </div>
      </div>
    </section>

    <!-- New Game Controls -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">New Game</h2>
      <div class="row">
        <div>
          <div class="label">Safety Lock</div>
          <label class="toggle">
            <input type="checkbox" id="new-game-arm">
            <span class="track"><span class="thumb"></span></span>
            <span>ARMED / SAFE</span>
          </label>
        </div>
        <div>
          <div class="label">Reset Game</div>
          <button type="button" class="btn btn-full btn-safe" id="new-game-btn" disabled>NEW GAME</button>
        </div>
      </div>
      <div class="row">
        <div>
          <div class="label">Auto-Save Status</div>
          <div class="crt">
            <pre id="save-status">Last saved: Never
Auto-save  : Active</pre>
          </div>
        </div>
      </div>
    </section>

    <!-- About -->
    <section class="panel section">
      <div class="rivet tl"></div><div class="rivet tr"></div><div class="rivet bl"></div><div class="rivet br"></div>

      <h2 class="label">About Space Trader</h2>
      <div style="display: grid; gap: 12px;">
        <div class="card">
          <div style="font-size: 14px; line-height: 1.6;">
            <div style="margin-bottom: 12px;">
              <strong style="font-size: 16px; color: var(--ink);">Space Trader v2.0.3</strong>
            </div>
            <div style="margin-bottom: 8px;">
              Created by <strong>Timeless Prototype</strong>,
              <strong>Claude Sonnet 4.5</strong>,
              <strong>GPT-5</strong>, and
              <strong>GPT-5-codex</strong>.
            </div>
            <div style="margin-bottom: 16px; color: var(--ink); opacity: 0.8;">
              An idle space trading game with realistic power management, procedural generation, and retro industrial aesthetics.
            </div>
            <div style="margin-bottom: 12px;">
              <strong>Features:</strong>
            </div>
            <ul style="margin: 0 0 16px 20px; padding: 0; color: var(--ink); opacity: 0.9;">
              <li>⚡ Realistic battery and solar panel systems</li>
              <li>🌟 Procedurally generated planets and star systems</li>
              <li>🚀 Cinematic warp travel animations</li>
              <li>📦 Dynamic cargo trading with NPC traders</li>
              <li>🎮 Physical control panel aesthetics</li>
              <li>💾 Auto-save system</li>
            </ul>
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--panel-rim);">
              <div style="margin-bottom: 8px; font-weight: 600;">Support the Developer:</div>
              <a href="https://buymeacoffee.com/timelessp" target="_blank" rel="noopener noreferrer" aria-label="Buy me a coffee">
                <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 45px; width: auto; display: block; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);" />
              </a>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // ============================================================================
    // EVENT BUS - Central event management system
    // ============================================================================
    class EventBus {
      constructor() {
        this.listeners = new Map();
      }

      /**
       * Subscribe to an event
       * @param {string} eventName - Name of the event to listen for
       * @param {Function} callback - Function to call when event fires
       * @param {Object} context - Optional context (this) for the callback
       * @returns {Function} Unsubscribe function
       */
      on(eventName, callback, context = null) {
        if (!this.listeners.has(eventName)) {
          this.listeners.set(eventName, []);
        }
        
        const listener = { callback, context };
        this.listeners.get(eventName).push(listener);
        
        // Return unsubscribe function
        return () => this.off(eventName, callback);
      }

      /**
       * Subscribe to an event (one-time only)
       */
      once(eventName, callback, context = null) {
        const unsubscribe = this.on(eventName, (...args) => {
          unsubscribe();
          callback.apply(context, args);
        }, context);
        return unsubscribe;
      }

      /**
       * Unsubscribe from an event
       */
      off(eventName, callback) {
        if (!this.listeners.has(eventName)) return;
        
        const listeners = this.listeners.get(eventName);
        const index = listeners.findIndex(l => l.callback === callback);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
        
        if (listeners.length === 0) {
          this.listeners.delete(eventName);
        }
      }

      /**
       * Emit an event to all subscribers
       * @param {string} eventName - Name of the event
       * @param {*} data - Data to pass to listeners
       */
      emit(eventName, data = null) {
        if (!this.listeners.has(eventName)) return;
        
        const listeners = this.listeners.get(eventName);
        listeners.forEach(({ callback, context }) => {
          try {
            callback.call(context, data);
          } catch (error) {
            console.error(`Error in event listener for '${eventName}':`, error);
          }
        });
      }

      /**
       * Clear all listeners for an event, or all events
       */
      clear(eventName = null) {
        if (eventName) {
          this.listeners.delete(eventName);
        } else {
          this.listeners.clear();
        }
      }
    }

    // Global event bus instance
    const eventBus = new EventBus();

    // ============================================================================
    // SAVE/LOAD SYSTEM
    // ============================================================================
    class SaveSystem {
      constructor() {
        this.SAVE_KEY = 'space-trader-v2';
        this.AUTO_SAVE_INTERVAL = 5000; // Auto-save every 5 seconds
        this.lastSaveTime = null;
        this.autoSaveEnabled = true;
        this.autoSaveTimer = null;
      }

      /**
       * Serialize game state to JSON
       */
      serializeGameState() {
        return {
          version: 2,
          timestamp: Date.now(),
          batteries: batterySystem.batteries.map(b => ({
            id: b.id,
            maxCapacity: b.maxCapacity,
            currentCharge: b.currentCharge,
            maxDischargeRate: b.maxDischargeRate,
            maxChargeRate: b.maxChargeRate,
            efficiency: b.efficiency,
            health: b.health,
            connectedToBus: b.connectedToBus,
            temperature: b.temperature,
            cycleCount: b.cycleCount,
            enabled: b.enabled
          })),
          solar: {
            panelState: solarSystem.panelState,
            extension: solarSystem.extension,
            sunlightIntensity: solarSystem.sunlightIntensity,
            connectedToBus: solarSystem.connectedToBus
          },
          fuel: {
            currentFuel: fuelSystem.currentFuel,
            credits: fuelSystem.credits
          },
          navigation: {
            x: navigationSystem.currentX,
            y: navigationSystem.currentY,
            planetIndex: navigationSystem.currentPlanetIndex,
            viewMode: navigationSystem.viewMode,
            cursorIndex: navigationSystem.cursorIndex
          },
          power: {
            activeSystems: Array.from(powerSystem.activeSystems)
          },
          trading: {
            cargo: tradingSystem.cargo.map(item => item ? {
              id: item.id,
              type: item.type,
              purchasePrice: item.purchasePrice,
              slotIndex: item.slotIndex
            } : null),
            nextCargoId: tradingSystem.nextCargoId
          }
        };
      }

      /**
       * Deserialize game state from JSON
       */
      deserializeGameState(data) {
        if (!data || data.version !== 2) {
          console.warn('Invalid or incompatible save data');
          return null;
        }

        return data;
      }

      /**
       * Save game state to localStorage
       */
      save() {
        try {
          const gameState = this.serializeGameState();
          localStorage.setItem(this.SAVE_KEY, JSON.stringify(gameState));
          this.lastSaveTime = Date.now();
          eventBus.emit('game:saved', { timestamp: this.lastSaveTime });
          
          return true;
        } catch (error) {
          console.error('Failed to save game:', error);
          eventBus.emit('game:save-failed', { error });
          return false;
        }
      }

      /**
       * Load game state from localStorage
       */
      load() {
        try {
          const savedData = localStorage.getItem(this.SAVE_KEY);
          if (!savedData) {
            
            return null;
          }

          const gameState = JSON.parse(savedData);
          const validatedState = this.deserializeGameState(gameState);
          
          if (validatedState) {
            
            eventBus.emit('game:loaded', { timestamp: gameState.timestamp });
            return validatedState;
          }
          
          return null;
        } catch (error) {
          console.error('Failed to load game:', error);
          eventBus.emit('game:load-failed', { error });
          return null;
        }
      }

      /**
       * Delete saved game
       */
      deleteSave() {
        try {
          localStorage.removeItem(this.SAVE_KEY);
          this.lastSaveTime = null;
          
          eventBus.emit('game:save-deleted', {});
          return true;
        } catch (error) {
          console.error('Failed to delete save:', error);
          return false;
        }
      }

      /**
       * Check if a save exists
       */
      hasSave() {
        return localStorage.getItem(this.SAVE_KEY) !== null;
      }

      /**
       * Start auto-save timer
       */
      startAutoSave() {
        if (this.autoSaveTimer) {
          clearInterval(this.autoSaveTimer);
        }

        this.autoSaveEnabled = true;
        this.autoSaveTimer = setInterval(() => {
          if (this.autoSaveEnabled) {
            this.save();
          }
        }, this.AUTO_SAVE_INTERVAL);

        
      }

      /**
       * Stop auto-save timer
       */
      stopAutoSave() {
        if (this.autoSaveTimer) {
          clearInterval(this.autoSaveTimer);
          this.autoSaveTimer = null;
        }
        this.autoSaveEnabled = false;
        
      }

      /**
       * Get formatted last save time
       */
      getLastSaveTimeFormatted() {
        if (!this.lastSaveTime) {
          return 'Never';
        }

        const now = Date.now();
        const diff = now - this.lastSaveTime;
        
        if (diff < 60000) {
          return 'Just now';
        } else if (diff < 3600000) {
          const mins = Math.floor(diff / 60000);
          return `${mins} min${mins !== 1 ? 's' : ''} ago`;
        } else {
          return new Date(this.lastSaveTime).toLocaleTimeString();
        }
      }
    }

    // Create save system instance
    const saveSystem = new SaveSystem();

    // ============================================================================
    // PROCEDURAL GENERATION - Seeded RNG and name generators
    // ============================================================================
    
    /**
     * FNV-1a 32-bit hash to improve seed entropy across generators
     * Accepts numbers/strings and returns unsigned 32-bit integer
     */
    function hash32(...parts) {
      let hash = 0x811c9dc5; // 2166136261
      const FNV_PRIME = 0x01000193; // 16777619
      for (const part of parts) {
        if (typeof part === 'number') {
          let n = part | 0; // coerce to 32-bit int
          hash ^= n & 0xff; hash = Math.imul(hash, FNV_PRIME);
          hash ^= (n >>> 8) & 0xff; hash = Math.imul(hash, FNV_PRIME);
          hash ^= (n >>> 16) & 0xff; hash = Math.imul(hash, FNV_PRIME);
          hash ^= (n >>> 24) & 0xff; hash = Math.imul(hash, FNV_PRIME);
        } else {
          const s = String(part);
          for (let i = 0; i < s.length; i++) {
            hash ^= s.charCodeAt(i) & 0xff;
            hash = Math.imul(hash, FNV_PRIME);
          }
        }
      }
      return hash >>> 0;
    }
    
    // Map 32-bit unsigned to a valid non-zero LCG seed (1..2147483646)
    function toLCGSeed(u32) {
      const mod = 2147483646;
      return (u32 % mod) + 1;
    }
    
    /**
     * Seeded random number generator class (from version 1)
     * Provides consistent random values with next(), nextInt(), and choice()
     */
    class SeededRNG {
      constructor(seed = 12345) {
        this.seed = seed;
      }
      
      next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
      }
      
      nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
      }
      
      choice(array) {
        return array[Math.floor(this.next() * array.length)];
      }
    }

    /**
     * Seeded pseudo-random number generator (Mulberry32)
     * Returns consistent results for same seed
     */
    function seededRandom(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // Seeded sunlight direction per-planet with phase clamp (<=40% of visible disk in shadow)
    function getSeededLightDir(x, y, planetIndex) {
      const r = seededRandom(hash32('LGT', x|0, y|0, planetIndex|0));
      const phi = r() * Math.PI * 2; // azimuth
      const cosA = 0.2 + r() * 0.8;  // ensure cos >= 0.2 => shadowed area <= ~40%
      const sinA = Math.sqrt(Math.max(0, 1 - cosA*cosA));
      const lx = sinA * Math.cos(phi);
      const ly = sinA * Math.sin(phi);
      const lz = cosA; // viewer direction is +Z
      const L = Math.hypot(lx, ly, lz) || 1;
      return [ lx/L, ly/L, lz/L ];
    }

    // --------------------------------------------------------------------------
    // Seeded planet sprite renderer
    // --------------------------------------------------------------------------
    const planetSpriteCache = new Map(); // key -> dataURL

  function getPlanetSprite(x, y, planetIndex, size = 192, typeOverride, baseColorOverride) {
    const key = `${x}|${y}|${planetIndex}|${size}|${typeOverride||''}|${baseColorOverride||''}`;
      const cached = planetSpriteCache.get(key);
      if (cached) return cached;

      // Seed derived from hashed coordinates + type discriminator
      const seedU32 = hash32('SPR', x | 0, y | 0, planetIndex | 0);
      const rng = seededRandom(seedU32);

      // Choose a planet profile deterministically
      const profile = choosePlanetProfile(rng, typeOverride);

  // Colors
  const baseHex = baseColorOverride || profile.baseColor;
  const baseRGB = hexToRgb(baseHex);
  const oceanRGB = hexToRgb(profile.oceanColor || '#204a87');
  const landRGB = hexToRgb(profile.landColor || '#8f7e5b');
  const iceRGB = hexToRgb(profile.iceColor || '#dfefff');
  const hazeRGB = hexToRgb(profile.hazeColor || '#b4d2ff');
  const cloudRGB = hexToRgb(profile.cloudColor || '#ffffff');
  const cityRGB = hexToRgb(profile.cityColor || '#ffd080');
  const lavaRGB = hexToRgb(profile.lavaColor || '#ff5a1f');
  const gasPalette = (profile.gasPalette || []).map(hexToRgb);

      // Noise generators (hash-seeded)
      const nSeed0 = hash32('N0', seedU32);
      const nSeed1 = hash32('N1', seedU32);
      const nSeed2 = hash32('N2', seedU32);
      const noise0 = makeFractalNoise3D(nSeed0, 4, 0.5); // base terrain
      const noise1 = makeFractalNoise3D(nSeed1, 5, 0.5); // detail/roughness
      const noise2 = makeFractalNoise3D(nSeed2, 3, 0.6); // clouds/bands

      // Offscreen canvas
      const cnv = document.createElement('canvas');
      cnv.width = size; cnv.height = size;
      const ctx = cnv.getContext('2d', { willReadFrequently: true });

  // Precompute lighting (seeded per-planet, with phase clamp so <=40% of disk shadowed)
  const lightDir = getSeededLightDir(x, y, planetIndex);
  const atmosphereThickness = (profile.atmosphere || profile.group === 'Ocean') ? 0.9 : 0.0;

      // --- Seeded planetary rings parameters ---
  const ringRnd = seededRandom(hash32('RING', seedU32));
  const hasRings = false; // rings disabled for now
      // Predeclare for closures used by drawRingHalf
      let ringAngle = 0, ringOpenScale = 1, ringInner = 0, ringOuter = 0, ringPalette = null, ringPhase = 0, ringFreq = 0.2;
      let ringInnerRatio = 0, ringOuterRatio = 0;
  if (hasRings) {
        // Inclination (rotation in screen plane)
        ringAngle = ringRnd() * Math.PI; // 0..pi
        // Opening (tilt) -> ellipse minor/major ratio (avoid edge-on)
        ringOpenScale = 0.35 + ringRnd() * 0.55; // 0.35..0.9
        // Inner/outer radii as ratios of planet radius (resolved later)
        ringInnerRatio = 1.12 + ringRnd() * 0.55; // 1.12R .. 1.67R
        ringOuterRatio = Math.min(2.6, ringInnerRatio + (0.5 + ringRnd() * 0.9)); // cap outer
        // Seeded band colors: derive from planet base color and a seeded neutral mix
        const neutralA = [200, 182, 150];
        const neutralB = [120, 110, 100];
        const mixT = 0.35 + ringRnd() * 0.3;
        const seedColor = lerpRgb(baseRGB, lerpRgb(neutralA, neutralB, ringRnd()), mixT);
        const lightenRgb = (c, t) => [ lerp(c[0], 255, t), lerp(c[1], 255, t), lerp(c[2], 255, t) ];
        const darkenRgb  = (c, t) => [ c[0]*(1-t), c[1]*(1-t), c[2]*(1-t) ];
        ringPalette = [
          lightenRgb(seedColor, 0.25),
          lightenRgb(seedColor, 0.08),
          darkenRgb(seedColor, 0.06),
          darkenRgb(seedColor, 0.18)
        ];
        // Banding globals reused for both halves
        ringPhase = ringRnd() * Math.PI * 2;
        ringFreq = 0.12 + ringRnd() * 0.35;
      }

      // Helper to draw ring half ("far" drawn before planet, "near" after planet)
      function drawRingHalf(half) {
        if (!hasRings) return;
        const currentRadius = radius;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(ringAngle);
        ctx.scale(1, ringOpenScale);
        // Clip to half-plane in ring-local space
        ctx.beginPath();
        const pad = ringOuter * 1.1 + 8;
        if (half === 'far') {
          ctx.rect(-pad, -pad, pad*2, pad); // y < 0
        } else {
          ctx.rect(-pad, 0, pad*2, pad); // y >= 0
        }
        ctx.clip();

        // Draw matte banded texture using concentric arcs (transformed to ellipse)
        let r = ringInner;
        ctx.globalCompositeOperation = 'source-over';
        while (r < ringOuter) {
          // Vary band thickness with a smooth function for natural groupings
          const w = 0.8 + 2.4 * Math.max(0, Math.sin(r * ringFreq * 0.2 + ringPhase));
          const t = Math.max(0, Math.min(1, (r - ringInner) / Math.max(1e-5, (ringOuter - ringInner))));
          // Choose palette index with slight variation across radius
          const idx = Math.floor((t * (ringPalette.length - 1)) + (Math.sin(r * 0.08 + ringPhase) * 0.5 + 0.5) * 0.4);
          const c = ringPalette[Math.max(0, Math.min(ringPalette.length - 1, idx))];
          const alpha = 0.65 + 0.2 * Math.sin(r * 0.12 + ringPhase * 0.7);
          ctx.strokeStyle = `rgba(${clamp255(c[0])},${clamp255(c[1])},${clamp255(c[2])},${Math.max(0.05, Math.min(0.95, alpha))})`;
          ctx.lineWidth = Math.max(0.75, w);
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.stroke();
          r += w;
        }

        // Planet shadow cast on rings (aligned with light direction)
        // Use multiply with a radial gradient offset opposite light
  const lx = lightDir[0], ly = lightDir[1];
        ctx.globalCompositeOperation = 'multiply';
  const g = ctx.createRadialGradient(-lx * currentRadius * 0.25, -ly * currentRadius * 0.25, currentRadius * 0.2,
             -lx * currentRadius * 0.85, -ly * currentRadius * 0.85, ringOuter);
        g.addColorStop(0.0, 'rgba(0,0,0,0.28)');
        g.addColorStop(0.4, 'rgba(0,0,0,0.16)');
        g.addColorStop(1.0, 'rgba(0,0,0,0.0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
        ctx.moveTo(ringInner, 0);
        ctx.arc(0, 0, ringInner, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }

      // Render sphere by raymarching the screen-space circle and sampling mapped 3D noise
      let radius = (size * 0.5) - 1;
      const cx = size * 0.5, cy = size * 0.5;
      const img = ctx.createImageData(size, size);
      const data = img.data;

      // If rings exist, shrink planet radius slightly so the full ring fits inside the sprite
      if (hasRings) {
        // Compute maximum ellipse extents in x/y due to rotation+tilt
        const Rx = 1, Ry = ringOpenScale;
        const cosA = Math.cos(ringAngle), sinA = Math.sin(ringAngle);
        const shapeX = Math.sqrt((Rx*cosA)**2 + (Ry*sinA)**2);
        const shapeY = Math.sqrt((Rx*sinA)**2 + (Ry*cosA)**2);
        const padding = 2;
        const halfCap = (size * 0.5) - padding;
        const needX = ringOuterRatio * shapeX;
        const needY = ringOuterRatio * shapeY;
        const haloFrac = profile.atmosphere ? 0.10 : 0.04;
        const rMax = Math.min(halfCap / (needX + haloFrac), halfCap / (needY + haloFrac), halfCap / (1 + haloFrac));
        radius = Math.min(radius, rMax);
        ringInner = radius * ringInnerRatio;
        ringOuter = radius * ringOuterRatio;
      }

      // Axial tilt/band rotation
      const tilt = (rng() * 0.6 - 0.3) * Math.PI; // -0.3..0.3 rad
      const rot = rng() * Math.PI * 2; // rotation around axis
      const rotMat = composeRotation(tilt, rot);

      // Profile parameters
  const seaLevel = profile.seaLevel;
  const mountainAmp = profile.mountainAmp;
  const craterChance = profile.craterChance;
  const cloudCover = profile.cloudCover;
  const gasBands = profile.gasBands;
  const bandScale = profile.bandScale || 25;
  const bandWarp = profile.bandWarp || 0.0;
  const specular = profile.specular || 0.0;
  const shininess = profile.shininess || 32;
  const cityLights = !!profile.cityLights;
  const glowLava = !!profile.glowLava;

      // Simple crater field helper (sample sparse circular dimples in tangent space)
      const craterPRNG = seededRandom(hash32('CRT', seedU32));
      const craters = [];
      const craterCount = profile.hasCraters ? Math.floor(craterPRNG() * 120) + 40 : 0;
      for (let i = 0; i < craterCount; i++) {
        // random point on sphere via uniform sampling
        const u = craterPRNG();
        const v = craterPRNG();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const p = [
          Math.sin(phi) * Math.cos(theta),
          Math.sin(phi) * Math.sin(theta),
          Math.cos(phi)
        ];
        const r = 0.01 + craterPRNG() * 0.05; // crater radius in sphere units
        craters.push({ p, r });
      }

      // Draw far half of ring behind the planet
      if (hasRings) {
        drawRingHalf('far');
      }

      // Per-pixel render (planet body)
      for (let y0 = 0, idx = 0; y0 < size; y0++) {
        const dy = y0 - cy;
        for (let x0 = 0; x0 < size; x0++, idx += 4) {
          const dx = x0 - cx;
          const d2 = dx*dx + dy*dy;
          if (d2 > radius*radius) {
            // Outside sphere
            data[idx+3] = 0;
            continue;
          }
          const dz = Math.sqrt(radius*radius - d2);
          // Map to unit sphere normal (N)
          let nx = dx / radius, ny = dy / radius, nz = dz / radius;
          // Rotate to give different band/orientation per planet
          const nRot = applyMat(rotMat, [nx, ny, nz]);
          nx = nRot[0]; ny = nRot[1]; nz = nRot[2];

          // Sample base terrain using 3D noise on sphere coordinates to avoid polar pinching
          // Use different scales for broad continents and details
          const cont = noise0(nx*1.2, ny*1.2, nz*1.2);
          const detail = noise1(nx*6.0, ny*6.0, nz*6.0);
          let height = cont * 0.7 + detail * 0.3;

          // Gas giants: band coordinate based on latitude with noise warp
          let bandT = 0;
          if (gasBands) {
            const s = ny * bandScale + noise2(nx*1.2, ny*1.2, nz*1.2) * bandWarp;
            bandT = 0.5 + 0.5 * Math.sin(s);
          }

          // Crater deformation for airless rocky/ice worlds
          if (profile.hasCraters) {
            let craterDepth = 0;
            for (let c = 0; c < craters.length; c++) {
              const cp = craters[c];
              const dot = nx*cp.p[0] + ny*cp.p[1] + nz*cp.p[2]; // cos(angle)
              const ang = Math.acos(Math.max(-1, Math.min(1, dot)));
              const s = ang / cp.r;
              if (s < 1.0) {
                // smooth bowl profile
                const t = 1 - s;
                craterDepth += t*t * 0.25; // depth
              }
            }
            height -= craterDepth * craterChance;
          }

          // Surface classification
          let surfaceRGB = baseRGB;
          if (!gasBands) {
            if (profile.hasOceans && height < seaLevel) {
              // Ocean color with depth-based darkening
              const depth = (seaLevel - height) / Math.max(1e-5, seaLevel + 1);
              surfaceRGB = lerpRgb(oceanRGB, baseRGB, 0.2 + 0.5 * Math.min(1, depth));
            } else {
              // Land: blend base and land, add mountain highlights
              let t = Math.max(0, height - seaLevel) * mountainAmp;
              t = Math.min(1, t);
              surfaceRGB = lerpRgb(landRGB, baseRGB, 0.4 + 0.6 * t);
              if (profile.polarCaps) {
                const pole = Math.pow(Math.abs(nz), 4);
                surfaceRGB = lerpRgb(surfaceRGB, iceRGB, 0.25 * pole);
              }
            }
          } else {
            // Gas giant palette blending across bands using provided palette
            if (gasPalette.length >= 2) {
              surfaceRGB = samplePalette(gasPalette, bandT);
            } else {
              surfaceRGB = lerpRgb(landRGB, baseRGB, bandT);
            }
          }

          // Clouds layer (if atmosphere exists)
          let outRGB = surfaceRGB;
          if (profile.atmosphere && cloudCover > 0) {
            const cloud = 0.5 + 0.5 * noise2(nx*3.5 + 20, ny*3.5 + 20, nz*3.5 + 20);
            const swirl = noise1(nx*1.5 - ny*1.5, ny*1.5 + nz*1.5, nz*1.5 - nx*1.5);
            const clouds = Math.max(0, cloud * 0.8 + swirl * 0.2 - (1.0 - cloudCover));
            outRGB = lerpRgb(outRGB, cloudRGB, 0.35 * Math.min(1, clouds));
          }

          // Lambert lighting
          const ndotl = Math.max(0, nx*lightDir[0] + ny*lightDir[1] + nz*lightDir[2]);
          const ambient = 0.25;
          let litRGB = scaleRgb(outRGB, ambient + ndotl * 0.9);

          // Ring shadow onto planet (attenuate only the direct component, only on day side)
          if (hasRings && ndotl > 0) {
            const cosA = Math.cos(ringAngle), sinA = Math.sin(ringAngle);
            const rx =  (dx)*cosA + (dy)*sinA;
            const ry = ((-dx)*sinA + (dy)*cosA) / Math.max(1e-5, ringOpenScale);
            const rr = Math.hypot(rx, ry);
            if (rr >= ringInner && rr <= ringOuter) {
              const t = Math.max(0, Math.min(1, (rr - ringInner) / Math.max(1e-5, (ringOuter - ringInner))));
              const atten = 1 - (0.35 * (0.7 + 0.3 * (1 - t)));
              litRGB = scaleRgb(litRGB, atten);
            }
          }

          // Specular highlight (simple Blinn-Phong approx with viewer ~ +Z)
          if (specular > 0) {
            const L = lightDir;
            const N = [nx, ny, nz];
            const V = [0, 0, 1];
            const Hx = (L[0]+V[0]);
            const Hy = (L[1]+V[1]);
            const Hz = (L[2]+V[2]);
            const Hn = normalize([Hx,Hy,Hz]);
            const ndoth = Math.max(0, N[0]*Hn[0] + N[1]*Hn[1] + N[2]*Hn[2]);
            const spec = Math.pow(ndoth, shininess) * specular;
            litRGB = lerpRgb(litRGB, [255,255,255], Math.min(1, spec));
          }

          // Rim atmosphere scattering (simple fresnel-style brighten at edge on lit side)
          if (profile.atmosphere) {
            const viewNdot = Math.max(0, nz); // facing viewer
            const fres = Math.pow(1 - viewNdot, 3);
            const atm = 0.6 * atmosphereThickness * ndotl * fres;
            litRGB = lerpRgb(litRGB, hazeRGB, atm * 0.5);
          }

          // City lights emission on night side (slightly more permissive near-terminator)
          if (cityLights) {
            const night = 1 - ndotl;
            if (night > 0.15) {
              const v = 0.5 + 0.5 * noise1(nx*50, ny*50, nz*50);
              if (v > 0.68) {
                const e = (v - 0.68) / 0.32 * night * 0.8;
                litRGB = [
                  litRGB[0] + cityRGB[0] * e,
                  litRGB[1] + cityRGB[1] * e,
                  litRGB[2] + cityRGB[2] * e
                ];
              }
            }
          }

          // Lava glow fissures
          if (glowLava && !gasBands) {
            const fiss = 0.5 + 0.5 * noise2(nx*12.0, ny*12.0, nz*12.0);
            if (fiss > 0.82) {
              const e = (fiss - 0.82) / 0.18;
              litRGB = [
                litRGB[0] + lavaRGB[0] * e * 0.35,
                litRGB[1] + lavaRGB[1] * e * 0.35,
                litRGB[2] + lavaRGB[2] * e * 0.35
              ];
            }
          }

          // Write pixel
          data[idx] = clamp255(litRGB[0]);
          data[idx+1] = clamp255(litRGB[1]);
          data[idx+2] = clamp255(litRGB[2]);
          data[idx+3] = 255;
        }
      }

  // Draw with a crisp limb (no inner alpha feather) to avoid inner-ring artifacts when compositing halos
  // Pixels outside the sphere are already alpha=0; inside are opaque from per-pixel write above.
  ctx.putImageData(img, 0, 0);

      // Atmosphere halo outside limb (renderer-based, not CSS)
      if ((profile.atmosphere || profile.group === 'Ocean') && profile.group !== 'Gas Giant') {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        const haloOuter = radius * 1.12;
        const haze = hazeRGB || [180,210,255];
        const grad = ctx.createRadialGradient(cx, cy, radius * 0.98, cx, cy, haloOuter);
        const haloAlpha = (profile.group === 'Ocean') ? 0.24 : 0.18;
        grad.addColorStop(0, `rgba(${clamp255(haze[0])},${clamp255(haze[1])},${clamp255(haze[2])},0.0)`);
        grad.addColorStop(1, `rgba(${clamp255(haze[0])},${clamp255(haze[1])},${clamp255(haze[2])},${haloAlpha})`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, haloOuter, 0, Math.PI*2);
        ctx.moveTo(cx + radius, cy);
        ctx.arc(cx, cy, radius, 0, Math.PI*2, true);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      // Draw near half of ring in front of the planet
      if (hasRings) {
        drawRingHalf('near');
      }

      const url = cnv.toDataURL('image/png');
      planetSpriteCache.set(key, url);
      return url;
    }

    function choosePlanetProfile(rng, typeOverride) {
      // Types and groups for diverse looks
      const baseProfiles = [
        // Terran-like groups
        { key: 'Rocky', group: 'Rocky', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.6, seaLevel: -0.15, mountainAmp: 2.0, cloudCover: 0.2, polarCaps: true, baseColor: '#8B6F47', landColor: '#9b8060', oceanColor: '#2a4b7c', iceColor: '#e6f2ff', hazeColor: '#c9ddff', specular: 0.05, shininess: 24 },
        { key: 'Barren', group: 'Rocky', hasOceans: false, atmosphere: false, hasCraters: true, craterChance: 0.9, seaLevel: -0.5, mountainAmp: 1.1, cloudCover: 0.0, polarCaps: false, baseColor: '#9a8a78', landColor: '#a5937f', iceColor: '#f6f6f6' },
  { key: 'Desert', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.4, seaLevel: -0.3, mountainAmp: 1.4, cloudCover: 0.05, polarCaps: false, baseColor: '#C9A66B', landColor: '#d4b57d', iceColor: '#f6faff', hazeColor: '#ffd9a6', paletteKey: 'Desert', atmosphereThicknessRange: [1.1, 1.9], albedoGain: 1.12 },
  { key: 'Dune', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.3, seaLevel: -0.45, mountainAmp: 1.0, cloudCover: 0.02, polarCaps: false, baseColor: '#c9b07a', landColor: '#e0c890', iceColor: '#fffbe6', hazeColor: '#ffe3b3', paletteKey: 'Dune', atmosphereThicknessRange: [1.0, 1.7], albedoGain: 1.1 },
  { key: 'Salt Flats', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.35, seaLevel: -0.25, mountainAmp: 1.2, cloudCover: 0.04, polarCaps: false, baseColor: '#f3ede1', landColor: '#fff7d1', iceColor: '#ffffff', hazeColor: '#fff1c9', paletteKey: 'DesertSalt', atmosphereThicknessRange: [1.6, 2.4], specular: 0.18, shininess: 68, albedoGain: 1.18 },
  { key: 'Sulfur Sands', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.32, seaLevel: -0.35, mountainAmp: 1.3, cloudCover: 0.03, polarCaps: false, baseColor: '#f6d94f', landColor: '#ffeb80', iceColor: '#fff6cf', hazeColor: '#ffe886', paletteKey: 'DesertSulfur', atmosphereThicknessRange: [1.3, 2.1], specular: 0.2, shininess: 72, albedoGain: 1.2 },
  { key: 'Basalt Dunes', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.45, seaLevel: -0.4, mountainAmp: 1.6, cloudCover: 0.02, polarCaps: false, baseColor: '#2c2b30', landColor: '#3a383f', iceColor: '#f2f2f2', hazeColor: '#707683', paletteKey: 'DesertBasalt', atmosphereThicknessRange: [1.2, 2.0], specular: 0.22, shininess: 76, albedoGain: 1.22 },
  { key: 'Verdant Flats', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.28, seaLevel: -0.33, mountainAmp: 1.1, cloudCover: 0.04, polarCaps: false, baseColor: '#4c7f5f', landColor: '#7ac48f', iceColor: '#f2fff6', hazeColor: '#c9f1d8', paletteKey: 'DesertVerdant', atmosphereThicknessRange: [1.4, 2.2], specular: 0.19, shininess: 70, albedoGain: 1.18 },
        { key: 'Ocean', group: 'Ocean', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: 0.25, mountainAmp: 0.8, cloudCover: 0.45, polarCaps: true, baseColor: '#3B7BBF', landColor: '#6aa56a', oceanColor: '#1f4f8f', iceColor: '#f0fbff', hazeColor: '#b4d2ff', specular: 0.12, shininess: 64 },
        { key: 'Life', group: 'Life', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: 0.05, mountainAmp: 1.2, cloudCover: 0.35, polarCaps: true, baseColor: '#4E8E5E', landColor: '#74b36d', oceanColor: '#1e4b7f', iceColor: '#f0fbff', hazeColor: '#cbe8d5' },
        { key: 'Jungle', group: 'Life', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: 0.15, mountainAmp: 1.0, cloudCover: 0.55, polarCaps: true, baseColor: '#3f7a49', landColor: '#6fb36a', oceanColor: '#1b4a78', iceColor: '#edfaff', hazeColor: '#cfe9d2' },
        { key: 'Swamp', group: 'Life', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.2, seaLevel: 0.3, mountainAmp: 0.7, cloudCover: 0.5, polarCaps: false, baseColor: '#3a6a42', landColor: '#5e8a54', oceanColor: '#264f4a', iceColor: '#e9fff9', hazeColor: '#bde6d1', cloudColor: '#dcead9' },
        { key: 'Tundra', group: 'Frozen', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.5, seaLevel: -0.1, mountainAmp: 1.3, cloudCover: 0.2, polarCaps: true, baseColor: '#d3e8f3', landColor: '#eef9ff', iceColor: '#ffffff', hazeColor: '#e7f6ff' },
        { key: 'Ice World', group: 'Frozen', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.7, seaLevel: -0.25, mountainAmp: 1.2, cloudCover: 0.15, polarCaps: true, baseColor: '#BFD9E8', landColor: '#dbeaf2', iceColor: '#ffffff', hazeColor: '#e7f6ff' },
        { key: 'Frozen', group: 'Frozen', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.7, seaLevel: -0.3, mountainAmp: 1.0, cloudCover: 0.1, polarCaps: true, baseColor: '#D6EEF7', landColor: '#e8f6fc', iceColor: '#ffffff', hazeColor: '#ecfbff' },
        { key: 'Volcanic', group: 'Volcanic', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.2, seaLevel: -0.4, mountainAmp: 2.8, cloudCover: 0.1, polarCaps: false, baseColor: '#7A1E10', landColor: '#b2451b', iceColor: '#ffeeee', hazeColor: '#ffccb3', glowLava: true, lavaColor: '#ff5a1f' },
        { key: 'Lava Ocean', group: 'Volcanic', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: 0.35, mountainAmp: 0.3, cloudCover: 0.05, polarCaps: false, baseColor: '#66210f', landColor: '#7a2a12', oceanColor: '#ff3b00', iceColor: '#ffeeee', hazeColor: '#ffb199', glowLava: true, lavaColor: '#ff3b00' },
        { key: 'Sulfur', group: 'Sulfur', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.5, seaLevel: -0.35, mountainAmp: 1.6, cloudCover: 0.05, polarCaps: false, baseColor: '#C1B433', landColor: '#e0d24a', iceColor: '#ffffee', hazeColor: '#ffe573' },
        { key: 'Carbon', group: 'Carbon', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.6, seaLevel: -0.2, mountainAmp: 2.2, cloudCover: 0.05, polarCaps: false, baseColor: '#3a3a3a', landColor: '#575757', iceColor: '#e6e6e6', hazeColor: '#cfd6e0', specular: 0.2, shininess: 48 },
        { key: 'Metallic', group: 'Metallic', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.4, seaLevel: -0.2, mountainAmp: 1.1, cloudCover: 0.02, polarCaps: false, baseColor: '#6c6f77', landColor: '#8c8f99', iceColor: '#eff2f7', hazeColor: '#d6e0ff', specular: 0.35, shininess: 96 },
        { key: 'Crystal', group: 'Metallic', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.2, seaLevel: -0.3, mountainAmp: 1.4, cloudCover: 0.02, polarCaps: false, baseColor: '#86c5ff', landColor: '#a6d6ff', iceColor: '#f3fbff', hazeColor: '#cbe5ff', specular: 0.5, shininess: 128 },
        { key: 'MegaCity', group: 'Life', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: -0.2, mountainAmp: 0.9, cloudCover: 0.25, polarCaps: false, baseColor: '#6d6d6d', landColor: '#7a7a7a', iceColor: '#e6f2ff', hazeColor: '#d9e3ff', cityLights: true, cityColor: '#ffd080', specular: 0.18, shininess: 56 },
        { key: 'Toxic', group: 'Toxic', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.6, seaLevel: -0.3, mountainAmp: 1.3, cloudCover: 0.35, polarCaps: false, baseColor: '#6d7f2a', landColor: '#829640', iceColor: '#f6ffe6', hazeColor: '#bde34f', cloudColor: '#d9f266' },
        { key: 'Methane', group: 'Toxic', hasOceans: true, atmosphere: true, hasCraters: true, craterChance: 0.5, seaLevel: 0.2, mountainAmp: 0.7, cloudCover: 0.2, polarCaps: true, baseColor: '#5b7f86', landColor: '#6e8f96', oceanColor: '#2e4a66', iceColor: '#e9f8ff', hazeColor: '#9fd0ff', cloudColor: '#cfe6ff' },

        // Gas giants and variants (group 'Gas Giant')
        { key: 'Gas Giant', group: 'Gas Giant', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: -1.0, mountainAmp: 0.0, cloudCover: 0.0, polarCaps: false, baseColor: '#7BA5D6', landColor: '#d6c08b', iceColor: '#e6f2ff', gasBands: true, bandScale: 35, bandWarp: 2.0, gasPalette: ['#a5c4e6','#d8c49a','#e9d7b7','#88a7cf'] },
        { key: 'Ice Giant', group: 'Gas Giant', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: -1.0, mountainAmp: 0.0, cloudCover: 0.0, polarCaps: false, baseColor: '#7FC6FF', landColor: '#9ed1ff', iceColor: '#e6f2ff', gasBands: true, bandScale: 28, bandWarp: 1.2, gasPalette: ['#a6e1ff','#7fc6ff','#4aa6e0','#b9ecff'] },
        { key: 'Hot Jupiter', group: 'Gas Giant', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: -1.0, mountainAmp: 0.0, cloudCover: 0.0, polarCaps: false, baseColor: '#e6a36a', landColor: '#f0c48a', iceColor: '#ffe9cc', gasBands: true, bandScale: 22, bandWarp: 3.5, gasPalette: ['#f2c185','#e89054','#c65f3a','#ffe1a6'] }
      ];

      let candidates = baseProfiles;
      if (typeOverride) {
        // Prefer matching group to allow subtypes (e.g., Gas Giant variants)
        const byGroup = baseProfiles.filter(p => p.group === typeOverride);
        if (byGroup.length) {
          candidates = byGroup;
        } else {
          const byKey = baseProfiles.filter(p => p.key === typeOverride);
          if (byKey.length) candidates = byKey;
        }
      }

      let chosen = candidates[Math.floor(rng() * candidates.length)];
      // Create a tweaked copy for per-planet variation
      chosen = { ...chosen };
      // Jitter numeric params slightly for diversity
      const jitter = (v, amt) => v + (rng()*2-1)*amt;
      if (typeof chosen.seaLevel === 'number') chosen.seaLevel = jitter(chosen.seaLevel, 0.08);
      if (typeof chosen.mountainAmp === 'number') chosen.mountainAmp = Math.max(0, jitter(chosen.mountainAmp, 0.3));
      if (typeof chosen.cloudCover === 'number') chosen.cloudCover = Math.max(0, Math.min(1, jitter(chosen.cloudCover, 0.08)));
      if (typeof chosen.craterChance === 'number') chosen.craterChance = Math.max(0, Math.min(1, jitter(chosen.craterChance, 0.1)));
      if (typeof chosen.bandScale === 'number') chosen.bandScale = Math.max(12, jitter(chosen.bandScale, 4));
      if (typeof chosen.bandWarp === 'number') chosen.bandWarp = Math.max(0, jitter(chosen.bandWarp, 0.6));
      if (typeof chosen.specular === 'number') chosen.specular = Math.max(0, jitter(chosen.specular, 0.05));
      if (typeof chosen.shininess === 'number') chosen.shininess = Math.max(8, jitter(chosen.shininess, 12));

      // Slight color variation
      const varyHex = (hex, strength=0.06) => {
        if (!hex) return hex;
        const rgb = hexToRgb(hex);
        const t = strength*(rng()*2-1);
        const mixed = [
          clamp255(rgb[0] + rgb[0]*t),
          clamp255(rgb[1] + rgb[1]*t),
          clamp255(rgb[2] + rgb[2]*t)
        ];
        return `#${mixed[0].toString(16).padStart(2,'0')}${mixed[1].toString(16).padStart(2,'0')}${mixed[2].toString(16).padStart(2,'0')}`;
      };
      chosen.baseColor = varyHex(chosen.baseColor);
      if (chosen.landColor) chosen.landColor = varyHex(chosen.landColor, 0.08);
      if (chosen.oceanColor) chosen.oceanColor = varyHex(chosen.oceanColor, 0.08);
      if (chosen.hazeColor) chosen.hazeColor = varyHex(chosen.hazeColor, 0.04);
      if (chosen.cloudColor) chosen.cloudColor = varyHex(chosen.cloudColor, 0.05);
      if (Array.isArray(chosen.gasPalette)) {
        // Randomly rotate palette for variety
        const rot = Math.floor(rng()*chosen.gasPalette.length);
        chosen.gasPalette = chosen.gasPalette.slice(rot).concat(chosen.gasPalette.slice(0,rot));
      }
      return chosen;
    }

    function getPlanetProfile(x, y, planetIndex, typeOverride) {
      // TEX namespace matches the renderer's seed so characteristics stay in sync
      const seedU32 = hash32('TEX', x | 0, y | 0, planetIndex | 0);
      const rng = seededRandom(seedU32);
      return choosePlanetProfile(rng, typeOverride);
    }

    // Utility: RGB/HEX and math helpers
    const FOUR_PALETTES = {
      Desert: ['#3A2D20', '#A77A46', '#D7B37A', '#F6E7C9'],
      Dune:   ['#3C2F1F', '#9F7E4E', '#D8C28E', '#F8EDD2'],
      DesertSalt: ['#FFFFFF', '#F2EDD7', '#E4D9BB', '#BCA784'],
      DesertSulfur: ['#FFF7A1', '#FFE05B', '#F6B836', '#A0631E'],
      DesertBasalt: ['#221F23', '#3A3539', '#504A50', '#888085'],
      DesertVerdant: ['#DAFAE4', '#A0E2BA', '#4F9D6D', '#1F3B28'],
      Rocky:  ['#2E2A26', '#6E5C4A', '#9E8C76', '#D2C6B6'], // Barren/Rocky
      VolcanicLand: ['#1E1412', '#3E2A26', '#6A4A3E', '#A07866'], // for non-lava surfaces
      Frozen: ['#63788A', '#B9D3E8', '#EFF7FF', '#FFFFFF']
    };
    function hexToRgb(hex) {
      const h = hex.replace('#','');
      const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
      return [r,g,b];
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function lerpRgb(a,b,t){ return [ lerp(a[0],b[0],t), lerp(a[1],b[1],t), lerp(a[2],b[2],t) ]; }
    function lightenRgb(c, t){ return [ clamp255(lerp(c[0], 255, t)), clamp255(lerp(c[1], 255, t)), clamp255(lerp(c[2], 255, t)) ]; }
    function darkenRgb(c, t){ return [ clamp255(c[0]*(1-t)), clamp255(c[1]*(1-t)), clamp255(c[2]*(1-t)) ]; }
    function scaleRgb(c, s){ return [ c[0]*s, c[1]*s, c[2]*s ]; }
    function clamp255(x){ return Math.max(0, Math.min(255, Math.round(x))); }
    // Scalar helpers
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function smoothstep(edge0, edge1, x){
      if (edge0 === edge1) return x >= edge1 ? 1 : 0;
      const t = clamp01((x - edge0) / (edge1 - edge0));
      return t * t * (3 - 2 * t);
    }
    function sample4(pal, t){
      // Discrete 4-step palette with narrow blend for crisp separation
      t = clamp01(t);
      const x = t * 3.0;
      let i = Math.floor(x);
      let f = x - i;
      i = Math.max(0, Math.min(3, i));
      const j = Math.min(3, i+1);
      const w = smoothstep(0.35, 0.65, f);
      return [
        lerp(pal[i][0], pal[j][0], w),
        lerp(pal[i][1], pal[j][1], w),
        lerp(pal[i][2], pal[j][2], w)
      ];
    }
    function normalize(v){ const l = Math.hypot(v[0],v[1],v[2])||1; return [v[0]/l,v[1]/l,v[2]/l]; }
    function angleDiff(a,b){
      let d = a - b;
      while (d > Math.PI) d -= 2*Math.PI;
      while (d < -Math.PI) d += 2*Math.PI;
      return d;
    }
    function smoothstep01(x){ x = Math.max(0, Math.min(1, x)); return x*x*(3.0 - 2.0*x); }
    function samplePalette(palette, t){
      if (!palette || palette.length === 0) return [255,255,255];
      if (palette.length === 1) return palette[0];
      t = Math.max(0, Math.min(1, t));
      const scaled = t * (palette.length - 1);
      const i = Math.floor(scaled);
      const f = scaled - i;
      const c0 = palette[i];
      const c1 = palette[Math.min(palette.length - 1, i + 1)];
      return lerpRgb(c0, c1, f);
    }

    // Rotation helpers: rotate around X (tilt) then Z (longitude rotation)
    function composeRotation(ax, az){
      const sx = Math.sin(ax), cx = Math.cos(ax);
      const sz = Math.sin(az), cz = Math.cos(az);
      // Combined matrix Rz * Rx
      return [
        [cz, -sz*cx,  sz*sx],
        [sz,  cz*cx, -cz*sx],
        [0 ,     sx,     cx]
      ];
    }
    function applyMat(m, v){
      return [
        m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
        m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
        m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
      ];
    }

    // 3D Value noise + fractal Brownian motion to avoid polar pinching (sampled in 3D)
    function makeValueNoise3D(seedU32){
      const rnd = seededRandom(seedU32);
      // Permutation table
      const P = new Uint16Array(512);
      for (let i=0;i<256;i++) P[i] = i;
      // Fisher-Yates
      for (let i=255;i>0;i--){
        const j = Math.floor(rnd()*(i+1));
        const t = P[i]; P[i] = P[j]; P[j] = t;
      }
      for (let i=0;i<256;i++) P[i+256] = P[i];

      function fade(t){ return t*t*t*(t*(t*6-15)+10); }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function grad(hash, x,y,z){
        // 12 gradients
        switch(hash & 0xF){
          case 0x0: return  x + y; case 0x1: return -x + y; case 0x2: return  x - y; case 0x3: return -x - y;
          case 0x4: return  x + z; case 0x5: return -x + z; case 0x6: return  x - z; case 0x7: return -x - z;
          case 0x8: return  y + z; case 0x9: return -y + z; case 0xA: return  y - z; case 0xB: return -y - z;
          case 0xC: return  y + x; case 0xD: return -y + x; case 0xE: return  y - x; case 0xF: return -y - x;
          default: return 0; }
      }

      return function perlin3(x,y,z){
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        const Z = Math.floor(z) & 255;
        x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
        const u = fade(x), v = fade(y), w = fade(z);
        const A  = P[X]+Y, AA = P[A]+Z, AB = P[A+1]+Z;
        const B  = P[X+1]+Y, BA = P[B]+Z, BB = P[B+1]+Z;
        return lerp(
          lerp(
            lerp(grad(P[AA], x, y, z), grad(P[BA], x-1, y, z), u),
            lerp(grad(P[AB], x, y-1, z), grad(P[BB], x-1, y-1, z), u), v
          ),
          lerp(
            lerp(grad(P[AA+1], x, y, z-1), grad(P[BA+1], x-1, y, z-1), u),
            lerp(grad(P[AB+1], x, y-1, z-1), grad(P[BB+1], x-1, y-1, z-1), u), v
          ), w
        );
      };
    }

    function makeFractalNoise3D(seedU32, octaves=4, persistence=0.5){
      const base = makeValueNoise3D(seedU32);
      return function(x,y,z){
        let amp = 1, freq = 1, sum = 0, norm = 0;
        for (let i=0;i<octaves;i++){
          sum += base(x*freq, y*freq, z*freq) * amp;
          norm += amp; amp *= persistence; freq *= 2;
        }
        return sum / (norm || 1);
      };
    }

    /**
     * Generate solar system name based on grid position
     * Uses consonant-vowel patterns with varying lengths
     */
    function generateSolarSystemName(x, y) {
      const seed = hash32('SYS', x | 0, y | 0);
      const rng = seededRandom(seed);
      
      const consonants = 'BCDFGHJKLMNPQRSTVWXZ';
      const vowels = 'AEIOU';
      
      // Determine name length (2-4 syllables = 4-8 characters)
      const syllables = Math.floor(rng() * 3) + 2; // 2-4 syllables
      let name = '';
      
      for (let i = 0; i < syllables; i++) {
        // Each syllable: consonant + vowel
        name += consonants[Math.floor(rng() * consonants.length)];
        name += vowels[Math.floor(rng() * vowels.length)].toLowerCase();
      }
      
      // Capitalize first letter
      return name.charAt(0).toUpperCase() + name.slice(1);
    }

    /**
     * Generate planet name (version 1 style with seeding on x, y, planetIndex)
     * Uses consonant-vowel patterns with optional suffixes
     */
    function generatePlanetName(x, y, planetIndex) {
      const seed = toLCGSeed(hash32('PLN', x | 0, y | 0, planetIndex | 0));
      const rng = new SeededRNG(seed);
      
      const C = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'];
      const V = ['a','e','i','o','u','y'];
      const len = rng.nextInt(2, 3);
      let s = '';
      for (let i = 0; i < len; i++) { 
        const cIndex = Math.floor(rng.next() * C.length);
        const vIndex = Math.floor(rng.next() * V.length);
        s += C[cIndex] + V[vIndex]; 
      }
      const suffixes = ['-I', '-II', '', '', '', ' Prime'];
      const sIndex = Math.floor(rng.next() * suffixes.length);
      return s.charAt(0).toUpperCase() + s.slice(1) + suffixes[sIndex];
    }

    /**
     * Generate planet names for a solar system
     * Based on Roman, Greek, and mythological naming conventions
     */
    function generatePlanetNames(x, y, count) {
      const names = [];
      for (let i = 0; i < count; i++) {
        names.push(generatePlanetName(x, y, i));
      }
      return names;
    }

    /**
     * Get planet color based on type (seeded on x, y, planetIndex)
     */
    function getPlanetColor(x, y, planetIndex) {
      const seed = toLCGSeed(hash32('COL', x | 0, y | 0, planetIndex | 0));
      const rng = new SeededRNG(seed);
      
      const planetTypes = ['Rocky', 'Gas Giant', 'Ice World', 'Desert', 'Ocean', 'Volcanic'];
      const typeIndex = Math.floor(rng.next() * planetTypes.length);
      const type = planetTypes[typeIndex];
      
      const colors = {
        'Rocky': ['#8B4513', '#CD853F', '#A0522D'],
        'Gas Giant': ['#4169E1', '#6495ED', '#87CEEB'],
        'Ice World': ['#E0FFFF', '#B0E0E6', '#F0F8FF'],
        'Desert': ['#DAA520', '#F4A460', '#CD853F'],
        'Ocean': ['#008B8B', '#20B2AA', '#48D1CC'],
        'Volcanic': ['#DC143C', '#B22222', '#8B0000']
      };
      
      const colorOptions = colors[type];
      const colorIndex = Math.floor(rng.next() * colorOptions.length);
      
      return {
        type,
        color: colorOptions[colorIndex]
      };
    }

    /**
     * Darken a color by a factor (0.0 - 1.0)
     */
    function darkenColor(color, factor = 0.4) {
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      const darkR = Math.floor(r * factor);
      const darkG = Math.floor(g * factor);
      const darkB = Math.floor(b * factor);
      
      return `#${darkR.toString(16).padStart(2, '0')}${darkG.toString(16).padStart(2, '0')}${darkB.toString(16).padStart(2, '0')}`;
    }

    const colorParseCanvas = document.createElement('canvas');
    colorParseCanvas.width = colorParseCanvas.height = 1;
    const colorParseCtx = colorParseCanvas.getContext('2d');

    function parseCssColorToRgba(color) {
      if (!colorParseCtx || !color) return null;
      try {
        colorParseCtx.fillStyle = '#000';
        colorParseCtx.fillStyle = color;
      } catch (err) {
        return null;
      }
      const computed = colorParseCtx.fillStyle;
      if (!computed) return null;
      if (computed.startsWith('#')) {
        let hex = computed.slice(1);
        if (hex.length === 3) {
          hex = hex.split('').map((ch) => ch + ch).join('');
        }
        if (hex.length === 6 || hex.length === 8) {
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          const a = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) / 255 : 1;
          return [r, g, b, a];
        }
      }
      const match = computed.match(/rgba?\(([^)]+)\)/);
      if (!match) return null;
      const parts = match[1].split(',').map((part) => part.trim());
      if (parts.length < 3) return null;
      const r = parseFloat(parts[0]);
      const g = parseFloat(parts[1]);
      const b = parseFloat(parts[2]);
      const a = parts.length >= 4 ? parseFloat(parts[3]) : 1;
      return [r, g, b, a];
    }

    function dimCssColor(color, factor = 0.5) {
      const rgba = parseCssColorToRgba(color);
      if (!rgba) return color;
      const [r, g, b, a = 1] = rgba;
      const dimR = Math.max(0, Math.min(255, Math.round(r * factor)));
      const dimG = Math.max(0, Math.min(255, Math.round(g * factor)));
      const dimB = Math.max(0, Math.min(255, Math.round(b * factor)));
      const alpha = Math.max(0, Math.min(1, a));
      if (alpha < 1) {
        const alphaRounded = Math.round(alpha * 1000) / 1000;
        return `rgba(${dimR}, ${dimG}, ${dimB}, ${alphaRounded})`;
      }
      return `rgb(${dimR}, ${dimG}, ${dimB})`;
    }

    function boostCssColor(color, factor = 1.15) {
      const rgba = parseCssColorToRgba(color);
      if (!rgba) return color;
      const [r, g, b, a = 1] = rgba;
      const boostR = Math.max(0, Math.min(255, Math.round(r * factor)));
      const boostG = Math.max(0, Math.min(255, Math.round(g * factor)));
      const boostB = Math.max(0, Math.min(255, Math.round(b * factor)));
      const alpha = Math.max(0, Math.min(1, a));
      if (alpha < 1) {
        const alphaRounded = Math.min(1, Math.round(alpha * factor * 1000) / 1000);
        return `rgba(${boostR}, ${boostG}, ${boostB}, ${alphaRounded})`;
      }
      return `rgb(${boostR}, ${boostG}, ${boostB})`;
    }

    /**
     * Get number of planets in a solar system (1-8)
     */
    function getPlanetCount(x, y) {
      const seed = (x * 73856093) ^ (y * 19349663) + 54321;
      const rng = seededRandom(seed);
      return Math.floor(rng() * 8) + 1; // 1-8 planets
    }

    /**
     * Get neighboring solar systems (only at even coordinates)
     * Returns array of {x, y, name, distance} sorted by distance
     */
    function getNeighboringSystems(currentX, currentY, maxDistance = 8) {
      const neighbors = [];
      
      for (let dx = -maxDistance; dx <= maxDistance; dx += 2) {
        for (let dy = -maxDistance; dy <= maxDistance; dy += 2) {
          // Skip if both offsets are 0 (current system)
          if (dx === 0 && dy === 0) continue;
          
          const x = currentX + dx;
          const y = currentY + dy;
          
          // Only include systems at even coordinates
          if (x % 2 !== 0 || y % 2 !== 0) continue;
          
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= maxDistance) {
            neighbors.push({
              x,
              y,
              name: generateSolarSystemName(x, y),
              distance: distance.toFixed(1)
            });
          }
        }
      }
      
      // Sort by distance
      neighbors.sort((a, b) => parseFloat(a.distance) - parseFloat(b.distance));
      
      // Limit to 8 nearest
      return neighbors.slice(0, 8);
    }

    // ============================================================================
    // NAVIGATION SYSTEM - Galaxy and solar system navigation
    // ============================================================================
    
    class NavigationSystem {
      constructor() {
        this.currentX = 0;
        this.currentY = 0;
        this.currentPlanetIndex = 0; // Which planet we're at (0 = closest to sun)
        this.viewMode = 'system'; // 'system' or 'galaxy'
        this.cursorIndex = 0;
        this.traveling = false;
        this.travelStartTime = 0;
        this.travelDuration = 10; // 10 seconds
        this.travelTarget = null;
        this.fuelCostPerUnit = 10; // 10 liters per distance unit
      }

      /**
       * Get current solar system info
       */
      getCurrentSystem() {
        const name = generateSolarSystemName(this.currentX, this.currentY);
        const planetCount = getPlanetCount(this.currentX, this.currentY);
        const planets = generatePlanetNames(this.currentX, this.currentY, planetCount);
        
        return {
          x: this.currentX,
          y: this.currentY,
          name,
          planetCount,
          planets
        };
      }

      /**
       * Get sun strength based on current planet index
       * Planet 0 (closest) = 100%, Planet 7 (farthest) = 20%
       */
      getSunStrength() {
        const system = this.getCurrentSystem();
        const maxIndex = system.planetCount - 1;
        
        // Linear interpolation: 100% at index 0, 20% at max index
        if (maxIndex === 0) return 1.0; // Single planet system = 100%
        
        const strength = 1.0 - (this.currentPlanetIndex / maxIndex) * 0.8;
        return Math.max(0.2, Math.min(1.0, strength));
      }

      /**
       * Get neighboring systems for galaxy map
       */
      getGalaxyMap() {
        return getNeighboringSystems(this.currentX, this.currentY);
      }

      /**
       * Switch between system and galaxy view
       */
      setViewMode(mode) {
        this.viewMode = mode;
        this.cursorIndex = 0;
        eventBus.emit('navigation:view-changed', { mode });
      }

      /**
       * Show current location (system map with cursor on current planet)
       */
      showCurrentLocation() {
        this.viewMode = 'system';
        this.cursorIndex = this.currentPlanetIndex;
        eventBus.emit('navigation:view-changed', { mode: 'system' });
      }

      /**
       * Move cursor up/down in list
       */
      moveCursor(direction) {
        const items = this.viewMode === 'system' 
          ? this.getCurrentSystem().planets 
          : this.getGalaxyMap();
        
        if (direction === 'up') {
          this.cursorIndex = Math.max(0, this.cursorIndex - 1);
        } else if (direction === 'down') {
          this.cursorIndex = Math.min(items.length - 1, this.cursorIndex + 1);
        }
        
        eventBus.emit('navigation:cursor-moved', { index: this.cursorIndex });
      }

      /**
       * Set cursor to specific position (from dial)
       */
      setCursor(index) {
        const items = this.viewMode === 'system' 
          ? this.getCurrentSystem().planets 
          : this.getGalaxyMap();
        
        this.cursorIndex = Math.max(0, Math.min(items.length - 1, index));
        eventBus.emit('navigation:cursor-moved', { index: this.cursorIndex });
      }

      /**
       * Show travel blocked message in navigation terminal for 5 seconds
       */
      showTravelBlockedMessage(message) {
        const lines = message.split('\n');
        
        // Store original state so we can restore it
        if (!this.blockedMessageTimeout) {
          this.savedViewMode = this.viewMode;
          this.savedCursorIndex = this.cursorIndex;
        }
        
        // Set a flag to show blocked message
        this.showingBlockedMessage = true;
        this.blockedMessageLines = lines;
        
        // Clear any existing timeout
        if (this.blockedMessageTimeout) {
          clearTimeout(this.blockedMessageTimeout);
        }
        
        // Update UI immediately
        eventBus.emit('navigation:update-ui');
        
        // Restore after 5 seconds
        this.blockedMessageTimeout = setTimeout(() => {
          this.showingBlockedMessage = false;
          this.blockedMessageLines = null;
          this.blockedMessageTimeout = null;
          eventBus.emit('navigation:update-ui');
        }, 5000);
      }

      /**
       * Start travel to selected destination
       */
      beginTravel() {
        if (this.traveling) {
          return { success: false, message: 'Already traveling!' };
        }

        // Check solar panel safety requirements
        const safetyIssues = [];
        
        // Check if solar panels are fully retracted (extension must be 0)
        if (solarSystem.extension > 0) {
          safetyIssues.push('Panels extended');
        }
        
        // Check if solar panels are stopped (panelState must be 1)
        // 0=retracting, 1=stopped, 2=extending
        if (solarSystem.panelState !== 1) {
          safetyIssues.push('Panels moving');
        }
        
        // Check if solar panels are disconnected from bus
        if (solarSystem.connectedToBus) {
          safetyIssues.push('Panels connected');
        }
        
        // If there are safety issues, show them and prevent travel
        if (safetyIssues.length > 0) {
          const message = 'BLOCKED:\n' + safetyIssues.map(issue => `• ${issue}`).join('\n');
          this.showTravelBlockedMessage(message);
          return { success: false, message };
        }

        if (this.viewMode === 'system') {
          // Travel to a planet in current system
          const system = this.getCurrentSystem();
          if (this.cursorIndex >= system.planets.length) {
            return { success: false, message: 'Invalid planet!' };
          }
          
          if (this.cursorIndex === this.currentPlanetIndex) {
            return { success: false, message: 'Already at this planet!' };
          }
          
          const targetIndex = this.cursorIndex;
          const targetPlanet = system.planets[targetIndex];
          const distance = Math.abs(targetIndex - this.currentPlanetIndex);
          const fuelNeeded = distance * 0.5; // 0.5L per planet distance
          const travelTime = distance * 2.0; // 2 seconds per planet hop
          
          if (fuelSystem.currentFuel < fuelNeeded) {
            return { success: false, message: 'Insufficient fuel!' };
          }
          
          // Start planet travel
          this.traveling = true;
          this.travelStartTime = performance.now() / 1000;
          this.travelDuration = travelTime;
          this.travelTarget = {
            type: 'planet',
            planetIndex: targetIndex,
            planetName: targetPlanet,
            distance: distance,
            fuelUsed: fuelNeeded,
            initialFuel: fuelSystem.currentFuel
          };
          
          eventBus.emit('navigation:travel-started', { 
            type: 'planet',
            target: targetPlanet, 
            distance,
            fuelCost: fuelNeeded,
            travelTime
          });
          
          return { success: true, type: 'planet', planetIndex: targetIndex, distance, fuelNeeded };
        } else {
          // Travel to another solar system
          const neighbors = this.getGalaxyMap();
          if (neighbors.length === 0 || this.cursorIndex >= neighbors.length) {
            return { success: false, message: 'No destination!' };
          }

          const target = neighbors[this.cursorIndex];
          const fuelCost = Math.ceil(parseFloat(target.distance) * this.fuelCostPerUnit);
          const travelTime = parseFloat(target.distance) * 1.5; // 1.5 seconds per unit distance

          if (fuelSystem.currentFuel < fuelCost) {
            return { success: false, message: 'Insufficient fuel!' };
          }

          // Start travel
          this.traveling = true;
          this.travelStartTime = performance.now() / 1000;
          this.travelDuration = travelTime;
          this.travelTarget = target;
          
          eventBus.emit('navigation:travel-started', { type: 'system', target, fuelCost, travelTime });
          
          return { success: true, type: 'system', fuelCost, target };
        }
      }

      /**
       * Update travel progress
       */
      update(deltaTime) {
        if (!this.traveling) return;

        const currentTime = performance.now() / 1000;
        const elapsed = currentTime - this.travelStartTime;
        const progress = Math.min(elapsed / this.travelDuration, 1.0);

        if (progress >= 1.0) {
          // Travel complete
          if (this.travelTarget.type === 'planet') {
            // Planet travel complete
            const fuelCost = this.travelTarget.fuelUsed;
            fuelSystem.consumeFuel(fuelCost);
            
            this.currentPlanetIndex = this.travelTarget.planetIndex;
            this.traveling = false;
            this.cursorIndex = this.currentPlanetIndex; // Move cursor to current planet
            
            // Update sun strength based on new planet
            const sunStrength = this.getSunStrength();
            solarSystem.updateSunlight(sunStrength);
            
            eventBus.emit('navigation:travel-complete', { 
              type: 'planet',
              planetIndex: this.currentPlanetIndex,
              planetName: this.travelTarget.planetName,
              fuelUsed: fuelCost,
              sunStrength
            });
          } else {
            // System travel complete
            const fuelCost = Math.ceil(parseFloat(this.travelTarget.distance) * this.fuelCostPerUnit);
            fuelSystem.consumeFuel(fuelCost);
            
            this.currentX = this.travelTarget.x;
            this.currentY = this.travelTarget.y;
            
            // Arrive at outermost planet
            const system = this.getCurrentSystem();
            this.currentPlanetIndex = system.planetCount - 1;
            
            this.traveling = false;
            this.cursorIndex = 0;
            this.viewMode = 'system'; // Return to system view
            
            // Update sun strength based on arrival planet
            const sunStrength = this.getSunStrength();
            solarSystem.updateSunlight(sunStrength);
            
            eventBus.emit('navigation:travel-complete', { 
              type: 'system',
              x: this.currentX, 
              y: this.currentY,
              planetIndex: this.currentPlanetIndex,
              fuelUsed: fuelCost,
              sunStrength
            });
          }
        } else {
          // Travel in progress - consume fuel gradually for planet travel
          if (this.travelTarget.type === 'planet') {
            const fuelPerSecond = this.travelTarget.fuelUsed / this.travelDuration;
            const fuelToConsume = fuelPerSecond * deltaTime;
            fuelSystem.currentFuel = Math.max(0, fuelSystem.currentFuel - fuelToConsume);
          }
          
          eventBus.emit('navigation:travel-progress', { progress, elapsed });
        }
      }

      /**
       * Get system status
       */
      getStatus() {
        return {
          position: { x: this.currentX, y: this.currentY },
          planetIndex: this.currentPlanetIndex,
          system: this.getCurrentSystem(),
          viewMode: this.viewMode,
          cursorIndex: this.cursorIndex,
          traveling: this.traveling,
          sunStrength: this.getSunStrength()
        };
      }
    }

    // Create navigation system
    const navigationSystem = new NavigationSystem();

    // ============================================================================
    // COMPONENT BASE CLASS
    // ============================================================================
    class Component {
      constructor(name) {
        this.name = name;
        this.enabled = true;
      }

      update(deltaTime) {
        // Override in subclasses
      }

      destroy() {
        // Override in subclasses for cleanup
      }
    }

    // ============================================================================
    // BATTERY COMPONENT
    // ============================================================================
    class Battery extends Component {
      constructor(id, config = {}) {
        super(`Battery_${id}`);
        
        this.id = id;
        this.maxCapacity = config.maxCapacity || 2000; // Wh (watt-hours) - sized for 10min charge
        this.currentCharge = config.initialCharge || this.maxCapacity * 0.7;
        this.maxDischargeRate = config.maxDischargeRate || 1000; // W (watts)
        this.maxChargeRate = config.maxChargeRate || 12600; // W (watts) - can accept full solar
        this.efficiency = config.efficiency || 0.95; // 95% efficient
        this.health = config.health || 100; // 0-100%
        this.connectedToBus = config.connectedToBus !== undefined ? config.connectedToBus : true;
        this.temperature = config.temperature || 20; // Celsius
        this.cycleCount = config.cycleCount || 0;
        
        // Teleportation energy tracking
        this.teleportEnergyDrawn = 0;
        
        // Degradation parameters
        this.degradationRate = 0.0001; // per cycle
        this.optimalTempMin = 15;
        this.optimalTempMax = 25;
      }

      /**
       * Get charge percentage (0-100)
       */
      getChargePercentage() {
        return (this.currentCharge / this.maxCapacity) * 100;
      }

      /**
       * Get effective capacity based on health
       */
      getEffectiveCapacity() {
        return this.maxCapacity * (this.health / 100);
      }

      /**
       * Attempt to draw power from the battery
       * @param {number} watts - Power to draw in watts
       * @param {number} deltaTime - Time step in seconds
       * @returns {number} Actual power drawn
       */
      draw(watts, deltaTime) {
        if (!this.connectedToBus || !this.enabled) {
          return 0;
        }

        // During teleportation or short bursts, allow higher discharge rates (capacitor assist)
        const peakDischarge = powerSystem.teleportInProgress || powerSystem.burstInProgress;
        const maxRate = peakDischarge ? watts : this.maxDischargeRate;
        
        // Limit by max discharge rate
        const actualWatts = Math.min(watts, maxRate);
        
        // Calculate energy in watt-hours for this time step
        const energyRequested = (actualWatts * deltaTime) / 3600;
        
        // Can't draw more than current charge
        const energyDrawn = Math.min(energyRequested, this.currentCharge);
        
        // Track teleportation energy if teleport is in progress
        if (powerSystem.teleportInProgress) {
          this.teleportEnergyDrawn += energyDrawn;
        }
        
        // Update charge
        const previousCharge = this.currentCharge;
        this.currentCharge = Math.max(0, this.currentCharge - energyDrawn);
        
        // Emit events for charge level changes
        this.checkChargeThresholds(previousCharge);
        
        // Apply degradation from discharge
        this.applyDegradation(deltaTime);
        
        // Return actual watts drawn
        return (energyDrawn / deltaTime) * 3600;
      }

      /**
       * Attempt to charge the battery
       * @param {number} watts - Power to charge with in watts
       * @param {number} deltaTime - Time step in seconds
       * @returns {number} Actual power accepted
       */
      charge(watts, deltaTime) {
        if (!this.connectedToBus || !this.enabled) {
          return 0;
        }

        const effectiveCapacity = this.getEffectiveCapacity();
        const availableCapacity = effectiveCapacity - this.currentCharge;
        
        if (availableCapacity <= 0) {
          return 0; // Already full
        }

        // Limit by max charge rate
        const actualWatts = Math.min(watts, this.maxChargeRate);
        
        // Calculate energy in watt-hours for this time step
        // Power (W) × Time (s) / 3600 (s/h) = Energy (Wh)
        const energyOffered = (actualWatts * deltaTime) / 3600;
        
        // Apply efficiency loss
        const energyAccepted = Math.min(energyOffered * this.efficiency, availableCapacity);
        
        // Update charge
        const previousCharge = this.currentCharge;
        this.currentCharge = Math.min(effectiveCapacity, this.currentCharge + energyAccepted);
        
        
        
        // Emit events for charge level changes
        this.checkChargeThresholds(previousCharge);
        
        // Apply degradation from charging
        this.applyDegradation(deltaTime * 0.5); // Charging causes less degradation
        
        // Return actual watts accepted (accounting for efficiency)
        return (energyAccepted / this.efficiency) * 3600 / deltaTime;
      }

      /**
       * Check for threshold crossings and emit events
       */
      checkChargeThresholds(previousCharge) {
        const currentPercent = this.getChargePercentage();
        const previousPercent = (previousCharge / this.maxCapacity) * 100;

        // Critical low (5%)
        if (previousPercent > 5 && currentPercent <= 5) {
          eventBus.emit('battery:critical', { battery: this });
        }

        // Low (20%)
        if (previousPercent > 20 && currentPercent <= 20) {
          eventBus.emit('battery:low', { battery: this });
        }

        // Empty (0%)
        if (previousPercent > 0 && currentPercent <= 0) {
          eventBus.emit('battery:depleted', { battery: this });
        }

        // Full (100%)
        if (previousPercent < 100 && currentPercent >= 100) {
          eventBus.emit('battery:full', { battery: this });
        }

        // General charge change
        eventBus.emit('battery:charge-changed', { battery: this, previousPercent, currentPercent });
      }

      /**
       * Apply degradation over time
       */
      applyDegradation(deltaTime) {
        // Temperature-based degradation
        let tempFactor = 1.0;
        if (this.temperature < this.optimalTempMin) {
          tempFactor = 1.2;
        } else if (this.temperature > this.optimalTempMax) {
          tempFactor = 1.5;
        }

        // Apply degradation
        const degradation = this.degradationRate * tempFactor * (deltaTime / 3600);
        this.health = Math.max(0, this.health - degradation);

        // Update cycle count (rough approximation)
        this.cycleCount += (deltaTime / 3600) / 24; // Assume 1 cycle per day of operation

        if (this.health < 50 && this.health > 49.9) {
          eventBus.emit('battery:degraded', { battery: this });
        }
      }

      /**
       * Connect battery to main bus
       */
      connectToBus() {
        if (!this.connectedToBus) {
          this.connectedToBus = true;
          eventBus.emit('battery:connected', { battery: this });
        }
      }

      /**
       * Disconnect battery from main bus
       */
      disconnectFromBus() {
        if (this.connectedToBus) {
          this.connectedToBus = false;
          eventBus.emit('battery:disconnected', { battery: this });
        }
      }

      /**
       * Toggle bus connection
       */
      toggleBus() {
        if (this.connectedToBus) {
          this.disconnectFromBus();
        } else {
          this.connectToBus();
        }

      }

      /**
       * Get status object for display
       */
      getStatus() {
        return {
          id: this.id,
          charge: this.currentCharge,
          chargePercent: this.getChargePercentage(),
          maxCapacity: this.maxCapacity,
          effectiveCapacity: this.getEffectiveCapacity(),
          health: this.health,
          connected: this.connectedToBus,
          enabled: this.enabled,
          temperature: this.temperature,
          cycleCount: this.cycleCount
        };
      }
    }

    // ============================================================================
    // POWER BUS SYSTEM - Main power distribution
    // ============================================================================
    class PowerBus {
      constructor() {
        this.currentDraw = 0; // Current power being drawn (watts)
        this.currentSupply = 0; // Current power being supplied (watts)
        this.voltage = 48; // Bus voltage (volts)
        this.maxCurrent = 500; // Max current (amps)
      }

      /**
       * Get maximum power capacity of the bus
       */
      getMaxPower() {
        return this.voltage * this.maxCurrent; // 24000W = 24kW
      }

      /**
       * Get bus utilization percentage
       */
      getUtilization() {
        return Math.min(100, (this.currentDraw / this.getMaxPower()) * 100);
      }

      /**
       * Check if power demand can be met
       */
      canSupply(watts) {
        return watts <= this.getMaxPower();
      }
    }

    // Create main power bus
    const mainBus = new PowerBus();

    // ============================================================================
    // SOLAR PANEL SYSTEM
    // ============================================================================
    class SolarPanelSystem {
      constructor() {
        this.panelState = 1; // 0=retracted, 1=stopped, 2=extended
        this.extension = 0.5; // 0.0 to 1.0 (0% to 100% extended)
        this.extensionSpeed = 0.1; // Extension/retraction rate per second
        this.maxPowerOutput = 12600; // Watts at full extension (sized for exactly 10min battery charge)
        this.currentOutput = 0; // Current power generation
        this.efficiency = 0.85; // 85% efficient
        this.temperature = 20; // Celsius
        this.connectedToBus = true; // Whether panels are connected to main bus
        
        // Physical specifications (two 33m² arrays = 66m² total, ~165kg total mass)
        this.panelArea = 66; // m² - total deployed area
        this.panelMass = 165; // kg - total mass of both panel arrays
        
        // Motor power consumption (realistic for 165kg solar arrays)
        // Based on: deployment actuators (~25W), control electronics (~10W), 
        // structural locks (~20W), motors (~5W), sensors (~5W), friction losses (~35W)
        this.motorBasePower = 100; // Watts baseline when extending/retracting
        this.currentMotorDraw = 0; // Current motor power draw
        
        // Sunlight intensity (simulated)
        // TODO: Later this will vary by distance from local sun/planet
        this.sunlightIntensity = 1.0; // 0.0 to 1.0 (currently full sun for testing)
      }

      /**
       * Get current power output based on extension and conditions
       */
      getPowerOutput() {
        if (!this.connectedToBus) {
          return 0; // No power if not connected to bus
        }
        // Power scales with extension percentage and sunlight
        const output = this.maxPowerOutput * this.extension * this.sunlightIntensity * this.efficiency;
        return Math.max(0, output);
      }

      /**
       * Get motor power draw - motors draw power when moving
       */
      getMotorDraw() {
        // Motors only draw power when extending or retracting
        if (this.panelState === 1) {
          return 0; // Stopped, no motor draw
        }

        // Check if we have power available to run motors
        // Motors can run if:
        // 1. At least one battery is connected to bus, OR
        // 2. Solar panels are connected and partially extended (generating power)
        
        const hasBatteryPower = batterySystem.getConnectedBatteries().length > 0;
        const hasSolarPower = this.connectedToBus && this.extension > 0;
        
        if (!hasBatteryPower && !hasSolarPower) {
          return 0; // No power source available
        }

        // Calculate base motor power with realistic load variation
        // Power increases with extension due to moment arm (torque = force × distance)
        // At 0% extension: 60W (initial deployment, structural locks releasing)
        // At 50% extension: 100W (baseline)
        // At 100% extension: 140W (maximum moment arm, highest torque required)
        const loadFactor = 0.6 + (0.8 * this.extension); // 0.6 to 1.4
        const basePower = this.motorBasePower * loadFactor;

        // If only solar power, voltage is lower, motors run slower
        // Calculate effective voltage based on available power
        let effectiveVoltage = mainBus.voltage;
        
        if (!hasBatteryPower && hasSolarPower) {
          // Running on solar alone - voltage drops based on solar output
          const solarOutput = this.getPowerOutput();
          effectiveVoltage = Math.min(mainBus.voltage, (solarOutput / basePower) * mainBus.voltage);
        }

        // Motor speed scales with voltage (power = nominal * (V/V_nominal)^2)
        const voltageRatio = effectiveVoltage / mainBus.voltage;
        return basePower * Math.pow(voltageRatio, 2);
      }

      /**
       * Set panel control state
       * @param {number} state - 0=retract, 1=stop, 2=extend
       */
      setPanelState(state) {
        this.panelState = state;
        eventBus.emit('solar:state-changed', { state: this.panelState });
      }

      /**
       * Update panel extension based on current state
       */
      update(deltaTime) {
        // Calculate motor draw first
        this.currentMotorDraw = this.getMotorDraw();

        // Extension/retraction speed scales with motor power
        let effectiveSpeed = this.extensionSpeed;
        if (this.currentMotorDraw < this.motorPower) {
          // Slower movement at reduced power
          effectiveSpeed *= Math.sqrt(this.currentMotorDraw / this.motorPower);
        }

        if (this.panelState === 0) {
          // Retracting
          this.extension = Math.max(0, this.extension - effectiveSpeed * deltaTime);
          if (this.extension <= 0) {
            eventBus.emit('solar:fully-retracted', {});
          }
        } else if (this.panelState === 2) {
          // Extending
          this.extension = Math.min(1, this.extension + effectiveSpeed * deltaTime);
          if (this.extension >= 1) {
            eventBus.emit('solar:fully-extended', {});
          }
        }
        // State 1 = stopped, no change

        // Calculate current output
        this.currentOutput = this.getPowerOutput();
      }

      /**
       * Simulate sunlight changes (day/night cycle, distance from star, etc.)
       */
      updateSunlight(intensity) {
        this.sunlightIntensity = Math.max(0, Math.min(1, intensity));
      }

      /**
       * Get status
       */
      getStatus() {
        return {
          state: this.panelState,
          extension: this.extension,
          extensionPercent: this.extension * 100,
          currentOutput: this.currentOutput,
          maxOutput: this.maxPowerOutput,
          sunlightIntensity: this.sunlightIntensity,
          temperature: this.temperature
        };
      }
    }

    // Create solar panel system
    const solarSystem = new SolarPanelSystem();

    // ============================================================================
    // POWER MANAGEMENT SYSTEM
    // ============================================================================
    class PowerManagementSystem {
      constructor() {
        this.baseLoad = 50; // Base power consumption (life support, computers, etc.)
        this.systemLoads = {
          navigation: 250, // Star tracking cameras (40W), database (25W), GPUs (150W), interfaces (10W), cooling (25W)
          sensors: 15,
          communications: 10,
          lifeSupportExtra: 30,
          traderComms: 800 // High-power radio, signal processing, AI translation, computing
        };
        this.activeSystems = new Set(['navigation', 'sensors', 'communications']);
        
        // Teleportation state
        this.teleportInProgress = false;
        this.teleportStartTime = 0;
        this.teleportDuration = 3.0; // 3 seconds to complete teleportation
        this.teleportPowerDraw = 12000; // 12 kW during teleportation (12kW × 3s / 3600 = 10Wh per second × 3s = 30Wh... wait)
        // Actually: 100Wh over 3 seconds = 33.33Wh per second = 120,000W
        // Let's use 10 seconds for more dramatic effect: 100Wh / 10s = 10Wh/s = 36,000W
        this.teleportTotalEnergy = 100; // Wh total

        // Generic short bursts (e.g., scanner scan/capture). Each item: { name, energyWh, duration, startSec }
        this.bursts = [];
        // Indicates there is an active burst that requires peak discharge beyond per-battery nominal limits
        this.burstInProgress = false;
      }

      /**
       * Calculate total power draw from all systems
       */
      getTotalDraw() {
        let total = this.baseLoad;
        
        // Add active system loads
        this.activeSystems.forEach(system => {
          total += this.systemLoads[system] || 0;
        });
        
        // Add solar panel motor draw
        total += solarSystem.currentMotorDraw;
        
        // Add teleportation draw if active
        if (this.teleportInProgress) {
          // Convert Wh to W for the duration
          total += (this.teleportTotalEnergy / this.teleportDuration) * 3600; // Wh → W
        }

        // Add any active burst draws (sum of Wh over their durations converted to W)
        if (this.bursts.length > 0) {
          for (const b of this.bursts) {
            // Each burst contributes a constant draw during its active duration
            total += (b.energyWh / b.duration) * 3600;
          }
        }
        
        return total;
      }

      /**
       * Enable a system
       */
      enableSystem(systemName) {
        this.activeSystems.add(systemName);
        eventBus.emit('power:system-enabled', { system: systemName });
        
      }

      /**
       * Disable a system
       */
      disableSystem(systemName) {
        this.activeSystems.delete(systemName);
        eventBus.emit('power:system-disabled', { system: systemName });
      }

      /**
       * Check if power is available to run systems
       * Returns true if solar is connected or any battery is connected with charge
       */
      isPowerAvailable() {
        // Check if solar panel is connected and producing power
        // Use getPowerOutput() instead of currentOutput to get real-time calculation
        if (solarSystem.connectedToBus && solarSystem.getPowerOutput() > 0) {
          return true;
        }
        
        // Check if any battery is connected with available charge
        const connectedBatteries = batterySystem.getConnectedBatteries();
        for (const battery of connectedBatteries) {
          if (battery.currentCharge > 10) { // At least 10Wh available
            return true;
          }
        }
        
        return false;
      }

      /**
       * Start teleportation sequence
       * @param {string} eventName - Name of the event
       * @param {number} energyWh - Energy required in watt-hours
       * @returns {boolean} - True if started, false if insufficient power or already in progress
       */
      startTeleportation(eventName, energyWh) {
        if (this.teleportInProgress) {
          
          return false;
        }

        // Check if we have connected batteries with enough charge
        // Teleportation requires battery power (solar can't provide the burst power needed)
        const connectedBatteries = batterySystem.getConnectedBatteries();
        const availablePower = connectedBatteries.reduce((sum, b) => sum + b.currentCharge, 0);
        
        if (connectedBatteries.length === 0) {
          console.error(`❌ Cannot ${eventName}: No batteries connected to bus`);
          eventBus.emit('power:teleport-failed', { event: eventName, required: energyWh, available: 0, reason: 'No batteries connected' });
          return false;
        }
        
        if (availablePower < energyWh) {
          // Show a user-facing warning via event handler; avoid console noise
          eventBus.emit('power:teleport-failed', { event: eventName, required: energyWh, available: availablePower });
          return false;
        }

        this.teleportInProgress = true;
        this.teleportStartTime = performance.now() / 1000; // Convert to seconds
        this.teleportTotalEnergy = energyWh;
        
        eventBus.emit('power:teleport-started', { event: eventName, energy: energyWh, duration: this.teleportDuration });
        
        return true;
      }

      /**
       * Start a generic short power burst (battery-backed), e.g., scanner scan/capture
       * @param {string} name - Name of the burst event
       * @param {number} energyWh - Total energy in Wh
       * @param {number} durationSec - Duration over which to draw the energy
       * @returns {boolean} True if started, false if insufficient power or no batteries
       */
      startBurst(name, energyWh, durationSec) {
        // Require at least one connected battery and enough total charge
        const connected = batterySystem.getConnectedBatteries();
        const availableWh = connected.reduce((s,b)=>s+b.currentCharge, 0);
        if (connected.length === 0 || availableWh < energyWh) {
          eventBus.emit('power:burst-failed', { name, required: energyWh, available: availableWh });
          return false;
        }
        const startSec = performance.now() / 1000;
        this.bursts.push({ name, energyWh, duration: durationSec, startSec });
        eventBus.emit('power:burst-started', { name, energy: energyWh, duration: durationSec });
        return true;
      }

      /**
       * Update power draw on the main bus and handle teleportation
       */
      update(deltaTime) {
        // Check if teleportation is complete (battery draw handled in main loop)
        if (this.teleportInProgress) {
          const currentTime = performance.now() / 1000;
          const elapsed = currentTime - this.teleportStartTime;
          
          if (elapsed >= this.teleportDuration) {
            this.teleportInProgress = false;
            const totalEnergyDrawn = batterySystem.batteries.reduce((sum, b) => sum + b.teleportEnergyDrawn, 0);
            
            // Reset tracking
            batterySystem.batteries.forEach(b => b.teleportEnergyDrawn = 0);
            
            eventBus.emit('power:teleport-complete', {});
          }
        }

        // Update active bursts (battery draw handled in main loop)
        if (this.bursts.length > 0) {
          const now = performance.now() / 1000;
          // Remove finished bursts and emit complete events
          const remaining = [];
          for (const b of this.bursts) {
            if ((now - b.startSec) >= b.duration) {
              eventBus.emit('power:burst-complete', { name: b.name });
            } else {
              remaining.push(b);
            }
          }
          this.bursts = remaining;
        }

        // Set burst flag for this frame
        this.burstInProgress = this.bursts.length > 0;

        mainBus.currentDraw = this.getTotalDraw();
      }

      /**
       * Compute current watts consumed by bursts and teleportation (for balancing only)
       */
      getBurstAndTeleportWatts() {
        let watts = 0;
        if (this.teleportInProgress) {
          watts += (this.teleportTotalEnergy / this.teleportDuration) * 3600;
        }
        if (this.bursts.length > 0) {
          for (const b of this.bursts) {
            watts += (b.energyWh / b.duration) * 3600;
          }
        }
        return watts;
      }
    }

    // Create power management system
    const powerSystem = new PowerManagementSystem();

    // ============================================================================
    // FUEL SYSTEM - Manages fuel tank and credits
    // ============================================================================
    class FuelSystem {
      constructor() {
        this.maxCapacity = 1000; // Liters
        this.currentFuel = 280; // Start at 28%
        this.refuelCostPerLiter = 1; // 1 credit per liter
        this.credits = 10000; // Starting credits
      }

      /**
       * Get fuel percentage
       */
      getFuelPercentage() {
        return (this.currentFuel / this.maxCapacity) * 100;
      }

      /**
       * Calculate cost to refuel to max
       */
      getRefuelCost() {
        const fuelNeeded = this.maxCapacity - this.currentFuel;
        return Math.ceil(fuelNeeded * this.refuelCostPerLiter);
      }

      /**
       * Attempt to refuel the tank
       * @returns {Object} Result with success flag and message
       */
      refuel() {
        const cost = this.getRefuelCost();
        
        if (this.currentFuel >= this.maxCapacity) {
          return { success: false, message: 'Tank already full!' };
        }
        
        if (this.credits < cost) {
          return { success: false, message: 'Insufficient credits!' };
        }
        
        // Deduct credits and fill tank
        this.credits -= cost;
        this.currentFuel = this.maxCapacity;
        
        eventBus.emit('fuel:refueled', { cost, credits: this.credits });
        
        return { success: true, message: `Refueled! -${cost}₵` };
      }

      /**
       * Use fuel (for travel, not implemented yet)
       */
      consumeFuel(amount) {
        this.currentFuel = Math.max(0, this.currentFuel - amount);
        eventBus.emit('fuel:consumed', { amount, remaining: this.currentFuel });
      }

      /**
       * Get system status
       */
      getStatus() {
        return {
          currentFuel: this.currentFuel,
          maxCapacity: this.maxCapacity,
          fuelPercentage: this.getFuelPercentage(),
          credits: this.credits,
          refuelCost: this.getRefuelCost()
        };
      }
    }

    // ==========================================================================
    // SCANNER SYSTEM
    // ==========================================================================
    const scannerSystem = {
      powered: false,
      loadWatts: 350, // Scanner power draw when ON
      canPowerOn() {
        // Can power on if: solar connected to bus and output > 0 OR any battery connected with charge
        if (solarSystem.connectedToBus && solarSystem.getPowerOutput() > 0) return true;
        const connected = batterySystem.getConnectedBatteries();
        return connected.some(b => b.currentCharge > 0);
      },
      setPowered(on) {
        const prev = this.powered;
        if (on) {
          if (!this.canPowerOn()) {
            this.powered = false;
          } else {
            this.powered = true;
            powerSystem.systemLoads.scanner = this.loadWatts;
            powerSystem.enableSystem('scanner');
          }
        } else {
          this.powered = false;
          delete powerSystem.systemLoads.scanner;
          powerSystem.disableSystem('scanner');
        }
        if (prev !== this.powered) eventBus.emit('scanner:power-changed', { powered: this.powered });
      }
    };

    function updateScannerUI() {
      const panel = document.getElementById('scanner-panel');
      if (!panel) return;
      const powerToggle = document.getElementById('scanner-power-toggle');
  const scanBtn = document.getElementById('scanner-scan-btn');
  const captureBtn = document.getElementById('scanner-capture-btn');
  const infoBtn = document.getElementById('scanner-infographic-btn');
      const term = document.getElementById('scanner-terminal');
      const hasPowerAvailable = powerSystem.isPowerAvailable();
      const scannerEnabled = powerSystem.activeSystems.has('scanner');

      // Enable toggle always, but enforce power gating on set
      powerToggle.checked = scannerEnabled; // persist toggle state from saved activeSystems
      powerToggle.disabled = !hasPowerAvailable; // mirror Trader Comms behavior
      const enabled = scannerEnabled && hasPowerAvailable; // actual powered state

      // Keep scannerSystem.powered in sync with effective state
      scannerSystem.powered = enabled;

      // Ensure system load is present when enabled, removed when disabled
      if (scannerEnabled) {
        powerSystem.systemLoads.scanner = scannerSystem.loadWatts;
      } else {
        delete powerSystem.systemLoads.scanner;
      }
  scanBtn.disabled = !enabled;
  captureBtn.disabled = !enabled;
  if (infoBtn) infoBtn.disabled = !enabled;
      if (!enabled) {
        // Clear terminal (no offline text) and camera
        term.textContent = '';
        disposeScannerContext();
        const cam = document.getElementById('scanner-planet');
        if (cam) {
          cam.style.backgroundImage = '';
          cam.style.boxShadow = 'none';
          cam.style.backgroundColor = 'transparent';
          cam.style.filter = 'none';
        }
        clearScannerPostProcessing();
      }

      // Update viewport planet sprite only when powered
      if (enabled) {
        renderScannerViewport();
      }
    }

    function clearScannerPostProcessing() {
      const vp = document.getElementById('scanner-viewport');
      if (!vp) return;
      const crt = vp.closest('.crt') || vp;
      crt.querySelectorAll('.scanlines, .amber-tint').forEach((element) => element.remove());
    }

    function applyLightScannerPostProcessing(container, filterStyle) {
      if (!container) return;
      clearScannerPostProcessing();
      container.style.boxShadow = 'none';
      container.style.backgroundColor = 'transparent';
      container.style.filter = filterStyle;
      const vpEl = document.getElementById('scanner-viewport');
      const crtEl = vpEl ? (vpEl.closest('.crt') || vpEl) : null;
      if (!crtEl) return;
      const rootStyles = getComputedStyle(document.documentElement);
      const amberHex = (rootStyles.getPropertyValue('--amber') || '#ffbf00').trim();
      const hexToRgba = (hex, alpha) => {
        const sanitized = hex.replace('#', '').trim();
        const isShort = sanitized.length === 3;
        const r = parseInt(isShort ? sanitized[0] + sanitized[0] : sanitized.slice(0, 2), 16);
        const g = parseInt(isShort ? sanitized[1] + sanitized[1] : sanitized.slice(2, 4), 16);
        const b = parseInt(isShort ? sanitized[2] + sanitized[2] : sanitized.slice(4, 6), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };
      const tint = document.createElement('div');
      tint.className = 'amber-tint';
      tint.style.position = 'absolute';
      tint.style.inset = '0';
      tint.style.borderRadius = '0';
      tint.style.pointerEvents = 'none';
      tint.style.zIndex = '1';
      tint.style.background = amberHex;
      tint.style.mixBlendMode = 'multiply';
      crtEl.appendChild(tint);

      const overlay = document.createElement('div');
      overlay.className = 'scanlines';
      overlay.style.position = 'absolute';
      overlay.style.inset = '0';
      overlay.style.borderRadius = '0';
      overlay.style.pointerEvents = 'none';
      overlay.style.zIndex = '2';
      overlay.style.backgroundImage = `repeating-linear-gradient(to bottom,
        rgba(0,0,0,0.16) 0px, rgba(0,0,0,0.16) 1px,
        rgba(0,0,0,0) 1px, rgba(0,0,0,0) 2px,
        ${hexToRgba(amberHex, 0.32)} 2px, ${hexToRgba(amberHex, 0.32)} 3px,
        rgba(0,0,0,0) 3px, rgba(0,0,0,0) 4px)`;
      overlay.style.mixBlendMode = 'multiply';
      crtEl.appendChild(overlay);
    }

    function applyDarkScannerPostProcessing(container) {
      if (!container) return;
      clearScannerPostProcessing();
      container.style.filter = 'none';
      container.style.backgroundColor = 'transparent';
      container.style.boxShadow = 'none';
    }

    function syncScannerCameraTheme(theme) {
      const container = document.getElementById('scanner-planet');
      if (!container) {
        clearScannerPostProcessing();
        return;
      }
      const scannerPowered = typeof powerSystem !== 'undefined'
        && powerSystem.activeSystems?.has('scanner')
        && powerSystem.isPowerAvailable();
      if (!scannerPowered) {
        clearScannerPostProcessing();
        container.style.filter = 'none';
        return;
      }
      if (theme === 'dark') {
        applyDarkScannerPostProcessing(container);
      } else {
        renderScannerViewport();
      }
    }

    function renderScannerViewport() {
      const container = document.getElementById('scanner-planet');
      if (!container) return;
      if (!powerSystem.activeSystems.has('scanner') || !powerSystem.isPowerAvailable()) return;
      const isDarkTheme = document.documentElement.getAttribute('data-theme') === 'dark';

      ensureThreeLoaded(() => {
        const x = navigationSystem.currentX;
        const y = navigationSystem.currentY;
        const planetIdx = navigationSystem.currentPlanetIndex;
        const info = getPlanetColor(x, y, planetIdx);

        try {
          const ctx = ensureScannerContext();
          if (!ctx) return;
          populatePlanetRenderContext(ctx, x, y, planetIdx, info.type, info.color);
          if (!ctx.isAnimating()) ctx.startAnimation();

          container.style.backgroundImage = '';
          container.style.background = 'transparent';
          if (isDarkTheme) {
            applyDarkScannerPostProcessing(container);
          } else {
            applyLightScannerPostProcessing(container, 'grayscale(1) brightness(1.12) contrast(1.02)');
          }
        } catch (err) {
          console.warn('Scanner viewport render failed; falling back to 2D gradient.', err);
          disposeScannerContext();
          container.style.background = `radial-gradient(circle at 30% 30%, ${info.color}, ${darkenColor(info.color, 0.4)} 60%, ${darkenColor(info.color, 0.1)})`;
          if (isDarkTheme) {
            applyDarkScannerPostProcessing(container);
          } else {
            applyLightScannerPostProcessing(container, 'grayscale(1) brightness(0.95) contrast(0.95) brightness(1.05)');
          }
        }
      });
    }

    function snapshotTraderShip3D(options = {}) {
      const params = { width: 512, height: 512, seed: 0, ...options };
      const width = Math.max(1, params.width | 0);
      const height = Math.max(1, params.height | 0);
      const shipSeed = typeof params.seed === 'number' ? params.seed >>> 0 : 0;

      return new Promise((resolve) => {
        ensureThreeLoaded(() => {
          if (!window.THREE) { resolve(''); return; }

          try {
            const ctx = ensureTraderShipSnapshotContext(width, height);
            if (!ctx) { resolve(''); return; }

            populateTraderShipContext(ctx, { shipSeed }, { frameMode: 'snapshot' });
            ctx.stopAnimation?.();
            ctx.renderOnce();
            const canvas = ctx.renderer?.domElement;
            const url = canvas ? canvas.toDataURL('image/png') : '';
            resolve(url || '');
          } catch (err) {
            console.warn('Trader ship snapshot failed', err);
            resolve('');
          }
        });
      });
    }

    function scanCurrentPlanet() {
      const term = document.getElementById('scanner-terminal');
      if (!powerSystem.activeSystems.has('scanner') || !powerSystem.isPowerAvailable()) {
        term.textContent = '';
        return;
      }
      const x = navigationSystem.currentX, y = navigationSystem.currentY, i = navigationSystem.currentPlanetIndex;
      const info = getPlanetColor(x, y, i);
      const profile = getPlanetProfile(x, y, i, info.type);

      // Build key/value pairs and align colons
      const kv = [];
      kv.push(['System', `(${x}, ${y})`]);
      kv.push(['Planet', `#${i+1}`]);
      kv.push(['Type', `${profile.key}`]);
      kv.push(['Oceans', profile.hasOceans ? 'Yes' : 'No']);
      kv.push(['Atmosphere', profile.atmosphere ? 'Yes' : 'No']);
      if (profile.gasBands) {
        kv.push(['Bands', 'Yes']);
        kv.push(['Band Scale', `${Math.round((profile.bandScale||0)*10)/10}`]);
      }
      if (profile.hasCraters) {
        kv.push(['Craters', 'Yes']);
        kv.push(['Crater Chance', `${(profile.craterChance*100|0)}%`]);
      }
      kv.push(['Cloud Cover', `${Math.round((profile.cloudCover||0)*100)}%`]);
      if (profile.glowLava) kv.push(['Lava Activity', 'Yes']);
      if (profile.cityLights) kv.push(['City Lights', 'Detected']);

      // compute max label width for alignment (in characters)
      const maxKeyLen = kv.reduce((m, [k]) => Math.max(m, k.length), 0);
      const lines = kv.map(([k, v]) => `${k.padEnd(maxKeyLen, ' ')}: ${v}`);
      term.textContent = lines.join('\n');
    }

    function capturePlanetPhoto() {
      if (!powerSystem.activeSystems.has('scanner') || !powerSystem.isPowerAvailable()) {
        return Promise.resolve();
      }
      // Determine target resolution
      const targetW = Math.max(1920, (window.innerWidth || 0) || 1920);
      const targetH = Math.max(1080, (window.innerHeight || 0) || 1080);
      const minDim = Math.min(targetW, targetH);
      const planetSize = Math.floor(minDim * 0.8);

      // Render planet sprite at full size
      const x = navigationSystem.currentX, y = navigationSystem.currentY, i = navigationSystem.currentPlanetIndex;
      const info = getPlanetColor(x, y, i);
      const profile = getPlanetProfile(x, y, i, info.type);
      return (async () => {
        const spriteUrl = await snapshotPlanet3D({
          size: planetSize,
          x,
          y,
          planetIndex: i,
          typeOverride: info.type,
          baseHex: info.color
        });

      // Composite on a large offscreen canvas
      const cnv = document.createElement('canvas');
      cnv.width = targetW; cnv.height = targetH;
      const ctx = cnv.getContext('2d');
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,targetW,targetH);

  // Background starfield (full coverage): base micro-stars grid + foreground glow stars
      (function drawStarfield(){
        const rnd = seededRandom(hash32('PHOTO-STARS', x|0, y|0, i|0));
        const prevOp = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'lighter';

        // 1) Base micro-stars grid to guarantee coverage across the entire canvas
        const cell = 48; // px cell size
        const jitter = 0.4; // jitter within cell
        for (let gy = 0; gy <= Math.ceil(targetH / cell); gy++) {
          for (let gx = 0; gx <= Math.ceil(targetW / cell); gx++) {
            // Multiple tiny stars per cell with low probability, deterministic per cell index
            const localRnd = seededRandom(hash32('PHOTO-STARS-CELL', x|0, y|0, i|0, gx|0, gy|0));
            const tries = 1 + (localRnd() < 0.25 ? 1 : 0); // sometimes 2 tiny stars
            for (let t = 0; t < tries; t++) {
              if (localRnd() < 0.5) continue; // 50% chance per try
              const sx = Math.floor(gx * cell + (localRnd()*2 - 1) * jitter * cell);
              const sy = Math.floor(gy * cell + (localRnd()*2 - 1) * jitter * cell);
              if (sx < 0 || sx >= targetW || sy < 0 || sy >= targetH) continue;
              const size = 0.5 + localRnd()*0.8; // 0.5-1.3 px
              const base = 0.35 + localRnd()*0.35; // dimmer base
              // Slight color temperature variance
              const tint = localRnd();
              let r=255, g=255, b=255;
              if (tint < 0.33) { r = Math.floor(210 + 45*base); g = Math.floor(220 + 35*base); b = 255; }
              else if (tint < 0.66) { r = 255; g = Math.floor(220 + 35*base); b = Math.floor(180 + 60*base); }
              // A tiny glow so they read, but very subtle
              const glowR = size * (2.0 + localRnd()*1.5);
              const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
              grad.addColorStop(0, `rgba(${r},${g},${b},${(0.25*base).toFixed(3)})`);
              grad.addColorStop(1, 'rgba(0,0,0,0)');
              ctx.fillStyle = grad;
              ctx.beginPath(); ctx.arc(sx, sy, glowR, 0, Math.PI*2); ctx.fill();
            }
          }
        }

        // 2) Foreground glow stars with slight overdraw beyond edges
        const area = targetW * targetH;
        const density = 0.00008 + rnd()*0.00005; // keep a bit lower due to base layer
        const starCount = Math.max(150, Math.min(1600, Math.floor(area * density)));
        const marginX = Math.max(40, Math.floor(targetW * 0.03));
        const marginY = Math.max(40, Math.floor(targetH * 0.03));
        for (let s=0; s<starCount; s++) {
          const sx = Math.floor(rnd()*(targetW + 2*marginX)) - marginX;
          const sy = Math.floor(rnd()*(targetH + 2*marginY)) - marginY;
          const base = 0.6 + rnd()*0.4;
          const size = 0.8 + rnd()*2.2;
          const tint = rnd();
          let r=255, g=255, b=255;
          if (tint < 0.33) { r = Math.floor(210 + 45*base); g = Math.floor(220 + 35*base); b = 255; }
          else if (tint < 0.66) { r = 255; g = Math.floor(220 + 35*base); b = Math.floor(180 + 60*base); }
          const glowR = size * (3.5 + rnd()*3.0);
          const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
          grad.addColorStop(0, `rgba(${r},${g},${b},${(0.35*base).toFixed(3)})`);
          grad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(sx, sy, glowR, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = `rgba(${r},${g},${b},${(0.7*base).toFixed(3)})`;
          ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalCompositeOperation = prevOp;
      })();

        return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const cx = targetW/2, cy = targetH/2;
          const x0 = Math.floor(cx - planetSize/2);
          const y0 = Math.floor(cy - planetSize/2);
          // Draw planet image only; 3D render already contains atmosphere/halo
          const R = planetSize/2;
          ctx.drawImage(img, x0, y0, planetSize, planetSize);

          const out = cnv.toDataURL('image/png');
          const a = document.createElement('a');
          a.href = out;
          const systemName = generateSolarSystemName(x, y).replace(/[^a-z0-9]+/gi, '_');
          const planetName = generatePlanetName(x, y, i).replace(/[^a-z0-9]+/gi, '_');
          const profileSlug = profile.key.replace(/[^a-z0-9]+/gi, '_');
          const utcTs = Math.floor(Date.now() / 1000);
          a.download = `space_trader-${x}-${y}-${systemName}-${planetName}-${profileSlug}-${utcTs}.png`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          resolve();
        };
        img.src = spriteUrl;
        });
      })();
    }

    async function printInfographic() {
      if (!powerSystem.activeSystems.has('scanner') || !powerSystem.isPowerAvailable()) return;

      const targetW = Math.max(1920, (window.innerWidth || 0) || 1920);
      const targetH = Math.max(1080, (window.innerHeight || 0) || 1080);
  const minDim = Math.min(targetW, targetH);
  // Match photo composition scale so the planet does not shrink relative to starfield
  const planetSize = Math.floor(minDim * 0.8);

      const x = navigationSystem.currentX, y = navigationSystem.currentY, i = navigationSystem.currentPlanetIndex;
      const systemName = generateSolarSystemName(x, y);
      const planetName = generatePlanetName(x, y, i);
      const info = getPlanetColor(x, y, i);
      const profile = getPlanetProfile(x, y, i, info.type);
        const seededTrader = generateSeededTraderMatchingComms(x, y, i);

      const spriteUrl = await snapshotPlanet3D({
        size: planetSize,
        x,
        y,
        planetIndex: i,
        typeOverride: info.type,
        baseHex: info.color
      });

      const cnv = document.createElement('canvas');
      cnv.width = targetW; cnv.height = targetH;
      const ctx = cnv.getContext('2d');
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,targetW,targetH);

      // Starfield background
      (function drawStarfield(){
        const rnd = seededRandom(hash32('PHOTO-STARS', x|0, y|0, i|0));
        const prevOp = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'lighter';
        const cell = 48, jitter = 0.4;
        for (let gy = 0; gy <= Math.ceil(targetH / cell); gy++) {
          for (let gx = 0; gx <= Math.ceil(targetW / cell); gx++) {
            const localRnd = seededRandom(hash32('PHOTO-STARS-CELL', x|0, y|0, i|0, gx|0, gy|0));
            const tries = 1 + (localRnd() < 0.25 ? 1 : 0);
            for (let t = 0; t < tries; t++) {
              if (localRnd() < 0.5) continue;
              const sx = Math.floor(gx * cell + (localRnd()*2 - 1) * jitter * cell);
              const sy = Math.floor(gy * cell + (localRnd()*2 - 1) * jitter * cell);
              if (sx < 0 || sx >= targetW || sy < 0 || sy >= targetH) continue;
              const size = 0.5 + localRnd()*0.8;
              const base = 0.35 + localRnd()*0.35;
              const tint = localRnd();
              let r=255,g=255,b=255;
              if (tint < 0.33) { r=Math.floor(210+45*base); g=Math.floor(220+35*base); b=255; }
              else if (tint < 0.66) { r=255; g=Math.floor(220+35*base); b=Math.floor(180+60*base); }
              const glowR = size * (2.0 + localRnd()*1.5);
              const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
              grad.addColorStop(0, `rgba(${r},${g},${b},${(0.25*base).toFixed(3)})`);
              grad.addColorStop(1, 'rgba(0,0,0,0)');
              ctx.fillStyle = grad;
              ctx.beginPath(); ctx.arc(sx, sy, glowR, 0, Math.PI*2); ctx.fill();
            }
          }
        }
        const area = targetW * targetH;
        const density = 0.00008 + rnd()*0.00005;
        const starCount = Math.max(150, Math.min(1600, Math.floor(area * density)));
        const marginX = Math.max(40, Math.floor(targetW * 0.03));
        const marginY = Math.max(40, Math.floor(targetH * 0.03));
        for (let s=0; s<starCount; s++) {
          const sx = Math.floor(rnd()*(targetW + 2*marginX)) - marginX;
          const sy = Math.floor(rnd()*(targetH + 2*marginY)) - marginY;
          const base = 0.6 + rnd()*0.4;
          const size = 0.8 + rnd()*2.2;
          const tint = rnd();
          let r=255,g=255,b=255;
          if (tint < 0.33) { r=Math.floor(210+45*base); g=Math.floor(220+35*base); b=255; }
          else if (tint < 0.66) { r=255; g=Math.floor(220+35*base); b=Math.floor(180+60*base); }
          const glowR = size * (3.5 + rnd()*3.0);
          const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
          grad.addColorStop(0, `rgba(${r},${g},${b},${(0.35*base).toFixed(3)})`);
          grad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(sx, sy, glowR, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = `rgba(${r},${g},${b},${(0.7*base).toFixed(3)})`;
          ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalCompositeOperation = prevOp;
      })();

      await new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const cx = targetW/2, cy = targetH/2;
          const x0 = Math.floor(cx - planetSize/2);
          const y0 = Math.floor(cy - planetSize/2);
          const R = planetSize/2;
          // Draw planet image only; 3D render already contains atmosphere/halo
          ctx.drawImage(img, x0, y0, planetSize, planetSize);
          resolve();
        };
        img.src = spriteUrl;
      });

      const pad = Math.floor(minDim * 0.03);
      const panelBg = `rgba(0,0,0,0.5)`;
      const textColor = '#ffffff';
      // Trader ship overlay rendered from the modular ship pipeline.
      const shipMaxW = Math.floor(targetW * 0.5);
      const shipMaxH = Math.floor(targetH * 0.6);
      let traderShipSprite = '';
      if (seededTrader && typeof seededTrader.shipSeed === 'number' && shipMaxW > 0 && shipMaxH > 0) {
    const renderWidth = Math.max(320, Math.min(Math.floor(shipMaxW * 1.5), targetW));
    const renderHeight = Math.max(320, Math.min(Math.floor(shipMaxH * 1.5), targetH));
        if (renderWidth > 0 && renderHeight > 0) {
          try {
            traderShipSprite = await snapshotTraderShip3D({
              seed: seededTrader.shipSeed,
              width: renderWidth,
              height: renderHeight
            });
          } catch (err) {
            console.warn('Infographic trader ship render failed', err);
          }
        }
      }

      if (traderShipSprite) {
        await new Promise((resolve) => {
          const shipImg = new Image();
          shipImg.onload = () => {
            const aspect = shipImg.height ? (shipImg.width / shipImg.height) : 1;
            let drawW = Math.min(shipImg.width, shipMaxW);
            let drawH = Math.round(drawW / Math.max(aspect, 0.0001));
            if (drawH > shipMaxH) {
              drawH = shipMaxH;
              drawW = Math.round(drawH * Math.max(aspect, 0.0001));
            }
            if (drawW > shipMaxW) {
              drawW = shipMaxW;
              drawH = Math.round(drawW / Math.max(aspect, 0.0001));
            }
            const shipX = targetW - pad - drawW;
            const shipY = targetH - pad - drawH;
            ctx.drawImage(shipImg, shipX, shipY, drawW, drawH);
            resolve();
          };
          shipImg.onerror = () => resolve();
          shipImg.src = traderShipSprite;
        });
      }
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      function drawPanel(x0, y0, w, h) {
        const r = Math.max(6, Math.floor(minDim * 0.01));
        ctx.fillStyle = panelBg;
        ctx.beginPath();
        ctx.moveTo(x0 + r, y0);
        ctx.lineTo(x0 + w - r, y0);
        ctx.quadraticCurveTo(x0 + w, y0, x0 + w, y0 + r);
        ctx.lineTo(x0 + w, y0 + h - r);
        ctx.quadraticCurveTo(x0 + w, y0 + h, x0 + w - r, y0 + h);
        ctx.lineTo(x0 + r, y0 + h);
        ctx.quadraticCurveTo(x0, y0 + h, x0, y0 + h - r);
        ctx.lineTo(x0, y0 + r);
        ctx.quadraticCurveTo(x0, y0, x0 + r, y0);
        ctx.closePath();
        ctx.fill();
      }
      function drawHeading(x0, y0, text) { ctx.fillStyle = textColor; ctx.font = `700 ${Math.floor(minDim*0.035)}px system-ui, sans-serif`; ctx.fillText(text, x0, y0); }
      function drawBody(x0, y0, lines, lineH) { ctx.fillStyle = textColor; ctx.font = `${Math.floor(minDim*0.022)}px system-ui, sans-serif`; let yy = y0; for (const l of lines) { ctx.fillText(l, x0, yy); yy += lineH; } }

      // Left info panel (auto-sized to text)
      const leftX = pad, leftY = pad;
      const headingFont = `700 ${Math.floor(minDim*0.035)}px system-ui, sans-serif`;
      const bodyFont = `${Math.floor(minDim*0.022)}px system-ui, sans-serif`;
      ctx.font = headingFont;
      const headingH = Math.floor(minDim*0.05);
      const bodyLineH = Math.floor(minDim*0.028);
      const subHeadingFont = `${Math.floor(minDim*0.026)}px system-ui, sans-serif`;
      const subHeadingH = Math.floor(minDim*0.034);
      const body1 = [
        `Planet #${i+1} from star`,
        `Coordinates: (${x}, ${y})`,
        `Profile: ${profile.key}`,
        `Oceans: ${profile.hasOceans ? 'Yes' : 'No'}`,
        `Atmosphere: ${profile.atmosphere ? 'Yes' : 'No'}`,
        ...(profile.gasBands ? [`Bands: Yes`, `Band Scale: ${Math.round((profile.bandScale||0)*10)/10}`] : []),
        ...(profile.hasCraters ? [`Craters: Yes`, `Crater Chance: ${(profile.craterChance*100|0)}%`] : []),
        `Cloud Cover: ${Math.round((profile.cloudCover||0)*100)}%`,
        ...(profile.glowLava ? ['Lava Activity: Yes'] : []),
        ...(profile.cityLights ? ['City Lights: Detected'] : [])
      ];
      // measure width
  const headingTitle = `Planet: ${planetName}`;
  const subHeadingTitle = `Star system: ${systemName}`;
  const headingWLeft = (ctx.font = headingFont, ctx.measureText(headingTitle).width);
  const subHeadingWLeft = (ctx.font = subHeadingFont, ctx.measureText(subHeadingTitle).width);
      ctx.font = bodyFont;
      const textW = Math.max(
        headingWLeft,
        subHeadingWLeft,
        ...body1.map(line => ctx.measureText(line).width)
      );
      const leftW = Math.ceil(textW + pad*2);
      const leftH = headingH + subHeadingH + pad + body1.length * bodyLineH + pad;
      drawPanel(leftX, leftY, leftW, leftH);
  drawHeading(leftX+pad, leftY+pad, headingTitle);
      // subheading with system name under the title
      ctx.fillStyle = textColor;
      ctx.font = subHeadingFont;
  ctx.fillText(subHeadingTitle, leftX+pad, leftY+pad+headingH);
      drawBody(leftX+pad, leftY+pad+headingH+subHeadingH, body1, bodyLineH);

  // Right-top: QR code
      const qrSize = Math.floor(minDim * 0.20);
      const qrPad = pad;
      const qrPanelW = qrSize + qrPad*2;
      const qrPanelH = qrSize + qrPad*2 + Math.floor(minDim*0.04);
      const qrX = targetW - qrPanelW - pad;
      const qrY = pad;
      drawPanel(qrX, qrY, qrPanelW, qrPanelH);
      let qrCanvas = null;
      async function ensureQRious() {
        if (typeof QRious !== 'undefined') return true;
        // Load QRious dynamically (same CDNs as qrloop) for offline infographic generation
        const loadScript = (src) => new Promise((res, rej) => { const s=document.createElement('script'); s.src=src; s.onload=()=>res(true); s.onerror=()=>rej(); document.head.appendChild(s); });
        try {
          await loadScript('https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js');
          return true;
        } catch {
          try {
            await loadScript('https://unpkg.com/qrious@4.0.2/dist/qrious.min.js');
            return true;
          } catch {
            return false;
          }
        }
      }
      try {
        // Attempt to ensure QRious is available
        // Note: If network blocked, we'll fallback to printing URL text
        // eslint-disable-next-line no-undef
        const ok = await ensureQRious();
        if (ok && typeof QRious !== 'undefined') {
          const temp = document.createElement('canvas');
          // eslint-disable-next-line no-undef
          const qr = new QRious({ element: temp, value: window.location.href, size: qrSize, level: 'H' });
          const srcCtx = temp.getContext('2d');
          const imgData = srcCtx.getImageData(0,0,temp.width,temp.height);
          let minX=temp.width, minY=temp.height, maxX=0, maxY=0, found=false;
          for (let yy=0; yy<temp.height; yy++) {
            for (let xx=0; xx<temp.width; xx++) {
              const idx=(yy*temp.width+xx)*4;
              const r=imgData.data[idx], g=imgData.data[idx+1], b=imgData.data[idx+2];
              if (r<240||g<240||b<240) { found=true; if (xx<minX) minX=xx; if (xx>maxX) maxX=xx; if (yy<minY) minY=yy; if (yy>maxY) maxY=yy; }
            }
          }
          qrCanvas = document.createElement('canvas');
          qrCanvas.width = qrCanvas.height = qrSize;
          const qctx = qrCanvas.getContext('2d');
          qctx.imageSmoothingEnabled = false;
          qctx.fillStyle = '#fff';
          qctx.fillRect(0,0,qrSize,qrSize);
          if (found) {
            const qrBox = Math.max(maxX-minX+1, maxY-minY+1);
            const quiet = Math.floor(qrSize*0.08);
            const renderSize = qrSize - quiet*2;
            qctx.drawImage(temp, minX, minY, qrBox, qrBox, quiet, quiet, renderSize, renderSize);
          } else {
            qctx.drawImage(temp, 0,0,qrSize,qrSize);
          }
        }
      } catch {}
      if (qrCanvas) {
        ctx.drawImage(qrCanvas, qrX+qrPad, qrY+qrPad, qrSize, qrSize);
        ctx.fillStyle = textColor;
        ctx.font = `${Math.floor(minDim*0.022)}px system-ui, sans-serif`;
        ctx.fillText('Play Space Trader', qrX+qrPad, qrY+qrPad+qrSize+Math.floor(minDim*0.01));
      } else {
        drawBody(qrX+qrPad, qrY+qrPad, ['Scan to play:', window.location.href], Math.floor(minDim*0.028));
      }

  // Bottom panel: Trader and crates (deterministic from seed, independent of UI power)
      function generateSeededTraderMatchingComms(x, y, planetIdx) {
        // Use TradingSystem's own seed and RNG to match Trader Comms identity and type order
        const seed = tradingSystem.hashLocation(x|0, y|0, planetIdx|0);
        const rng = tradingSystem.seededRandom(seed);
        const titles = tradingSystem.traderTitles;
        const names = tradingSystem.traderNames;
        const adjs = tradingSystem.shipAdjectives;
        const nouns = tradingSystem.shipNouns;
        const availableTypes = Object.keys(tradingSystem.cargoTypes);
        // Identity (same order as generateNewTrader)
        const title = titles[Math.floor(rng() * titles.length)] || 'Trader';
        const name = names[Math.floor(rng() * names.length)] || 'Anon';
        const adjective = adjs[Math.floor(rng() * adjs.length)] || 'Rusty';
        const noun = nouns[Math.floor(rng() * nouns.length)] || 'Bucket';
        const shipSeed = hash32('SHIP', seed, 0x9e3779b9, 0x7f4a7c15);
        const shipClass = deriveTraderShipClass(shipSeed);
        // Shuffle types using the same rng
        const shuffled = [...availableTypes];
        for (let si = shuffled.length - 1; si > 0; si--) {
          const j = Math.floor(rng() * (si + 1));
          [shuffled[si], shuffled[j]] = [shuffled[j], shuffled[si]];
        }
        // Trader Comms picks 2-4 sell items first, then demands from the remainder
        const sellCount = 2 + Math.floor(rng() * 3); // 2..4
        const demandStartIndex = sellCount;
        const demandCount = 6;
        const wants = [];
        for (let k = 0; k < demandCount && (demandStartIndex + k) < shuffled.length; k++) {
          const type = shuffled[demandStartIndex + k];
          // Quantity not shown in infographic; keep deterministic placeholder
          wants.push({ type, quantity: 1 });
        }
        return { name: `${title} ${name}`, ship: `${adjective} ${noun}`, shipClass, shipSeed, demand: wants };
      }
      
  // Auto-size bottom panel to crates only (no text list, no labels)
  ctx.font = headingFont;
  const traderHeading = `Trader: ${seededTrader.name} — ${seededTrader.ship}`;
  const headingW = ctx.measureText(traderHeading).width;
  const baseCrate = Math.floor(minDim * 0.06);
  const crateSize = Math.floor(baseCrate * 1.5);
  const perRow = Math.min(6, seededTrader.demand.length);
  const gap = Math.floor(crateSize*0.3);
  const cratesW = crateSize * perRow + gap * Math.max(0, perRow - 1);
  // Label above crates
  const demandsLabel = `Trader's cargo demands:`;
  ctx.font = bodyFont;
  const labelW = ctx.measureText(demandsLabel).width;
  const bottomContentW = Math.max(headingW, labelW, cratesW);
  const bottomPanelW = Math.min(bottomContentW + pad*2, targetW - pad*2);
  // Dynamic height: heading + small gap + label + gap + crates + padding
  const gapSmall = Math.floor(minDim*0.01);
  const gapToCrates = Math.floor(minDim*0.02);
  const bottomH = pad*2 + headingH + gapSmall + bodyLineH + gapToCrates + crateSize;
      const bottomY = targetH - bottomH - pad;
    drawPanel(pad, bottomY, bottomPanelW, bottomH);
    const tX = pad*2, tY = bottomY + pad;
  drawHeading(tX, tY, traderHeading);
  // Draw label under the trader heading
  ctx.fillStyle = textColor;
  ctx.font = bodyFont;
  const labelY = tY + headingH + gapSmall;
  ctx.fillText(demandsLabel, tX, labelY);

      // Crates
    // Crates row (bigger size, no labels)
  // Left-align crates to start at the same x as the heading (tX)
  const bottomPanelWidth = bottomPanelW;
  let cx = tX;
    const rowY = labelY + bodyLineH + gapToCrates;
      // Ensure Orbitron font is loaded at the target size to avoid first-crate metrics mismatch
      const codeFont = `900 ${Math.floor(crateSize*0.7)}px Orbitron, monospace`;
      let codeBaselineOffset = 0; // (ascent - descent)/2 when available
      if (document.fonts && document.fonts.load) {
        try {
          await document.fonts.load(codeFont, 'AA');
          if (document.fonts.ready) await document.fonts.ready;
        } catch (e) { /* ignore */ }
      }
      // Precompute baseline offset using a representative uppercase sample
      try {
        ctx.save();
        ctx.font = codeFont;
        const m = ctx.measureText('AA');
        const asc = m.actualBoundingBoxAscent || 0;
        const desc = m.actualBoundingBoxDescent || 0;
        if (asc || desc) codeBaselineOffset = (asc - desc) / 2;
        ctx.restore();
      } catch (e) { /* ignore */ }
      // Precise visual vertical-centering per code using offscreen measurement
      const codeYOffsetCache = new Map();
      function getVisualYOffsetForText(text, fontPx) {
        const key = `${text}|${fontPx}`;
        if (codeYOffsetCache.has(key)) return codeYOffsetCache.get(key);
        const W = Math.max(8, Math.ceil(fontPx * 2));
        const H = Math.max(8, Math.ceil(fontPx * 2));
        const tmp = document.createElement('canvas');
        tmp.width = W; tmp.height = H;
        const tctx = tmp.getContext('2d');
        tctx.clearRect(0,0,W,H);
        tctx.font = codeFont;
        tctx.textAlign = 'center';
        tctx.textBaseline = 'middle';
        tctx.fillStyle = '#fff';
        tctx.fillText(text, W/2, H/2);
        const data = tctx.getImageData(0,0,W,H).data;
        let minY = H, maxY = -1;
        for (let y=0; y<H; y++) {
          for (let x=0; x<W; x++) {
            const a = data[(y*W + x)*4 + 3];
            if (a > 8) { // ignore near-transparent AA
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
              break;
            }
          }
        }
        let offset = 0;
        if (maxY >= minY && maxY >= 0 && minY < H) {
          const mid = (minY + maxY) / 2;
          offset = (H/2 - mid);
        }
        codeYOffsetCache.set(key, offset);
        return offset;
      }
  function drawCrate(x0, y0, size, typeName, index) {
        const typeInfo = tradingSystem.cargoTypes[typeName] || { color: '#888', code: '??' };
        // Full-crate color tint with shaded gradient based on cargo color
        const [cr,cg,cb] = hexToRgb(typeInfo.color || '#888');
        const shade = (v,f)=>Math.max(0, Math.min(255, v*f));
        const top = `rgb(${shade(cr,1.10)|0},${shade(cg,1.10)|0},${shade(cb,1.10)|0})`;
        const mid = `rgb(${cr|0},${cg|0},${cb|0})`;
        const bot = `rgb(${shade(cr,0.85)|0},${shade(cg,0.85)|0},${shade(cb,0.85)|0})`;
        const grd = ctx.createLinearGradient(x0, y0, x0, y0+size);
        grd.addColorStop(0, top);
        grd.addColorStop(0.5, mid);
        grd.addColorStop(1, bot);
        ctx.fillStyle = grd;
        ctx.fillRect(x0, y0, size, size);
        // Outer border
        ctx.strokeStyle = '#2a2a28';
        ctx.lineWidth = Math.max(3, Math.floor(size*0.04));
        ctx.strokeRect(x0 + Math.floor(size*0.075), y0 + Math.floor(size*0.075), size - Math.floor(size*0.15), size - Math.floor(size*0.15));
        // X braces
        ctx.strokeStyle = 'rgba(26,26,26,0.4)';
        ctx.lineWidth = Math.max(3, Math.floor(size*0.05));
        ctx.beginPath();
        ctx.moveTo(x0 + Math.floor(size*0.075), y0 + Math.floor(size*0.075));
        ctx.lineTo(x0 + size - Math.floor(size*0.075), y0 + size - Math.floor(size*0.075));
        ctx.moveTo(x0 + size - Math.floor(size*0.075), y0 + Math.floor(size*0.075));
        ctx.lineTo(x0 + Math.floor(size*0.075), y0 + size - Math.floor(size*0.075));
        ctx.stroke();
        // Code text (match cargo label color/opacity style), centered
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        const codeText = typeInfo.code || '??';
        ctx.font = codeFont;
        ctx.textAlign = 'center';
        // Vertically center using measured visual offset for this code
        ctx.textBaseline = 'middle';
        const fontPx = Math.floor(size * 0.7);
        const yOff = getVisualYOffsetForText(codeText, fontPx);
        ctx.fillText(codeText, x0 + size/2, y0 + size/2 + yOff);
      }
      for (let idx=0; idx<Math.min(perRow, seededTrader.demand.length); idx++) {
        const x0 = cx + idx*(crateSize+gap);
        drawCrate(x0, rowY, crateSize, seededTrader.demand[idx].type, idx);
      }

      // Save
      const out = cnv.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = out;
      const systemSlug = systemName.replace(/[^a-z0-9]+/gi, '_');
      const planetSlug = planetName.replace(/[^a-z0-9]+/gi, '_');
      const profileSlug = profile.key.replace(/[^a-z0-9]+/gi, '_');
      const utcTs = Math.floor(Date.now() / 1000);
      a.download = `space_trader-${x}-${y}-${systemSlug}-${planetSlug}-${profileSlug}-infographic-${utcTs}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    // Hook up Scanner UI events after DOM content is set
    document.addEventListener('DOMContentLoaded', () => {
  const powerToggle = document.getElementById('scanner-power-toggle');
  const scanBtn = document.getElementById('scanner-scan-btn');
  const captureBtn = document.getElementById('scanner-capture-btn');
  const infoBtn = document.getElementById('scanner-infographic-btn');
      if (powerToggle) {
        powerToggle.addEventListener('change', () => {
          scannerSystem.setPowered(powerToggle.checked);
          if (scannerSystem.powered) {
            // If power conditions fail, revert toggle and notify terminal
            if (!scannerSystem.canPowerOn()) {
              scannerSystem.setPowered(false);
              powerToggle.checked = false;
              const term = document.getElementById('scanner-terminal');
              if (term) term.textContent = '';
            }
          }
          updateScannerUI();
        });
      }
      if (scanBtn) {
        scanBtn.addEventListener('click', () => {
          if (!scannerSystem.powered || !powerSystem.isPowerAvailable()) return;
          // Draw extra power like teleportation but shorter
          const burstName = 'Scanner Scan';
          const ok = powerSystem.startBurst(burstName, 10, 1.5); // 10Wh over 1.5s
          if (!ok) return;
          scanBtn.disabled = true;
          const onComplete = ({ name }) => {
            if (name !== burstName) return;
            scanCurrentPlanet();
            scanBtn.disabled = false;
            eventBus.off('power:burst-complete', onComplete);
          };
          eventBus.on('power:burst-complete', onComplete);
        });
      }
      if (captureBtn) {
        captureBtn.addEventListener('click', async () => {
          if (!scannerSystem.powered || !powerSystem.isPowerAvailable()) return;
          const burstName = 'Scanner Capture';
          const ok = powerSystem.startBurst(burstName, 30, 2.0); // 30Wh over 2s
          if (!ok) return;
          captureBtn.disabled = true;
          const onComplete = async ({ name }) => {
            if (name !== burstName) return;
            await capturePlanetPhoto();
            captureBtn.disabled = false;
            eventBus.off('power:burst-complete', onComplete);
          };
          eventBus.on('power:burst-complete', onComplete);
        });
      }
      if (infoBtn) {
        infoBtn.addEventListener('click', async () => {
          if (!scannerSystem.powered || !powerSystem.isPowerAvailable()) return;
          const burstName = 'Scanner Infographic';
          const ok = powerSystem.startBurst(burstName, 40, 2.5); // 40Wh over 2.5s
          if (!ok) return;
          infoBtn.disabled = true;
          const onComplete = async ({ name }) => {
            if (name !== burstName) return;
            await printInfographic();
            infoBtn.disabled = false;
            eventBus.off('power:burst-complete', onComplete);
          };
          eventBus.on('power:burst-complete', onComplete);
        });
      }
      // Initial draw
      updateScannerUI();
    });

    // Keep scanner viewport in sync with navigation
    eventBus.on('navigation:view-changed', renderScannerViewport);
    eventBus.on('navigation:cursor-moved', renderScannerViewport);
    eventBus.on('navigation:travel-complete', renderScannerViewport);
    eventBus.on('navigation:travel-progress', renderScannerViewport);
  eventBus.on('solar:state-changed', () => updateScannerUI());
  eventBus.on('battery:charge-changed', () => updateScannerUI());

    // Create fuel system
    const fuelSystem = new FuelSystem();

    // ============================================================================
    // TRADING SYSTEM - Manages cargo, traders, and economy
    // ============================================================================
    class TradingSystem {
      constructor() {
        this.cargoCapacity = 20; // 20 slots matching UI
        this.cargo = new Array(this.cargoCapacity).fill(null); // Cargo slots (null = empty)
        this.nextCargoId = 1; // For unique IDs
        
        // Current trader session
        this.currentTrader = null;
        this.currentPage = 0;
        this.isBuying = true; // true = we're buying from trader, false = we're selling to trader
        this.lastHaggleResult = null; // Track last haggle for display
        
        // Offer prices for selling mode - maps cargoId -> current offer price
        this.offerPrices = {}; // When selling, track trader's offer for each cargo item
        
        // Cargo types and their base price ranges (based on fuel @ 1₵/L)
        this.cargoTypes = {
          'Food': { min: 150, max: 300, color: '#8fbc8f', code: 'FD' },
          'Medical Supplies': { min: 200, max: 400, color: '#ff6b6b', code: 'MD' },
          'Electronics': { min: 300, max: 500, color: '#4dabf7', code: 'EL' },
          'Rare Metals': { min: 400, max: 700, color: '#ffd43b', code: 'RM' },
          'Fuel Cells': { min: 250, max: 450, color: '#ff922b', code: 'FC' },
          'Textiles': { min: 100, max: 200, color: '#cc5de8', code: 'TX' },
          'Machinery': { min: 350, max: 600, color: '#868e96', code: 'MC' },
          'Gems': { min: 500, max: 1000, color: '#f783ac', code: 'GM' },
          'Spices': { min: 180, max: 350, color: '#d9480f', code: 'SP' },
          'Art Objects': { min: 600, max: 1200, color: '#845ef7', code: 'AO' },
          'Weapons': { min: 400, max: 800, color: '#343a40', code: 'WP' },
          'Tools': { min: 150, max: 300, color: '#74c0fc', code: 'TL' },
          'Computers': { min: 450, max: 750, color: '#4c6ef5', code: 'CP' },
          'Biomatter': { min: 200, max: 400, color: '#51cf66', code: 'BM' },
          'Alien Artifacts': { min: 800, max: 1500, color: '#be4bdb', code: 'AA' }
        };
        
        // Trader name components
        this.traderTitles = ['Captain', 'Commander', 'Admiral', 'Merchant', 'Trader', 'Baron', 'Duchess'];
        this.traderNames = ['Fingers', 'Rex', 'Nova', 'Blaze', 'Storm', 'Hawk', 'Viper', 'Phoenix', 
                            'Drake', 'Wolf', 'Fox', 'Raven', 'Steel', 'Iron', 'Gold', 'Silver'];
        this.shipAdjectives = ['Stellar', 'Cosmic', 'Void', 'Star', 'Galactic', 'Nebula', 'Solar',
                               'Quantum', 'Astral', 'Celestial', 'Orbital', 'Lunar', 'Deep'];
        this.shipNouns = ['Wanderer', 'Seeker', 'Voyager', 'Explorer', 'Drifter', 'Nomad', 'Pioneer',
                          'Runner', 'Hauler', 'Trader', 'Merchant', 'Cruiser', 'Clipper', 'Banana'];
      }

      /**
       * Simple hash function to generate seed from location coordinates
       * Uses a modified FNV-1a hash algorithm for better distribution
       */
      hashLocation(x, y, planetIndex) {
        // FNV-1a hash with 32-bit
        let hash = 2166136261; // FNV offset basis
        
        // Hash x coordinate
        hash ^= x & 0xff;
        hash = Math.imul(hash, 16777619); // FNV prime
        hash ^= (x >> 8) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (x >> 16) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (x >> 24) & 0xff;
        hash = Math.imul(hash, 16777619);
        
        // Hash y coordinate
        hash ^= y & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (y >> 8) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (y >> 16) & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (y >> 24) & 0xff;
        hash = Math.imul(hash, 16777619);
        
        // Hash planet index
        hash ^= planetIndex & 0xff;
        hash = Math.imul(hash, 16777619);
        hash ^= (planetIndex >> 8) & 0xff;
        hash = Math.imul(hash, 16777619);
        
        // Convert to unsigned 32-bit integer
        return hash >>> 0;
      }

      /**
       * Seeded random number generator (mulberry32)
       * Returns a function that generates random numbers 0-1 based on seed
       */
      seededRandom(seed) {
        return function() {
          seed = (seed + 0x6D2B79F5) | 0;
          let t = Math.imul(seed ^ (seed >>> 15), 1 | seed);
          t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      /**
       * Generate a new trader with seeded random inventory based on location
       * Each planet gets consistent trader name and demands
       */
      generateNewTrader() {
        // Get current location from navigation system
        const x = navigationSystem.currentX;
        const y = navigationSystem.currentY;
        const planetIndex = navigationSystem.currentPlanetIndex;
        
        // Create seed from hashed location (one unique trader per planet)
        const seed = this.hashLocation(x, y, planetIndex);
        const rng = this.seededRandom(seed);
        
        // Generate trader identity (seeded)
        const title = this.traderTitles[Math.floor(rng() * this.traderTitles.length)];
        const name = this.traderNames[Math.floor(rng() * this.traderNames.length)];
        const adjective = this.shipAdjectives[Math.floor(rng() * this.shipAdjectives.length)];
        const noun = this.shipNouns[Math.floor(rng() * this.shipNouns.length)];
    const shipSeed = hash32('SHIP', seed, 0x9e3779b9, 0x7f4a7c15);
    const shipClass = deriveTraderShipClass(shipSeed);
        
        const availableTypes = Object.keys(this.cargoTypes);
        
        // Shuffle cargo types using seeded random
        const shuffled = [...availableTypes];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        
        // Generate items they're SELLING (2-4 items with quantity 1-5) - seeded
        const sellInventory = [];
        const sellCount = 2 + Math.floor(rng() * 3); // 2-4 items
        
        for (let i = 0; i < sellCount; i++) {
          const type = shuffled[i];
          const priceRange = this.cargoTypes[type];
          const quantity = 1 + Math.floor(rng() * 5); // 1-5 units
          const basePrice = priceRange.min + rng() * (priceRange.max - priceRange.min);
          
          sellInventory.push({
            type,
            quantity,
            basePrice: Math.round(basePrice),
            currentPrice: Math.round(basePrice) // Will be modified by haggling
          });
        }
        
        // Generate items they're BUYING (demand) - 6 different types with quantities
        const demandList = [];
        const demandCount = 6; // Always 6 demands
        const demandStartIndex = sellCount; // Don't overlap with sell items
        
        for (let i = 0; i < demandCount && (demandStartIndex + i) < shuffled.length; i++) {
          const type = shuffled[demandStartIndex + i];
          const quantity = 1 + Math.floor(Math.random() * 10); // Random 1-10 (not seeded)
          demandList.push({ type, quantity });
        }
        
        this.currentTrader = {
          name: `${title} ${name}`,
          ship: `${adjective} ${noun}`,
          shipSeed,
          shipClass,
          personality: ['Friendly', 'Suspicious', 'Greedy', 'Honest', 'Eccentric'][Math.floor(rng() * 5)],
          haggleSkill: 1 + Math.floor(rng() * 10), // 1-10
          inventory: sellInventory, // Items they're selling
          demand: demandList, // Item types they want to buy with quantities
          reputation: 50 + Math.floor(rng() * 50) // 50-100 for neutral-good
        };
        
        this.currentPage = 0;
        this.lastHaggleResult = null;
        
        // Generate offer prices for all cargo items that match trader's demand
        this.offerPrices = {};
        this.cargo.forEach(item => {
          if (item && demandList.some(d => d.type === item.type)) {
            const priceRange = this.cargoTypes[item.type];
            const offerPrice = Math.round(priceRange.min + Math.random() * (priceRange.max - priceRange.min));
            this.offerPrices[item.id] = offerPrice;
          }
        });
      }

      /**
       * Haggle with current trader
       * Returns { success: boolean, priceChange: number, message: string }
       */
      haggle() {
        if (!this.currentTrader) {
          return { success: false, priceChange: 0, message: 'No active trader!' };
        }
        
        const currentItem = this.getCurrentItem();
        if (!currentItem) {
          return { success: false, priceChange: 0, message: 'No item to haggle!' };
        }
        
        // Initialize haggle tracking for this item if needed
        if (!currentItem.haggleAttempts) {
          currentItem.haggleAttempts = 0;
          currentItem.totalHaggleChange = 0;
        }
        
        // Maximum 3 haggle attempts per item
        if (currentItem.haggleAttempts >= 3) {
          return { 
            success: false, 
            priceChange: 0, 
            message: 'Trader won\'t negotiate further!' 
          };
        }
        
        // Haggle success chance decreases with each attempt
        // Base: 60% -> 45% -> 30%
        const baseChance = 60 - (currentItem.haggleAttempts * 15);
        const traderModifier = this.currentTrader.haggleSkill * 3; // 3-30 penalty
        const successChance = Math.max(10, baseChance - traderModifier);
        
        const playerRoll = Math.random() * 100;
        const success = playerRoll < successChance;
        
        currentItem.haggleAttempts++;
        
        if (this.isBuying) {
          // Buying from trader - try to reduce their price
          const basePrice = currentItem.basePrice;
          const currentPrice = currentItem.currentPrice;
          
          if (success) {
            // Success: reduce price by 5-15%
            const changePercent = 0.05 + Math.random() * 0.10;
            const priceChange = Math.round(currentPrice * changePercent);
            currentItem.currentPrice = Math.max(Math.round(basePrice * 0.5), currentPrice - priceChange);
            currentItem.totalHaggleChange -= priceChange;
            this.lastHaggleResult = { success: true, priceChange };
            
            return { 
              success: true, 
              priceChange, 
              message: `Success! Price reduced by ${priceChange}₵` 
            };
          } else {
            // Failure: price increases slightly (2-5%)
            const changePercent = 0.02 + Math.random() * 0.03;
            const priceChange = Math.round(currentPrice * changePercent);
            currentItem.currentPrice = currentPrice + priceChange;
            currentItem.totalHaggleChange += priceChange;
            this.lastHaggleResult = { success: false, priceChange };
            
            return { 
              success: false, 
              priceChange, 
              message: `Failed! Price increased by ${priceChange}₵` 
            };
          }
        } else {
          // Selling to trader - try to increase their offer
          const currentOfferPrice = this.offerPrices[currentItem.id] || 0;
          
          if (success) {
            // Success: increase offer by 5-15%
            const changePercent = 0.05 + Math.random() * 0.10;
            const priceChange = Math.round(currentOfferPrice * changePercent);
            this.offerPrices[currentItem.id] = currentOfferPrice + priceChange;
            currentItem.totalHaggleChange += priceChange;
            this.lastHaggleResult = { success: true, priceChange };
            
            return { 
              success: true, 
              priceChange, 
              message: `Success! Offer increased by ${priceChange}₵` 
            };
          } else {
            // Failure: offer decreases slightly (2-5%)
            const changePercent = 0.02 + Math.random() * 0.03;
            const priceChange = Math.round(currentOfferPrice * changePercent);
            this.offerPrices[currentItem.id] = Math.max(1, currentOfferPrice - priceChange);
            currentItem.totalHaggleChange -= priceChange;
            this.lastHaggleResult = { success: false, priceChange };
            
            return { 
              success: false, 
              priceChange, 
              message: `Failed! Offer reduced by ${priceChange}₵` 
            };
          }
        }
      }

      /**
       * Execute a trade (buy or sell)
       */
      executeTrade() {
        if (!this.currentTrader) {
          return { success: false, message: 'No active trader!' };
        }
        
        if (this.isBuying) {
          // We're buying from trader
          if (!this.currentTrader.inventory || this.currentTrader.inventory.length === 0) {
            return { success: false, message: 'Trader has no inventory!' };
          }
          
          if (this.currentPage >= this.currentTrader.inventory.length) {
            this.currentPage = 0;
          }
          
          const currentItem = this.currentTrader.inventory[this.currentPage];
          if (!currentItem) {
            return { success: false, message: 'No items available!' };
          }
          
          const cost = currentItem.currentPrice;
          
          if (fuelSystem.credits < cost) {
            return { success: false, message: `Insufficient credits! Need ${cost}₵, have ${fuelSystem.credits}₵` };
          }
          
          // Find empty cargo slot
          const emptySlotIndex = this.cargo.findIndex(slot => slot === null);
          if (emptySlotIndex === -1) {
            return { success: false, message: 'Cargo hold full!' };
          }
          
          // Execute purchase
          fuelSystem.credits -= cost;
          currentItem.quantity -= 1;
          
          // Add to cargo
          const cargoItem = {
            id: this.nextCargoId++,
            type: currentItem.type,
            purchasePrice: cost,
            slotIndex: emptySlotIndex
          };
          this.cargo[emptySlotIndex] = cargoItem;
          
          // Remove item from trader inventory if quantity reaches 0
          if (currentItem.quantity <= 0) {
            this.currentTrader.inventory.splice(this.currentPage, 1);
            // Adjust current page if needed
            if (this.currentPage >= this.currentTrader.inventory.length && this.currentPage > 0) {
              this.currentPage--;
            }
          }
          
          
          return { success: true, message: `Purchased ${cargoItem.type} for ${cost}₵` };
          
        } else {
          // We're selling to trader
          if (this.getCargoCount() === 0) {
            return { success: false, message: 'No cargo to sell!' };
          }
          
          // Get current cargo item
          const ourCargoItems = this.cargo.filter(item => item !== null);
          
          if (this.currentPage >= ourCargoItems.length) {
            return { success: false, message: 'Invalid selection!' };
          }
          
          const cargoToSell = ourCargoItems[this.currentPage];
          
          // Check if trader wants this item
          if (this.currentTrader?.demand && this.currentTrader.demand.length > 0) {
            if (!this.currentTrader.demand.some(d => d.type === cargoToSell.type)) {
              return { success: false, message: `Trader doesn't want ${cargoToSell.type}!` };
            }
          }
          
          const salePrice = this.getSellingPrice(cargoToSell);
          const profit = salePrice - cargoToSell.purchasePrice;
          
          // Execute sale
          fuelSystem.credits += salePrice;
          this.cargo[cargoToSell.slotIndex] = null;
          
          // Adjust current page if needed after sale
          const remainingCargoCount = this.getCargoCount();
          if (remainingCargoCount === 0) {
            this.currentPage = 0;
          } else if (this.currentPage >= remainingCargoCount) {
            this.currentPage = remainingCargoCount - 1;
          }
          
          return { 
            success: true, 
            message: `Sold ${cargoToSell.type} for ${salePrice}₵ (${profit > 0 ? '+' : ''}${profit}₵)` 
          };
        }
      }

      /**
       * Calculate selling price for a cargo item
       * Uses the current offer price from offerPrices map
       */
      getSellingPrice(cargoItem) {
        // Return the trader's current offer price for this cargo item
        return this.offerPrices[cargoItem.id] || 0;
      }

      /**
       * Get current item (buying from trader) or cargo (selling to trader)
       */
      getCurrentItem() {
        if (this.isBuying) {
          // Buying from trader - show their inventory
          return this.currentTrader?.inventory[this.currentPage] || null;
        } else {
          // Selling to trader - show ALL our cargo (one per page)
          const ourCargo = this.cargo.filter(item => item !== null);
          return ourCargo[this.currentPage] || null;
        }
      }

      /**
       * Navigate to next page
       */
      nextPage() {
        if (this.isBuying) {
          const maxIndex = Math.max(0, (this.currentTrader?.inventory.length || 0) - 1);
          this.currentPage = Math.min(this.currentPage + 1, maxIndex);
        } else {
          const maxIndex = Math.max(0, this.getCargoCount() - 1);
          this.currentPage = Math.min(this.currentPage + 1, maxIndex);
        }
        this.lastHaggleResult = null; // Reset haggle on page change
      }

      /**
       * Navigate to previous page
       */
      prevPage() {
        this.currentPage = Math.max(0, this.currentPage - 1);
        this.lastHaggleResult = null; // Reset haggle on page change
      }

      /**
       * Get maximum page count (for display purposes)
       */
      getMaxPage() {
        if (this.isBuying) {
          return this.currentTrader?.inventory.length || 0;
        } else {
          return this.getCargoCount();
        }
      }

      /**
       * Set trading mode (buying/selling)
       */
      setMode(isBuying) {
        if (this.isBuying !== isBuying) {
          this.isBuying = isBuying;
          this.currentPage = 0;
          this.lastHaggleResult = null;
          // Generate new trader when switching modes
          this.generateNewTrader();
        }
      }

      /**
       * Get count of cargo items
       */
      getCargoCount() {
        return this.cargo.filter(item => item !== null).length;
      }

      /**
       * Get cargo items as array
       */
      getCargoItems() {
        return this.cargo.filter(item => item !== null);
      }

      /**
       * Generate starting cargo for new game (5 random items)
       */
      generateStartingCargo() {
        // Clear existing cargo
        this.cargo = new Array(this.cargoCapacity).fill(null);
        this.nextCargoId = 1;
        
        // Generate 5 random cargo items
        const availableTypes = Object.keys(this.cargoTypes);
        
        for (let i = 0; i < 5; i++) {
          // Pick random cargo type
          const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
          const priceRange = this.cargoTypes[type];
          
          // Purchase price is somewhere in the range (simulating we bought it previously)
          const purchasePrice = Math.round(priceRange.min + Math.random() * (priceRange.max - priceRange.min));
          
          // Add to cargo in slot i
          this.cargo[i] = {
            id: this.nextCargoId++,
            type,
            purchasePrice,
            slotIndex: i
          };
        }
        
        
      }

      /**
       * Swap cargo items between two slots
       * @param {number} fromIndex - Source slot index
       * @param {number} toIndex - Destination slot index
       */
      swapCargo(fromIndex, toIndex) {
        // Validate indices
        if (fromIndex < 0 || fromIndex >= this.cargoCapacity || 
            toIndex < 0 || toIndex >= this.cargoCapacity) {
          return false;
        }
        
        // Swap the items
        const temp = this.cargo[fromIndex];
        this.cargo[fromIndex] = this.cargo[toIndex];
        this.cargo[toIndex] = temp;
        
        // Update slot indices if items exist
        if (this.cargo[fromIndex]) {
          this.cargo[fromIndex].slotIndex = fromIndex;
        }
        if (this.cargo[toIndex]) {
          this.cargo[toIndex].slotIndex = toIndex;
        }
        
        
        return true;
      }

      /**
       * Get status for display
       */
      getStatus() {
        const currentItem = this.getCurrentItem();
        const maxPage = this.getMaxPage();
        
        return {
          trader: this.currentTrader,
          isBuying: this.isBuying,
          currentPage: this.currentPage,
          maxPage,
          currentItem,
          cargoCount: this.getCargoCount(),
          cargoCapacity: this.cargoCapacity,
          lastHaggleResult: this.lastHaggleResult
        };
      }
    }

    // Create trading system
    const tradingSystem = new TradingSystem();

    // ============================================================================
    // BATTERY SYSTEM - Manages all batteries
    // ============================================================================
    class BatterySystem {
      constructor() {
        this.batteries = [];
        this.totalPowerDraw = 0;
        this.totalPowerCharge = 0;
        this.setupEventListeners();
      }

      /**
       * Add a battery to the system
       */
      addBattery(config) {
        const id = String.fromCharCode(65 + this.batteries.length); // A, B, C, etc.
        const battery = new Battery(id, config);
        this.batteries.push(battery);
        eventBus.emit('battery:added', { battery });
        return battery;
      }

      /**
       * Get battery by ID
       */
      getBattery(id) {
        return this.batteries.find(b => b.id === id);
      }

      /**
       * Get all connected batteries
       */
      getConnectedBatteries() {
        return this.batteries.filter(b => b.connectedToBus && b.enabled);
      }

      /**
       * Get total available power from all connected batteries
       */
      getTotalAvailablePower() {
        return this.getConnectedBatteries().reduce((sum, b) => {
          return sum + b.currentCharge;
        }, 0);
      }

      /**
       * Get total capacity
       */
      getTotalCapacity() {
        return this.batteries.reduce((sum, b) => {
          return sum + b.getEffectiveCapacity();
        }, 0);
      }

      /**
       * Get average charge percentage across all batteries
       */
      getAverageCharge() {
        if (this.batteries.length === 0) return 0;
        const total = this.batteries.reduce((sum, b) => sum + b.getChargePercentage(), 0);
        return total / this.batteries.length;
      }

      /**
       * Draw power from the battery system
       * Distributes load across connected batteries proportionally
       */
      drawPower(watts, deltaTime) {
        const connectedBatteries = this.getConnectedBatteries();
        
        if (connectedBatteries.length === 0) {
          eventBus.emit('power:no-batteries', { requested: watts });
          return 0;
        }

        // Calculate total available charge
        const totalCharge = connectedBatteries.reduce((sum, b) => sum + b.currentCharge, 0);
        
        if (totalCharge <= 0) {
          eventBus.emit('power:depleted', { requested: watts });
          return 0;
        }

        let totalDrawn = 0;

        // Distribute load proportionally based on current charge
        connectedBatteries.forEach(battery => {
          const proportion = battery.currentCharge / totalCharge;
          const requestedFromBattery = watts * proportion;
          const actualDrawn = battery.draw(requestedFromBattery, deltaTime);
          totalDrawn += actualDrawn;
        });

        this.totalPowerDraw = totalDrawn;

        // Check if we couldn't meet demand
        if (totalDrawn < watts * 0.9) { // Allow 10% tolerance
          eventBus.emit('power:insufficient', { 
            requested: watts, 
            actual: totalDrawn,
            deficit: watts - totalDrawn
          });
        }

        return totalDrawn;
      }

      /**
       * Charge batteries from available power
       * Distributes charging across connected batteries
       */
      chargeBatteries(watts, deltaTime) {
        const connectedBatteries = this.getConnectedBatteries();
        
        // Debug: Log which batteries are connected
        if (Math.random() < 0.01) { // Log 1% of the time
          
        }
        
        if (connectedBatteries.length === 0) {
          return 0;
        }

        // Find batteries that can accept charge
        const chargingBatteries = connectedBatteries.filter(b => {
          return b.currentCharge < b.getEffectiveCapacity();
        });

        if (chargingBatteries.length === 0) {
          return 0; // All batteries full
        }

        let totalAccepted = 0;

        // Distribute charge evenly
        const wattsPerBattery = watts / chargingBatteries.length;
        
        chargingBatteries.forEach(battery => {
          const actualAccepted = battery.charge(wattsPerBattery, deltaTime);
          totalAccepted += actualAccepted;
        });

        this.totalPowerCharge = totalAccepted;

        return totalAccepted;
      }

      /**
       * Update all batteries
       */
      update(deltaTime) {
        this.batteries.forEach(battery => {
          if (battery.enabled) {
            battery.update(deltaTime);
          }
        });

        // Check for system-wide power failure
        const availablePower = this.getTotalAvailablePower();
        if (availablePower <= 0 && this.getConnectedBatteries().length > 0) {
          eventBus.emit('power:system-failure', { system: 'batteries' });
        }
      }

      /**
       * Setup event listeners for system-level responses
       */
      setupEventListeners() {
        // Example: Log critical battery events
        eventBus.on('battery:critical', (data) => {
          console.warn(`🔋 Battery ${data.battery.id} is critically low!`);
        });

        eventBus.on('battery:depleted', (data) => {
          console.error(`🔋 Battery ${data.battery.id} is depleted!`);
        });

        eventBus.on('power:system-failure', (data) => {
          console.error(`⚠️ POWER SYSTEM FAILURE: ${data.system}`);
        });
      }

      /**
       * Get system status
       */
      getStatus() {
        return {
          batteries: this.batteries.map(b => b.getStatus()),
          totalCapacity: this.getTotalCapacity(),
          totalAvailable: this.getTotalAvailablePower(),
          averageCharge: this.getAverageCharge(),
          connectedCount: this.getConnectedBatteries().length,
          totalCount: this.batteries.length,
          currentDraw: this.totalPowerDraw,
          currentCharge: this.totalPowerCharge
        };
      }
    }

    // ============================================================================
    // GAME INITIALIZATION
    // ============================================================================
    
    // Create battery system
    const batterySystem = new BatterySystem();

    /**
     * Initialize a new game with default values
     */
    function initializeNewGame() {
      

      // Clear existing batteries
      batterySystem.batteries = [];

      // Add two batteries with NEW specifications (2000 Wh, 10-min charge time)
      batterySystem.addBattery({
        maxCapacity: 2000,
        initialCharge: 1400, // 70%
        maxChargeRate: 12600, // Can accept full solar output
        maxDischargeRate: 1000,
        connectedToBus: true
      });

      batterySystem.addBattery({
        maxCapacity: 2000,
        initialCharge: 1160, // 58%
        maxChargeRate: 12600, // Can accept full solar output
        maxDischargeRate: 1000,
        connectedToBus: true
      });

      // Reset solar panels (NEW specifications)
      solarSystem.panelState = 1; // Stopped
      solarSystem.extension = 0.5; // 50% extended
      solarSystem.sunlightIntensity = 1.0; // 100% sunlight (full sun strength for testing)
      solarSystem.connectedToBus = true; // Connected to main bus

      // Reset power systems
      powerSystem.activeSystems = new Set(['navigation', 'sensors', 'communications']);

      // Reset navigation system to starting position
      navigationSystem.currentX = 0;
      navigationSystem.currentY = 0;
      navigationSystem.currentPlanetIndex = 0;
      navigationSystem.viewMode = 'system';
      navigationSystem.cursorIndex = 0;
      navigationSystem.traveling = false;
      navigationSystem.travelStartTime = 0;
      navigationSystem.travelTarget = null;
      
      // Update sun strength for starting planet
      const sunStrength = navigationSystem.getSunStrength();
      solarSystem.updateSunlight(sunStrength);

      // Reset fuel system
      fuelSystem.currentFuel = 280; // Start with 280L fuel (28%)
      fuelSystem.credits = 10000; // Starting credits

      // Initialize trading system with starting cargo
      tradingSystem.generateStartingCargo();

      // Update all UI
      updateAllUI();

      // Save the new game state
      saveSystem.save();
      
      eventBus.emit('game:new-game', {});
      
    }

    /**
     * Load game from saved state
     */
    function loadGameFromSave(saveData) {
      

      // Clear existing batteries
      batterySystem.batteries = [];

      // Restore batteries
      if (saveData.batteries) {
        saveData.batteries.forEach(batteryData => {
          const battery = new Battery(batteryData.id, {
            maxCapacity: batteryData.maxCapacity,
            initialCharge: batteryData.currentCharge,
            maxDischargeRate: batteryData.maxDischargeRate,
            maxChargeRate: batteryData.maxChargeRate,
            efficiency: batteryData.efficiency,
            health: batteryData.health,
            connectedToBus: batteryData.connectedToBus,
            temperature: batteryData.temperature,
            cycleCount: batteryData.cycleCount
          });
          battery.enabled = batteryData.enabled;
          batterySystem.batteries.push(battery);
        });
      }

      // Restore solar panels
      if (saveData.solar) {
        solarSystem.panelState = saveData.solar.panelState;
        solarSystem.extension = saveData.solar.extension;
        solarSystem.sunlightIntensity = saveData.solar.sunlightIntensity;
        solarSystem.connectedToBus = saveData.solar.connectedToBus !== undefined ? saveData.solar.connectedToBus : true;
      }

      // Restore fuel system
      if (saveData.fuel) {
        fuelSystem.currentFuel = saveData.fuel.currentFuel;
        fuelSystem.credits = saveData.fuel.credits;
      }

      // Restore navigation
      if (saveData.navigation) {
        navigationSystem.currentX = saveData.navigation.x;
        navigationSystem.currentY = saveData.navigation.y;
        navigationSystem.currentPlanetIndex = saveData.navigation.planetIndex || 0;
        navigationSystem.viewMode = saveData.navigation.viewMode || 'system';
        navigationSystem.cursorIndex = saveData.navigation.cursorIndex || 0;
        
        // Update sun strength based on loaded planet
        const sunStrength = navigationSystem.getSunStrength();
        solarSystem.updateSunlight(sunStrength);
      }

      // Restore power systems
      if (saveData.power) {
        powerSystem.activeSystems = new Set(saveData.power.activeSystems);
        // If scanner was saved as active, ensure its load entry exists
        if (powerSystem.activeSystems.has('scanner')) {
          powerSystem.systemLoads.scanner = scannerSystem.loadWatts;
        } else {
          delete powerSystem.systemLoads.scanner;
        }
      }

      // Restore trading/cargo
      if (saveData.trading) {
        tradingSystem.cargo = new Array(tradingSystem.cargoCapacity).fill(null);
        if (saveData.trading.cargo) {
          saveData.trading.cargo.forEach((item, index) => {
            if (item) {
              tradingSystem.cargo[index] = {
                id: item.id,
                type: item.type,
                purchasePrice: item.purchasePrice,
                slotIndex: item.slotIndex
              };
            }
          });
        }
        if (saveData.trading.nextCargoId) {
          tradingSystem.nextCargoId = saveData.trading.nextCargoId;
        }
      }

      // Update all UI
      updateAllUI();

      // Set last save time
      saveSystem.lastSaveTime = saveData.timestamp;

      eventBus.emit('game:loaded', { timestamp: saveData.timestamp });
      
    }

    /**
     * Update all UI elements from current game state
     */
    function updateAllUI() {
      // Update all batteries
      batterySystem.batteries.forEach(battery => {
        updateBatteryUI(battery);
        updateBatteryToggleUI(battery);
      });

      // Update solar panel UI
      updateSolarPanelUI();
      updatePowerDrawUI();
      
      // Update Fuel UI
      updateFuelUI();
      
      // Update Navigation UI
      updateNavigationUI();
      
      // Update Trader Comms UI
      updateTraderCommsUI();

      // Update other UI elements here
      updateSaveStatusUI();
      // Update Scanner UI
      updateScannerUI();
    }

    function updateFuelUI() {
      const fuelSection = document.querySelectorAll('.panel')[2]; // Fuel panel (index 2)
      const fuelGauge = fuelSection.querySelector('.gauge');
      const fuelTerminal = fuelSection.querySelector('.crt pre');
      
      if (fuelGauge) {
        const fuelPercent = fuelSystem.getFuelPercentage();
        fuelGauge.style.setProperty('--value', fuelPercent.toFixed(1));
      }
      
      if (fuelTerminal) {
        const refuelCost = fuelSystem.getRefuelCost();
        fuelTerminal.textContent = `Current credits: ${fuelSystem.credits}₵\nCost to refuel : ${refuelCost}₵`;
      }
    }

    function updateNavigationUI() {
      const navigationSection = document.querySelectorAll('.panel')[1]; // Navigation panel (index 1)
      const navTerminal = navigationSection.querySelector('.crt pre');
      const navDial = navigationSection.querySelector('.dial input');
      const navPowerToggle = navigationSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const navButtons = navigationSection.querySelectorAll('.btn');
      
      const isNavigationEnabled = powerSystem.activeSystems.has('navigation');
      const isPowerAvailable = powerSystem.isPowerAvailable();
      const isPowered = isNavigationEnabled && isPowerAvailable;
      
      if (navPowerToggle) {
        navPowerToggle.checked = isNavigationEnabled;
        // Disable toggle if no power available
        navPowerToggle.disabled = !isPowerAvailable;
      }

      if (navTerminal) {
        if (!isPowered) {
          // Power off or no power available: clear screen but keep 9 lines
          const lines = [];
          for (let i = 0; i < 9; i++) {
            lines.push('\u00A0'); // Non-breaking space
          }
          navTerminal.textContent = lines.join('\n');
        } else if (navigationSystem.showingBlockedMessage) {
          // Show travel blocked message (always 9 lines)
          const lines = [];
          navigationSystem.blockedMessageLines.forEach(line => {
            lines.push(line);
          });
          // Pad to exactly 9 lines with non-breaking spaces
          while (lines.length < 9) lines.push('\u00A0');
          navTerminal.textContent = lines.slice(0, 9).join('\n');
        } else {
          // Power on: show normal navigation info
          const system = navigationSystem.getCurrentSystem();
          let lines = [];
          
          if (navigationSystem.traveling) {
            // Show travel progress (always 9 lines)
            const currentTime = performance.now() / 1000;
            const elapsed = currentTime - navigationSystem.travelStartTime;
            const progress = Math.min((elapsed / navigationSystem.travelDuration) * 100, 100);
            const target = navigationSystem.travelTarget;
            const remaining = Math.max(0, navigationSystem.travelDuration - elapsed);
            
            if (navigationSystem.travelTarget.type === 'planet') {
              // Traveling to planet in same system
              lines.push(`Moving to: ${target.planetName}`);
              lines.push(`Progress: ${progress.toFixed(0)}%`);
              lines.push('\u00A0');
              lines.push(`${'='.repeat(Math.floor(progress / 5))}${' '.repeat(20 - Math.floor(progress / 5))}`);
              lines.push('\u00A0');
              lines.push(`ETA: ${remaining.toFixed(1)}s`);
              lines.push(`Fuel: ${target.fuelUsed.toFixed(1)}L`);
              lines.push('\u00A0');
              lines.push('\u00A0');
            } else {
              // Traveling to another system
              lines.push(`Traveling to: ${target.name}`);
              lines.push(`Progress: ${progress.toFixed(0)}%`);
              lines.push('\u00A0');
              lines.push(`${'='.repeat(Math.floor(progress / 5))}${' '.repeat(20 - Math.floor(progress / 5))}`);
              lines.push('\u00A0');
              lines.push(`ETA: ${remaining.toFixed(1)}s`);
              lines.push('\u00A0');
              lines.push('\u00A0');
            }
          } else if (navigationSystem.viewMode === 'system') {
            // Show planet list (always 9 lines)
            lines.push(`Solar system: ${system.name}`);
            system.planets.forEach((planet, i) => {
              const cursor = i === navigationSystem.cursorIndex ? '> ' : '  ';
              const current = i === navigationSystem.currentPlanetIndex ? '●' : '';
              lines.push(`${cursor}${planet} ${current}`);
            });
            // Pad to exactly 9 lines with non-breaking spaces
            while (lines.length < 9) lines.push('\u00A0'); // Non-breaking space
          } else {
            // Show neighboring systems - galaxy map (always 9 lines)
            lines.push(`Galaxy Map - ${system.name}`);
            const neighbors = navigationSystem.getGalaxyMap();
            neighbors.forEach((neighbor, i) => {
              if (i < 8) {
                const cursor = i === navigationSystem.cursorIndex ? '> ' : '  ';
                // Omit distance in Galaxy Map view
                lines.push(`${cursor}${neighbor.name}`);
              }
            });
            // Pad to exactly 9 lines with non-breaking spaces
            while (lines.length < 9) lines.push('\u00A0'); // Non-breaking space
          }
          
          // Ensure exactly 9 lines
          navTerminal.textContent = lines.slice(0, 9).join('\n');
        }
      }

      // Disable/enable buttons based on power state
      if (navButtons) {
        navButtons.forEach(button => {
          button.disabled = !isPowered;
          if (!isPowered) {
            button.classList.add('disabled');
          } else {
            button.classList.remove('disabled');
          }
        });
      }

      // Disable/enable dial based on power state
      if (navDial) {
        const dialContainer = navDial.closest('.dial');
        navDial.disabled = !isPowered;
        const currentValue = navigationSystem.cursorIndex;
        navDial.value = currentValue;
        if (dialContainer) {
          dialContainer.style.setProperty('--value', currentValue);
          setDialFill(dialContainer, currentValue, navDial.max);
        }
      }

      // Update planet visual
      updatePlanetVisual();
    }

    /**
     * Update the planet visual in the viewport based on current location
     */
    function updatePlanetVisual() {
      const system = navigationSystem.getCurrentSystem();
      const planetIndex = navigationSystem.currentPlanetIndex;
      
      // Get base planet color/type from seeded generation
      const planetInfo = getPlanetColor(
        navigationSystem.currentX,
        navigationSystem.currentY,
        planetIndex
      );

      // Initialize/Update cockpit 3D progressive enhancement
      try {
        updateCockpit3D(
          navigationSystem.currentX,
          navigationSystem.currentY,
          planetIndex,
          planetInfo.type,
          planetInfo.color
        );
      } catch (e) {
        // If 3D fails, nothing to render here
      }

      // Update starfield
      updateStarfield(navigationSystem.currentX, navigationSystem.currentY, planetIndex);
    }

    // --- Three.js-based cockpit renderer ---
    // Rendering quality (hard-coded for now)
    const RENDER_QUALITY = {
      textureSize: 256,
      sphereSegments: { width: 64, height: 48 },
      cloudSegments: { width: 48, height: 36 },
      fps: 20
    };

    const ATMOSPHERE_PRESETS = {
      Ocean: { thickness: [1.6, 2.6], colorJitter: 0.06, intensity: 0.52, softness: 1.25 },
      Life: { thickness: [1.4, 2.4], colorJitter: 0.08, intensity: 0.48, softness: 1.15 },
      Desert: { thickness: [1.0, 1.8], colorJitter: 0.12, intensity: 0.44, softness: 1.05 },
      Rocky: { thickness: [0.9, 1.6], colorJitter: 0.1, intensity: 0.4, softness: 1.0 },
      Volcanic: { thickness: [1.1, 1.9], colorJitter: 0.14, intensity: 0.46, softness: 1.05 },
      Frozen: { thickness: [1.1, 1.9], colorJitter: 0.05, intensity: 0.42, softness: 1.2 },
      Default: { thickness: [1.0, 1.5], colorJitter: 0.08, intensity: 0.42, softness: 1.05 }
    };

  let cockpit3D = null;
  let scanner3D = null;
  let snapshot3D = null;
  let traderShip3D = null;
  let traderShipSnapshot3D = null;
  const planet3DTextureCache = new Map(); // key -> {albedoTex,bumpTex,roughTex,emissTex,cloudTex}
  const traderShipTextureCache = new Map();
  const TRADER_SHIP_PALETTES = [
    { base: '#0d1b2a', accent: '#3bc4d6', trim: '#8df7ff', glow: '#6dffff' },
    { base: '#2a1b2d', accent: '#f06bc1', trim: '#ffc8f0', glow: '#ff9ee2' },
    { base: '#1f2435', accent: '#9ac431', trim: '#d1ff73', glow: '#d9ff9c' },
    { base: '#2b1f33', accent: '#ff9f1c', trim: '#ffd7a4', glow: '#ffc76f' },
    { base: '#1b1f33', accent: '#6c63ff', trim: '#c9c3ff', glow: '#908bff' },
    { base: '#2a2f1b', accent: '#f0cf61', trim: '#ffe9a8', glow: '#fff3bf' }
  ];
  const TRADER_SHIP_CLASSES = [
    'Light Freighter',
    'Courier Sloop',
    'Blockade Runner',
    'Survey Skiff',
    'Salvage Tender',
    'Diplomatic Barge',
    'Prospector Barge',
    'Cryo Hauler'
  ];

    function createPlanetRenderContext({ width, height, canvas, pixelRatio = Math.min(window.devicePixelRatio || 1, 2), autoAnimate = false, preserveDrawingBuffer = true }) {
      const THREE = window.THREE;
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
        preserveDrawingBuffer,
        premultipliedAlpha: true
      });
      renderer.setPixelRatio(pixelRatio);
      renderer.setSize(width, height, false);
      renderer.autoClear = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(35, width / height, 1.0, 2000);
      camera.position.set(0, 0, 260);

      scene.add(new THREE.AmbientLight(0x222222));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(-200, -200, 150);
      dir.castShadow = true;
      dir.shadow.mapSize.set(512, 512);
      dir.shadow.radius = 3;
      dir.shadow.camera.near = 50;
      dir.shadow.camera.far = 800;
      dir.shadow.camera.left = -250;
      dir.shadow.camera.right = 250;
      dir.shadow.camera.top = 250;
      dir.shadow.camera.bottom = -250;
      dir.shadow.bias = -0.0003;
      dir.shadow.normalBias = 0.04;
      scene.add(dir);

      const group = new THREE.Group();
      scene.add(group);

      let animationCallback = null;
      let requestId = null;
      let lastRender = 0;
      const frameInterval = 1000 / RENDER_QUALITY.fps;

      const ctx = {
        renderer,
        scene,
        camera,
        group,
        light: dir,
        planet: null,
        clouds: null,
        atmosphere: null,
        rings: null,
        moons: [],
        currentKey: null,
        width,
        height,
        rotationSpeed: 0.00015,
        cloudRotationSpeed: 0.00025,
        timeAcc: 0,
        setSize(newW, newH) {
          this.width = newW;
          this.height = newH;
          renderer.setSize(newW, newH, false);
          camera.aspect = newW / newH;
          camera.updateProjectionMatrix();
        },
        renderOnce() {
          renderer.render(scene, camera);
        },
        setAnimationCallback(cb) {
          animationCallback = cb;
        },
        startAnimation(cb) {
          if (typeof cb === 'function') animationCallback = cb;
          if (requestId) return;
          lastRender = 0;
          const loop = (ts) => {
            requestId = requestAnimationFrame(loop);
            if (document.hidden) return;
            if (ts - lastRender < frameInterval) return;
            const dt = Math.min(0.05, (ts - lastRender) / 1000) || 0.05;
            lastRender = ts;
            ctx.timeAcc += dt;
            if (typeof animationCallback === 'function') {
              animationCallback(ts, dt);
            }
          };
          requestId = requestAnimationFrame(loop);
        },
        stopAnimation() {
          if (requestId) {
            cancelAnimationFrame(requestId);
            requestId = null;
          }
        },
        isAnimating() {
          return requestId !== null;
        },
        dispose(options = {}) {
          const { forceContextLoss = false } = options;
          ctx.stopAnimation();
          if (forceContextLoss && renderer) {
            try {
              const gl = renderer.getContext();
              const lose = gl && (gl.getExtension('WEBGL_lose_context') || gl.getExtension('WEBKIT_WEBGL_lose_context'));
              if (lose && typeof lose.loseContext === 'function') {
                lose.loseContext();
              }
            } catch (e) {
              console.warn('Failed to force WebGL context loss during dispose.', e);
            }
          }
          renderer.dispose();
          ctx.currentKey = null;
          ctx.planet = null;
          ctx.clouds = null;
          ctx.atmosphere = null;
          ctx.rings = null;
          ctx.moons = [];
        }
      };

      if (autoAnimate) {
        ctx.startAnimation(() => {
          if (ctx.planet) ctx.planet.rotation.y += ctx.rotationSpeed;
          if (ctx.clouds) ctx.clouds.rotation.y += ctx.cloudRotationSpeed;
          renderer.render(scene, camera);
        });
      }

      return ctx;
    }
    function ensureThreeLoaded(cb) {
      if (window.THREE) { cb(); return; }
      // Load ESM build only to avoid multiple-instance warnings
      (async () => {
        try {
          const mod = await import('https://unpkg.com/three@0.160.0/build/three.module.js');
          // Cache the module namespace on window for downstream code
          window.THREE = mod;
        } catch (e) {
          console.warn('Three.js ESM failed to load; 3D cockpit will be disabled in this session.', e);
        } finally {
          cb();
        }
      })();
    }

    function initCockpit3D() {
      const viewport = document.querySelector('.window .viewport');
      if (!viewport) return null;
      if (!window.THREE) return null;

      if (cockpit3D && cockpit3D._resizeHandler) {
        window.removeEventListener('resize', cockpit3D._resizeHandler);
      }

      const width = Math.max(1, viewport.clientWidth);
      const height = Math.max(1, viewport.clientHeight);
      const ctx = createPlanetRenderContext({ width, height, autoAnimate: true, preserveDrawingBuffer: true });
      if (!ctx) return null;

      const canvasEl = ctx.renderer.domElement;
      canvasEl.classList.add('renderer-canvas');
      canvasEl.style.position = 'absolute';
      canvasEl.style.inset = '0';
      canvasEl.style.animation = 'planetFigureEight 120s ease-in-out infinite';

      const glass = viewport.querySelector('.glass');
      if (glass) {
        viewport.insertBefore(canvasEl, glass);
      } else {
        viewport.appendChild(canvasEl);
      }

      const handleResize = () => {
        const w = Math.max(1, viewport.clientWidth);
        const h = Math.max(1, viewport.clientHeight);
        ctx.setSize(w, h);
        ctx.renderOnce();
      };

      window.addEventListener('resize', handleResize);

      cockpit3D = ctx;
      cockpit3D.viewport = viewport;
      cockpit3D._resizeHandler = handleResize;
      cockpit3D.timeAcc = 0;
      cockpit3D.moons = [];
      cockpit3D.rings = null;

      if (!cockpit3D.isAnimating()) {
        cockpit3D.startAnimation();
      }

      return cockpit3D;
    }

    function snapshotPlanet3D(sizeOrOptions = 256, overrides = {}) {
      const params = (typeof sizeOrOptions === 'object' && sizeOrOptions !== null)
        ? { ...sizeOrOptions }
        : { size: sizeOrOptions, ...overrides };
      const size = Math.max(1, params.size ?? 256);

      return new Promise((resolve) => {
        ensureThreeLoaded(() => {
          if (!window.THREE) { resolve(''); return; }

          const x = params.x ?? navigationSystem.currentX;
          const y = params.y ?? navigationSystem.currentY;
          const planetIndex = params.planetIndex ?? navigationSystem.currentPlanetIndex;
          const info = getPlanetColor(x, y, planetIndex);
          const typeOverride = params.typeOverride ?? info.type;
          const baseHex = params.baseHex ?? info.color;

          try {
            const ctx = ensureSnapshotRenderContext(size);
            if (!ctx) { resolve(''); return; }
            populatePlanetRenderContext(ctx, x, y, planetIndex, typeOverride, baseHex);
            ctx.renderOnce();
            const canvas = ctx.renderer.domElement;
            const url = canvas.toDataURL('image/png');
            resolve(url || '');
          } catch (err) {
            console.warn('Snapshot render failed', err);
            resolve('');
          }
        });
      });
    }
    // Capture a snapshot via the unified renderer and set the viewport planet sprite
    async function setPlanetSpriteFrom3DForViewportPlanet() {
      const planetElement = document.querySelector('.window .planet');
      if (!planetElement) return false;

      const width = Math.max(1, planetElement.clientWidth || 140);
      const height = Math.max(1, planetElement.clientHeight || 140);
      const size = Math.round(Math.max(width, height));

      const x = navigationSystem.currentX;
      const y = navigationSystem.currentY;
      const planetIndex = navigationSystem.currentPlanetIndex;
      const info = getPlanetColor(x, y, planetIndex);

      try {
        const dataUrl = await snapshotPlanet3D({
          size,
          x,
          y,
          planetIndex,
          typeOverride: info.type,
          baseHex: info.color
        });
        if (!dataUrl) return false;
        planetElement.style.background = 'transparent';
        planetElement.style.backgroundImage = `url(${dataUrl})`;
        planetElement.style.backgroundSize = '100% 100%';
        planetElement.style.backgroundRepeat = 'no-repeat';
        planetElement.style.backgroundPosition = 'center center';
        return true;
      } catch (err) {
        console.warn('Viewport sprite update failed', err);
        return false;
      }
    }

    function populatePlanetRenderContext(ctx, x, y, planetIndex, typeOverride, baseHex) {
      const THREE = window.THREE;
      if (!THREE || !ctx) return;

      const key = `${x}|${y}|${planetIndex}|${typeOverride || ''}|${baseHex || ''}`;
      if (ctx.currentKey === key) return;
      ctx.currentKey = key;

      const { group, light, renderer } = ctx;

      if (ctx.rings) {
        group.remove(ctx.rings);
        ctx.rings.geometry.dispose();
        if (ctx.rings.material.map) ctx.rings.material.map.dispose();
        ctx.rings.material.dispose();
        ctx.rings = null;
      }
      if (ctx.atmosphere) {
        group.remove(ctx.atmosphere);
        ctx.atmosphere.geometry.dispose();
        ctx.atmosphere.material.dispose();
        ctx.atmosphere = null;
      }
      if (ctx.clouds) {
        group.remove(ctx.clouds);
        ctx.clouds.geometry.dispose();
        ctx.clouds.material.dispose();
        ctx.clouds = null;
      }
      if (ctx.moons && ctx.moons.length) {
        for (const moon of ctx.moons) {
          if (moon.parent) moon.parent.remove(moon);
          moon.geometry.dispose();
          moon.material.dispose();
        }
        ctx.moons = [];
      }
      if (ctx.planet) {
        group.remove(ctx.planet);
        ctx.planet.geometry.dispose();
        ctx.planet.material.dispose();
        ctx.planet = null;
      }

      const seedU32 = hash32('3D', x | 0, y | 0, planetIndex | 0);
      const rnd = seededRandom(seedU32);

      const radius = 70;
      const geo = new THREE.SphereGeometry(radius, RENDER_QUALITY.sphereSegments.width, RENDER_QUALITY.sphereSegments.height);

      let cached = planet3DTextureCache.get(key);
      if (!cached) {
        const texSet = generatePlanetTextureSet(x, y, planetIndex, typeOverride, baseHex, RENDER_QUALITY.textureSize);
        cached = {
          albedoTex: createTextureFromCanvas(texSet.albedoCanvas, renderer, { sRGB: true, anisotropy: 8 }),
          bumpTex: createTextureFromCanvas(texSet.bumpCanvas, renderer, { anisotropy: 4 }),
          normalTex: createTextureFromCanvas(texSet.normalCanvas, renderer, { anisotropy: 4 }),
          roughTex: createTextureFromCanvas(texSet.roughnessCanvas, renderer, { anisotropy: 2 }),
          metalTex: createTextureFromCanvas(texSet.metalnessCanvas, renderer, { anisotropy: 2 }),
          emissTex: createTextureFromCanvas(texSet.emissiveCanvas, renderer, { anisotropy: 2 }),
          cloudTex: createTextureFromCanvas(texSet.cloudCanvas, renderer, { anisotropy: 4 })
        };
        planet3DTextureCache.set(key, cached);
      }

      const { albedoTex, bumpTex, normalTex, roughTex, metalTex, emissTex, cloudTex } = cached;
      const profile = choosePlanetProfile(seededRandom(hash32('TEX', x | 0, y | 0, planetIndex | 0)), typeOverride);
      let bumpScale = (profile.group === 'Ocean') ? -0.8 : 0.8;
      if (profile.group === 'Desert' || profile.key === 'Dune') bumpScale = 1.2;

      const mat = new THREE.MeshStandardMaterial({
        map: albedoTex,
        roughnessMap: roughTex,
        metalnessMap: metalTex,
        metalness: 0.0,
        normalMap: normalTex,
        normalScale: new THREE.Vector2(1, -1),
        bumpMap: bumpTex,
        bumpScale,
        emissiveMap: emissTex,
        emissiveIntensity: 1.1,
        emissive: 0xffffff,
        roughness: 0.9
      });
      if (profile.group === 'Desert') {
        mat.metalness = Math.min(0.2, (mat.metalness ?? 0) + 0.08);
        mat.roughness = Math.max(0.45, mat.roughness - 0.25);
      } else {
        mat.roughness = Math.max(0.5, mat.roughness - 0.12);
      }
      applyPlanetAlbedoLift(mat, profile);
      const planet = new THREE.Mesh(geo, mat);
      planet.castShadow = false;
      planet.receiveShadow = true;
      group.add(planet);
      ctx.planet = planet;

      const cloudGeo = new THREE.SphereGeometry(radius * 1.015, RENDER_QUALITY.cloudSegments.width, RENDER_QUALITY.cloudSegments.height);
      const cloudMat = new THREE.MeshStandardMaterial({ map: cloudTex, transparent: true, opacity: 0.85, depthWrite: false, roughness: 1.0, metalness: 0.0 });
      cloudMat.polygonOffset = true;
      cloudMat.polygonOffsetFactor = -1;
      cloudMat.polygonOffsetUnits = -1;
      const clouds = new THREE.Mesh(cloudGeo, cloudMat);
      clouds.renderOrder = 2;
      clouds.receiveShadow = false;
      clouds.castShadow = false;
      clouds.rotation.y = Math.PI * 2 * rnd();
      group.add(clouds);
      ctx.clouds = clouds;

      if ((profile.atmosphere || profile.group === 'Ocean') && profile.group !== 'Gas Giant') {
        const preset = ATMOSPHERE_PRESETS[profile.group] || ATMOSPHERE_PRESETS.Default;
        const atmRng = seededRandom(hash32('ATM', seedU32));
        const thicknessRange = profile.atmosphereThicknessRange || preset.thickness || [1, 1];
        const rawThickness = thicknessRange[0] + (thicknessRange[1] - thicknessRange[0]) * atmRng();
        const thickness = Math.max(0.75, Math.min(3.0, rawThickness));
        const colorJitter = profile.hazeJitter ?? preset.colorJitter ?? 0.0;
        const hazeBase = hexToRgb(profile.hazeColor || '#b4d2ff');
        const colorShift = (atmRng() * 2 - 1) * colorJitter;
        let hazeTint = hazeBase;
        if (colorShift > 1e-6) {
          hazeTint = lightenRgb(hazeBase, Math.min(0.45, colorShift));
        } else if (colorShift < -1e-6) {
          hazeTint = darkenRgb(hazeBase, Math.min(0.45, -colorShift));
        }
        const tintColor = new THREE.Color(hazeTint[0] / 255, hazeTint[1] / 255, hazeTint[2] / 255);

        const shellScale = 1.02 + 0.012 * thickness;
        const baseIntensity = profile.atmosphereIntensity ?? preset.intensity ?? 0.42;
        const intensity = baseIntensity * (0.8 + 0.2 * thickness);
        const baseSoftness = profile.atmosphereSoftness ?? preset.softness ?? 1.05;
        const softness = baseSoftness * (0.9 + 0.18 * Math.min(thickness, 3.0));

        const atmGeo = new THREE.SphereGeometry(radius * shellScale, 64, 48);
        const atmMat = new THREE.ShaderMaterial({
          side: THREE.BackSide,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          uniforms: {
            uColor: { value: tintColor },
            uLightDir: { value: new THREE.Vector3(0, 0, 1) },
            uIntensity: { value: intensity },
            uThickness: { value: thickness },
            uSoftness: { value: softness }
          },
          vertexShader: `
            varying vec3 vWorldNormal;
            varying vec3 vWorldPos;
            void main(){
              vec4 wp = modelMatrix * vec4(position,1.0);
              vWorldPos = wp.xyz;
              vWorldNormal = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * wp;
            }
          `,
          fragmentShader: `
            precision highp float;
            varying vec3 vWorldNormal;
            varying vec3 vWorldPos;
            uniform vec3 uColor;
            uniform vec3 uLightDir;
            uniform float uIntensity;
            uniform float uThickness;
            uniform float uSoftness;
            void main(){
              vec3 N = normalize(vWorldNormal);
              vec3 V = normalize(cameraPosition - vWorldPos);
              float viewDot = max(0.0, 1.0 - dot(N, V));
              float thicknessNorm = clamp((uThickness - 1.0) / 2.0, 0.0, 1.0);
              float fresPower = mix(3.0, 1.25, thicknessNorm);
              float fres = pow(viewDot, fresPower);
              float lit = dot(N, normalize(uLightDir));
              float forwardScatter = smoothstep(-0.55 * uThickness, 0.25, lit);
              float shadowMask = 1.0 - smoothstep(-0.7, -0.22, lit);
              float rimSoft = smoothstep(0.0, 0.55 * uSoftness, viewDot);
              float alpha = uIntensity * fres * forwardScatter * (0.5 + 0.5 * shadowMask) * rimSoft;
              gl_FragColor = vec4(uColor, alpha);
            }
          `
        });
        const atmosphere = new THREE.Mesh(atmGeo, atmMat);
        atmosphere.renderOrder = 3;
        group.add(atmosphere);
        ctx.atmosphere = atmosphere;
      }

      const L = getSeededLightDir(x, y, planetIndex);
      light.position.set(L[0] * 300, L[1] * 300, L[2] * 300);
      if (ctx.atmosphere) {
        ctx.atmosphere.material.uniforms.uLightDir.value.set(L[0], L[1], L[2]);
      }

      ctx.rotationSpeed = 0.00005 + rnd() * 0.00012;
      ctx.cloudRotationSpeed = ctx.rotationSpeed * (1.3 + rnd() * 0.6);

      ctx.setAnimationCallback(() => {
        if (ctx.planet) ctx.planet.rotation.y += ctx.rotationSpeed;
        if (ctx.clouds) ctx.clouds.rotation.y += ctx.cloudRotationSpeed;
        renderer.render(ctx.scene, ctx.camera);
      });

      ctx.renderOnce();
    }

    function deriveTraderShipClass(seed) {
      const classSeed = hash32('SHIP_CLASS', seed >>> 0);
      const classRng = seededRandom(classSeed);
      const idx = Math.floor(classRng() * TRADER_SHIP_CLASSES.length);
      return TRADER_SHIP_CLASSES[idx % TRADER_SHIP_CLASSES.length] || TRADER_SHIP_CLASSES[0];
    }

    function generateTraderShipProfile(seed) {
      const profileSeed = hash32('SHIP_PROFILE', seed >>> 0);
      const rng = seededRandom(profileSeed);
      const hullLength = 72 + rng() * 56;
      const baseRadius = 11 + rng() * 7;
      const hullRadiusFront = baseRadius * (0.8 + rng() * 0.35);
      const hullRadiusRear = baseRadius * (0.9 + rng() * 0.3);
      const noseLength = hullLength * (0.24 + rng() * 0.2);
      const tailLength = hullLength * (0.18 + rng() * 0.18);
      const wingSpan = hullLength * (0.95 + rng() * 0.75);
      const wingChord = hullLength * (0.26 + rng() * 0.24);
      const wingThickness = 3 + rng() * 3.5;
      const wingSweep = (rng() - 0.5) * 0.5;
      const wingDihedral = (rng() - 0.5) * 0.28;
      const wingMountY = -hullLength * (0.04 + rng() * 0.08);
      const hasTopFin = rng() < 0.72;
      const hasVentralFin = rng() < 0.46;
      const hasCargoPods = rng() < 0.55;
      const hasSensorDish = rng() < 0.34;
      const engineCount = 2 + Math.floor(rng() * 3);
      const engineRadius = 3.6 + rng() * 3.4;
      const engineLength = 12 + rng() * 11;
      const engineGlowLength = 16 + rng() * 9;
      const engineMountOffset = 4 + rng() * 6;
      const engineSpread = 0.7 + rng() * 0.7;
      const canopyRadius = baseRadius * (0.42 + rng() * 0.24);
      const canopyOffsetY = hullLength * (0.08 + rng() * 0.16);
      const canopyOffsetZ = (rng() - 0.5) * 12;
      const dorsalFinHeight = hullLength * (0.12 + rng() * 0.12);
      const ventralFinHeight = hullLength * (0.08 + rng() * 0.12);
      const palette = TRADER_SHIP_PALETTES[Math.floor(rng() * TRADER_SHIP_PALETTES.length)] || TRADER_SHIP_PALETTES[0];
      const spinRate = 0.32 + rng() * 0.25;
      const wobbleRate = 0.75 + rng() * 0.55;
      const wobbleAmount = 4 + rng() * 5;
      const trimBandCount = 2 + Math.floor(rng() * 3);
      const noseStripes = Math.floor(rng() * 3);
      const hullClass = deriveTraderShipClass(seed);

      return {
        seed: seed >>> 0,
        hullClass,
        palette,
        moduleSeed: hash32('SHIP_MODULES', seed >>> 0),
        hullLength,
        hullRadiusFront,
        hullRadiusRear,
        noseLength,
        tailLength,
        wingSpan,
        wingChord,
        wingThickness,
        wingSweep,
        wingDihedral,
        wingMountY,
        hasTopFin,
        hasVentralFin,
        hasCargoPods,
        hasSensorDish,
        engineCount,
        engineRadius,
        engineLength,
        engineGlowLength,
        engineMountOffset,
        engineSpread,
        canopyRadius,
        canopyOffsetY,
        canopyOffsetZ,
        dorsalFinHeight,
        ventralFinHeight,
        spinRate,
        wobbleRate,
        wobbleAmount,
        trimBandCount,
        noseStripes,
        patternSeed: hash32('SHIP_PATTERN', seed),
        accentSeed: hash32('SHIP_ACCENT', seed)
      };
    }

    function chooseFrom(list, rng) {
      if (!Array.isArray(list) || list.length === 0) return null;
      const index = Math.floor(rng() * list.length);
      return list[(index % list.length + list.length) % list.length];
    }

    function assignContactPlanes(target, planes) {
      const Vec3 = window.THREE && window.THREE.Vector3;
      if (!target || !Array.isArray(planes) || !Vec3) return;
      target.userData = target.userData || {};
      target.userData.contactPlanes = planes.map(plane => {
        const origin = plane.origin instanceof Vec3 ? plane.origin.clone() : new Vec3().copy(plane.origin || { x: 0, y: 0, z: 0 });
        const normal = plane.normal instanceof Vec3 ? plane.normal.clone() : new Vec3().copy(plane.normal || { x: 0, y: 1, z: 0 });
        if (normal.lengthSq() === 0) {
          normal.set(0, 1, 0);
        } else {
          normal.normalize();
        }
        return {
          id: plane.id || 'mount',
          origin,
          normal,
          radius: typeof plane.radius === 'number' ? plane.radius : null,
          size: typeof plane.size === 'number' ? plane.size : null
        };
      });
    }

    function buildTraderShipAssembly(THREE, profile, materials) {
      const moduleRng = seededRandom(profile.moduleSeed ?? hash32('SHIP_MODULES', profile.seed >>> 0));
      const assemblyGroup = new THREE.Group();
      assemblyGroup.name = 'TraderShipAssembly';
      const resources = {
        meshes: [],
        geometries: [],
        materials: [],
        lights: []
      };

      function pushMeshes(...items) {
        items.forEach(item => {
          if (item) resources.meshes.push(item);
        });
      }

      function pushGeometries(...items) {
        items.forEach(item => {
          if (item) resources.geometries.push(item);
        });
      }

      function pushMaterials(...items) {
        items.forEach(item => {
          if (item) resources.materials.push(item);
        });
      }

      function pushLights(...items) {
        items.forEach(item => {
          if (item) resources.lights.push(item);
        });
      }

      function createCylindricalPlanes(length, radiusRear, radiusFront) {
        const radial = Math.max(radiusRear, radiusFront);
        return [
          { id: 'rear', origin: new THREE.Vector3(0, -length / 2, 0), normal: new THREE.Vector3(0, -1, 0), radius: radiusRear },
          { id: 'front', origin: new THREE.Vector3(0, length / 2, 0), normal: new THREE.Vector3(0, 1, 0), radius: radiusFront },
          { id: 'port', origin: new THREE.Vector3(-radial, 0, 0), normal: new THREE.Vector3(-1, 0, 0), radius: radial },
          { id: 'starboard', origin: new THREE.Vector3(radial, 0, 0), normal: new THREE.Vector3(1, 0, 0), radius: radial },
          { id: 'dorsal', origin: new THREE.Vector3(0, 0, -radial), normal: new THREE.Vector3(0, 0, -1), radius: radial },
          { id: 'ventral', origin: new THREE.Vector3(0, 0, radial), normal: new THREE.Vector3(0, 0, 1), radius: radial }
        ];
      }

      function alignGroupToAnchorPlane(group, anchor, gap = 0) {
        if (!group || !anchor || !anchor.normal || !anchor.position) return;
        const normal = anchor.normal.clone();
        if (normal.lengthSq() === 0) return;
        normal.normalize();
        const planePoint = anchor.position.clone();
        group.updateMatrixWorld(true);
        const corner = new THREE.Vector3();
        const worldPoint = new THREE.Vector3();
        const relative = new THREE.Vector3();
        let closest = Infinity;
        group.traverse(child => {
          if (!child.isMesh || !child.geometry) return;
          const geometry = child.geometry;
          if (!geometry.boundingBox) geometry.computeBoundingBox();
          const bbox = geometry.boundingBox;
          for (let ix = 0; ix < 2; ix++) {
            for (let iy = 0; iy < 2; iy++) {
              for (let iz = 0; iz < 2; iz++) {
                corner.set(
                  ix ? bbox.max.x : bbox.min.x,
                  iy ? bbox.max.y : bbox.min.y,
                  iz ? bbox.max.z : bbox.min.z
                );
                worldPoint.copy(corner).applyMatrix4(child.matrixWorld);
                relative.copy(worldPoint).sub(planePoint);
                const projection = relative.dot(normal);
                if (projection < closest) closest = projection;
              }
            }
          }
        });
        if (!isFinite(closest)) return;
        const delta = gap - closest;
        if (Math.abs(delta) < 1e-3) return;
        group.position.addScaledVector(normal, delta);
        group.updateMatrixWorld(true);
      }

      function buildHullCore() {
        const hullGroup = new THREE.Group();
        hullGroup.name = 'Module:HullCore';
        const segmentBuilders = [buildHullSegmentBarrel, buildHullSegmentArmored, buildHullSegmentCargo];
        const segmentCount = 3 + Math.floor(moduleRng() * 2);
        const segments = [];
        let prevRadius = profile.hullRadiusRear;
        for (let i = 0; i < segmentCount; i++) {
          const builder = chooseFrom(segmentBuilders, moduleRng) || buildHullSegmentBarrel;
          const segment = builder({ prevRadius, index: i, total: segmentCount });
          segments.push(segment);
          prevRadius = segment.endRadius;
        }

        const totalLength = segments.reduce((sum, seg) => sum + seg.length, 0);
        let cursor = -totalLength / 2;
        const anchors = {
          front: null,
          rear: null,
          port: [],
          starboard: [],
          dorsal: [],
          ventral: [],
          axial: []
        };

        segments.forEach((segment, index) => {
          segment.group.position.y = cursor + segment.length * 0.5;
          hullGroup.add(segment.group);
          pushMeshes(...segment.resources.meshes);
          pushGeometries(...segment.resources.geometries);
          pushMaterials(...segment.resources.materials);

          const centerY = segment.group.position.y;
          const radiusAvg = (segment.startRadius + segment.endRadius) * 0.5;
          const portAnchor = {
            position: new THREE.Vector3(-radiusAvg, centerY, 0),
            normal: new THREE.Vector3(-1, 0, 0),
            radius: radiusAvg,
            segmentIndex: index,
            plane: { origin: new THREE.Vector3(-radiusAvg, centerY, 0), normal: new THREE.Vector3(-1, 0, 0) }
          };
          const starboardAnchor = {
            position: new THREE.Vector3(radiusAvg, centerY, 0),
            normal: new THREE.Vector3(1, 0, 0),
            radius: radiusAvg,
            segmentIndex: index,
            plane: { origin: new THREE.Vector3(radiusAvg, centerY, 0), normal: new THREE.Vector3(1, 0, 0) }
          };
          const dorsalAnchor = {
            position: new THREE.Vector3(0, centerY, -radiusAvg),
            normal: new THREE.Vector3(0, 0, -1),
            radius: radiusAvg,
            segmentIndex: index,
            plane: { origin: new THREE.Vector3(0, centerY, -radiusAvg), normal: new THREE.Vector3(0, 0, -1) }
          };
          const ventralAnchor = {
            position: new THREE.Vector3(0, centerY, radiusAvg),
            normal: new THREE.Vector3(0, 0, 1),
            radius: radiusAvg,
            segmentIndex: index,
            plane: { origin: new THREE.Vector3(0, centerY, radiusAvg), normal: new THREE.Vector3(0, 0, 1) }
          };

          anchors.port.push(portAnchor);
          anchors.starboard.push(starboardAnchor);
          anchors.dorsal.push(dorsalAnchor);
          anchors.ventral.push(ventralAnchor);

          anchors.axial.push({
            segmentIndex: index,
            front: {
              position: new THREE.Vector3(0, segment.group.position.y + segment.length / 2, 0),
              normal: new THREE.Vector3(0, 1, 0),
              radius: segment.endRadius
            },
            rear: {
              position: new THREE.Vector3(0, segment.group.position.y - segment.length / 2, 0),
              normal: new THREE.Vector3(0, -1, 0),
              radius: segment.startRadius
            }
          });

          cursor += segment.length;
        });

  const lastSegment = segments.length ? segments[segments.length - 1] : null;
  const firstSegment = segments.length ? segments[0] : null;
  anchors.front = anchors.axial[anchors.axial.length - 1]?.front || { position: new THREE.Vector3(0, totalLength / 2, 0), normal: new THREE.Vector3(0, 1, 0), radius: lastSegment ? lastSegment.endRadius : profile.hullRadiusFront };
  anchors.rear = anchors.axial[0]?.rear || { position: new THREE.Vector3(0, -totalLength / 2, 0), normal: new THREE.Vector3(0, -1, 0), radius: firstSegment ? firstSegment.startRadius : profile.hullRadiusRear };

        return {
          group: hullGroup,
          anchors,
          length: totalLength,
          frontRadius: anchors.front.radius,
          rearRadius: anchors.rear.radius
        };
      }

      function buildHullSegmentBarrel({ prevRadius }) {
        const length = profile.hullLength * (0.22 + moduleRng() * 0.2);
        const startRadius = prevRadius * (0.92 + moduleRng() * 0.12);
        const endRadius = startRadius * (0.88 + moduleRng() * 0.22);
        const geometry = new THREE.CylinderGeometry(endRadius, startRadius, length, 34, 1, false);
        const mesh = new THREE.Mesh(geometry, materials.base);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        assignContactPlanes(mesh, createCylindricalPlanes(length, startRadius, endRadius));

        const edgeGeo = new THREE.EdgesGeometry(geometry, 0.24);
        const edgeMat = new THREE.LineBasicMaterial({
          color: new THREE.Color(profile.palette.trim).multiplyScalar(0.45),
          transparent: true,
          opacity: 0.42
        });
        const edges = new THREE.LineSegments(edgeGeo, edgeMat);

        const group = new THREE.Group();
        group.name = 'HullSegment:Barrel';
        group.add(mesh);
        group.add(edges);

        return {
          length,
          startRadius,
          endRadius,
          group,
          resources: {
            meshes: [mesh, edges],
            geometries: [geometry, edgeGeo],
            materials: [edgeMat]
          }
        };
      }

      function buildHullSegmentArmored({ prevRadius }) {
        const length = profile.hullLength * (0.18 + moduleRng() * 0.18);
        const startRadius = prevRadius * (0.95 + moduleRng() * 0.1);
        const endRadius = startRadius * (0.9 + moduleRng() * 0.18);
        const geometry = new THREE.CylinderGeometry(endRadius, startRadius, length, 18, 1, false);
        const mesh = new THREE.Mesh(geometry, materials.base);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        assignContactPlanes(mesh, createCylindricalPlanes(length, startRadius, endRadius));

        const ribMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(profile.palette.accent).lerp(new THREE.Color(profile.palette.base), 0.6),
          metalness: 0.48,
          roughness: 0.32
        });
        const ribGeo = new THREE.BoxGeometry(startRadius * 0.32, length * 1.06, startRadius * 0.22);
        const ribs = [];
        for (let i = 0; i < 4; i++) {
          const rib = new THREE.Mesh(ribGeo, ribMaterial);
          rib.rotation.y = (Math.PI / 2) * i;
          ribs.push(rib);
        }

        const strutGeo = new THREE.TorusGeometry(startRadius * (0.92 + moduleRng() * 0.08), startRadius * 0.08, 8, 40);
        const strutMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(profile.palette.trim).multiplyScalar(0.85),
          metalness: 0.52,
          roughness: 0.38
        });
        const bandA = new THREE.Mesh(strutGeo, strutMat);
        const bandB = new THREE.Mesh(strutGeo, strutMat);
        bandA.rotation.x = Math.PI / 2;
        bandB.rotation.x = Math.PI / 2;
        bandA.position.y = length * 0.35;
        bandB.position.y = -length * 0.35;

        const group = new THREE.Group();
        group.name = 'HullSegment:Armored';
        group.add(mesh);
        ribs.forEach(rib => group.add(rib));
        group.add(bandA);
        group.add(bandB);

        return {
          length,
          startRadius,
          endRadius,
          group,
          resources: {
            meshes: [mesh, ...ribs, bandA, bandB],
            geometries: [geometry, ribGeo, strutGeo],
            materials: [ribMaterial, strutMat]
          }
        };
      }

      function buildHullSegmentCargo({ prevRadius }) {
        const length = profile.hullLength * (0.2 + moduleRng() * 0.22);
        const width = prevRadius * (1.55 + moduleRng() * 0.35);
        const depth = prevRadius * (1.25 + moduleRng() * 0.28);
        const geometry = new THREE.BoxGeometry(width, length, depth);
        const mesh = new THREE.Mesh(geometry, materials.base);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        assignContactPlanes(mesh, [
          { id: 'rear', origin: new THREE.Vector3(0, -length / 2, 0), normal: new THREE.Vector3(0, -1, 0), size: width },
          { id: 'front', origin: new THREE.Vector3(0, length / 2, 0), normal: new THREE.Vector3(0, 1, 0), size: width },
          { id: 'port', origin: new THREE.Vector3(-width / 2, 0, 0), normal: new THREE.Vector3(-1, 0, 0), size: depth },
          { id: 'starboard', origin: new THREE.Vector3(width / 2, 0, 0), normal: new THREE.Vector3(1, 0, 0), size: depth },
          { id: 'dorsal', origin: new THREE.Vector3(0, 0, -depth / 2), normal: new THREE.Vector3(0, 0, -1), size: width },
          { id: 'ventral', origin: new THREE.Vector3(0, 0, depth / 2), normal: new THREE.Vector3(0, 0, 1), size: width }
        ]);

        const frameGeo = new THREE.EdgesGeometry(geometry);
        const frameMat = new THREE.LineBasicMaterial({
          color: new THREE.Color(profile.palette.trim).multiplyScalar(0.6),
          transparent: true,
          opacity: 0.55
        });
        const frame = new THREE.LineSegments(frameGeo, frameMat);

        const crateGeo = new THREE.BoxGeometry(width * 0.45, length * 0.35, depth * 0.4);
        const crateMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(profile.palette.accent).multiplyScalar(0.85),
          metalness: 0.35,
          roughness: 0.55
        });
        const crateA = new THREE.Mesh(crateGeo, crateMat);
        const crateB = new THREE.Mesh(crateGeo, crateMat);
        crateA.position.set(0, 0, -depth * 0.18);
        crateB.position.set(0, 0, depth * 0.18);

        const group = new THREE.Group();
        group.name = 'HullSegment:Cargo';
        group.add(mesh);
        group.add(frame);
        group.add(crateA);
        group.add(crateB);

        const radiusEquiv = Math.max(width, depth) / 2;

        return {
          length,
          startRadius: radiusEquiv,
          endRadius: radiusEquiv,
          group,
          resources: {
            meshes: [mesh, frame, crateA, crateB],
            geometries: [geometry, frameGeo, crateGeo],
            materials: [frameMat, crateMat]
          }
        };
      }

      const hull = buildHullCore();
      assemblyGroup.add(hull.group);
      profile.hullLength = hull.length;
      profile.hullRadiusFront = hull.frontRadius;
      profile.hullRadiusRear = hull.rearRadius;

      function extendAlong(anchor, length, radius = anchor.radius) {
        const tip = anchor.position.clone().add(anchor.normal.clone().multiplyScalar(length));
        return {
          position: tip,
          normal: anchor.normal.clone(),
          radius
        };
      }

      function attachNose() {
        const anchor = hull.anchors.front;
        if (!anchor) return anchor;
  const builders = [buildNeedleNose, buildSurveyNose, buildHammerNose, buildBladeNose];
        const builder = chooseFrom(builders, moduleRng) || buildNeedleNose;
        const nose = builder(anchor);
  alignGroupToAnchorPlane(nose.group, anchor, 0);
        assemblyGroup.add(nose.group);
        pushMeshes(...nose.meshes);
        pushGeometries(...nose.geometries);
        pushMaterials(...nose.materials);
        pushLights(...(nose.lights || []));
        return extendAlong(anchor, nose.length, nose.tipRadius);
      }

      function buildNeedleNose(anchor) {
        const length = profile.noseLength * (0.78 + moduleRng() * 0.42);
        const baseRadius = anchor.radius * (0.92 + moduleRng() * 0.08);
        const tipRadius = Math.max(1.2, baseRadius * 0.18);
        const bodyLength = length * 0.82;
        const capLength = length - bodyLength;

        const bodyGeo = new THREE.CylinderGeometry(Math.max(tipRadius * 1.05, 1.1), baseRadius, bodyLength, 30, 1, false);
        const body = new THREE.Mesh(bodyGeo, materials.accent);
        body.position.y = bodyLength / 2;
        assignContactPlanes(body, [
          { id: 'base', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, -1, 0), radius: baseRadius }
        ]);

        const capGeo = new THREE.SphereGeometry(Math.max(tipRadius * 1.05, 1.1), 20, 14);
        const cap = new THREE.Mesh(capGeo, materials.accent);
        cap.scale.set(1.05, 0.55, 1.05);
        cap.position.y = bodyLength + capLength * 0.5;
        const capTipOffset = (capGeo.parameters?.radius || tipRadius) * 0.55;
        assignContactPlanes(cap, [
          { id: 'tip', origin: new THREE.Vector3(0, capTipOffset, 0), normal: new THREE.Vector3(0, 1, 0), radius: tipRadius }
        ]);

        const stripeGeo = new THREE.CylinderGeometry(baseRadius * 1.02, baseRadius * 1.02, length * 0.14, 30, 1, true);
        const stripeMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color(profile.palette.trim),
          transparent: true,
          opacity: 0.45
        });
        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
        stripe.position.y = bodyLength * 0.55;

        const group = new THREE.Group();
        group.name = 'Module:NoseNeedle';
        group.position.copy(anchor.position);
        group.add(body);
        group.add(cap);
        group.add(stripe);

        return {
          group,
          length,
          tipRadius,
          meshes: [body, cap, stripe],
          geometries: [bodyGeo, capGeo, stripeGeo],
          materials: [stripeMat],
          lights: []
        };
      }

      function buildSurveyNose(anchor) {
        const length = profile.noseLength * (0.64 + moduleRng() * 0.32);
        const baseRadius = anchor.radius * (1.05 + moduleRng() * 0.12);
        const midRadius = baseRadius * (0.75 + moduleRng() * 0.18);
        const tipRadius = Math.max(1.4, midRadius * 0.4);
        const cylinderGeo = new THREE.CylinderGeometry(midRadius, baseRadius, length * 0.55, 20, 1, false);
        const cylinder = new THREE.Mesh(cylinderGeo, materials.accent);
        cylinder.position.y = length * 0.275;
        assignContactPlanes(cylinder, [
          { id: 'base', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, -1, 0), radius: baseRadius }
        ]);

        const dishDepth = length * 0.32;
        const rimRadius = midRadius * (0.95 + moduleRng() * 0.1);
        const dishProfile = [];
        for (let i = 0; i <= 14; i++) {
          const t = i / 14;
          const eased = Math.pow(t, 1.4);
          const radius = THREE.MathUtils.lerp(tipRadius * 0.6, rimRadius, eased);
          const y = -Math.pow(t, 1.8) * dishDepth;
          dishProfile.push(new THREE.Vector2(radius, y));
        }
        const dishGeo = new THREE.LatheGeometry(dishProfile, 36);
        const dish = new THREE.Mesh(dishGeo, materials.trim);
        dish.rotation.x = Math.PI;
        dish.position.y = length + dishDepth * 0.28;
        assignContactPlanes(dish, [
          { id: 'tip', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, 1, 0), radius: tipRadius }
        ]);

        const rimGeo = new THREE.TorusGeometry(rimRadius * 0.98, midRadius * 0.07, 10, 32);
        const rim = new THREE.Mesh(rimGeo, materials.accent);
        rim.rotation.x = Math.PI / 2;
        rim.position.y = length + dishDepth * 0.32;

        const feedGeo = new THREE.SphereGeometry(tipRadius * 0.6, 16, 12);
        const feed = new THREE.Mesh(feedGeo, materials.glass);
        feed.scale.set(1, 0.6, 1);
        feed.position.y = length + dishDepth * 0.18;

        const strutGeo = new THREE.BoxGeometry(tipRadius * 0.25, dishDepth * 0.6, tipRadius * 0.25);
        const struts = [];
        const strutCount = 3;
        for (let i = 0; i < strutCount; i++) {
          const angle = (i / strutCount) * Math.PI * 2;
          const radius = rimRadius * 0.45;
          const strut = new THREE.Mesh(strutGeo, materials.trim);
          strut.position.set(
            Math.cos(angle) * radius,
            length + dishDepth * 0.05,
            Math.sin(angle) * radius
          );
          strut.rotation.y = angle;
          strut.rotation.x = Math.PI / 12;
          struts.push(strut);
        }

        const sensorGeo = new THREE.SphereGeometry(midRadius * 0.48, 16, 12);
        const sensor = new THREE.Mesh(sensorGeo, materials.glass);
        sensor.position.y = length * 0.82;

        const group = new THREE.Group();
        group.name = 'Module:NoseSurvey';
        group.position.copy(anchor.position);
        group.add(cylinder);
        group.add(dish);
        group.add(rim);
        struts.forEach(strut => group.add(strut));
        group.add(feed);
        group.add(sensor);

        return {
          group,
          length,
          tipRadius,
          meshes: [cylinder, dish, rim, ...struts, feed, sensor],
          geometries: [cylinderGeo, dishGeo, rimGeo, strutGeo, feedGeo, sensorGeo],
          materials: [],
          lights: []
        };
      }

      function buildHammerNose(anchor) {
        const length = profile.noseLength * (0.5 + moduleRng() * 0.28);
        const baseRadius = anchor.radius * (1.1 + moduleRng() * 0.15);
        const faceWidth = baseRadius * (1.8 + moduleRng() * 0.4);
        const faceHeight = baseRadius * (0.9 + moduleRng() * 0.3);
        const blockGeo = new THREE.BoxGeometry(faceWidth, faceHeight, length * 0.65);
        const block = new THREE.Mesh(blockGeo, materials.accent);
        block.position.y = length * 0.25;
        assignContactPlanes(block, [
          { id: 'base', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, -1, 0), size: faceWidth },
          { id: 'tip', origin: new THREE.Vector3(0, length * 0.65, 0), normal: new THREE.Vector3(0, 1, 0), size: faceWidth }
        ]);

        const ramGeo = new THREE.CylinderGeometry(faceWidth * 0.28, faceWidth * 0.36, length * 0.35, 18, 1, false);
        const ram = new THREE.Mesh(ramGeo, materials.trim);
        ram.rotation.z = Math.PI / 2;
        ram.position.set(0, length * 0.55, 0);

        const lights = [];
        if (moduleRng() < 0.35) {
          const lamp = new THREE.PointLight(profile.palette.glow, 0.8, faceWidth * 2.4, 1.8);
          lamp.position.set(0, length * 0.72, 0);
          lights.push(lamp);
        }

        const group = new THREE.Group();
        group.name = 'Module:NoseHammer';
        group.position.copy(anchor.position);
        group.add(block);
        group.add(ram);
        lights.forEach(light => group.add(light));

        return {
          group,
          length,
          tipRadius: faceWidth * 0.35,
          meshes: [block, ram],
          geometries: [blockGeo, ramGeo],
          materials: [],
          lights
        };
      }

      function buildBladeNose(anchor) {
        const length = profile.noseLength * (0.68 + moduleRng() * 0.34);
        const baseRadius = anchor.radius * (0.92 + moduleRng() * 0.16);
        const spineThickness = Math.max(1.2, baseRadius * (0.26 + moduleRng() * 0.12));
        const spineWidth = Math.max(2.0, baseRadius * (0.52 + moduleRng() * 0.2));
        const spineGeo = new THREE.BoxGeometry(spineThickness, length, spineWidth);
        const spine = new THREE.Mesh(spineGeo, materials.accent);
        spine.position.y = length * 0.5;
        assignContactPlanes(spine, [
          { id: 'base', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, -1, 0), size: baseRadius }
        ]);

        const edgeGeo = new THREE.CylinderGeometry(spineWidth * 0.42, spineWidth * 0.08, length * 0.55, 18, 1, true);
        const edge = new THREE.Mesh(edgeGeo, materials.trim);
        edge.rotation.z = Math.PI / 2;
        edge.position.set(0, length * 0.7, 0);

        const lightChance = moduleRng();
        const lights = [];
        if (lightChance < 0.3) {
          const probe = new THREE.PointLight(profile.palette.glow, 0.65, spineWidth * 2.6, 1.7);
          probe.position.set(0, length * 0.9, 0);
          lights.push(probe);
        }

        const group = new THREE.Group();
        group.name = 'Module:NoseBlade';
        group.position.copy(anchor.position);
        group.add(spine);
        group.add(edge);
        lights.forEach(light => group.add(light));

        return {
          group,
          length,
          tipRadius: spineThickness * 0.45,
          meshes: [spine, edge],
          geometries: [spineGeo, edgeGeo],
          materials: [],
          lights
        };
      }

      function attachTail(currentAnchor) {
        const anchor = currentAnchor;
        if (!anchor) return anchor;
  const builders = [buildConeTail, buildVentedTail, buildRingTail];
        const builder = chooseFrom(builders, moduleRng) || buildConeTail;
        const tail = builder(anchor);
  alignGroupToAnchorPlane(tail.group, anchor, 0);
        assemblyGroup.add(tail.group);
        pushMeshes(...tail.meshes);
        pushGeometries(...tail.geometries);
        pushMaterials(...tail.materials);
        return extendAlong(anchor, tail.length, tail.newRadius);
      }

      function buildConeTail(anchor) {
        const length = profile.tailLength * (0.7 + moduleRng() * 0.4);
        const baseRadius = anchor.radius * (1.0 + moduleRng() * 0.12);
        const chokeRadius = Math.max(1.6, baseRadius * 0.46);
        const collarHeight = length * 0.18;
        const collarGeo = new THREE.CylinderGeometry(baseRadius * 1.02, baseRadius * 1.02, collarHeight, 28, 1, false);
        const collar = new THREE.Mesh(collarGeo, materials.trim);
        collar.position.y = -collarHeight / 2;
        assignContactPlanes(collar, [
          { id: 'base', origin: new THREE.Vector3(0, collarHeight / 2, 0), normal: new THREE.Vector3(0, 1, 0), radius: baseRadius }
        ]);

        const taperLength = length * 0.55;
        const taperGeo = new THREE.CylinderGeometry(chokeRadius * 1.05, baseRadius * 0.94, taperLength, 28, 1, false);
        const taper = new THREE.Mesh(taperGeo, materials.accent);
        taper.position.y = -collarHeight - taperLength / 2;

        const ventLength = length - collarHeight - taperLength;
        const ventHeight = Math.max(ventLength, 1.2);
        const ventGeo = new THREE.CylinderGeometry(chokeRadius * 0.9, chokeRadius, ventHeight, 22, 1, false);
        const vent = new THREE.Mesh(ventGeo, materials.engine);
        vent.position.y = -collarHeight - taperLength - ventHeight / 2;
        assignContactPlanes(vent, [
          { id: 'tip', origin: new THREE.Vector3(0, -ventHeight / 2, 0), normal: new THREE.Vector3(0, -1, 0), radius: chokeRadius }
        ]);

        const baffleGeo = new THREE.TorusGeometry(chokeRadius * 0.85, Math.max(0.4, chokeRadius * 0.18), 12, 32);
        const baffle = new THREE.Mesh(baffleGeo, materials.trim);
        baffle.rotation.x = Math.PI / 2;
        baffle.position.y = -collarHeight - taperLength - ventHeight * 0.8;

        const group = new THREE.Group();
        group.name = 'Module:TailCone';
        group.position.copy(anchor.position);
        group.add(collar);
        group.add(taper);
        group.add(vent);
        group.add(baffle);

        return {
          group,
          length,
          meshes: [collar, taper, vent, baffle],
          geometries: [collarGeo, taperGeo, ventGeo, baffleGeo],
          materials: [],
          newRadius: chokeRadius
        };
      }

      function buildVentedTail(anchor) {
        const length = profile.tailLength * (0.55 + moduleRng() * 0.35);
        const baseRadius = anchor.radius * (1.1 + moduleRng() * 0.2);
        const tipRadius = Math.max(2.0, baseRadius * 0.45);
        const collarGeo = new THREE.CylinderGeometry(baseRadius * 1.05, baseRadius * 1.05, length * 0.35, 20, 1, true);
        const collar = new THREE.Mesh(collarGeo, materials.accent);
        collar.position.y = -length * 0.2;
        const finsGeo = new THREE.BoxGeometry(baseRadius * 0.6, length * 0.55, baseRadius * 0.12);
        const fins = [];
        for (let i = 0; i < 3; i++) {
          const fin = new THREE.Mesh(finsGeo, materials.trim);
          fin.rotation.y = (Math.PI * 2 / 3) * i;
          fin.position.y = -length * 0.6;
          fins.push(fin);
        }
        const nozzleGeo = new THREE.CylinderGeometry(tipRadius, baseRadius, length * 0.6, 18, 1, true);
        const nozzle = new THREE.Mesh(nozzleGeo, materials.base);
        nozzle.rotation.x = Math.PI;
        nozzle.position.y = -length * 0.7;

        const group = new THREE.Group();
        group.name = 'Module:TailVented';
        group.position.copy(anchor.position);
        group.add(collar);
        fins.forEach(fin => group.add(fin));
        group.add(nozzle);

        assignContactPlanes(collar, [
          { id: 'base', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, 1, 0), radius: baseRadius }
        ]);

        return {
          group,
          length,
          meshes: [collar, ...fins, nozzle],
          geometries: [collarGeo, finsGeo, nozzleGeo],
          materials: [],
          newRadius: tipRadius
        };
      }

      function buildRingTail(anchor) {
        const length = profile.tailLength * (0.48 + moduleRng() * 0.26);
        const hubRadius = anchor.radius * (0.95 + moduleRng() * 0.2);
        const ringRadius = hubRadius * (1.4 + moduleRng() * 0.35);
        const hubGeo = new THREE.CylinderGeometry(hubRadius * 0.85, hubRadius * 0.72, length * 0.5, 26, 1, false);
        const hub = new THREE.Mesh(hubGeo, materials.trim);
        hub.rotation.x = Math.PI;
        hub.position.y = -length * 0.25;
        assignContactPlanes(hub, [
          { id: 'base', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, 1, 0), radius: hubRadius }
        ]);

        const ringGeo = new THREE.TorusGeometry(ringRadius, Math.max(0.6, hubRadius * 0.22), 14, 48);
        const ring = new THREE.Mesh(ringGeo, materials.accent);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = -length * 0.72;

        const vaneGeo = new THREE.CylinderGeometry(hubRadius * 0.1, hubRadius * 0.1, ringRadius * 0.9, 10, 1, true);
        const vaneA = new THREE.Mesh(vaneGeo, materials.base);
        const vaneB = new THREE.Mesh(vaneGeo, materials.base);
        vaneA.rotation.z = Math.PI / 2;
        vaneB.rotation.y = Math.PI / 2;
        vaneB.rotation.x = Math.PI / 2;
        vaneA.position.y = -length * 0.6;
        vaneB.position.y = -length * 0.6;

        const group = new THREE.Group();
        group.name = 'Module:TailRing';
        group.position.copy(anchor.position);
        group.add(hub);
        group.add(ring);
        group.add(vaneA);
        group.add(vaneB);

        return {
          group,
          length,
          meshes: [hub, ring, vaneA, vaneB],
          geometries: [hubGeo, ringGeo, vaneGeo],
          materials: [],
          newRadius: ringRadius
        };
      }

      const frontAnchor = attachNose();
      hull.anchors.front = frontAnchor;
      const rearAnchor = attachTail(hull.anchors.rear);
      hull.anchors.rear = rearAnchor;

      function pairAnchors(portList, starboardList) {
        const pairs = [];
        const len = Math.min(portList.length, starboardList.length);
        for (let i = 0; i < len; i++) {
          pairs.push({ port: portList[i], starboard: starboardList[i] });
        }
        return pairs;
      }

      function attachWingset() {
        const pairs = pairAnchors(hull.anchors.port, hull.anchors.starboard);
        if (pairs.length === 0) return;
        const pair = chooseFrom(pairs, moduleRng) || pairs[Math.floor(pairs.length / 2)];
  const builders = [buildDeltaWing, buildSweptWing, buildArrowWing, buildForwardWing];
        const builder = chooseFrom(builders, moduleRng) || buildDeltaWing;
        const wing = builder(pair);
        if (!wing) return;
        assemblyGroup.add(wing.group);
        pushMeshes(...wing.meshes);
        pushGeometries(...wing.geometries);
        pushMaterials(...wing.materials);
      }

      function buildWingGeometry(span, thickness, chord) {
        const geo = new THREE.BoxGeometry(span, thickness, chord);
        return geo;
      }

      function buildDeltaWing(pair) {
        const span = profile.wingSpan * (0.4 + moduleRng() * 0.35);
        const chord = profile.wingChord * (0.45 + moduleRng() * 0.4);
        const thickness = profile.wingThickness * (0.6 + moduleRng() * 0.5);
        const wingGeo = buildWingGeometry(span, thickness, chord);
        const leftWing = new THREE.Mesh(wingGeo, materials.accent);
        const rightWing = new THREE.Mesh(wingGeo, materials.accent);
        leftWing.position.set(pair.port.position.x - span / 2, pair.port.position.y + moduleRng() * 6 - 3, pair.port.position.z + chord * 0.1);
        rightWing.position.set(pair.starboard.position.x + span / 2, pair.starboard.position.y + moduleRng() * 6 - 3, pair.starboard.position.z + chord * 0.1);
        leftWing.rotation.y = profile.wingSweep;
        rightWing.rotation.y = -profile.wingSweep;
        leftWing.rotation.z = profile.wingDihedral;
        rightWing.rotation.z = -profile.wingDihedral;

        assignContactPlanes(leftWing, [
          { id: 'root', origin: new THREE.Vector3(span / 2, 0, 0), normal: new THREE.Vector3(1, 0, 0), size: chord }
        ]);
        assignContactPlanes(rightWing, [
          { id: 'root', origin: new THREE.Vector3(-span / 2, 0, 0), normal: new THREE.Vector3(-1, 0, 0), size: chord }
        ]);

        const strutGeo = new THREE.CylinderGeometry(thickness * 0.18, thickness * 0.18, chord * 0.6, 12, 1);
        const strutLeft = new THREE.Mesh(strutGeo, materials.trim);
        const strutRight = new THREE.Mesh(strutGeo, materials.trim);
        strutLeft.rotation.x = Math.PI / 2;
        strutRight.rotation.x = Math.PI / 2;
        strutLeft.position.set(pair.port.position.x - span * 0.42, pair.port.position.y, pair.port.position.z + chord * 0.32);
        strutRight.position.set(pair.starboard.position.x + span * 0.42, pair.starboard.position.y, pair.starboard.position.z + chord * 0.32);

        const group = new THREE.Group();
        group.name = 'Module:WingDelta';
        group.add(leftWing);
        group.add(rightWing);
        group.add(strutLeft);
        group.add(strutRight);

        return {
          group,
          meshes: [leftWing, rightWing, strutLeft, strutRight],
          geometries: [wingGeo, strutGeo],
          materials: []
        };
      }

      function buildSweptWing(pair) {
        const span = profile.wingSpan * (0.32 + moduleRng() * 0.4);
        const chord = profile.wingChord * (0.35 + moduleRng() * 0.4);
        const thickness = profile.wingThickness * (0.4 + moduleRng() * 0.4);
        const wingGeo = buildWingGeometry(span, thickness, chord);
        const mat = materials.accent;
        const leftWing = new THREE.Mesh(wingGeo, mat);
        const rightWing = new THREE.Mesh(wingGeo, mat);
        leftWing.position.set(pair.port.position.x - span / 2, pair.port.position.y + moduleRng() * 4 - 2, pair.port.position.z + chord * 0.25);
        rightWing.position.set(pair.starboard.position.x + span / 2, pair.starboard.position.y + moduleRng() * 4 - 2, pair.starboard.position.z + chord * 0.25);
        leftWing.rotation.y = profile.wingSweep * 1.4;
        rightWing.rotation.y = -profile.wingSweep * 1.4;
        leftWing.rotation.z = profile.wingDihedral * 0.8;
        rightWing.rotation.z = -profile.wingDihedral * 0.8;

        assignContactPlanes(leftWing, [
          { id: 'root', origin: new THREE.Vector3(span / 2, 0, 0), normal: new THREE.Vector3(1, 0, 0), size: chord }
        ]);
        assignContactPlanes(rightWing, [
          { id: 'root', origin: new THREE.Vector3(-span / 2, 0, 0), normal: new THREE.Vector3(-1, 0, 0), size: chord }
        ]);

        const group = new THREE.Group();
        group.name = 'Module:WingSwept';
        group.add(leftWing);
        group.add(rightWing);

        if (moduleRng() < 0.4) {
          const pylonGeo = new THREE.CylinderGeometry(thickness * 0.2, thickness * 0.2, chord * 0.7, 10, 1);
          const pylonMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(profile.palette.trim).multiplyScalar(0.8),
            metalness: 0.45,
            roughness: 0.42
          });
          const pylonLeft = new THREE.Mesh(pylonGeo, pylonMat);
          const pylonRight = new THREE.Mesh(pylonGeo, pylonMat);
          pylonLeft.rotation.x = Math.PI / 2;
          pylonRight.rotation.x = Math.PI / 2;
          pylonLeft.position.set(pair.port.position.x - span * 0.46, pair.port.position.y - thickness * 1.1, pair.port.position.z + chord * 0.4);
          pylonRight.position.set(pair.starboard.position.x + span * 0.46, pair.starboard.position.y - thickness * 1.1, pair.starboard.position.z + chord * 0.4);
          group.add(pylonLeft);
          group.add(pylonRight);
          return {
            group,
            meshes: [leftWing, rightWing, pylonLeft, pylonRight],
            geometries: [wingGeo, pylonGeo],
            materials: [pylonMat]
          };
        }

        return {
          group,
          meshes: [leftWing, rightWing],
          geometries: [wingGeo],
          materials: []
        };
      }

      function buildArrowWing(pair) {
        const span = profile.wingSpan * (0.28 + moduleRng() * 0.32);
        const chord = profile.wingChord * (0.32 + moduleRng() * 0.3);
        const thickness = profile.wingThickness * (0.3 + moduleRng() * 0.3);
        const wingGeo = buildWingGeometry(span, thickness, chord);
        const mat = materials.trim;
        const leftWing = new THREE.Mesh(wingGeo, mat);
        const rightWing = new THREE.Mesh(wingGeo, mat);
        leftWing.scale.x = 0.7;
        rightWing.scale.x = 0.7;
        leftWing.position.set(pair.port.position.x - span * 0.35, pair.port.position.y + moduleRng() * 6 - 3, pair.port.position.z + chord * 0.16);
        rightWing.position.set(pair.starboard.position.x + span * 0.35, pair.starboard.position.y + moduleRng() * 6 - 3, pair.starboard.position.z + chord * 0.16);
        leftWing.rotation.y = profile.wingSweep * 2;
        rightWing.rotation.y = -profile.wingSweep * 2;
        leftWing.rotation.z = profile.wingDihedral * 1.4;
        rightWing.rotation.z = -profile.wingDihedral * 1.4;

  const stabilizerGeo = new THREE.CylinderGeometry(chord * 0.14, chord * 0.22, thickness * 4, 16, 1, false);
        const stabilizerLeft = new THREE.Mesh(stabilizerGeo, materials.accent);
        const stabilizerRight = new THREE.Mesh(stabilizerGeo, materials.accent);
  stabilizerLeft.rotation.x = Math.PI / 2;
  stabilizerLeft.rotation.z = Math.PI / 10;
  stabilizerRight.rotation.x = Math.PI / 2;
  stabilizerRight.rotation.z = -Math.PI / 10;
        stabilizerLeft.position.set(pair.port.position.x - span * 0.55, pair.port.position.y, pair.port.position.z - chord * 0.35);
        stabilizerRight.position.set(pair.starboard.position.x + span * 0.55, pair.starboard.position.y, pair.starboard.position.z - chord * 0.35);

        const group = new THREE.Group();
        group.name = 'Module:WingArrow';
        group.add(leftWing);
        group.add(rightWing);
        group.add(stabilizerLeft);
        group.add(stabilizerRight);

        return {
          group,
          meshes: [leftWing, rightWing, stabilizerLeft, stabilizerRight],
          geometries: [wingGeo, stabilizerGeo],
          materials: []
        };
      }

      function buildForwardWing(pair) {
        const span = profile.wingSpan * (0.3 + moduleRng() * 0.34);
        const chord = profile.wingChord * (0.28 + moduleRng() * 0.32);
        const thickness = profile.wingThickness * (0.32 + moduleRng() * 0.36);
        const wingGeo = buildWingGeometry(span, thickness, chord);
        const mat = materials.accent;
        const leftWing = new THREE.Mesh(wingGeo, mat);
        const rightWing = new THREE.Mesh(wingGeo, mat);
        const sweep = Math.abs(profile.wingSweep) * (0.8 + moduleRng() * 0.4);
        leftWing.position.set(pair.port.position.x - span * 0.4, pair.port.position.y + moduleRng() * 3 - 1.5, pair.port.position.z - chord * 0.12);
        rightWing.position.set(pair.starboard.position.x + span * 0.4, pair.starboard.position.y + moduleRng() * 3 - 1.5, pair.starboard.position.z - chord * 0.12);
        leftWing.rotation.y = -sweep;
        rightWing.rotation.y = sweep;
        leftWing.rotation.z = profile.wingDihedral * 0.6;
        rightWing.rotation.z = -profile.wingDihedral * 0.6;

        assignContactPlanes(leftWing, [
          { id: 'root', origin: new THREE.Vector3(span / 2, 0, 0), normal: new THREE.Vector3(1, 0, 0), size: chord }
        ]);
        assignContactPlanes(rightWing, [
          { id: 'root', origin: new THREE.Vector3(-span / 2, 0, 0), normal: new THREE.Vector3(-1, 0, 0), size: chord }
        ]);

  const canardGeo = new THREE.CylinderGeometry(chord * 0.1, chord * 0.14, span * 0.22, 14, 1, false);
  const canardLeft = new THREE.Mesh(canardGeo, materials.trim);
  const canardRight = new THREE.Mesh(canardGeo, materials.trim);
  canardLeft.rotation.z = Math.PI / 2;
  canardLeft.rotation.y = Math.PI / 10;
  canardRight.rotation.z = -Math.PI / 2;
  canardRight.rotation.y = -Math.PI / 10;
  canardLeft.position.set(pair.port.position.x - span * 0.18, pair.port.position.y + moduleRng() * 2, pair.port.position.z - chord * 0.38);
  canardRight.position.set(pair.starboard.position.x + span * 0.18, pair.starboard.position.y + moduleRng() * 2, pair.starboard.position.z - chord * 0.38);

        const group = new THREE.Group();
        group.name = 'Module:WingForward';
        group.add(leftWing);
        group.add(rightWing);
        group.add(canardLeft);
        group.add(canardRight);

        return {
          group,
          meshes: [leftWing, rightWing, canardLeft, canardRight],
          geometries: [wingGeo, canardGeo],
          materials: []
        };
      }

      attachWingset();

      function attachFin(kind, builder) {
        const sourceAnchors = kind === 'dorsal' ? hull.anchors.dorsal : hull.anchors.ventral;
        if (!sourceAnchors.length) return;
        const anchor = chooseFrom(sourceAnchors, moduleRng) || sourceAnchors[Math.floor(sourceAnchors.length / 2)];
        const fin = builder(anchor);
  alignGroupToAnchorPlane(fin.group, anchor, 0);
        assemblyGroup.add(fin.group);
        pushMeshes(...fin.meshes);
        pushGeometries(...fin.geometries);
        pushMaterials(...fin.materials);
      }

      function buildDorsalFin(anchor) {
        const height = profile.dorsalFinHeight * (0.8 + moduleRng() * 0.6);
        const base = Math.max(2.4, anchor.radius * 0.45);
        const finGeo = new THREE.CylinderGeometry(base * 0.35, base * 0.58, height, 18, 1, false);
        const fin = new THREE.Mesh(finGeo, materials.trim);
        fin.rotation.x = Math.PI / 2;
        fin.position.z = -height / 2;
        assignContactPlanes(fin, [
          { id: 'root', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, 0, 1), size: base }
        ]);

        const braceGeo = new THREE.BoxGeometry(base * 0.4, height * 0.2, base * 0.25);
        const brace = new THREE.Mesh(braceGeo, materials.accent);
        brace.position.z = -height * 0.35;

        const group = new THREE.Group();
        group.name = 'Module:FinDorsal';
        group.position.copy(anchor.position);
        group.add(fin);
        group.add(brace);

        return {
          group,
          meshes: [fin, brace],
          geometries: [finGeo, braceGeo],
          materials: []
        };
      }

      function buildVentralFin(anchor) {
        const height = profile.ventralFinHeight * (0.8 + moduleRng() * 0.6);
        const base = Math.max(2.2, anchor.radius * 0.4);
        const finGeo = new THREE.CylinderGeometry(base * 0.32, base * 0.5, height, 16, 1, false);
        const fin = new THREE.Mesh(finGeo, materials.trim);
        fin.rotation.x = -Math.PI / 2;
        fin.position.z = height / 2;
        assignContactPlanes(fin, [
          { id: 'root', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, 0, -1), size: base }
        ]);

        const braceGeo = new THREE.BoxGeometry(base * 0.36, height * 0.18, base * 0.22);
        const brace = new THREE.Mesh(braceGeo, materials.accent);
        brace.position.z = height * 0.35;

        const group = new THREE.Group();
        group.name = 'Module:FinVentral';
        group.position.copy(anchor.position);
        group.add(fin);
        group.add(brace);

        return {
          group,
          meshes: [fin, brace],
          geometries: [finGeo, braceGeo],
          materials: []
        };
      }

      if (profile.hasTopFin) {
        attachFin('dorsal', buildDorsalFin);
      }
      if (profile.hasVentralFin) {
        attachFin('ventral', buildVentralFin);
      }

      function attachCanopy() {
        if (!hull.anchors.dorsal.length) return;
        const sorted = [...hull.anchors.dorsal].sort((a, b) => b.position.y - a.position.y);
        const anchor = sorted[Math.min(sorted.length - 1, Math.floor(moduleRng() * Math.min(2, sorted.length)))];
        const radius = profile.canopyRadius * (0.9 + moduleRng() * 0.2);
        const geometry = new THREE.SphereGeometry(radius, 24, 16);
        const mesh = new THREE.Mesh(geometry, materials.glass);
        const scaleY = 0.8 + moduleRng() * 0.18;
        mesh.scale.set(1.32 + moduleRng() * 0.16, scaleY, 1.06 + moduleRng() * 0.18);
        mesh.position.z = -radius * scaleY;
        assignContactPlanes(mesh, [
          { id: 'mount', origin: new THREE.Vector3(0, 0, 0), normal: new THREE.Vector3(0, 0, 1), radius }
        ]);

        const frameGeo = new THREE.TorusGeometry(radius * 0.96, radius * 0.12, 12, 32);
        const frame = new THREE.Mesh(frameGeo, materials.trim);
        frame.rotation.z = Math.PI / 2;
        frame.rotation.x = Math.PI / 2;
        frame.position.set(0, 0, 0);

        const group = new THREE.Group();
        group.name = 'Module:BridgeCanopy';
        group.position.copy(anchor.position);
        group.add(mesh);
        group.add(frame);
        alignGroupToAnchorPlane(group, anchor, 0);
        assemblyGroup.add(group);

        pushMeshes(mesh, frame);
        pushGeometries(geometry, frameGeo);
      }

      attachCanopy();

      function attachCargoPods() {
        if (!profile.hasCargoPods) return;
        const pairs = pairAnchors(hull.anchors.port, hull.anchors.starboard);
        if (!pairs.length) return;
        const podPairs = Math.min(pairs.length, 1 + Math.floor(moduleRng() * 2));
        for (let i = 0; i < podPairs; i++) {
          const pair = pairs[(i + Math.floor(moduleRng() * pairs.length)) % pairs.length];
          const baseRadius = pair.port.radius;
          const podWidth = baseRadius * (0.85 + moduleRng() * 0.35);
          const podHeight = baseRadius * (0.6 + moduleRng() * 0.3);
          const podDepth = baseRadius * (0.55 + moduleRng() * 0.28);
          const geometry = new THREE.BoxGeometry(podWidth, podHeight, podDepth);
          const leftPod = new THREE.Mesh(geometry, materials.trim);
          const rightPod = new THREE.Mesh(geometry, materials.trim);
          leftPod.position.set(pair.port.position.x - podWidth / 2 - baseRadius * 0.12, pair.port.position.y - podHeight * 0.1, pair.port.position.z + podDepth * 0.4);
          rightPod.position.set(pair.starboard.position.x + podWidth / 2 + baseRadius * 0.12, pair.starboard.position.y - podHeight * 0.1, pair.starboard.position.z + podDepth * 0.4);
          assignContactPlanes(leftPod, [
            { id: 'mount', origin: new THREE.Vector3(podWidth / 2, 0, 0), normal: new THREE.Vector3(1, 0, 0), size: podHeight }
          ]);
          assignContactPlanes(rightPod, [
            { id: 'mount', origin: new THREE.Vector3(-podWidth / 2, 0, 0), normal: new THREE.Vector3(-1, 0, 0), size: podHeight }
          ]);

          const rackGeo = new THREE.CylinderGeometry(podHeight * 0.18, podHeight * 0.18, podDepth * 1.2, 12, 1);
          const rackMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(profile.palette.accent).multiplyScalar(0.75),
            metalness: 0.32,
            roughness: 0.5
          });
          const leftRack = new THREE.Mesh(rackGeo, rackMat);
          const rightRack = new THREE.Mesh(rackGeo, rackMat);
          leftRack.rotation.x = Math.PI / 2;
          rightRack.rotation.x = Math.PI / 2;
          leftRack.position.set(pair.port.position.x - baseRadius * 0.35, pair.port.position.y - podHeight * 0.48, pair.port.position.z + podDepth * 0.2);
          rightRack.position.set(pair.starboard.position.x + baseRadius * 0.35, pair.starboard.position.y - podHeight * 0.48, pair.starboard.position.z + podDepth * 0.2);

          assemblyGroup.add(leftPod);
          assemblyGroup.add(rightPod);
          assemblyGroup.add(leftRack);
          assemblyGroup.add(rightRack);

          pushMeshes(leftPod, rightPod, leftRack, rightRack);
          pushGeometries(geometry, rackGeo);
          pushMaterials(rackMat);
        }
      }

      attachCargoPods();

      function attachSensorModule() {
        if (!profile.hasSensorDish) return;
        if (!hull.anchors.starboard.length) return;
        const anchor = hull.anchors.starboard[Math.floor(moduleRng() * hull.anchors.starboard.length)];
        const boomLength = profile.hullRadiusFront * (1.2 + moduleRng() * 0.8);
        const boomGeo = new THREE.CylinderGeometry(0.6, 0.6, boomLength, 10, 1);
        const boom = new THREE.Mesh(boomGeo, materials.trim);
        boom.rotation.z = Math.PI / 2;
        boom.position.x = anchor.position.x + boomLength / 2;
        boom.position.y = anchor.position.y + moduleRng() * 6 - 3;
        boom.position.z = anchor.position.z - moduleRng() * 3;

        const dishRadius = profile.hullRadiusFront * 0.44;
        const dishDepth = dishRadius * 0.6;
        const dishProfile = [];
        for (let i = 0; i <= 12; i++) {
          const t = i / 12;
          const eased = Math.pow(t, 1.5);
          const radius = THREE.MathUtils.lerp(dishRadius * 0.3, dishRadius, eased);
          const y = -Math.pow(t, 1.7) * dishDepth;
          dishProfile.push(new THREE.Vector2(radius, y));
        }
        const dishGeo = new THREE.LatheGeometry(dishProfile, 28);
        const dish = new THREE.Mesh(dishGeo, materials.accent);
        dish.rotation.y = Math.PI / 2;
        dish.position.set(boom.position.x + boomLength * 0.55, boom.position.y, boom.position.z);

        const dishRimGeo = new THREE.TorusGeometry(dishRadius * 0.96, Math.max(0.35, dishRadius * 0.08), 10, 28);
        const dishRim = new THREE.Mesh(dishRimGeo, materials.trim);
        dishRim.rotation.y = Math.PI / 2;
        dishRim.position.copy(dish.position).add(new THREE.Vector3(0, 0, -dishDepth * 0.05));

        const feedGeo = new THREE.SphereGeometry(dishRadius * 0.22, 12, 10);
        const feed = new THREE.Mesh(feedGeo, materials.glass);
        feed.scale.set(1, 0.7, 1);
        feed.position.set(dish.position.x - dishDepth * 0.32, dish.position.y, dish.position.z);

        const strutGeo = new THREE.BoxGeometry(dishDepth * 0.5, dishRadius * 0.1, dishRadius * 0.1);
        const struts = [];
        for (let i = 0; i < 3; i++) {
          const strut = new THREE.Mesh(strutGeo, materials.trim);
          const angle = (i / 3) * Math.PI * 2;
          const offset = new THREE.Vector3(0, Math.cos(angle) * dishRadius * 0.32, Math.sin(angle) * dishRadius * 0.32);
          strut.position.copy(dish.position).add(offset).add(new THREE.Vector3(-dishDepth * 0.22, 0, 0));
          strut.rotation.x = Math.PI / 12;
          strut.rotation.y = angle;
          struts.push(strut);
        }

        const group = new THREE.Group();
        group.name = 'Module:SensorArray';
        group.add(boom);
        group.add(dish);
        group.add(dishRim);
        struts.forEach(strut => group.add(strut));
        group.add(feed);
        assemblyGroup.add(group);

        assignContactPlanes(boom, [
          { id: 'mount', origin: new THREE.Vector3(-boomLength / 2, 0, 0), normal: new THREE.Vector3(-1, 0, 0), size: boomLength }
        ]);

        pushMeshes(boom, dish, dishRim, feed, ...struts);
        pushGeometries(boomGeo, dishGeo, dishRimGeo, feedGeo, strutGeo);
      }

      attachSensorModule();

      function attachWhitePanels() {
        if (!materials.white) return;
        const candidateAnchors = [];
        ['port', 'starboard', 'dorsal'].forEach(side => {
          const list = hull.anchors[side];
          if (Array.isArray(list)) {
            list.forEach(anchor => {
              if (anchor) candidateAnchors.push(anchor);
            });
          }
        });
        if (!candidateAnchors.length) return;
        const panelCount = 1 + Math.floor(moduleRng() * 3);
        for (let i = 0; i < panelCount; i++) {
          const anchor = candidateAnchors[Math.floor(moduleRng() * candidateAnchors.length)];
          if (!anchor || !anchor.normal || !anchor.position) continue;
          const width = anchor.radius * (0.7 + moduleRng() * 0.5);
          const height = anchor.radius * (0.45 + moduleRng() * 0.55);
          const inset = Math.max(0.18, anchor.radius * 0.08);
          const panelGeo = new THREE.PlaneGeometry(width, height, 1, 1);
          const panel = new THREE.Mesh(panelGeo, materials.white);
          const normal = anchor.normal.clone().normalize();
          panel.position.copy(anchor.position).addScaledVector(normal, inset);
          panel.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normal);

          if (moduleRng() < 0.55) {
            const stripeGeo = new THREE.PlaneGeometry(width * (0.22 + moduleRng() * 0.2), height * 0.2, 1, 1);
            const stripe = new THREE.Mesh(stripeGeo, materials.trim);
            stripe.position.set(0, (moduleRng() - 0.5) * height * 0.5, 0.01);
            panel.add(stripe);
            pushMeshes(stripe);
            pushGeometries(stripeGeo);
          }

          assemblyGroup.add(panel);
          pushMeshes(panel);
          pushGeometries(panelGeo);
        }
      }

      attachWhitePanels();

      function attachEngineCluster() {
        const anchor = hull.anchors.rear;
        if (!anchor) return;
        const engineGroup = new THREE.Group();
        engineGroup.name = 'Module:EngineCluster';
        engineGroup.position.copy(anchor.position);

        const engineSpacing = profile.engineRadius * 2.4;
        const spread = profile.engineSpread;
        const offsets = [];
        if (profile.engineCount === 2) {
          offsets.push(-engineSpacing * spread * 0.5, engineSpacing * spread * 0.5);
        } else if (profile.engineCount === 3) {
          offsets.push(-engineSpacing * spread, 0, engineSpacing * spread);
        } else {
          offsets.push(-engineSpacing * spread * 1.5, -engineSpacing * spread * 0.5, engineSpacing * spread * 0.5, engineSpacing * spread * 1.5);
        }

        const engineLength = profile.engineLength;
        const glowLength = profile.engineGlowLength;
        const rawMountOffset = Math.max(0, profile.engineMountOffset || 0);
        const mountClearance = Math.min(rawMountOffset, Math.max(1.2, engineLength * 0.35));
        const verticalOffset = -profile.engineRadius * 0.32;

        if (offsets.length) {
          const minOffset = Math.min(...offsets);
          const maxOffset = Math.max(...offsets);
          const clusterWidth = Math.max(profile.engineRadius * 2.2, (maxOffset - minOffset) + profile.engineRadius * 1.6);
          const blockHeight = mountClearance + profile.engineRadius * 1.1;
          const blockDepth = profile.engineRadius * (1.4 + Math.min(0.6, profile.engineSpread * 0.35));
          const blockGeo = new THREE.BoxGeometry(clusterWidth, blockHeight, blockDepth);
          const block = new THREE.Mesh(blockGeo, materials.base);
          block.position.set((minOffset + maxOffset) * 0.5, -blockHeight * 0.5, verticalOffset);
          engineGroup.add(block);
          assignContactPlanes(block, [
            { id: 'mount', origin: new THREE.Vector3(0, blockHeight / 2, 0), normal: new THREE.Vector3(0, 1, 0), size: clusterWidth }
          ]);
          pushMeshes(block);
          pushGeometries(blockGeo);
        }

        offsets.forEach(offset => {
          const engineGeo = new THREE.CylinderGeometry(profile.engineRadius * 1.05, profile.engineRadius * 1.18, engineLength, 22, 1, false);
          const engine = new THREE.Mesh(engineGeo, materials.engine);
          engine.position.set(offset, -(mountClearance + engineLength * 0.5), verticalOffset);
          engineGroup.add(engine);
          pushMeshes(engine);
          pushGeometries(engineGeo);
          assignContactPlanes(engine, [
            { id: 'mount', origin: new THREE.Vector3(0, engineLength / 2, 0), normal: new THREE.Vector3(0, 1, 0), radius: profile.engineRadius }
          ]);

          if (mountClearance > 0.35) {
            const strutGeo = new THREE.CylinderGeometry(profile.engineRadius * 0.26, profile.engineRadius * 0.22, mountClearance, 12, 1, false);
            const strut = new THREE.Mesh(strutGeo, materials.trim);
            strut.position.set(offset, -mountClearance / 2, verticalOffset);
            engineGroup.add(strut);
            pushMeshes(strut);
            pushGeometries(strutGeo);
          }

          const exhaustGeo = new THREE.ConeGeometry(profile.engineRadius * 0.82, glowLength, 22, 1, true);
          const exhaust = new THREE.Mesh(exhaustGeo, materials.engineGlow);
          exhaust.rotation.x = Math.PI;
          exhaust.position.set(offset, -(mountClearance + engineLength) - glowLength * 0.5, verticalOffset);
          engineGroup.add(exhaust);
          pushMeshes(exhaust);
          pushGeometries(exhaustGeo);

          const engineLight = new THREE.PointLight(profile.palette.glow, 1.35, glowLength * 4.2, 2.4);
          engineLight.position.set(offset, -(mountClearance + engineLength) - glowLength * 0.25, verticalOffset * 0.82);
          engineGroup.add(engineLight);
          pushLights(engineLight);
        });

        alignGroupToAnchorPlane(engineGroup, anchor, 0);
        assemblyGroup.add(engineGroup);
      }

      attachEngineCluster();

      function attachTrimBands() {
        const count = profile.trimBandCount;
        if (!count) return;
        for (let i = 0; i < count; i++) {
          const radius = profile.hullRadiusFront * (0.65 + moduleRng() * 0.25);
          const bandGeo = new THREE.TorusGeometry(radius, 0.8, 8, 36);
          const band = new THREE.Mesh(bandGeo, materials.trim);
          band.rotation.x = Math.PI / 2;
          band.position.y = (moduleRng() - 0.5) * profile.hullLength * 0.5;
          assemblyGroup.add(band);
          pushMeshes(band);
          pushGeometries(bandGeo);
        }
      }

      attachTrimBands();

      return {
        group: assemblyGroup,
        meshes: resources.meshes,
        geometries: resources.geometries,
        materials: resources.materials,
        lights: resources.lights
      };
    }

    function createTraderShipTexture(patternRng, palette) {
      const cnv = document.createElement('canvas');
      cnv.width = 128;
      cnv.height = 256;
      const ctx = cnv.getContext('2d');
      if (!ctx) return cnv;

      ctx.fillStyle = palette.base;
      ctx.fillRect(0, 0, cnv.width, cnv.height);

      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let i = 0; i < 16; i++) {
        const y = Math.floor(patternRng() * cnv.height);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(cnv.width, y);
        ctx.stroke();
        if (patternRng() < 0.35) {
          const x = Math.floor(patternRng() * cnv.width);
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, cnv.height);
          ctx.stroke();
        }
      }

      ctx.globalAlpha = 0.95;
      const stripeCount = 1 + Math.floor(patternRng() * 3);
      for (let s = 0; s < stripeCount; s++) {
        const h = 14 + patternRng() * 30;
        const y = patternRng() * (cnv.height - h);
        ctx.fillStyle = palette.accent;
        ctx.fillRect(0, y, cnv.width, h);
        const trimHeight = Math.max(4, h * 0.24);
        ctx.fillStyle = palette.trim;
        ctx.fillRect(0, y + h - trimHeight, cnv.width, trimHeight);
      }
      ctx.globalAlpha = 1;

      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      for (let i = 0; i < 140; i++) {
        const x = Math.floor(patternRng() * cnv.width);
        const y = Math.floor(patternRng() * cnv.height);
        ctx.fillRect(x, y, 1, 1);
      }

      const whitePanelCount = 1 + Math.floor(patternRng() * 3);
      for (let i = 0; i < whitePanelCount; i++) {
        const panelWidth = 18 + patternRng() * 44;
        const panelHeight = 10 + patternRng() * 28;
        const x = 2 + patternRng() * (cnv.width - panelWidth - 4);
        const y = 8 + patternRng() * (cnv.height - panelHeight - 16);
        ctx.fillStyle = 'rgba(248,248,255,0.92)';
        ctx.fillRect(x, y, panelWidth, panelHeight);
        ctx.strokeStyle = 'rgba(0,0,0,0.18)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, panelWidth - 1, panelHeight - 1);
        if (patternRng() < 0.55) {
          ctx.fillStyle = 'rgba(220,220,240,0.8)';
          const barHeight = Math.max(3, panelHeight * 0.24);
          ctx.fillRect(x, y + panelHeight - barHeight, panelWidth, barHeight);
        }
      }

      const codeAlphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
      const letterA = codeAlphabet[Math.floor(patternRng() * codeAlphabet.length)] || 'A';
      const letterB = codeAlphabet[Math.floor(patternRng() * codeAlphabet.length)] || 'Z';
      const code = `${letterA}${letterB}`;
      const codeSize = 20 + patternRng() * 14;
      const codeX = 12 + patternRng() * (cnv.width - codeSize * 2 - 18);
      const codeY = 16 + patternRng() * (cnv.height - codeSize - 32);
      ctx.save();
      ctx.translate(codeX, codeY);
      ctx.rotate((patternRng() - 0.5) * 0.28);
      ctx.font = `bold ${Math.round(codeSize)}px sans-serif`;
      ctx.textBaseline = 'top';
      ctx.textAlign = 'left';
      ctx.lineWidth = Math.max(1, Math.floor(codeSize / 12));
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.strokeText(code, 0, 0);
      ctx.fillText(code, 0, 0);
      ctx.restore();

      return cnv;
    }

    function getTraderShipTextures(seed, palette, renderer) {
      const key = `${seed >>> 0}|${palette.base}|${palette.accent}|${palette.trim}`;
      let entry = traderShipTextureCache.get(key);
      if (entry) return entry;

      const textureRng = seededRandom(hash32('SHIP_TEX', seed >>> 0));
      const canvas = createTraderShipTexture(textureRng, palette);
      const baseTexture = createTextureFromCanvas(canvas, renderer, { sRGB: true, anisotropy: 6 });
      entry = { base: baseTexture };
      traderShipTextureCache.set(key, entry);
      return entry;
    }

    function ensureTraderShipContext(container) {
      if (!window.THREE || !container) return null;
      const width = Math.max(1, container.clientWidth || container.offsetWidth || 220);
      const height = Math.max(1, container.clientHeight || container.offsetHeight || 200);

      if (!traderShip3D) {
        traderShip3D = createPlanetRenderContext({ width, height, autoAnimate: false, preserveDrawingBuffer: true });
        if (!traderShip3D) return null;
        const canvas = traderShip3D.renderer.domElement;
        canvas.style.position = 'absolute';
        canvas.style.inset = '0';
        canvas.style.display = 'block';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.pointerEvents = 'none';
        container.appendChild(canvas);
        traderShip3D.container = container;
        traderShip3D.renderer.setPixelRatio(1);
        traderShip3D.renderer.setClearColor(0x000509, 0);
        traderShip3D.camera.position.set(0, 36, 210);
        traderShip3D.camera.lookAt(0, 0, 0);
        traderShip3D.light.intensity = 1.25;
        traderShip3D.light.position.set(140, 160, 220);
        traderShip3D.scene.fog = null;
        const resizeHandler = () => {
          if (!traderShip3D || !traderShip3D.container) return;
          const target = traderShip3D.container;
          const w = Math.max(1, target.clientWidth || target.offsetWidth || width);
          const h = Math.max(1, target.clientHeight || target.offsetHeight || height);
          traderShip3D.setSize(w, h);
          traderShip3D.renderOnce();
        };
        traderShip3D._resizeHandler = resizeHandler;
        window.addEventListener('resize', resizeHandler);
      } else {
        if (traderShip3D.container !== container) {
          disposeTraderShipContext();
          return ensureTraderShipContext(container);
        }
        if (traderShip3D.width !== width || traderShip3D.height !== height) {
          traderShip3D.setSize(width, height);
        }
        const canvas = traderShip3D.renderer?.domElement;
        if (canvas && canvas.parentNode !== container) {
          container.appendChild(canvas);
        }
      }

      traderShip3D.container = container;
      return traderShip3D;
    }

    function ensureTraderShipSnapshotContext(width, height) {
      if (!window.THREE) return null;
      const w = Math.max(1, width | 0);
      const h = Math.max(1, height | 0);

      if (!traderShipSnapshot3D) {
        traderShipSnapshot3D = createPlanetRenderContext({ width: w, height: h, autoAnimate: false, preserveDrawingBuffer: true });
        if (!traderShipSnapshot3D) return null;
        traderShipSnapshot3D.renderer.setPixelRatio(1);
        traderShipSnapshot3D.renderer.setClearColor(0x000000, 0);
        traderShipSnapshot3D.camera.position.set(0, 36, 210);
        traderShipSnapshot3D.camera.lookAt(0, 0, 0);
        traderShipSnapshot3D.light.intensity = 1.25;
        traderShipSnapshot3D.light.position.set(140, 160, 220);
      } else {
        if (traderShipSnapshot3D.width !== w || traderShipSnapshot3D.height !== h) {
          traderShipSnapshot3D.setSize(w, h);
        }
      }

      return traderShipSnapshot3D;
    }

    function clearTraderShipContext(ctx) {
      if (!ctx) return;
      if (typeof ctx.shipCleanup === 'function') {
        try { ctx.shipCleanup(); } catch (e) { console.warn('Trader ship cleanup failed', e); }
      }
      ctx.shipCleanup = null;
      ctx.shipGroup = null;
      ctx.shipModel = null;
      ctx.shipSpinGroup = null;
      ctx.shipAnimationState = null;
      ctx.currentShipKey = null;
    }

    function populateTraderShipContext(ctx, trader, options = {}) {
      const THREE = window.THREE;
      if (!THREE || !ctx) return;

      const frameMode = options.frameMode || 'display';
      const padScale = options.padScale;

      const fallbackSeed = hash32(
        'SHIP_FALLBACK',
        (trader?.ship || 'Unknown').length,
        (trader?.name || 'Anon').length,
        Math.floor(trader?.reputation || 0)
      );
      const shipSeed = (trader && typeof trader.shipSeed === 'number') ? trader.shipSeed >>> 0 : fallbackSeed >>> 0;
      const cacheKey = `ship:${shipSeed}`;
      if (ctx.currentShipKey === cacheKey) {
        return;
      }

      clearTraderShipContext(ctx);

      const profile = generateTraderShipProfile(shipSeed);
      const textures = getTraderShipTextures(shipSeed, profile.palette, ctx.renderer);

      const materials = [];
      const geometries = [];
      const objects = [];
      const lights = [];

      const baseMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xffffff),
        map: textures.base,
        metalness: 0.38,
        roughness: 0.48
      });
      materials.push(baseMaterial);

      const whitePaintMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xf4f6ff),
        metalness: 0.2,
        roughness: 0.36
      });
      materials.push(whitePaintMaterial);

      const accentMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(profile.palette.accent),
        metalness: 0.34,
        roughness: 0.4
      });
      materials.push(accentMaterial);

      const trimMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(profile.palette.trim),
        metalness: 0.22,
        roughness: 0.55
      });
      materials.push(trimMaterial);

      const glassMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(profile.palette.accent).lerp(new THREE.Color(0xffffff), 0.6),
        metalness: 0.04,
        roughness: 0.12,
        transparent: true,
        opacity: 0.35,
        emissive: new THREE.Color(profile.palette.glow).multiplyScalar(0.15),
        emissiveIntensity: 0.6
      });
      glassMaterial.depthWrite = false;
      materials.push(glassMaterial);

      const engineMaterial = new THREE.MeshStandardMaterial({
        color: new THREE.Color(profile.palette.accent).multiplyScalar(0.75),
        metalness: 0.62,
        roughness: 0.3
      });
      materials.push(engineMaterial);

      const boostedGlowColor = new THREE.Color(profile.palette.glow).lerp(new THREE.Color(0xffffff), 0.3);
      const engineGlowMaterial = new THREE.MeshBasicMaterial({
        color: boostedGlowColor,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        depthTest: true,
        side: THREE.DoubleSide,
        toneMapped: false
      });
      materials.push(engineGlowMaterial);

      const assembly = buildTraderShipAssembly(THREE, profile, {
        base: baseMaterial,
        white: whitePaintMaterial,
        accent: accentMaterial,
        trim: trimMaterial,
        glass: glassMaterial,
        engine: engineMaterial,
        engineGlow: engineGlowMaterial
      });

  const shipModel = assembly.group;
  shipModel.position.set(0, 0, 0);
  shipModel.rotation.set(0, 0, 0);

  const shipSpin = new THREE.Group();
  shipSpin.name = 'TraderShipSpin';
  shipSpin.position.set(0, 0, 0);
  shipSpin.rotation.set(0, 0, 0);
  shipSpin.add(shipModel);

  const shipPivot = new THREE.Group();
  shipPivot.name = 'TraderShipPivot';
  shipPivot.position.set(0, 0, 0);
  shipPivot.rotation.set(0, 0, 0);
  shipPivot.add(shipSpin);

  const pitch = THREE.MathUtils.degToRad(-12);
  const yaw = THREE.MathUtils.degToRad(32);
  const roll = Math.PI / 2;
  shipSpin.rotation.set(pitch, yaw, roll);
  ctx.group.add(shipPivot);
  ctx.shipGroup = shipPivot;
  ctx.shipSpinGroup = shipSpin;
  ctx.shipModel = shipModel;

      assembly.meshes.forEach(mesh => {
        if (mesh) objects.push(mesh);
      });
      assembly.geometries.forEach(geo => {
        if (geo) geometries.push(geo);
      });
      assembly.materials.forEach(mat => {
        if (mat) materials.push(mat);
      });
      assembly.lights.forEach(light => {
        if (light) lights.push(light);
      });

      ctx.shipCleanup = () => {
        lights.forEach(light => {
          if (light?.parent) light.parent.remove(light);
        });
        objects.forEach(obj => {
          if (obj?.parent) obj.parent.remove(obj);
        });
        geometries.forEach(geo => {
          if (geo?.dispose) geo.dispose();
        });
        materials.forEach(mat => {
          if (mat?.dispose) mat.dispose();
        });
        if (shipPivot.parent) {
          shipPivot.parent.remove(shipPivot);
        }
        ctx.shipModel = null;
        ctx.shipSpinGroup = null;
      };

      ctx.shipGroup.position.set(0, 0, 0);
      ctx.shipGroup.rotation.set(0, 0, 0);

      const deg = THREE.MathUtils.degToRad;
      if (frameMode === 'snapshot') {
        frameTraderShipInContext(ctx, profile, {
          padScale: typeof padScale === 'number' ? padScale : 1.04,
          centerYOffsetFactor: 0.34,
          centerXOffsetFactor: 0,
          azimuth: deg(34),
          elevation: deg(12),
          distanceBias: 0.22,
          distanceScale: 2 / 3,
          heightBias: 0.05,
          lookAtYOffsetFactor: 0.015,
          rollAmplitude: 0,
          spinMultiplier: 0,
          wobbleMultiplier: 0,
          wobbleRateMultiplier: 0
        });
      } else {
        frameTraderShipInContext(ctx, profile, {
          padScale: typeof padScale === 'number' ? padScale : 1.14,
          centerYOffsetFactor: 0.26,
          centerXOffsetFactor: 0,
          azimuth: deg(30),
          elevation: deg(18),
          distanceBias: 0.28,
          distanceScale: 0.5,
          heightBias: 0.08,
          lookAtYOffsetFactor: 0.02,
          rollAmplitude: 0.035,
          rollFrequency: 0.45,
          spinMultiplier: 0.55,
          wobbleMultiplier: 0.7,
          wobbleRateMultiplier: 0.85
        });
      }
      ctx.currentShipKey = cacheKey;

      ctx.setAnimationCallback((ts, dt) => {
        const anim = ctx.shipAnimationState;
        if (!anim || !ctx.shipGroup) {
          ctx.renderer.render(ctx.scene, ctx.camera);
          return;
        }
        anim.wobblePhase += anim.wobbleRate * dt;
        if (ctx.shipModel) {
          anim.spinAngle = (anim.spinAngle || 0) + anim.spinRate * dt;
          if (anim.spinAngle > Math.PI * 2) {
            anim.spinAngle -= Math.PI * 2;
          }
          ctx.shipModel.rotation.y = anim.spinAngle;
        }
        const rollAmp = typeof anim.rollAmplitude === 'number' ? anim.rollAmplitude : 0.05;
        const rollFreq = typeof anim.rollFrequency === 'number' ? anim.rollFrequency : 0.5;
        ctx.shipGroup.rotation.z = Math.sin(anim.wobblePhase * rollFreq) * rollAmp;
        ctx.shipGroup.position.y = anim.baseY + Math.sin(anim.wobblePhase) * anim.wobbleAmount;
        ctx.renderer.render(ctx.scene, ctx.camera);
      });

      ctx.renderOnce();
      if (!ctx.isAnimating()) {
        ctx.startAnimation();
      }
    }

    function frameTraderShipInContext(ctx, profile, options = {}) {
      const THREE = window.THREE;
      if (!THREE || !ctx || !ctx.shipGroup) return;

      ctx.shipGroup.updateMatrixWorld(true);
      if (ctx.shipModel) {
        ctx.shipModel.rotation.y = 0;
        ctx.shipModel.updateMatrixWorld(true);
        if (ctx.shipSpinGroup) {
          ctx.shipSpinGroup.updateMatrixWorld(true);
        }
        ctx.shipGroup.updateMatrixWorld(true);
      }

      const bbox = new THREE.Box3().setFromObject(ctx.shipGroup);
      if (!Number.isFinite(bbox.min.x) || !Number.isFinite(bbox.max.x)) {
        return;
      }

      const toFinite = (value, fallback) => (typeof value === 'number' && Number.isFinite(value) ? value : fallback);

      const padScale = Math.max(0.6, toFinite(options.padScale, 1.18));

      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      bbox.getSize(size);
      bbox.getCenter(center);

      ctx.shipGroup.position.sub(center);

      const centerXFactor = toFinite(options.centerXOffsetFactor, 0);
      const centerYFactor = toFinite(options.centerYOffsetFactor, 0.2);
      const centerZFactor = toFinite(options.centerZOffsetFactor, 0);

      ctx.shipGroup.position.x -= size.x * centerXFactor;
      ctx.shipGroup.position.y -= size.y * centerYFactor;
      ctx.shipGroup.position.z -= size.z * centerZFactor;

      const sphere = new THREE.Sphere();
      bbox.getBoundingSphere(sphere);
      const radius = Math.max(1, sphere.radius);
      const paddedRadius = radius * padScale;

      const camera = ctx.camera;
      const vFov = THREE.MathUtils.degToRad(camera.fov);
      const vDist = paddedRadius / Math.tan(Math.max(vFov / 2, 0.0001));
      const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect);
      const halfWidth = (size.x * padScale) / 2;
      const hDist = halfWidth / Math.tan(Math.max(hFov * 0.5, 0.0001));
      const baseDistance = Math.max(vDist, hDist);

    const distanceBias = toFinite(options.distanceBias, 0.28);
    const distanceScale = Math.max(0.1, toFinite(options.distanceScale, 1));
    const orbitDistanceRaw = baseDistance + paddedRadius * distanceBias;
    const orbitDistance = Math.max(0.1, orbitDistanceRaw * distanceScale);

      const azimuth = toFinite(options.azimuth, THREE.MathUtils.degToRad(28));
      const elevation = toFinite(options.elevation, THREE.MathUtils.degToRad(14));

      const planarDistance = Math.cos(elevation) * orbitDistance;
      const cameraX = Math.sin(azimuth) * planarDistance;
      const cameraZ = Math.cos(azimuth) * planarDistance;
      const heightBias = toFinite(options.heightBias, 0);
      const cameraY = Math.sin(elevation) * orbitDistance + paddedRadius * heightBias;

      const worldCenter = center.clone().add(ctx.shipGroup.position);
      const lookAtX = worldCenter.x + toFinite(options.lookAtXOffset, 0);
      const lookAtYOffsetFactor = toFinite(options.lookAtYOffsetFactor, 0.05);
      const lookAtY = worldCenter.y + toFinite(options.lookAtYOffset, -size.y * lookAtYOffsetFactor);
      const lookAtZ = worldCenter.z + toFinite(options.lookAtZOffset, 0);

      camera.position.set(cameraX, cameraY, cameraZ);
      camera.lookAt(lookAtX, lookAtY, lookAtZ);
      const range = paddedRadius * 3;
      camera.near = Math.max(0.1, orbitDistance - range);
      camera.far = orbitDistance + range;
      camera.updateProjectionMatrix();

      const wobbleMultiplier = Math.max(0, toFinite(options.wobbleMultiplier, 1));
      const wobbleRateMultiplier = Math.max(0, toFinite(options.wobbleRateMultiplier, 1));
      const spinMultiplier = toFinite(options.spinMultiplier, 1);
      const rollAmplitude = Math.max(0, toFinite(options.rollAmplitude, 0.05));
      const rollFrequency = Math.max(0, toFinite(options.rollFrequency, 0.5));

      const wobbleAmount = profile.wobbleAmount * 0.25 * wobbleMultiplier;
      ctx.shipAnimationState = {
        wobblePhase: 0,
        wobbleRate: profile.wobbleRate * wobbleRateMultiplier,
        wobbleAmount,
        baseY: ctx.shipGroup.position.y,
        spinRate: profile.spinRate * spinMultiplier,
        spinAngle: 0,
        rollAmplitude,
        rollFrequency
      };
    }

    function disposeTraderShipContext() {
      if (!traderShip3D) return;
      try {
        if (traderShip3D._resizeHandler) {
          window.removeEventListener('resize', traderShip3D._resizeHandler);
        }
        clearTraderShipContext(traderShip3D);
        const canvas = traderShip3D.renderer?.domElement;
        traderShip3D.dispose({ forceContextLoss: true });
        if (canvas && canvas.parentNode) {
          canvas.parentNode.removeChild(canvas);
        }
      } catch (e) {
        console.warn('Trader ship context cleanup error', e);
      }
      traderShip3D = null;
    }

    function disposeTraderShipSnapshotContext() {
      if (!traderShipSnapshot3D) return;
      try {
        clearTraderShipContext(traderShipSnapshot3D);
        traderShipSnapshot3D.dispose?.({ forceContextLoss: true });
      } catch (e) {
        console.warn('Trader ship snapshot cleanup error', e);
      }
      traderShipSnapshot3D = null;
    }

    function disposeScannerContext() {
      if (!scanner3D) return;
      const canvasEl = scanner3D.renderer?.domElement;
      scanner3D.dispose({ forceContextLoss: true });
      if (canvasEl && canvasEl.parentNode) {
        canvasEl.parentNode.removeChild(canvasEl);
      }
      scanner3D = null;
    }

    function ensureScannerContext() {
      const container = document.getElementById('scanner-planet');
      if (!container) return null;
      if (!window.THREE) return null;

      const width = Math.max(1, container.clientWidth || 160);
      const height = Math.max(1, container.clientHeight || 160);

      if (!scanner3D) {
        scanner3D = createPlanetRenderContext({ width, height, autoAnimate: false, preserveDrawingBuffer: true });
        if (!scanner3D) return null;
        scanner3D.container = container;
        const canvas = scanner3D.renderer.domElement;
        canvas.style.position = 'absolute';
        canvas.style.inset = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.display = 'block';
        container.appendChild(canvas);
      } else {
        if (scanner3D.container !== container) {
          disposeScannerContext();
          return ensureScannerContext();
        }
        if (scanner3D.width !== width || scanner3D.height !== height) {
          scanner3D.setSize(width, height);
        }
        const canvas = scanner3D.renderer?.domElement;
        if (canvas && canvas.parentNode !== container) {
          container.appendChild(canvas);
        }
      }

      scanner3D.container = container;
      return scanner3D;
    }

    function ensureSnapshotRenderContext(size) {
      if (!window.THREE) return null;
      const clamped = Math.max(1, size | 0);
      if (!snapshot3D) {
        snapshot3D = createPlanetRenderContext({ width: clamped, height: clamped, autoAnimate: false, preserveDrawingBuffer: true });
      } else if (snapshot3D.width !== clamped || snapshot3D.height !== clamped) {
        snapshot3D.setSize(clamped, clamped);
      }
      return snapshot3D;
    }

    function disposeSnapshotRenderContext() {
      if (!snapshot3D) return;
      snapshot3D.dispose({ forceContextLoss: true });
      snapshot3D = null;
    }

    const releaseContexts = () => {
      try { disposeSnapshotRenderContext(); } catch (e) { console.warn('Snapshot context cleanup failed', e); }
      try { disposeTraderShipSnapshotContext(); } catch (e) { console.warn('Trader ship snapshot cleanup failed', e); }
      try {
        if (scanner3D) {
          const canvasEl = scanner3D.renderer?.domElement;
          scanner3D.dispose({ forceContextLoss: true });
          if (canvasEl && canvasEl.parentNode) {
            canvasEl.parentNode.removeChild(canvasEl);
          }
          scanner3D = null;
        }
        if (cockpit3D) {
          cockpit3D.dispose({ forceContextLoss: true });
          cockpit3D = null;
        }
        disposeTraderShipContext();
      } catch (e) {
        console.warn('Context cleanup error', e);
      }
    };

    window.addEventListener('pagehide', releaseContexts, { once: true });
    window.addEventListener('beforeunload', releaseContexts, { once: true });

    function updateCockpit3D(x, y, planetIndex, typeOverride, baseHex) {
      ensureThreeLoaded(() => {
        if (!cockpit3D) initCockpit3D();
        if (!cockpit3D) return; // failed to init

        populatePlanetRenderContext(cockpit3D, x, y, planetIndex, typeOverride, baseHex);
      });
    }

    function updateTraderShipPreview(status, isPowered) {
      const container = document.getElementById('trader-ship-viewport');
      const labelEl = document.getElementById('trader-ship-name');
      if (!container || !labelEl) return;

      if (!isPowered) {
        container.classList.add('offline');
        container.classList.remove('scanning');
        labelEl.textContent = '';
        disposeTraderShipContext();
        return;
      }

      if (!status || !status.trader) {
        container.classList.remove('offline');
        container.classList.add('scanning');
        labelEl.textContent = 'SCANNING...';
        disposeTraderShipContext();
        return;
      }

      container.classList.remove('offline');
      container.classList.remove('scanning');
      const shipLabel = status.trader.shipClass
        ? `${status.trader.ship} • ${status.trader.shipClass}`
        : status.trader.ship;
      labelEl.textContent = shipLabel;

      ensureThreeLoaded(() => {
        if (!window.THREE) return;
        const liveContainer = document.getElementById('trader-ship-viewport');
        const liveLabel = document.getElementById('trader-ship-name');
        if (!liveContainer || !liveLabel || !liveContainer.isConnected) return;
        const ctx = ensureTraderShipContext(liveContainer);
        if (!ctx) return;
        populateTraderShipContext(ctx, status.trader);
      });
    }

    // Rings removed: helper functions deleted

    function createTextureFromCanvas(cnv, renderer, opts={}){
      const THREE = window.THREE;
      const tex = new THREE.CanvasTexture(cnv);
      tex.generateMipmaps = opts.generateMipmaps ?? true;
      tex.minFilter = opts.minFilter ?? THREE.LinearMipmapLinearFilter;
      tex.magFilter = opts.magFilter ?? THREE.LinearFilter;
      tex.wrapS = opts.wrapS ?? THREE.ClampToEdgeWrapping;
      tex.wrapT = opts.wrapT ?? THREE.ClampToEdgeWrapping;
      if (opts.sRGB) tex.colorSpace = THREE.SRGBColorSpace;
      const maxAniso = renderer?.capabilities?.getMaxAnisotropy?.() || 8;
      tex.anisotropy = Math.min(maxAniso, opts.anisotropy ?? maxAniso);
      tex.needsUpdate = true;
      return tex;
    }

    function applyPlanetAlbedoLift(material, profile) {
      if (!material || material.userData?.albedoLiftApplied) return;
      const gamma = profile?.albedoGamma ?? (profile?.group === 'Desert' ? 0.82 : 0.88);
      const gain = profile?.albedoGain ?? (profile?.group === 'Desert' ? 1.18 : 1.08);
      const saturationBoost = profile?.albedoSaturation ?? (profile?.group === 'Desert' ? 0.18 : 0.1);
      material.onBeforeCompile = (shader) => {
        shader.fragmentShader = shader.fragmentShader.replace(
          'vec4 diffuseColor = vec4( diffuse, opacity );',
          `
            vec3 lifted = pow( max(vec3(0.0), diffuse), vec3(${gamma.toFixed(2)}) );
            float luma = dot(lifted, vec3(0.299, 0.587, 0.114));
            lifted = lifted + (lifted - vec3(luma)) * ${saturationBoost.toFixed(2)};
            lifted *= ${gain.toFixed(2)};
            lifted = clamp(lifted, 0.0, 1.5);
            vec4 diffuseColor = vec4( lifted, opacity );
          `
        );
      };
      material.customProgramCacheKey = () => `planet_albedo_lift_${gamma}_${gain}_${saturationBoost}`;
      material.userData.albedoLiftApplied = true;
      material.needsUpdate = true;
    }

    function generatePlanetTextureSet(x, y, planetIndex, typeOverride, baseHex, size=RENDER_QUALITY.textureSize) {
      const THREE = window.THREE;
      const seedU32 = hash32('TEX', x|0, y|0, planetIndex|0);
      const rng = seededRandom(seedU32);
      const profile = choosePlanetProfile(rng, typeOverride);
      const baseRGB = hexToRgb(baseHex || profile.baseColor);
      const oceanRGB = hexToRgb(profile.oceanColor || '#204a87');
      const landRGB = hexToRgb(profile.landColor || '#8f7e5b');
      const iceRGB = hexToRgb(profile.iceColor || '#dfefff');
      const cloudRGB = hexToRgb(profile.cloudColor || '#ffffff');
      const lavaRGB = hexToRgb(profile.lavaColor || '#ff5a1f');
      const n0 = makeFractalNoise3D(hash32('TN0', seedU32), 4, 0.5);
      const n1 = makeFractalNoise3D(hash32('TN1', seedU32), 5, 0.5);
      const n2 = makeFractalNoise3D(hash32('TN2', seedU32), 3, 0.6);

  const cnvA = document.createElement('canvas'); cnvA.width = size; cnvA.height = size;
      const cnvB = document.createElement('canvas'); cnvB.width = size; cnvB.height = size;
      const cnvR = document.createElement('canvas'); cnvR.width = size; cnvR.height = size;
      const cnvE = document.createElement('canvas'); cnvE.width = size; cnvE.height = size;
      const cnvC = document.createElement('canvas'); cnvC.width = size; cnvC.height = size;
  const cnvM = document.createElement('canvas'); cnvM.width = size; cnvM.height = size; // metalness
      const ctxA = cnvA.getContext('2d'); const imgA = ctxA.createImageData(size, size);
      const ctxB = cnvB.getContext('2d'); const imgB = ctxB.createImageData(size, size);
      const ctxR = cnvR.getContext('2d'); const imgR = ctxR.createImageData(size, size);
      const ctxE = cnvE.getContext('2d'); const imgE = ctxE.createImageData(size, size);
      const ctxC = cnvC.getContext('2d'); const imgC = ctxC.createImageData(size, size);
  const ctxM = cnvM.getContext('2d'); const imgM = ctxM.createImageData(size, size);

      const seaLevel = profile.seaLevel;
      const mountainAmp = profile.mountainAmp;
      const cloudCover = profile.cloudCover;
  const gasBands = profile.gasBands;
      const bandScale = profile.bandScale || 25;
      const bandWarp = profile.bandWarp || 0.0;
  const glowLava = !!profile.glowLava;
  // Extra seeded features per-planet
  const featSeed = hash32('FEA', seedU32);
  const featRng = seededRandom(featSeed);
  const hasLavaLakes = (!gasBands && (profile.group === 'Volcanic' || (profile.group === 'Rocky' && featRng() < 0.15)));
  const hasCityLights = (!!profile.cityLights);
  const hasGiantStorms = (profile.group === 'Gas Giant');

      const tilt = (rng() * 0.6 - 0.3) * Math.PI; // -0.3..0.3 rad
      const rot = rng() * Math.PI * 2;
      const rotMat = composeRotation(tilt, rot);

      // Seeded crater field
      const craterRng = seededRandom(hash32('TCR', seedU32));
      const craterCount = profile.hasCraters ? Math.floor(craterRng()*40)+20 : 0; // 20..60
      const craters = [];
      for (let i=0;i<craterCount;i++){
        const u = craterRng();
        const v = craterRng();
        const theta = 2*Math.PI*u;
        const phi = Math.acos(2*v - 1);
        const p = [ Math.sin(phi)*Math.cos(theta), Math.sin(phi)*Math.sin(theta), Math.cos(phi) ];
        const r = (0.008 + craterRng()*0.035) * (profile.group === 'Frozen' ? 1.2 : 1.0);
        craters.push({ p, r });
      }

  // Desert dunes: locally oriented, noise-driven ridges (no planet-wide bands)
  const duneFreq = 38 + rng()*26;       // ridge frequency in local coords
  const duneAmp  = 0.10 + rng()*0.10;   // bump contribution from dunes
  const duneWarp = 0.6 + rng()*0.6;     // warp strength for jittering ridges
  const dunePatchiness = 0.45 + rng()*0.25; // controls where dunes occur

      // Seeded scars
      const scarRng = seededRandom(hash32('SCR', seedU32));
      const scarCount = (profile.group === 'Rocky' || profile.group === 'Desert') ? Math.floor(scarRng()*3)+1 : 0;
      const scars = [];
      for (let i=0;i<scarCount;i++){
        const u = scarRng(); const v = scarRng();
        const theta = 2*Math.PI*u;
        const phi = Math.acos(2*v - 1);
        const p = [ Math.sin(phi)*Math.cos(theta), Math.sin(phi)*Math.sin(theta), Math.cos(phi) ];
        const r = 0.15 + scarRng()*0.25; // large blotches
        scars.push({ p, r });
      }

      // Polar cap variability (seeded per-planet)
    const capRng = seededRandom(hash32('CAP', seedU32));
    const capsEnabled = !!profile.polarCaps;
  // Fixed cap extent: extend 15° from the pole toward the equator => latitude 75° => |ny| threshold = sin(75°)
  const capExtent = capsEnabled ? Math.sin(75 * Math.PI/180) : 1.0;
      const capRoughTarget = 0.30 + capRng()*0.10; // slightly shinier ice target roughness

      for (let y0=0, idx=0; y0<size; y0++){
        const v = (y0 / (size-1)) * Math.PI - Math.PI/2; // -pi/2..pi/2
        for (let x0=0; x0<size; x0++, idx+=4){
          const u = (x0 / (size-1)) * 2*Math.PI - Math.PI; // -pi..pi
          // unit sphere normal from equirectangular
          let nx = Math.cos(v) * Math.cos(u);
          let ny = Math.sin(v);
          let nz = Math.cos(v) * Math.sin(u);
          const nRot = applyMat(rotMat, [nx, ny, nz]);
          nx = nRot[0]; ny = nRot[1]; nz = nRot[2];

          const cont = n0(nx*1.2, ny*1.2, nz*1.2);
          const detail = n1(nx*6.0, ny*6.0, nz*6.0);
          let height = cont * 0.7 + detail * 0.3;
          let bandT = 0;
          if (gasBands) {
            const s = ny * bandScale + n2(nx*1.2, ny*1.2, nz*1.2) * bandWarp;
            bandT = 0.5 + 0.5 * Math.sin(s);
          }

          let albedo = baseRGB;
          let rough = 0.8; // default land
          let bump = 0.5;
          let emiss = [0,0,0];
          let clouds = 0;
          if (!gasBands) {
            if (profile.hasOceans && height < seaLevel) {
              const depth = (seaLevel - height) / Math.max(1e-5, seaLevel + 1);
              albedo = lerpRgb(oceanRGB, baseRGB, 0.2 + 0.5 * Math.min(1, depth));
              // oceans a bit less specular (higher roughness), subtle bump
              rough = 0.35; bump = 0.15;
            } else {
              let t = Math.max(0, height - seaLevel) * mountainAmp;
              t = Math.min(1, t);
              // Four-color palette sampling to increase definition
              const isDesert = (profile.group === 'Desert');
              const isBarren = (profile.key === 'Barren' || profile.group === 'Rocky');
              const isVolcanicLand = (profile.group === 'Volcanic' && profile.key !== 'Lava Ocean');
              const isFrozen = (profile.group === 'Frozen');
              const palKey = isDesert
                ? (profile.paletteKey && FOUR_PALETTES[profile.paletteKey] ? profile.paletteKey : (profile.key === 'Dune' ? 'Dune' : 'Desert'))
                : (isBarren ? 'Rocky' : (isVolcanicLand ? 'VolcanicLand' : (isFrozen ? 'Frozen' : null)));
              if (palKey) {
                const pal = FOUR_PALETTES[palKey].map(hexToRgb);
                // Elevation-based index with valley emphasis via negative detail noise
                const valley = 0.5 + 0.5 * (-Math.abs(n1(nx*2.5+7, ny*2.5-9, nz*2.5+3)) + 1.0);
                const idxT = clamp01(0.25 * valley + 0.75 * t);
                albedo = sample4(pal, idxT);
              } else {
                albedo = lerpRgb(landRGB, baseRGB, 0.4 + 0.6 * t);
              }
              rough = 0.82; bump = 0.6;
              if (isFrozen) {
                // Snow/ice reflect more light: slightly brighten and lower base roughness
                albedo = lerpRgb(albedo, [255,255,255], 0.06);
                rough = Math.min(rough, 0.65);
              }
              // Volcanic world base (non-lava-ocean): basalt and ash variety
              if (profile.group === 'Volcanic' && profile.key !== 'Lava Ocean') {
                // Blend toward dark basalt
                albedo = lerpRgb(albedo, [45,42,48], 0.5);
                // Ashy deposits
                const ashField = 0.5 + 0.5 * n1(nx*3.0 + 5.2, ny*3.0 - 1.1, nz*3.0 + 2.7);
                const ashMask = Math.max(0, ashField - 0.35);
                albedo = lerpRgb(albedo, [110,104,98], Math.min(0.35, ashMask*0.35));
                bump = Math.min(1.0, bump + ashMask*0.12);
                rough = Math.max(0.78, rough);
              }
              // Ice near poles with variability and noisy edge (latitude-based)
              if (capsEnabled) {
                const poleLat = Math.abs(ny); // 0 at equator, 1 at pole
                // base edge: starts near capExtent, then ramps to 1
                const edgeBase = Math.max(0, (poleLat - capExtent) / Math.max(1e-5, (1.0 - capExtent)));
                const edgeNoise = Math.max(0, n1(nx*2.5+11, ny*2.5-7, nz*2.5+3) * 0.18);
                let cap = Math.max(0, Math.min(1, Math.pow(edgeBase + edgeNoise, 2.2)));
                if (cap > 0) {
                  // Use Frozen palette bright tones for snowcaps
                  const palF = FOUR_PALETTES.Frozen.map(hexToRgb);
                  const snowCol = sample4(palF, 0.88 + 0.12 * cap);
                  // Stronger blend for visibility
                  albedo = lerpRgb(albedo, snowCol, Math.min(0.85, 0.85 * cap));
                  // Snow reflects: lower roughness aggressively on caps
                  rough = lerp(rough, Math.min(0.28, capRoughTarget), cap*0.9);
                  // Sastrugi/ridged snow detail
                  const ridged = 1.0 - Math.abs(n2(nx*12.0+31, ny*12.0-17, nz*12.0+13));
                  const sMask = Math.max(0, (ridged - 0.72) / 0.20);
                  if (sMask > 0) {
                    bump = Math.min(1.0, bump + sMask * 0.10 * cap);
                  }
                  // Edge accent for definition
                  const edge = cap * (1 - cap);
                  bump = Math.min(1.0, bump + edge * 0.06);
                }
              }
              // Deserts sunlit bias: very subtle to avoid washing out palette separation
              if (profile.group === 'Desert') {
                albedo = lerpRgb(albedo, [255, 244, 220], 0.06);
                rough = Math.max(0.7, rough - 0.03);
              }
            }
            // Terrain feature overlays
            // Dunes: use local equirectangular (u,v) with warped orientation and patch mask to avoid global ribs
            if (profile.group === 'Desert' || profile.key === 'Dune') {
              // Convert to local 0..1 uv (reuse u,v computed earlier)
              const U = (Math.atan2(nz, nx) + Math.PI) / (2*Math.PI); // 0..1
              const V = (Math.asin(ny) + Math.PI/2) / Math.PI;       // 0..1
              // Orientation field from low-frequency noise
              const ori = n0(nx*0.8+13, ny*0.8-7, nz*0.8+5) * Math.PI; // 0..pi
              const sU = Math.cos(ori), sV = Math.sin(ori);
              // Warped ridge coordinate
              const wU = U + duneWarp * n1(nx*2.2+3, ny*2.2-1, nz*2.2+7) * 0.02;
              const wV = V + duneWarp * n1(nx*2.0-4, ny*2.0+6, nz*2.0-2) * 0.02;
              const coord = (wU*sU + wV*sV);
              const ridge = Math.sin(coord * duneFreq * 6.283185307179586);
              // Patch mask: where dunes exist vs. flats/rock
              let patch = n0(nx*1.6+21, ny*1.6-11, nz*1.6+9);
              patch = smoothstep(dunePatchiness-0.15, dunePatchiness+0.10, patch);
              // Primary dune contribution (shaped to be mostly positive heights)
              const ridgePos = Math.max(0.0, ridge);
              const duneStrength = duneAmp * 1.8; // stronger relief on deserts
              const dMask = ridgePos * patch;
              bump += dMask * duneStrength;

              // Macro undulations (longer-wavelength sets of dunes)
              const macroFreq = duneFreq * 0.22;
              const macroRidge = Math.sin(coord * macroFreq * 6.283185307179586 + n0(nx*0.7-5, ny*0.7+2, nz*0.7-3)*1.57);
              const macroMask = smoothstep(0.35, 0.75, n1(nx*0.9+17, ny*0.9-9, nz*0.9+4));
              const macro = Math.max(0, macroRidge) * macroMask;
              bump += macro * 0.12;

              // Fine ripples to catch light at grazing angles
              const ripple = 0.5 + 0.5 * n2(nx*18.0+9, ny*18.0-13, nz*18.0+5);
              bump += Math.max(0, ripple - 0.7) * 0.05;

              // Slight albedo lift with desaturation toward sand color
              const sandTint = [248, 236, 210];
              albedo = lerpRgb(albedo, sandTint, dMask*0.06 + macro*0.04);
              // Blotchy albedo variation: wind-blown pale sand and darker rocky patches
              // Domain-warped FBM-style masks to avoid defined shapes
              {
                // Light sand blotches
                const w1x = n1(nx*1.3+31, ny*1.3-19, nz*1.3+7) * 0.25;
                const w1y = n1(nx*1.1-23, ny*1.1+17, nz*1.1-5) * 0.25;
                const w1z = n1(nx*1.2+11, ny*1.2+13, nz*1.2-9) * 0.25;
                const lBase = 0.5 + 0.5 * n0(nx*1.6 + w1x + 9, ny*1.6 + w1y - 4, nz*1.6 + w1z + 3);
                const lMod  = 0.5 + 0.5 * n2(nx*2.8 - 6, ny*2.8 + 8, nz*2.8 + 1);
                let lMask = lBase * lMod;
                // Sharper, less blurred mask
                lMask = smoothstep(0.60, 0.74, lMask);
                lMask = Math.pow(lMask, 1.6);
                if (lMask > 0) {
                  const lightTint = [252, 240, 215];
                  const li = Math.min(0.26, 0.26 * lMask);
                  albedo = lerpRgb(albedo, lightTint, li);
                  // Edge accent to add definition (small positive relief at boundaries)
                  const lEdge = lMask * (1 - lMask);
                  bump = Math.max(0, bump + lEdge * 0.05 - 0.02 * lMask);
                  rough = Math.max(0.68, rough - 0.025 * lMask);
                }
                // Dark rock blotches (e.g., lava remnants, rocky plateaus)
                const w2x = n2(nx*1.0-17, ny*1.0+21, nz*1.0+15) * 0.30;
                const w2y = n2(nx*1.2+27, ny*1.2-15, nz*1.2-11) * 0.30;
                const w2z = n2(nx*1.1+19, ny*1.1+13, nz*1.1-17) * 0.30;
                const dBase = 0.5 + 0.5 * n0(nx*1.4 + w2x - 5, ny*1.4 + w2y + 6, nz*1.4 + w2z - 2);
                const dMod  = 0.5 + 0.5 * n1(nx*3.0 + 3, ny*3.0 - 9, nz*3.0 + 7);
                let dMask = dBase * dMod;
                dMask = smoothstep(0.64, 0.80, dMask);
                dMask = Math.pow(dMask, 1.5);
                if (dMask > 0) {
                  const darkTint = [110, 95, 85];
                  const di = Math.min(0.22, 0.22 * dMask);
                  albedo = lerpRgb(albedo, darkTint, di);
                  // Darker rocky areas: slightly rougher and higher relief, with edge accent
                  const dEdge = dMask * (1 - dMask);
                  bump = Math.min(1.0, bump + 0.12 * dMask + 0.05 * dEdge);
                  rough = Math.min(1.0, rough + 0.06 * dMask);
                }
              }
            }
            // Crater rims and floors
            if (profile.hasCraters && craters.length){
              let rimAccum = 0, floorAccum = 0;
              for (let i=0;i<craters.length;i++){
                const cp = craters[i].p; const cr = craters[i].r;
                const dot = nx*cp[0] + ny*cp[1] + nz*cp[2];
                const ang = Math.acos(Math.max(-1, Math.min(1, dot)));
                const sC = ang / cr;
                if (sC < 1.0) {
                  const tC = 1.0 - sC;
                  // Rim ring around sC~1: emphasize at 0.8..1 region
                  const rim = Math.max(0, Math.min(1, (sC>0.75? (sC-0.75)/0.25 : 0)));
                  rimAccum = Math.max(rimAccum, rim);
                  // Floor darkening at center
                  floorAccum = Math.max(floorAccum, tC*tC);
                }
              }
              if (rimAccum > 0){
                bump += rimAccum * 0.35; // elevated rim
                albedo = lerpRgb(albedo, [230, 220, 210], rimAccum*0.12);
              }
              if (floorAccum > 0){
                albedo = lerpRgb(albedo, [60, 60, 60], floorAccum*0.15);
                rough = Math.min(0.95, rough + floorAccum*0.05);
              }
            }
            // Scars (ink-blot)
            if (scars.length){
              let scarMask = 0;
              for (let i=0;i<scars.length;i++){
                const sp = scars[i].p; const sr = scars[i].r;
                const dot = nx*sp[0] + ny*sp[1] + nz*sp[2];
                const ang = Math.acos(Math.max(-1, Math.min(1, dot)));
                const sS = ang / sr;
                if (sS < 1.0){
                  const tS = 1.0 - sS;
                  scarMask = Math.max(scarMask, Math.pow(tS, 1.5));
                }
              }
              if (scarMask > 0) {
                albedo = lerpRgb(albedo, [90, 80, 75], scarMask*0.25);
                bump += scarMask * 0.15;
                rough = Math.min(1.0, rough + scarMask*0.1);
              }
            }
            // clouds
            if (profile.atmosphere && cloudCover > 0) {
              const cloud = 0.5 + 0.5 * n2(nx*3.5 + 20, ny*3.5 + 20, nz*3.5 + 20);
              const swirl = n1(nx*1.5 - ny*1.5, ny*1.5 + nz*1.5, nz*1.5 - nx*1.5);
              clouds = Math.max(0, cloud * 0.8 + swirl * 0.2 - (1.0 - cloudCover));
            }

            // Ice world extras: cracks/chasms and equatorial melt pools
            if (profile.group === 'Frozen') {
              // crack network using ridged noise
              const ridged = 1.0 - Math.abs(n2(nx*9.0+31, ny*9.0-17, nz*9.0+13));
              const crackMask = Math.max(0, Math.min(1, (ridged - 0.78) / 0.06));
              if (crackMask > 0) {
                const c = Math.pow(crackMask, 1.3);
                albedo = lerpRgb(albedo, [120,130,140], c*0.25);
                bump = Math.min(1.0, bump + c*0.12);
                rough = Math.min(1.0, rough + c*0.05);
              }
              // equatorial melt pools (dark, smoother, lower bump)
              const latAbs = Math.abs(ny);
              if (latAbs < 0.35) {
                const poolNoise = 0.5 + 0.5 * n1(nx*6.0+57, ny*6.0-21, nz*6.0+8);
                const bias = 0.75 - 0.25 * (1.0 - (latAbs/0.35));
                const poolMask = Math.max(0, poolNoise - bias);
                if (poolMask > 0) {
                  const melt = Math.min(1, poolMask * 0.8);
                  const poolRGB = [70, 90, 105];
                  albedo = lerpRgb(albedo, poolRGB, melt*0.4);
                  rough = lerp(rough, 0.25, melt*0.6);
                  bump = Math.max(0, bump - melt*0.1);
                }
              }
            }
            // Lava lakes: pool-like emissive patches near low elevations
            if (hasLavaLakes) {
              const basin = 0.5 + 0.5 * n2(nx*4.5 + 77.3, ny*4.5 - 13.2, nz*4.5 + 5.1);
              const pool = Math.max(0, (seaLevel - height) * 0.8 + (basin - 0.75));
              if (pool > 0.0) {
                const e = Math.min(1, pool * 2.0);
                emiss = [ Math.max(emiss[0], lavaRGB[0]*e), Math.max(emiss[1], lavaRGB[1]*e), Math.max(emiss[2], lavaRGB[2]*e) ];
                albedo = lerpRgb(albedo, [60, 30, 20], Math.min(0.5, e*0.3));
                rough = Math.max(rough, 0.7);
              }
            }
            // City lights on night side (for MegaCity): subtle emissive speckle based on lat-long
            if (hasCityLights) {
              // Day-night via seeded light direction matching cockpit 3D
              const L = getSeededLightDir(x, y, planetIndex);
              const N = normalize([nx, ny, nz]);
              const ndotl = N[0]*L[0] + N[1]*L[1] + N[2]*L[2];
              if (ndotl < 0.0) {
                const grid = 0.5 + 0.5 * Math.sin(u * 28.0 + 9.0 * Math.sin(v * 17.0));
                const dens = 0.5 + 0.5 * n1(nx*10.0 + 3.1, ny*10.0 - 1.7, nz*10.0 + 2.3);
                const lights = Math.max(0, grid * dens - 0.65);
                if (lights > 0) {
                  const e = lights * 1.0;
                  const cc = hexToRgb(profile.cityColor || '#ffd080');
                  emiss = [ Math.max(emiss[0], cc[0]*e), Math.max(emiss[1], cc[1]*e), Math.max(emiss[2], cc[2]*e) ];
                  rough = Math.min(1.0, rough + lights*0.05);
                }
              }
            }
            if (glowLava) {
              // dark solidified rock base, with emissive seams only
              albedo = lerpRgb(albedo, [60, 35, 25], 0.5);
              rough = Math.max(rough, 0.75);
              const fissVal = 0.5 + 0.5 * n2(nx*12.0, ny*12.0, nz*12.0);
              // Soot darkening near hot seams
              const soot = Math.max(0, Math.min(1, (fissVal - 0.7) / 0.15));
              if (soot > 0) {
                albedo = lerpRgb(albedo, [35, 30, 28], soot * 0.4);
                rough = Math.min(1.0, rough + soot*0.05);
              }
              if (fissVal > 0.84) {
                const e = (fissVal - 0.84) / 0.16;
                emiss = [ Math.max(emiss[0], lavaRGB[0]*e), Math.max(emiss[1], lavaRGB[1]*e), Math.max(emiss[2], lavaRGB[2]*e) ];
                bump = Math.max(bump, 0.55);
              }
            }
          } else {
            // Gas giant: variable-width meandering bands with palette and storms
            const paletteHex = Array.isArray(profile.gasPalette) ? profile.gasPalette : [];
            let gasPal = paletteHex.length ? paletteHex.map(hexToRgb) : [
              lightenRgb(baseRGB, 0.2), lightenRgb(baseRGB, 0.05), darkenRgb(baseRGB, 0.08), darkenRgb(baseRGB, 0.2)
            ];
            // Palette diversity with seeded accents
            const gRnd = seededRandom(hash32('GPL', seedU32));
            if (gRnd() < 0.7) {
              const accents = [ [180,220,240], [200,170,220], [240,190,160], [180,210,180], [160,210,200], [220,200,140], [190,200,230], [210,180,200] ];
              const pick = () => accents[Math.floor(gRnd()*accents.length)];
              const a1 = pick();
              const a2 = pick();
              const mix = (c,d,t)=>[ lerp(c[0],d[0],t), lerp(c[1],d[1],t), lerp(c[2],d[2],t) ];
              const p0 = lightenRgb(baseRGB, 0.18);
              const p1 = mix(baseRGB, a1, 0.35 + gRnd()*0.25);
              const p2 = mix(baseRGB, a2, 0.25 + gRnd()*0.25);
              const p3 = darkenRgb(baseRGB, 0.22);
              gasPal = [p0,p1,p2,p3];
            }
            // Meander bands with longitude-dependent phase and variable width
            const lon = u; // -pi..pi
            const lat = ny; // -1..1
            const phase = lat * bandScale + n2(nx*1.2, ny*1.2, nz*1.2) * bandWarp + 0.8 * Math.sin(lon * (2.0 + 0.6 * n1(nx*0.7, ny*0.7, nz*0.7)) + 3.14 * n1(nx*0.3+10, ny*0.3-7, nz*0.3+5));
            const wave = 0.5 + 0.5 * Math.sin(phase);
            const widthVar = 0.22 + 0.55 * (0.5 + 0.5 * n2(nx*0.9+21, ny*0.9-13, nz*0.9+7)); // variable stripe thickness
            const stripe = smoothstep01((wave - (0.5 - widthVar)) / (widthVar*2.0));
            // Secondary family to create splits/merges
            const phase2 = lat * (bandScale*0.62) + 0.6 * Math.sin(lon*1.3 + n1(nx*0.5+3, ny*0.5-2, nz*0.5+4));
            const wave2 = 0.5 + 0.5 * Math.sin(phase2);
            const widthVar2 = 0.18 + 0.45 * (0.5 + 0.5 * n1(nx*0.8+1, ny*0.8+2, nz*0.8-1));
            const stripe2 = smoothstep01((wave2 - (0.5 - widthVar2)) / (widthVar2*2.0));
            const bandMix = Math.max(stripe, stripe2) * (0.7 + 0.3 * (0.5 + 0.5*Math.sin(lon*0.7)));
            // Color from palette along latitude with slight longitudinal drift
            const tColor = Math.max(0, Math.min(1, 0.5 + 0.5 * Math.sin(lat * (bandScale*0.33) + lon*0.08)));
            const cA = samplePalette(gasPal, tColor);
            const cB = samplePalette(gasPal, Math.max(0, Math.min(1, tColor + 0.18*(0.5 + 0.5*Math.sin(lon*0.3)))));
            let bandBase = lerpRgb(cB, cA, bandMix);
            // Desaturate slightly to avoid toy-like bands
            bandBase = lerpRgb(bandBase, [200,200,200], 0.18);
            albedo = bandBase;
            // Multiple cyclones/ovals
            if (hasGiantStorms) {
              const stormCount = 1 + Math.floor(featRng()*3); // 1..3
              for (let si=0; si<stormCount; si++) {
                const sx = (featRng()*2.0 - 1.0) * Math.PI;
                const sy = (featRng()*1.8 - 0.9) * (Math.PI/2);
                const dx = angleDiff(u, sx);
                const dy = angleDiff(v, sy);
                const radX = 0.18 + featRng()*0.35;
                const radY = 0.10 + featRng()*0.25;
                const e = Math.max(0, 1.0 - Math.hypot(dx/radX, dy/radY));
                if (e > 0) {
                  const edge = smoothstep01(e);
                  const bright = featRng() < 0.6;
                  const tint = bright ? [240,240,240] : [150,135,120];
                  albedo = lerpRgb(albedo, tint, 0.22 * edge);
                }
              }
            }
            // High clouds layer to break stripes
            const hCloud = Math.max(0, (0.5 + 0.5 * n2(nx*4.0+20, ny*4.0+20, nz*4.0+20)) * 0.9 - 0.45);
            clouds = Math.max(clouds, hCloud * 0.8);
            // Slightly glossier to reflect more on lit side
            rough = 0.45; bump = 0.15;
          }

          // Metallic/Crystal tweak
          let metal = 0;
          if (profile.group === 'Metallic') {
            metal = 0.6;
            rough = Math.max(0.3, rough - 0.25);
          }
          if (profile.key === 'Crystal') {
            metal = 0.2;
            rough = Math.max(0.2, rough - 0.2);
          }

          // write albedo (sRGB)
          imgA.data[idx] = clamp255(albedo[0]);
          imgA.data[idx+1] = clamp255(albedo[1]);
          imgA.data[idx+2] = clamp255(albedo[2]);
          imgA.data[idx+3] = 255;
          // bump (grayscale)
          const b = clamp255(bump*255);
          imgB.data[idx] = b; imgB.data[idx+1] = b; imgB.data[idx+2] = b; imgB.data[idx+3] = 255;
          // roughness (grayscale)
          const r = clamp255(rough*255);
          imgR.data[idx] = r; imgR.data[idx+1] = r; imgR.data[idx+2] = r; imgR.data[idx+3] = 255;
          // metalness (grayscale)
          const m = clamp255(metal*255);
          imgM.data[idx] = m; imgM.data[idx+1] = m; imgM.data[idx+2] = m; imgM.data[idx+3] = 255;
          // emissive (RGB)
          imgE.data[idx] = clamp255(emiss[0]);
          imgE.data[idx+1] = clamp255(emiss[1]);
          imgE.data[idx+2] = clamp255(emiss[2]);
          imgE.data[idx+3] = 255;
          // clouds alpha
          const ca = clamp255(Math.max(0, Math.min(1, clouds)) * 255);
          imgC.data[idx] = 255; imgC.data[idx+1] = 255; imgC.data[idx+2] = 255; imgC.data[idx+3] = ca;
        }
      }
      ctxA.putImageData(imgA, 0, 0);
      ctxB.putImageData(imgB, 0, 0);
      ctxR.putImageData(imgR, 0, 0);
      ctxE.putImageData(imgE, 0, 0);
      ctxC.putImageData(imgC, 0, 0);

      // Generate normal map from bump
      const cnvN = generateNormalMapFromHeightCanvas(cnvB);

      return { albedoCanvas: cnvA, bumpCanvas: cnvB, normalCanvas: cnvN, roughnessCanvas: cnvR, metalnessCanvas: cnvM, emissiveCanvas: cnvE, cloudCanvas: cnvC };
    }

    function generateNormalMapFromHeightCanvas(heightCanvas) {
      const w = heightCanvas.width, h = heightCanvas.height;
      const ctx = heightCanvas.getContext('2d');
      const src = ctx.getImageData(0,0,w,h).data;
      const dstCanvas = document.createElement('canvas'); dstCanvas.width = w; dstCanvas.height = h;
      const dctx = dstCanvas.getContext('2d');
      const out = dctx.createImageData(w,h);
      const getH = (x,y) => {
        x = (x + w) % w; y = Math.max(0, Math.min(h-1, y));
        const i = (y*w + x) * 4;
        return src[i] / 255; // grayscale
      };
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const sx = (getH(x+1,y) - getH(x-1,y));
          const sy = (getH(x,y+1) - getH(x,y-1));
          const nx = -sx, ny = -sy, nz = 1.0;
          const len = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
          const r = Math.round((nx/len*0.5 + 0.5)*255);
          const g = Math.round((ny/len*0.5 + 0.5)*255);
          const b = Math.round((nz/len*0.5 + 0.5)*255);
          const i = (y*w + x) * 4;
          out.data[i] = r; out.data[i+1] = g; out.data[i+2] = b; out.data[i+3] = 255;
        }
      }
      dctx.putImageData(out, 0, 0);
      return dstCanvas;
    }

    /**
     * Generate a procedural starfield based on location
     */
    function updateStarfield(x, y, planetIndex) {
      const viewport = document.querySelector('.window .viewport');
      if (!viewport) return;
      
      // Generate seed from location
      let seed = (x * 73856093) ^ (y * 19349663) ^ (planetIndex * 83492791);
      seed = Math.abs(seed) + 1;
      const rng = new SeededRNG(seed);
      
      // Generate 50-80 stars for a rich starfield
      const starCount = rng.nextInt(50, 80);
      const starGradients = [];
      const starSizes = [];
      
      for (let i = 0; i < starCount; i++) {
        const x = rng.next() * 100; // 0-100%
        const y = rng.next() * 100; // 0-100%
        const size = rng.nextInt(1, 3); // 1-3px
        const brightness = 0.6 + (rng.next() * 0.4); // 0.6-1.0
        
        starGradients.push(`radial-gradient(${size}px ${size}px at ${x.toFixed(1)}% ${y.toFixed(1)}%, rgba(255,255,255,${brightness.toFixed(2)}), transparent)`);
        starSizes.push('200% 200%');
      }
      
      // Create CSS for ::before pseudo-element
      const styleId = 'starfield-style';
      let styleEl = document.getElementById(styleId);
      if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = styleId;
        document.head.appendChild(styleEl);
      }
      
      styleEl.textContent = `
        .window .viewport::before {
          content: '';
          position: absolute;
          inset: -50%;
          background: ${starGradients.join(',\n        ')};
          background-size: ${starSizes.join(', ')};
          background-repeat: repeat;
          animation: 
            starfieldFigureEight 120s ease-in-out infinite,
            starfieldTwinkle 8s ease-in-out infinite;
          pointer-events: none;
        }
      `;
    }

    /**
     * Travel Animation System
     * Manages the cinematic travel sequence:
     * 1. Departure: Planet/stars move down (ship goes up)
     * 2. Warp: Burst effect during travel
     * 3. Arrival: New planet grows into view
     */
    const travelAnimationSystem = {
      isAnimating: false,
      travelDuration: 0,
      warpAnimationFrame: null,
      // Helpers to toggle 3D canvas visibility
      hide3D() {
        try {
          if (window.cockpit3D && cockpit3D.renderer && cockpit3D.renderer.domElement) {
            cockpit3D.renderer.domElement.style.display = 'none';
          }
        } catch (_) {}
      },
      show3D() {
        try {
          if (window.cockpit3D && cockpit3D.renderer && cockpit3D.renderer.domElement) {
            cockpit3D.renderer.domElement.style.display = '';
          }
        } catch (_) {}
      },
      
      /**
       * Generate procedural warp streaks emanating from center
       */
      generateWarpStreaks(warpBurst, streakCount = 60) {
        // Clear existing content
        warpBurst.innerHTML = '';
        
        // Create SVG
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 400 220'); // Match viewport aspect ratio
        
        // Store streaks data for continuous spawning
        svg.dataset.centerX = '200';
        svg.dataset.centerY = '110';
        svg.dataset.nextSpawnTime = '0';
        svg.dataset.streakIdCounter = '0';
        
        warpBurst.appendChild(svg);
      },
      
      /**
       * Create a single new warp streak at the center
       */
      createWarpStreak(svg, angle, rng) {
        const centerX = parseFloat(svg.dataset.centerX);
        const centerY = parseFloat(svg.dataset.centerY);
        
        const speed = 150 + rng.next() * 200; // Pixels per second
        const length = 30 + rng.next() * 50; // 30-80 units long
        const width = 0.8 + rng.next() * 1.8; // Vary thickness
        
        // Create polygon element
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polygon.setAttribute('class', 'star-streak');
        
        // Color: cyan-white spectrum for hyperspace feel
        const brightness = 0.6 + rng.next() * 0.4;
        const cyan = Math.floor(150 + brightness * 105); // 150-255
        const white = Math.floor(200 + brightness * 55); // 200-255
        const color = `rgb(${cyan}, ${white}, 255)`;
        
        polygon.setAttribute('fill', color);
        polygon.setAttribute('opacity', 0.5 + brightness * 0.3);
        
        // Store animation data
        polygon.dataset.angle = angle;
        polygon.dataset.speed = speed;
        polygon.dataset.length = length;
        polygon.dataset.innerWidth = width * 0.3;
        polygon.dataset.outerWidth = width * 1.5;
        polygon.dataset.currentDist = '0'; // Start at center
        polygon.dataset.birthTime = performance.now();
        
        svg.appendChild(polygon);
        return polygon;
      },
      
      /**
       * Update a streak's visual position
       */
      updateStreakPosition(streak, centerX, centerY) {
        const angle = parseFloat(streak.dataset.angle);
        const currentDist = parseFloat(streak.dataset.currentDist);
        const length = parseFloat(streak.dataset.length);
        const innerWidth = parseFloat(streak.dataset.innerWidth);
        const outerWidth = parseFloat(streak.dataset.outerWidth);
        
        const startDist = currentDist;
        const endDist = currentDist + length;
        
        const startX = centerX + Math.cos(angle) * startDist;
        const startY = centerY + Math.sin(angle) * startDist;
        const endX = centerX + Math.cos(angle) * endDist;
        const endY = centerY + Math.sin(angle) * endDist;
        
        const perpAngle = angle + Math.PI / 2;
        
        // Inner edge (near center/tail of streak)
        const x1 = startX + Math.cos(perpAngle) * innerWidth;
        const y1 = startY + Math.sin(perpAngle) * innerWidth;
        const x2 = startX - Math.cos(perpAngle) * innerWidth;
        const y2 = startY - Math.sin(perpAngle) * innerWidth;
        
        // Outer edge (far from center/head of streak)
        const x3 = endX - Math.cos(perpAngle) * outerWidth;
        const y3 = endY - Math.sin(perpAngle) * outerWidth;
        const x4 = endX + Math.cos(perpAngle) * outerWidth;
        const y4 = endY + Math.sin(perpAngle) * outerWidth;
        
        streak.setAttribute('points', `${x1},${y1} ${x2},${y2} ${x3},${y3} ${x4},${y4}`);
        
        // Fade in when spawning, fade out when leaving viewport
        let opacity = parseFloat(streak.getAttribute('opacity'));
        if (startDist < 10) {
          // Fade in
          opacity *= (startDist / 10);
        } else if (startDist > 250) {
          // Fade out as leaving viewport
          opacity *= Math.max(0, 1 - ((startDist - 250) / 100));
        }
        streak.setAttribute('opacity', opacity);
      },
      
      /**
       * Animate warp streaks radiating outward continuously
       */
      animateWarpStreaks(warpBurst) {
        const svg = warpBurst.querySelector('svg');
        if (!svg) return;
        
        const centerX = parseFloat(svg.dataset.centerX);
        const centerY = parseFloat(svg.dataset.centerY);
        const maxDist = 350; // Distance beyond which streaks are removed
        
        let lastTime = performance.now();
        const rng = new SeededRNG(Date.now()); // Random for varied angles
        let nextSpawnTime = 0;
        const spawnInterval = 80; // Spawn new streak every 80ms
        
        const animate = () => {
          const currentTime = performance.now();
          const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
          lastTime = currentTime;
          
          const streaks = svg.querySelectorAll('.star-streak');
          
          // Update existing streaks
          const streaksToRemove = [];
          streaks.forEach(streak => {
            const speed = parseFloat(streak.dataset.speed);
            let currentDist = parseFloat(streak.dataset.currentDist);
            
            // Move streak outward
            currentDist += speed * deltaTime;
            streak.dataset.currentDist = currentDist;
            
            // Update visual position
            this.updateStreakPosition(streak, centerX, centerY);
            
            // Mark for removal if too far
            if (currentDist > maxDist) {
              streaksToRemove.push(streak);
            }
          });
          
          // Remove old streaks
          streaksToRemove.forEach(streak => streak.remove());
          
          // Spawn new streaks periodically
          nextSpawnTime -= deltaTime * 1000;
          if (nextSpawnTime <= 0) {
            // Spawn a batch of 2-4 streaks at random angles
            const batchSize = 2 + Math.floor(rng.next() * 3);
            for (let i = 0; i < batchSize; i++) {
              const angle = rng.next() * Math.PI * 2; // Random angle
              this.createWarpStreak(svg, angle, rng);
            }
            nextSpawnTime = spawnInterval;
          }
          
          if (this.isAnimating && warpBurst.classList.contains('active')) {
            this.warpAnimationFrame = requestAnimationFrame(animate);
          }
        };
        
        animate();
      },
      
      /**
       * Start travel animation sequence
       */
      startTravelAnimation(durationSeconds) {
        this.isAnimating = true;
        this.travelDuration = durationSeconds;
        
        const planetElement = document.querySelector('.window .planet');
        const viewport = document.querySelector('.window .viewport');
        const warpBurst = document.querySelector('.window .viewport .warp-burst');
        
        if (!planetElement || !viewport || !warpBurst) return;
        // Ensure 3D canvas is visible for departure; we animate it in lockstep with starfield
        this.show3D();
        
        // Calculate timing for each phase
        const departureDuration = Math.min(1.5, durationSeconds * 0.2); // 20% of travel or max 1.5s
        const warpDuration = durationSeconds - (departureDuration * 2); // Middle section
        const arrivalDuration = departureDuration; // Same as departure
        
        // Phase 1: Departure - planet and stars move down
        this.runDeparturePhase(planetElement, viewport, departureDuration);
        
        // Phase 2: Warp burst - starts after departure
        setTimeout(() => {
          this.runWarpPhase(planetElement, warpBurst, viewport, warpDuration);
        }, departureDuration * 1000);
        
        // Phase 3: Arrival - new planet grows in (handled by travel-complete event)
      },
      
      /**
       * Departure phase: Planet and stars exit downward
       */
      runDeparturePhase(planetElement, viewport, duration) {
        // Stop the 2D sprite animation (not used) and let 3D canvas move with starfield
        planetElement.style.animation = 'none';
        // Move starfield and 3D renderer down (ship up) to exit frame
        try {
          if (window.cockpit3D && cockpit3D.renderer && cockpit3D.renderer.domElement) {
            cockpit3D.renderer.domElement.style.animation = `travelDeparture ${duration}s ease-in forwards`;
          }
        } catch (_) {}
        
        // Apply departure animation to both planet and starfield
        planetElement.style.animation = `travelDeparture ${duration}s ease-in forwards`;
        
        // Also animate starfield via dynamic CSS update
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (!styleEl) {
          styleEl = document.createElement('style');
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
        
        styleEl.textContent = `
          .window .viewport::before {
            animation: travelDeparture ${duration}s ease-in forwards !important;
          }
          .window .viewport .renderer-canvas {
            animation: travelDeparture ${duration}s ease-in forwards !important;
          }
        `;
      },
      
      /**
       * Warp phase: Show burst effect, hide planet
       */
      runWarpPhase(planetElement, warpBurst, viewport, duration) {
        // Hide 3D during warp to show burst cleanly and prevent reappearing at center
        this.hide3D();
        
        // Generate warp streaks
        this.generateWarpStreaks(warpBurst, 60);
        
        // Show warp burst overlay
        warpBurst.classList.add('active');
        
        // Start animating the streaks
        this.animateWarpStreaks(warpBurst);
        
        // Hide starfield during warp by modifying its opacity
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (styleEl) {
          styleEl.textContent = `
            .window .viewport::before {
              opacity: 0 !important;
            }
            .window .viewport .renderer-canvas {
              opacity: 0 !important;
            }
          `;
        }
      },
      
      /**
       * Arrival phase: New planet grows into view, resume normal animations
       */
  runArrivalPhase(planetElement, warpBurst, viewport, duration) {
        // Stop warp animation
        if (this.warpAnimationFrame) {
          cancelAnimationFrame(this.warpAnimationFrame);
          this.warpAnimationFrame = null;
        }
        
        // Hide warp burst
        warpBurst.classList.remove('active');
        
        // Update planet visual for new location BEFORE showing 3D again
        updatePlanetVisual();
        
        // Show 3D and perform arrival motion with starfield via CSS keyframes on the renderer
        this.show3D();
        try {
          const styleId = 'starfield-travel-style';
          let styleEl = document.getElementById(styleId);
          if (styleEl) {
            styleEl.textContent = styleEl.textContent.replace('opacity: 0 !important;', '');
          }
          const canvas = cockpit3D && cockpit3D.renderer && cockpit3D.renderer.domElement;
          if (canvas) canvas.style.opacity = '';
        } catch(_){}
        try {
          if (window.cockpit3D && cockpit3D.renderer && cockpit3D.renderer.domElement) {
            cockpit3D.renderer.domElement.style.animation = `travelArrival ${duration}s ease-out forwards`;
            // After animation, restore lemniscate
            setTimeout(() => {
              cockpit3D.renderer.domElement.style.animation = 'planetFigureEight 120s ease-in-out infinite';
            }, duration * 1000);
          }
        } catch (_) {}
        
        // Fade starfield back in with arrival
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (styleEl) {
          styleEl.textContent = `
            .window .viewport::before {
              animation: travelArrival ${duration}s ease-out forwards !important;
            }
            .window .viewport .renderer-canvas {
              animation: travelArrival ${duration}s ease-out forwards !important;
            }
          `;
        }
        
        // After arrival completes, resume normal figure-8 idle animation
        setTimeout(() => {
          this.resumeIdleAnimation(planetElement);
        }, duration * 1000);
      },
      
      /**
       * Resume normal idle figure-8 animation
       */
      resumeIdleAnimation(planetElement) {
        this.isAnimating = false;
        
  // Ensure no 2D planet animation (sprite removed); 3D canvas handles lemniscate
  planetElement.style.animation = 'none';
        // Ensure 3D canvas follows the same idle figure-8 path
        try {
          if (window.cockpit3D && cockpit3D.renderer && cockpit3D.renderer.domElement) {
            cockpit3D.renderer.domElement.style.animation = 'planetFigureEight 120s ease-in-out infinite';
          }
        } catch (_) {}
        
        // Resume starfield's figure-8 idle animation
        const styleId = 'starfield-travel-style';
        let styleEl = document.getElementById(styleId);
        if (styleEl) {
          styleEl.remove(); // Remove override, let normal styles take over
        }
      }
    };

    // Expose for cross-module checks (e.g., updatePlanetVisual)
    window.travelAnimationSystem = travelAnimationSystem;

    function updateTraderCommsUI() {
      const traderCommsSection = document.querySelectorAll('.panel')[5]; // Trader Comms panel
      const traderCommsPowerToggle = traderCommsSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const tradeDetailsDisplay = traderCommsSection.querySelector('.crt pre');
      // Transient overlay message support
      window.__traderCommsOverlay__ = window.__traderCommsOverlay__ || { lines: null, timeoutId: null };
      
      const isTraderCommsEnabled = powerSystem.activeSystems.has('traderComms');
      const isPowerAvailable = powerSystem.isPowerAvailable();
      const isPowered = isTraderCommsEnabled && isPowerAvailable;
      const status = isPowered ? tradingSystem.getStatus() : null;
      
      // Update power toggle
      if (traderCommsPowerToggle) {
        traderCommsPowerToggle.checked = isTraderCommsEnabled;
        traderCommsPowerToggle.disabled = !isPowerAvailable; // Disable toggle if no power
      }

      updateTraderShipPreview(status, isPowered);
      
      // If an overlay message is active, show it regardless of power state
      if (window.__traderCommsOverlay__.lines && tradeDetailsDisplay) {
        const overlayLines = window.__traderCommsOverlay__.lines.slice(0, 10);
        // Pad to 10 lines using NBSP for blank lines
        while (overlayLines.length < 10) overlayLines.push('\u00A0');
        tradeDetailsDisplay.textContent = overlayLines.join('\n');
        return; // Defer normal rendering until overlay clears
      }

      // Update terminals based on power state
      if (!isPowered) {
        // Powered off - clear terminal
        if (tradeDetailsDisplay) {
          tradeDetailsDisplay.textContent = '\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0\n\u00A0'; // 10 nbsp lines
        }
      } else {
        // Powered on - show trade details
        if (!status?.trader) {
          // No trader yet - pad to 10 lines
          const lines = [];
          lines.push('No trader signal detected...');
          lines.push('Enable comms to scan for traders.');
          while (lines.length < 10) lines.push('\u00A0');
          
          if (tradeDetailsDisplay) {
            tradeDetailsDisplay.textContent = lines.join('\n');
          }
        } else {
          // Show current trade details
          const currentItem = status.currentItem;
          const mode = status.isBuying ? 'BUYING' : 'SELLING';
          
          // Show page info, handle empty inventory/cargo
          let page = '';
          if (status.maxPage === 0) {
            page = status.isBuying ? '(sold out)' : '(no cargo)';
          } else {
            page = `(page ${status.currentPage + 1} of ${status.maxPage})`;
          }
          
          const lines = [];
          lines.push(`${mode} ${page}`);
          lines.push(`Trader: ${status.trader.name}`);
          lines.push(`Ship  : ${status.trader.ship}`);
          lines.push(`Mood  : ${status.trader.personality}`);
          if (status.trader.shipClass) {
            lines.push(`Class : ${status.trader.shipClass}`);
          }
          
          if (currentItem) {
            if (status.isBuying) {
              // Buying from trader
              lines.push('');
              lines.push(`Item  : ${currentItem.type}`);
              lines.push(`Qty   : ${currentItem.quantity}`);
              lines.push(`Price : ${currentItem.currentPrice}₵`);
              lines.push(`Credits: ${fuelSystem.credits}₵`);
            } else {
              // Selling to trader - show our cargo with trader's offer
              const offerPrice = tradingSystem.getSellingPrice(currentItem);
              const profit = offerPrice - currentItem.purchasePrice;
              
              // Check if trader wants this item
              const demandItem = status.trader.demand && status.trader.demand.find(d => d.type === currentItem.type);
              
              lines.push('');
              lines.push(`Item  : ${currentItem.type}`);
              lines.push(`Bought: ${currentItem.purchasePrice}₵`);
              
              if (demandItem) {
                lines.push(`Offer : ${offerPrice}₵  Demand: ${demandItem.quantity}`);
                lines.push(`Profit: ${profit > 0 ? '+' : ''}${profit}₵  Credits: ${fuelSystem.credits}₵`);
              } else {
                lines.push(`Offer : NO DEMAND`);
                lines.push(`Status: No demand  Credits: ${fuelSystem.credits}₵`);
              }
            }
          } else {
            lines.push('');
            if (status.isBuying) {
              // Check if trader had inventory but it's all sold out
              if (status.trader.inventory && status.trader.inventory.length === 0) {
                lines.push('Trader is sold out!');
                lines.push('');
                lines.push('All inventory purchased.');
                lines.push('Try another planet or');
                lines.push('toggle to SELL mode.');
              } else {
                lines.push('No items available');
              }
            } else {
              // Show what trader wants when we have no matching cargo
              lines.push('Trader wants:');
              if (status.trader.demand && status.trader.demand.length > 0) {
                status.trader.demand.forEach(demandItem => {
                  if (lines.length < 10) {
                    lines.push(`  - ${demandItem.type} (${demandItem.quantity})`);
                  }
                });
              } else {
                lines.push('  (nothing specific)');
              }
            }
          }
          
          // Pad to exactly 10 lines
          while (lines.length < 10) lines.push('\u00A0');
          
          if (tradeDetailsDisplay) {
            tradeDetailsDisplay.textContent = lines.slice(0, 10).join('\n');
          }
        }
      }
      
      // Update cargo hold display
      updateCargoHoldUI();
    }
    
    function updateCargoHoldUI() {
      const cargoSection = document.querySelectorAll('.panel')[6]; // Cargo Hold panel
      const cargoSlots = cargoSection.querySelectorAll('.cargo-grid .cargo-slot'); // Only grid slots, not inspect slot
      
      // Update cargo slots based on tradingSystem.cargo
      cargoSlots.forEach((slot, index) => {
        if (index < tradingSystem.cargo.length) {
          const cargoItem = tradingSystem.cargo[index];
          if (cargoItem) {
            slot.classList.remove('empty');
            slot.classList.add('full');
            // Set color based on cargo type
            const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
            if (typeInfo && typeInfo.color) {
              slot.style.background = typeInfo.color;
            }
            
            // Add cargo label if not already present
            let label = slot.querySelector('.cargo-label');
            if (!label) {
              label = document.createElement('div');
              label.className = 'cargo-label';
              slot.appendChild(label);
            }
            label.textContent = typeInfo ? typeInfo.code : '??';
            
            // Make slot draggable
            slot.setAttribute('draggable', 'true');
          } else {
            slot.classList.remove('full');
            slot.classList.add('empty');
            slot.style.background = '';
            // Remove cargo label
            const label = slot.querySelector('.cargo-label');
            if (label) {
              label.remove();
            }
            
            // Empty slots can receive drops but aren't draggable
            slot.setAttribute('draggable', 'false');
          }
        }
      });
    }

    // Subscribe to battery events for UI updates
    eventBus.on('battery:charge-changed', (data) => {
      updateBatteryUI(data.battery);
    });

    eventBus.on('battery:connected', (data) => {
      
      updateBatteryToggleUI(data.battery);
    });

    eventBus.on('battery:disconnected', (data) => {
      
      updateBatteryToggleUI(data.battery);
    });

    // Subscribe to navigation events
    eventBus.on('navigation:travel-started', (data) => {
      // Start the cinematic travel animation
      const travelTime = data.travelTime || data.target.time || 5; // Use provided time or default
  travelAnimationSystem.startTravelAnimation(travelTime);
    });
    
    eventBus.on('navigation:travel-complete', (data) => {
      // Run arrival animation before updating UI
      const planetElement = document.querySelector('.window .planet');
      const warpBurst = document.querySelector('.window .viewport .warp-burst');
      const viewport = document.querySelector('.window .viewport');
      
      if (planetElement && warpBurst && viewport) {
        const arrivalDuration = Math.min(1.5, travelAnimationSystem.travelDuration * 0.2);
        travelAnimationSystem.runArrivalPhase(planetElement, warpBurst, viewport, arrivalDuration);
      }
      
      const system = navigationSystem.getCurrentSystem();
      const planet = system.planets[data.planetIndex];
      
      updateNavigationUI();
      updateFuelUI();
      
      // Generate new trader if Trader Comms is enabled
      if (powerSystem.activeSystems.has('traderComms')) {
        tradingSystem.generateNewTrader();
  updateTraderCommsUI();
      }
    });

    eventBus.on('navigation:planet-changed', (data) => {
      
      updateNavigationUI();
      
      // Generate new trader if Trader Comms is enabled
      if (powerSystem.activeSystems.has('traderComms')) {
        tradingSystem.generateNewTrader();
  updateTraderCommsUI();
      }
    });

    eventBus.on('navigation:view-changed', (data) => {
      updateNavigationUI();
    });

    eventBus.on('navigation:update-ui', () => {
      updateNavigationUI();
    });

    // Subscribe to save/load events
    eventBus.on('game:saved', (data) => {
      updateSaveStatusUI();
    });

    eventBus.on('game:loaded', (data) => {
  updateSaveStatusUI();
    });

    eventBus.on('game:new-game', (data) => {
      updateSaveStatusUI();
    });

    // ============================================================================
    // UI UPDATE FUNCTIONS
    // ============================================================================
    
    function updateBatteryUI(battery) {
      // Update gauge value (scoped to Batteries panel to avoid index drift)
      const gaugeIndex = battery.id.charCodeAt(0) - 65; // A=0, B=1
      const batteriesPanel = document.querySelectorAll('.panel')[3]; // Batteries panel
      if (!batteriesPanel) return;
      const panelGauges = batteriesPanel.querySelectorAll('.gauge');
      // Expect two gauges within the Batteries panel: A then B
      const targetGauge = panelGauges[gaugeIndex];
      if (targetGauge) {
        const chargePercent = battery.getChargePercentage();
        // Use one decimal for smoother gauge updates
        targetGauge.style.setProperty('--value', chargePercent.toFixed(1));

        const progress = targetGauge.querySelector('progress');
        if (progress) {
          // Display actual charge in Wh
          const chargeWh = Math.round(battery.currentCharge);
          progress.value = Math.round(chargePercent);
          progress.textContent = `${chargeWh} Wh`;
        }
      }
    }

    function updateBatteryToggleUI(battery) {
      const toggleIndex = battery.id.charCodeAt(0) - 65;
      const batterySection = document.querySelectorAll('.panel')[3]; // Batteries panel
      const toggles = batterySection.querySelectorAll('.toggle input[type="checkbox"]');
      
      if (toggles[toggleIndex]) {
        toggles[toggleIndex].checked = battery.connectedToBus;
      }
    }

    function updateSolarPanelUI() {
      const solarSection = document.querySelectorAll('.panel')[4]; // Solar Panels panel
      const slider = solarSection.querySelector('.slider');
      const busToggle = solarSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      
      if (slider) {
        slider.value = solarSystem.panelState;
        setSliderFill(slider);
      }

      if (busToggle) {
        busToggle.checked = solarSystem.connectedToBus;
      }

      // Update charge gauge (solar power generation)
      const gauges = document.querySelectorAll('.gauge');
      const chargeGauge = gauges[3]; // First gauge in solar panel section
      
      if (chargeGauge) {
        const chargePercent = (solarSystem.currentOutput / solarSystem.maxPowerOutput) * 100;
        // Use decimal for smooth gauge movement
        chargeGauge.style.setProperty('--value', chargePercent.toFixed(1));
        
        const progress = chargeGauge.querySelector('progress');
        if (progress) {
          // Display actual power output in watts
          const powerW = Math.round(solarSystem.currentOutput);
          progress.value = Math.round(chargePercent);
          progress.textContent = `${powerW} W`;
        }
      }
    }

    function updatePowerDrawUI() {
      const gauges = document.querySelectorAll('.gauge');
      const drawGauge = gauges[4]; // Second gauge in solar panel section
      
      if (drawGauge) {
        // Only show draw if we have power supply available
        // If no batteries and no solar, we can't supply power
        const hasPower = batterySystem.getConnectedBatteries().length > 0 || 
                        (solarSystem.connectedToBus && solarSystem.extension > 0);
        
        const totalDraw = hasPower ? powerSystem.getTotalDraw() : 0;
        const drawPercent = (totalDraw / mainBus.getMaxPower()) * 100;
        // Use decimal for smooth gauge movement
        drawGauge.style.setProperty('--value', drawPercent.toFixed(1));
        
        const progress = drawGauge.querySelector('progress');
        if (progress) {
          // Display actual power draw in watts
          const powerW = Math.round(totalDraw);
          progress.value = Math.round(drawPercent);
          progress.textContent = `${powerW} W`;
        }
      }
    }

    function updateSaveStatusUI() {
      const saveStatusEl = document.getElementById('save-status');
      if (saveStatusEl) {
        const lastSaved = saveSystem.getLastSaveTimeFormatted();
        const autoSaveStatus = saveSystem.autoSaveEnabled ? 'Active' : 'Disabled';
        saveStatusEl.textContent = `Last saved: ${lastSaved}\nAuto-save  : ${autoSaveStatus}`;
      }
    }

    // ============================================================================
    // WIRE UP UI CONTROLS
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', () => {
      // Try to load saved game, otherwise start new game
      const savedGame = saveSystem.load();
      if (savedGame) {
        loadGameFromSave(savedGame);
      } else {
        initializeNewGame();
      }

      // Generate trader if Trader Comms is enabled on page load
      if (powerSystem.activeSystems.has('traderComms')) {
        tradingSystem.generateNewTrader();
        updateTraderCommsUI(); // Update UI to show the trader
      }

      // Start auto-save
      saveSystem.startAutoSave();

      // Wire up battery bus toggles
      const batterySection = document.querySelectorAll('.panel')[3]; // Batteries panel
      const toggles = batterySection.querySelectorAll('.toggle input[type="checkbox"]');
      
      toggles.forEach((toggle, index) => {
        const batteryId = String.fromCharCode(65 + index); // A, B
        const battery = batterySystem.getBattery(batteryId);
        
        if (battery) {
          // Initialize toggle state
          toggle.checked = battery.connectedToBus;
          
          // Handle toggle changes
          toggle.addEventListener('change', () => {
            battery.toggleBus();
            updateNavigationUI(); // Check power availability immediately
            updateTraderCommsUI(); // Update Trader Comms UI immediately
            updateScannerUI(); // Update Scanner UI immediately
          });
        }
      });

      // Wire up solar panel slider
      const solarSection = document.querySelectorAll('.panel')[4]; // Solar Panels panel
      const solarSlider = solarSection.querySelector('.slider');
      const solarBusToggle = solarSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      
      if (solarSlider) {
        // Initialize slider state
        solarSlider.value = solarSystem.panelState;
        setSliderFill(solarSlider);
        
        // Handle slider changes
        solarSlider.addEventListener('input', () => {
          solarSystem.setPanelState(parseInt(solarSlider.value));
          setSliderFill(solarSlider);
        });
      }

      if (solarBusToggle) {
        // Initialize toggle state
        solarBusToggle.checked = solarSystem.connectedToBus;
        
        // Handle toggle changes
        solarBusToggle.addEventListener('change', () => {
          solarSystem.connectedToBus = solarBusToggle.checked;
          updateNavigationUI(); // Check power availability immediately
          updateTraderCommsUI(); // Update Trader Comms UI immediately
          updateScannerUI(); // Update Scanner UI immediately
        });
      }

      // Wire up Navigation Power toggle
      const navigationSection = document.querySelectorAll('.panel')[1]; // Navigation panel (index 1)
      const navigationPowerToggle = navigationSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const navButtons = navigationSection.querySelectorAll('.btn');
      const navDial = navigationSection.querySelector('.dial input');
      
      if (navigationPowerToggle) {
        // Initialize toggle state
        const isNavigationActive = powerSystem.activeSystems.has('navigation');
        navigationPowerToggle.checked = isNavigationActive;
        
        // Handle toggle changes
        navigationPowerToggle.addEventListener('change', () => {
          if (navigationPowerToggle.checked) {
            // Check if power is available before enabling
            if (!powerSystem.isPowerAvailable()) {
              
              navigationPowerToggle.checked = false;
              return;
            }
            powerSystem.enableSystem('navigation');
            
          } else {
            powerSystem.disableSystem('navigation');
            
          }
          updateNavigationUI(); // Update UI immediately on power change
        });
      }

      // Wire up navigation buttons
      if (navButtons.length >= 4) {
        // CURRENT LOC button
        navButtons[0].addEventListener('click', () => {
          if (navigationSystem.traveling) return;
          navigationSystem.showCurrentLocation();
          updateNavigationUI();
          
        });

        // SYSTEM MAP button
        navButtons[1].addEventListener('click', () => {
          if (navigationSystem.traveling) return;
          navigationSystem.setViewMode('system');
          updateNavigationUI();
          
        });

        // GALAXY MAP button
        navButtons[2].addEventListener('click', () => {
          if (navigationSystem.traveling) return;
          navigationSystem.setViewMode('galaxy');
          updateNavigationUI();
          
        });

        // BEGIN TRAVEL button
        navButtons[3].addEventListener('click', () => {
          const result = navigationSystem.beginTravel();
          
          if (!result.success) {
            
          } else {
            if (result.type === 'planet') {
              const sunStrength = navigationSystem.getSunStrength();
            } else {
              
            }
            updateNavigationUI();
          }
        });
      }

      // Wire up navigation dial
      if (navDial) {
        const dialContainer = navDial.closest('.dial');

        navDial.addEventListener('input', () => {
          if (navigationSystem.traveling) return;
          const index = parseInt(navDial.value);
          if (dialContainer) {
            dialContainer.style.setProperty('--value', index);
            setDialFill(dialContainer, index, navDial.max);
          }
          navigationSystem.setCursor(index);
          updateNavigationUI();
        });
        
        // Prevent context menu on long press (mobile)
        if (dialContainer) {
          dialContainer.style.setProperty('--value', navDial.value || 0);
          setDialFill(dialContainer, navDial.value || 0, navDial.max);
          dialContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
          });
          
          // Also prevent on the input itself
          navDial.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
          });
          
          // Prevent long-press text selection on touch devices
          dialContainer.addEventListener('touchstart', (e) => {
            // Don't prevent default as we need the touch to work
            // Just mark that we're interacting
          }, { passive: true });
        }
      }

      // Wire up Refuel button
      const fuelSection = document.querySelectorAll('.panel')[2]; // Fuel panel (index 2)
      const refuelButton = fuelSection.querySelector('.btn');
      const fuelTerminal = fuelSection.querySelector('.crt pre');
      
      if (refuelButton) {
        refuelButton.addEventListener('click', () => {
          const result = fuelSystem.refuel();
          
          if (result.success) {
            updateFuelUI();
          } else {
            
            // Show error message in terminal temporarily
            if (fuelTerminal) {
              const originalText = fuelTerminal.textContent;
              fuelTerminal.textContent = `Current credits: ${fuelSystem.credits}₵\n${result.message}`;
              
              // Restore after 5 seconds
              setTimeout(() => {
                updateFuelUI();
              }, 5000);
            }
          }
        });
      }

      // Wire up Trader Comms controls
      const traderCommsSection = document.querySelectorAll('.panel')[5]; // Trader Comms panel
      const traderCommsPowerToggle = traderCommsSection.querySelectorAll('.toggle input[type="checkbox"]')[0];
      const traderCommsModeToggle = traderCommsSection.querySelectorAll('.toggle input[type="checkbox"]')[1];
      const tradeButtons = traderCommsSection.querySelectorAll('.btn');

      // Show insufficient power message in Trader Comms terminal for 5 seconds on teleport failure
      eventBus.on('power:teleport-failed', ({ required, available }) => {
        const pre = traderCommsSection.querySelector('.crt pre');
        if (!pre) return;
        window.__traderCommsOverlay__ = window.__traderCommsOverlay__ || { lines: null, timeoutId: null };
        // Build 10-line message, with first two lines as specified and the rest padded with NBSP
        const msgLines = [
          'Insufficient power',
          'for teleport'
        ];
        // Optional detail line (small, non-intrusive): comment out if not desired
        // msgLines.push(`Need ${required}Wh, have ${available?.toFixed ? available.toFixed(1) : available}Wh`);
        while (msgLines.length < 10) msgLines.push('\u00A0');
        window.__traderCommsOverlay__.lines = msgLines;
        // Ensure only one timeout is active
        if (window.__traderCommsOverlay__.timeoutId) clearTimeout(window.__traderCommsOverlay__.timeoutId);
        // Render immediately and schedule clear
        updateTraderCommsUI();
        window.__traderCommsOverlay__.timeoutId = setTimeout(() => {
          window.__traderCommsOverlay__.lines = null;
          window.__traderCommsOverlay__.timeoutId = null;
          updateTraderCommsUI();
        }, 5000);
      });
      const prevPageBtn = tradeButtons[0]; // PREVIOUS PAGE
      const nextPageBtn = tradeButtons[1]; // NEXT PAGE
      const haggleBtn = tradeButtons[2]; // HAGGLE
      const tradeBtn = tradeButtons[3]; // TRADE
      
  // Get cargo hold elements (grid slots only, exclude the Inspect slot)
  const cargoSection = document.querySelectorAll('.panel')[6]; // Cargo Hold panel
  const cargoSlots = cargoSection.querySelectorAll('.cargo-grid .cargo-slot'); // Only grid slots, not inspect slot
      
      if (traderCommsPowerToggle) {
        // Initialize toggle state
        const isCommsActive = powerSystem.activeSystems.has('traderComms');
        traderCommsPowerToggle.checked = isCommsActive;
        
        // Handle toggle changes
        traderCommsPowerToggle.addEventListener('change', () => {
          if (traderCommsPowerToggle.checked) {
            // Check if power is available before enabling
            if (!powerSystem.isPowerAvailable()) {
              console.warn('⚠️ Cannot enable Trader Comms: No power available');
              traderCommsPowerToggle.checked = false; // Revert toggle
              return;
            }
            powerSystem.enableSystem('traderComms');
            // Generate new trader when power turned on
            tradingSystem.generateNewTrader();
          } else {
            powerSystem.disableSystem('traderComms');
          }
          updateTraderCommsUI(); // Update UI immediately
        });
      }
      
      if (traderCommsModeToggle) {
        // Initialize mode (checked = SELLING, unchecked = BUYING)
        traderCommsModeToggle.checked = !tradingSystem.isBuying;
        
        traderCommsModeToggle.addEventListener('change', () => {
          const newMode = !traderCommsModeToggle.checked; // unchecked = buying
          tradingSystem.setMode(newMode);
          updateTraderCommsUI();
        });
      }
      
      if (prevPageBtn) {
        prevPageBtn.addEventListener('click', () => {
          if (!powerSystem.activeSystems.has('traderComms')) return;
          tradingSystem.prevPage();
          updateTraderCommsUI();
        });
      }
      
      if (nextPageBtn) {
        nextPageBtn.addEventListener('click', () => {
          if (!powerSystem.activeSystems.has('traderComms')) return;
          tradingSystem.nextPage();
          updateTraderCommsUI();
        });
      }
      
      if (haggleBtn) {
        haggleBtn.addEventListener('click', () => {
          if (!powerSystem.activeSystems.has('traderComms')) {
            return;
          }
          
          const result = tradingSystem.haggle();
          updateTraderCommsUI();
        });
      }
      
      if (tradeBtn) {
        tradeBtn.addEventListener('click', () => {
          // Check if Trader Comms is online
          if (!powerSystem.activeSystems.has('traderComms')) {
            return;
          }

          // Check if teleportation already in progress
          if (powerSystem.teleportInProgress) {
            return;
          }

          // Pre-validate the trade before starting teleportation
          const isBuying = tradingSystem.isBuying;
          
          if (isBuying) {
            // Buying - check if there's actually an item to buy
            if (!tradingSystem.currentTrader?.inventory || tradingSystem.currentTrader.inventory.length === 0) {
              return;
            }
            
            // Validate page bounds
            if (tradingSystem.currentPage >= tradingSystem.currentTrader.inventory.length) {
              tradingSystem.currentPage = Math.max(0, tradingSystem.currentTrader.inventory.length - 1);
              updateTraderCommsUI();
              return;
            }
            
            const currentItem = tradingSystem.currentTrader.inventory[tradingSystem.currentPage];
            if (!currentItem) {
              return;
            }
          } else {
            // Selling - check if trader wants the item
            const currentItem = tradingSystem.getCurrentItem();
            if (currentItem && tradingSystem.currentTrader?.demand) {
              const traderWantsItem = tradingSystem.currentTrader.demand.some(d => d.type === currentItem.type);
              if (!traderWantsItem) {
                return; // Exit without starting teleportation
              }
            }
          }

          // Start teleportation sequence (5% of one battery = 100 Wh over 3 seconds)
          const teleportEnergy = 100; // Wh (5% of 2000 Wh battery)
          const success = powerSystem.startTeleportation('Cargo Teleportation', teleportEnergy);
          
          if (success) {
            
            // Find the cargo slot to animate
            let targetSlot = null;
            
            if (isBuying) {
              // Buying - find first empty slot
              targetSlot = Array.from(cargoSlots).find(slot => slot.classList.contains('empty'));
            } else {
              // Selling - find the slot of the current cargo item
              const currentItem = tradingSystem.getCurrentItem();
              if (currentItem) {
                targetSlot = cargoSlots[currentItem.slotIndex];
              }
            }
            
            // Add teleportation visual effect
            if (targetSlot) {
              targetSlot.classList.add('teleporting');
            }
            
            // After teleportation completes, execute trade
            const completeHandler = () => {
              // Remove teleporting effect
              if (targetSlot) {
                targetSlot.classList.remove('teleporting');
              }
              
              // Execute the trade
              const tradeResult = tradingSystem.executeTrade();
              
              
              
              // Update UI
              updateTraderCommsUI();
              updateFuelUI(); // Update credits display
              
              // Clean up event listener
              eventBus.off('power:teleport-complete', completeHandler);
            };
            
            eventBus.once('power:teleport-complete', completeHandler);
          } else {
          }
        });
      }

      // Wire up new game controls
      const newGameArm = document.getElementById('new-game-arm');
      const newGameBtn = document.getElementById('new-game-btn');

      if (newGameArm && newGameBtn) {
        const applyNewGameButtonState = (armed) => {
          newGameBtn.disabled = !armed;
          newGameBtn.classList.toggle('btn-armed', armed);
          newGameBtn.classList.toggle('btn-safe', !armed);
          if (!armed) {
            newGameBtn.classList.add('btn-safe');
          }
        };

        applyNewGameButtonState(false);
        // Handle arm toggle
        newGameArm.addEventListener('change', () => {
          applyNewGameButtonState(newGameArm.checked);
        });

        // Handle new game button
        newGameBtn.addEventListener('click', () => {
          if (!newGameArm.checked) return;

          // Delete save
          saveSystem.deleteSave();
          
          // Initialize new game
          initializeNewGame();
          
          // Disarm the button
          newGameArm.checked = false;
          applyNewGameButtonState(false);
          
          // Scroll to top
          window.scrollTo({ top: 0, behavior: 'smooth' });
          
          
        });
      }

      // ============================================================================
      // CARGO DRAG-AND-DROP HANDLERS (Mouse + Touch Support)
      // ============================================================================
      
      const cargoHoldSection = document.querySelectorAll('.panel')[6]; // Cargo Hold panel
      const cargoHoldSlots = cargoHoldSection.querySelectorAll('.cargo-grid .cargo-slot'); // Only grid slots, not inspect slot
      
  let draggedSlotIndex = null;
  let lastDraggedIndex = null; // Fallback for mouse synthetic drop
      let touchDraggedSlot = null;
      let touchClone = null;
      
      cargoHoldSlots.forEach((slot, index) => {
        // ===== MOUSE DRAG HANDLERS =====
        
        // Drag start
        slot.addEventListener('dragstart', (e) => {
          // Only allow dragging if slot is full
          if (!slot.classList.contains('full')) {
            e.preventDefault();
            return;
          }
          
          draggedSlotIndex = index;
          lastDraggedIndex = index; // track last dragged index for fallback
          slot.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', index.toString());
          
        });
        
        // Drag end
        slot.addEventListener('dragend', (e) => {
          slot.classList.remove('dragging');
          // Defer clearing to allow other dragend listeners to read the value
          setTimeout(() => { draggedSlotIndex = null; }, 0);
          
        });
        
        // Drag over (allow drop)
        slot.addEventListener('dragover', (e) => {
          e.preventDefault(); // Allow drop
          e.dataTransfer.dropEffect = 'move';
          
          if (draggedSlotIndex !== null && draggedSlotIndex !== index) {
            slot.classList.add('drag-over');
          }
        });
        
        // Drag enter
        slot.addEventListener('dragenter', (e) => {
          e.preventDefault();
          if (draggedSlotIndex !== null && draggedSlotIndex !== index) {
            slot.classList.add('drag-over');
          }
        });
        
        // Drag leave
        slot.addEventListener('dragleave', (e) => {
          slot.classList.remove('drag-over');
        });
        
        // Drop
        slot.addEventListener('drop', (e) => {
          e.preventDefault();
          slot.classList.remove('drag-over');
          
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = index;
          
          
          
          if (fromIndex !== toIndex) {
            // Perform the swap
            tradingSystem.swapCargo(fromIndex, toIndex);
            
            // Update UI
            updateCargoHoldUI();
            
            // Save the game after swap
            saveSystem.save();
          }
        });
        
        // ===== TOUCH DRAG HANDLERS =====
        
        slot.addEventListener('touchstart', (e) => {
          // Only allow dragging if slot is full
          if (!slot.classList.contains('full')) {
            return;
          }
          
          e.preventDefault(); // Prevent scrolling while dragging
          draggedSlotIndex = index;
          touchDraggedSlot = slot;
          slot.classList.add('dragging');
          
          // Create a visual clone that follows the finger
          touchClone = slot.cloneNode(true);
          touchClone.style.position = 'fixed';
          touchClone.style.pointerEvents = 'none';
          touchClone.style.opacity = '0.8';
          touchClone.style.zIndex = '10000';
          touchClone.style.width = slot.offsetWidth + 'px';
          touchClone.style.height = slot.offsetHeight + 'px';
          
          const touch = e.touches[0];
          touchClone.style.left = (touch.clientX - slot.offsetWidth / 2) + 'px';
          touchClone.style.top = (touch.clientY - slot.offsetHeight / 2) + 'px';
          
          document.body.appendChild(touchClone);
          
        });
        
        slot.addEventListener('touchmove', (e) => {
          if (!touchClone) return;
          
          e.preventDefault(); // Prevent scrolling
          const touch = e.touches[0];
          
          // Move the clone with the finger
          touchClone.style.left = (touch.clientX - touchClone.offsetWidth / 2) + 'px';
          touchClone.style.top = (touch.clientY - touchClone.offsetHeight / 2) + 'px';
          
          // Find what element is under the finger
          touchClone.style.display = 'none';
          const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
          touchClone.style.display = 'block';
          
          // Remove drag-over from all slots
          cargoHoldSlots.forEach(s => s.classList.remove('drag-over'));
          const inspectSlot = document.getElementById('inspect-slot');
          if (inspectSlot) inspectSlot.classList.remove('drag-over');
          const refuelSlotEl = document.getElementById('refuel-slot');
          if (refuelSlotEl) refuelSlotEl.classList.remove('drag-over');
          
          // Add drag-over to the element below if it's a valid drop target
          if (elementBelow) {
            const targetSlot = elementBelow.closest('.cargo-slot');
            if (targetSlot && targetSlot !== touchDraggedSlot) {
              targetSlot.classList.add('drag-over');
            }
          }
        });
        
        slot.addEventListener('touchend', (e) => {
          if (!touchClone) return;
          
          e.preventDefault();
          const touch = e.changedTouches[0];
          
          // Find what element is under the finger
          touchClone.style.display = 'none';
          const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
          
          // Clean up
          if (touchClone && touchClone.parentNode) {
            touchClone.parentNode.removeChild(touchClone);
          }
          touchClone = null;
          
          if (touchDraggedSlot) {
            touchDraggedSlot.classList.remove('dragging');
          }
          
          // Remove drag-over from all slots
          cargoHoldSlots.forEach(s => s.classList.remove('drag-over'));
          const inspectSlotEl = document.getElementById('inspect-slot');
          if (inspectSlotEl) inspectSlotEl.classList.remove('drag-over');
          const refuelSlotElEnd = document.getElementById('refuel-slot');
          if (refuelSlotElEnd) refuelSlotElEnd.classList.remove('drag-over');
          
          
          
          // Handle the drop
          if (elementBelow) {
            const targetSlot = elementBelow.closest('.cargo-slot');
            
            if (targetSlot) {
              targetSlot.classList.remove('drag-over');
              // Check if it's the inspect slot
              if (targetSlot.id === 'inspect-slot') {
                
                // Inspect the cargo
                const cargoItem = tradingSystem.cargo[draggedSlotIndex];
                if (cargoItem) {
                  const inspectTerminal = document.getElementById('inspect-terminal');
                  const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
                  
                  // Update inspect slot visual
                  targetSlot.classList.remove('empty');
                  targetSlot.classList.add('full');
                  targetSlot.style.background = typeInfo.color;
                  
                  let label = targetSlot.querySelector('.cargo-label');
                  if (label) {
                    label.textContent = typeInfo.code;
                    label.style.fontSize = '56px';
                    label.style.opacity = '0.4';
                    label.style.animation = 'none';
                  }
                  
                  // Update terminal
                  if (inspectTerminal) {
                    cancelCargoHoldWarning();
                    const lines = [];
                    lines.push(`Type: ${cargoItem.type}`);
                    lines.push(`Code: ${typeInfo.code}`);
                    lines.push(`Purchase Price: ${cargoItem.purchasePrice}₵`);
                    lines.push(`Slot: ${draggedSlotIndex + 1} of ${tradingSystem.cargoCapacity}`);
                    
                    while (lines.length < 4) {
                      lines.push('\u00A0');
                    }
                    
                    inspectTerminal.textContent = lines.slice(0, 4).join('\n');
                    
                  }
                }
              } else if (targetSlot.id === 'refuel-slot') {
                if (draggedSlotIndex !== null) {
                  handleFuelCellRefuel(draggedSlotIndex);
                }
              } else {
                // Regular cargo slot - swap
                const targetIndex = Array.from(cargoHoldSlots).indexOf(targetSlot);
                
                if (targetIndex !== -1 && targetIndex !== draggedSlotIndex) {
                  
                  tradingSystem.swapCargo(draggedSlotIndex, targetIndex);
                  updateCargoHoldUI();
                  saveSystem.save();
                }
              }
            }
          }
          
          draggedSlotIndex = null;
          touchDraggedSlot = null;
        });
        
        slot.addEventListener('touchcancel', (e) => {
          // Clean up on cancel
          if (touchClone && touchClone.parentNode) {
            touchClone.parentNode.removeChild(touchClone);
          }
          touchClone = null;
          
          if (touchDraggedSlot) {
            touchDraggedSlot.classList.remove('dragging');
          }
          
          cargoHoldSlots.forEach(s => s.classList.remove('drag-over'));
          const inspectSlotEl = document.getElementById('inspect-slot');
          if (inspectSlotEl) inspectSlotEl.classList.remove('drag-over');
          const refuelSlotElCancel = document.getElementById('refuel-slot');
          if (refuelSlotElCancel) refuelSlotElCancel.classList.remove('drag-over');
          
          draggedSlotIndex = null;
          touchDraggedSlot = null;
          
        });
      });

      // ============================================================================
      // INSPECT SLOT DRAG-AND-DROP HANDLER (Mouse Only - Touch handled above)
      // ============================================================================
      
      const inspectSlot = document.getElementById('inspect-slot');
      const inspectTerminal = document.getElementById('inspect-terminal');
      
      
      
      if (inspectSlot && inspectTerminal) {
        
        
        let dragEnterCounter = 0; // Track nested drag enter/leave
        let lastDragOverTime = 0; // Track last dragover
        let isOverInspectSlot = false; // Track if we've been over inspect slot recently
        
        // Drag over (allow drop)
        inspectSlot.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation(); // Stop it from bubbling to parent
          
          // Always set dropEffect even if draggedSlotIndex is null
          e.dataTransfer.dropEffect = 'copy';
          
          lastDragOverTime = Date.now();
          isOverInspectSlot = true; // Mark that we're actively over the slot
          
          if (draggedSlotIndex !== null) {
            inspectSlot.classList.add('drag-over');
          }
        });
        
        // Drag enter
        inspectSlot.addEventListener('dragenter', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragEnterCounter++;
          
          if (draggedSlotIndex !== null) {
            inspectSlot.classList.add('drag-over');
          }
        });
        
        // Drag leave - use counter to track nested enter/leave
        inspectSlot.addEventListener('dragleave', (e) => {
          e.stopPropagation();
          dragEnterCounter--;
          
          // Only remove drag-over when counter reaches 0 AND we're not actively dragging over
          if (dragEnterCounter <= 0) {
            dragEnterCounter = 0;
            // Don't immediately clear isOverInspectSlot - let dragend handle cleanup
            // This prevents race condition where dragleave fires right before drop
            const timeSinceDragover = Date.now() - lastDragOverTime;
            // Do not clear isOverInspectSlot here; keep until dragend decides
            if (timeSinceDragover > 300) { // only remove highlight if user clearly moved away
              inspectSlot.classList.remove('drag-over');
            } else {
              
            }
          } else {
            
          }
        });
        
        // Also clear drag-over on dragend of cargo slots
        cargoHoldSlots.forEach(slot => {
          slot.addEventListener('dragend', () => {
            const timeSinceLastDragover = Date.now() - lastDragOverTime;
            // Capture BEFORE it gets cleared; fallback to lastDraggedIndex if needed
            const capturedDraggedIndex = (draggedSlotIndex !== null ? draggedSlotIndex : lastDraggedIndex);
            
            // If we were recently over the inspect slot, trigger a synthetic drop
            if (isOverInspectSlot && timeSinceLastDragover < 250 && capturedDraggedIndex !== null) {
              
              
              const cargoItem = tradingSystem.cargo[capturedDraggedIndex];
              if (cargoItem) {
                const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
                
                // Update inspect slot visual
                inspectSlot.classList.remove('empty');
                inspectSlot.classList.add('full');
                inspectSlot.style.background = typeInfo.color;
                
                let label = inspectSlot.querySelector('.cargo-label');
                if (label) {
                  label.textContent = typeInfo.code;
                  label.style.fontSize = '56px';
                  label.style.opacity = '0.4';
                  label.style.animation = 'none';
                }
                
                // Update terminal
                if (inspectTerminal) {
                  const lines = [];
                  lines.push(`Type: ${cargoItem.type}`);
                  lines.push(`Code: ${typeInfo.code}`);
                  lines.push(`Purchase Price: ${cargoItem.purchasePrice}₵`);
                  lines.push(`Slot: ${capturedDraggedIndex + 1} of ${tradingSystem.cargoCapacity}`);

                  while (lines.length < 4) {
                    lines.push('\u00A0');
                  }

                  cancelCargoHoldWarning();
                  inspectTerminal.textContent = lines.slice(0, 4).join('\n');
                }
              }
            }
            
            inspectSlot.classList.remove('drag-over');
            dragEnterCounter = 0; // Reset counter
            isOverInspectSlot = false; // Reset flag
          });
        });
        
        // Drop - inspect the cargo without moving it
        inspectSlot.addEventListener('drop', (e) => {
          
          e.preventDefault();
          e.stopPropagation(); // Stop event from bubbling
          inspectSlot.classList.remove('drag-over');
          
          
          
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          
          
          const cargoItem = tradingSystem.cargo[fromIndex];
          
          
          if (cargoItem) {
            // Update inspect slot visual
            const typeInfo = tradingSystem.cargoTypes[cargoItem.type];
            inspectSlot.classList.remove('empty');
            inspectSlot.classList.add('full');
            inspectSlot.style.background = typeInfo.color;
            
            // Update cargo label
            let label = inspectSlot.querySelector('.cargo-label');
            if (label) {
              label.textContent = typeInfo.code;
              label.style.fontSize = '56px';
              label.style.opacity = '0.4';
              label.style.animation = 'none';
            }
            
            // Update terminal with cargo info (always keep 4 lines)
            const lines = [];
            lines.push(`Type: ${cargoItem.type}`);
            lines.push(`Code: ${typeInfo.code}`);
            lines.push(`Purchase Price: ${cargoItem.purchasePrice}₵`);
            lines.push(`Slot: ${fromIndex + 1} of ${tradingSystem.cargoCapacity}`);
            
            // Ensure exactly 4 lines (pad with non-breaking spaces if needed)
            while (lines.length < 4) {
              lines.push('\u00A0'); // Non-breaking space
            }
            
            cancelCargoHoldWarning();
            inspectTerminal.textContent = lines.slice(0, 4).join('\n');
          } else {
            
          }
        });
        
        
      } else {
  console.error(`Inspect slot or terminal not found!`);
      }

      // ========================================================================
      // REFUEL SLOT DRAG-AND-DROP HANDLER
      // ========================================================================
      const refuelSlot = document.getElementById('refuel-slot');
      const CARGO_HOLD_TERMINAL_LINE_COUNT = 4;
      const CARGO_HOLD_TERMINAL_BLANK = Array(CARGO_HOLD_TERMINAL_LINE_COUNT).fill('\u00A0').join('\n');
      let cargoHoldWarningTimeout = null;

      function cancelCargoHoldWarning() {
        if (cargoHoldWarningTimeout) {
          clearTimeout(cargoHoldWarningTimeout);
          cargoHoldWarningTimeout = null;
        }
      }

      function showCargoHoldWarning(message, duration = 2200) {
        if (!inspectTerminal) return;

        cancelCargoHoldWarning();

        const lines = [message];
        while (lines.length < CARGO_HOLD_TERMINAL_LINE_COUNT) {
          lines.push('\u00A0');
        }

        inspectTerminal.textContent = lines.join('\n');

        cargoHoldWarningTimeout = setTimeout(() => {
          inspectTerminal.textContent = CARGO_HOLD_TERMINAL_BLANK;
          cargoHoldWarningTimeout = null;
        }, Math.max(0, duration));
      }

      function handleFuelCellRefuel(fromIndex, { animate = true, showWarning = true } = {}) {
        if (!refuelSlot) return false;
        if (typeof fromIndex !== 'number' || Number.isNaN(fromIndex)) return false;

        refuelSlot.classList.remove('drag-over');

        const cargoItem = tradingSystem.cargo[fromIndex];
        if (!cargoItem || cargoItem.type !== 'Fuel Cells') {
          if (showWarning) {
            showCargoHoldWarning('Refuel slot only accepts Fuel Cells.');
          }
          return false;
        }

        // Fully refuel main tank
        const previousFuel = fuelSystem.currentFuel;
        fuelSystem.currentFuel = fuelSystem.maxCapacity;
        if (previousFuel < fuelSystem.maxCapacity) {
          eventBus.emit('fuel:refueled', { cost: 0, credits: fuelSystem.credits, source: 'fuel-cell' });
        }

        // Recharge every battery to effective capacity
        batterySystem.batteries.forEach(battery => {
          const previousCharge = battery.currentCharge;
          battery.currentCharge = battery.getEffectiveCapacity();
          battery.checkChargeThresholds(previousCharge);
        });

        // Consume the crate
        tradingSystem.cargo[fromIndex] = null;

        // Refresh UI
        updateCargoHoldUI();
        updateFuelUI();
        batterySystem.batteries.forEach(battery => {
          updateBatteryUI(battery);
          updateBatteryToggleUI(battery);
        });

        saveSystem.save();

        if (animate) {
          refuelSlot.classList.remove('empty');
          refuelSlot.classList.add('full');
          refuelSlot.style.background = '#4caf50';

          const label = refuelSlot.querySelector('.cargo-label');
          if (label) {
            label.textContent = '✓';
            label.style.fontSize = '56px';
            label.style.opacity = '1';
            label.style.animation = 'none';
          }

          setTimeout(() => {
            refuelSlot.classList.remove('full');
            refuelSlot.classList.add('empty');
            refuelSlot.style.background = '';
            const resetLabel = refuelSlot.querySelector('.cargo-label');
            if (resetLabel) {
              resetLabel.textContent = '⚡';
              resetLabel.style.fontSize = '48px';
              resetLabel.style.opacity = '0.3';
              resetLabel.style.animation = 'pulse-energy 1.5s ease-in-out infinite';
            }
          }, 800);
        } else {
          refuelSlot.classList.remove('full');
          refuelSlot.classList.add('empty');
        }

        return true;
      }

      if (refuelSlot) {
        let refuelDragEnterCounter = 0;
        
        // Dragover - allow dropping
        refuelSlot.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
        
        // Dragenter
        refuelSlot.addEventListener('dragenter', (e) => {
          e.preventDefault();
          e.stopPropagation();
          refuelDragEnterCounter++;
          
          if (refuelDragEnterCounter === 1) {
            refuelSlot.classList.add('drag-over');
          }
        });
        
        // Dragleave
        refuelSlot.addEventListener('dragleave', (e) => {
          e.preventDefault();
          e.stopPropagation();
          refuelDragEnterCounter--;
          
          if (refuelDragEnterCounter === 0) {
            refuelSlot.classList.remove('drag-over');
          }
        });
        
        // Drop - consume fuel cell and refuel
        refuelSlot.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          refuelSlot.classList.remove('drag-over');
          refuelDragEnterCounter = 0;
          
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
          if (!handleFuelCellRefuel(fromIndex)) {
            refuelSlot.classList.remove('full');
          }
        });
      } else {
        console.error(`Refuel slot not found!`);
      }

      // Update save status UI periodically
      setInterval(updateSaveStatusUI, 1000);
    });

    // ============================================================================
    // GAME LOOP
    // ============================================================================
    
    let lastTime = performance.now();
    const TARGET_FPS = 60;
    const FRAME_TIME = 1000 / TARGET_FPS;
    let frameCounter = 0;

    function gameLoop(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;
      frameCounter++;

      // Update all systems
      solarSystem.update(deltaTime);
      powerSystem.update(deltaTime);
      batterySystem.update(deltaTime);
      navigationSystem.update(deltaTime);

      // Check power availability and auto-disable systems if no power
      if (!powerSystem.isPowerAvailable()) {
        // No power available - force disable navigation if it's on
        if (powerSystem.activeSystems.has('navigation')) {
          powerSystem.disableSystem('navigation');
          updateNavigationUI(); // Update UI to reflect power toggle off
          console.warn('⚠️ Navigation auto-disabled: No power available');
        }
        // Force disable trader comms if it's on
        if (powerSystem.activeSystems.has('traderComms')) {
          powerSystem.disableSystem('traderComms');
          updateTraderCommsUI(); // Update UI to reflect power toggle off
          console.warn('⚠️ Trader Comms auto-disabled: No power available');
        }
        // Force disable scanner if it's on
        if (powerSystem.activeSystems.has('scanner')) {
          powerSystem.disableSystem('scanner');
          scannerSystem.powered = false;
          updateScannerUI();
        }
      }

      // Power flow management
      const solarPower = solarSystem.currentOutput;
      const systemDraw = powerSystem.getTotalDraw();
  // Battery-only events (teleport/bursts) should be sourced from batteries even if solar has surplus
  const batteryOnlyWatts = powerSystem.getBurstAndTeleportWatts();
  const nonBatteryDraw = Math.max(0, systemDraw - batteryOnlyWatts);
      
      // Calculate power balance
  const powerBalance = solarPower - nonBatteryDraw;
      
      
      
      if (powerBalance > 0) {
        // Surplus power - charge batteries, but do not negate battery-only bursts in same frame
        const actualCharged = batterySystem.chargeBatteries(powerBalance, deltaTime);
        // Also draw battery-only watts explicitly from batteries
        if (batteryOnlyWatts > 0) {
          batterySystem.drawPower(batteryOnlyWatts, deltaTime);
        }
        mainBus.currentSupply = solarPower;
      } else if (powerBalance < 0) {
        // Deficit - draw from batteries for non-battery draw deficit
        const deficit = Math.abs(powerBalance);
        let actualDrawn = batterySystem.drawPower(deficit, deltaTime);
        // Plus battery-only watts
        if (batteryOnlyWatts > 0) {
          actualDrawn += batterySystem.drawPower(batteryOnlyWatts, deltaTime);
        }
        mainBus.currentSupply = solarPower + actualDrawn;
        
        // Check if we couldn't meet demand
        if (actualDrawn < deficit * 0.9) {
          // Power shortage!
          // In future: trigger brownout, disable non-critical systems
        }
      } else {
        // Perfect balance (rare): still must draw battery-only watts
        if (batteryOnlyWatts > 0) {
          const actualDrawn = batterySystem.drawPower(batteryOnlyWatts, deltaTime);
          mainBus.currentSupply = solarPower + actualDrawn;
        } else {
          mainBus.currentSupply = solarPower;
        }
      }

      // Update UI at 10 Hz (every 6 frames at 60 FPS)
      if (frameCounter % 6 === 0) {
        updateSolarPanelUI();
        updatePowerDrawUI();
        
        // Update battery UI if charge changed significantly
        batterySystem.batteries.forEach(battery => {
          updateBatteryUI(battery);
        });

        // Update navigation UI (especially during travel)
        if (navigationSystem.traveling) {
          updateNavigationUI();
        }

        if (document.documentElement.getAttribute('data-theme') === 'dark') {
          updateGaugeLedArrays();
        }
      }

      // Continue loop
      requestAnimationFrame(gameLoop);
    }

    // Start game loop
    requestAnimationFrame(gameLoop);

    

    // ============================================================================
    // ============================================================================
    // THEME TOGGLE
    // ============================================================================
    const THEME_STORAGE_KEY = 'spaceTraderTheme';
    const themeToggle = document.getElementById('theme-toggle');
    const themeColorMeta = document.querySelector('meta[name="theme-color"]');
    const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)');

    let storedTheme = null;
    try {
      storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
    } catch (error) {
      console.warn('Theme preference could not be read:', error);
    }

    let ledsInitialized = false;
    let userThemePreference = storedTheme;
    const initialTheme = storedTheme || (mediaQueryDark.matches ? 'dark' : 'light');
    applyTheme(initialTheme);

    if (themeToggle) {
      themeToggle.checked = initialTheme === 'dark';
      themeToggle.addEventListener('change', () => {
        const nextTheme = themeToggle.checked ? 'dark' : 'light';
        userThemePreference = nextTheme;
        applyTheme(nextTheme);
        try {
          localStorage.setItem(THEME_STORAGE_KEY, nextTheme);
        } catch (error) {
          console.warn('Theme preference could not be saved:', error);
        }
      });
    }

    const handleColorSchemeChange = (event) => {
      if (userThemePreference === null) {
        const autoTheme = event.matches ? 'dark' : 'light';
        applyTheme(autoTheme);
        if (themeToggle) {
          themeToggle.checked = autoTheme === 'dark';
        }
      }
    };

    if (typeof mediaQueryDark.addEventListener === 'function') {
      mediaQueryDark.addEventListener('change', handleColorSchemeChange);
    } else if (typeof mediaQueryDark.addListener === 'function') {
      mediaQueryDark.addListener(handleColorSchemeChange);
    }

    function applyTheme(theme) {
      const root = document.documentElement;
      root.setAttribute('data-theme', theme);
      root.style.colorScheme = theme === 'dark' ? 'dark' : 'light';
      if (themeColorMeta) {
        themeColorMeta.setAttribute('content', theme === 'dark' ? '#061321' : '#e6dfcf');
      }
      if (theme === 'dark') {
        ensureGaugeLeds();
      }
      updateGaugeLedArrays();
      if (themeToggle) {
        themeToggle.checked = theme === 'dark';
      }
      const navDialInput = document.querySelector('.dial input');
      if (navDialInput) {
        const dialContainer = navDialInput.closest('.dial');
        setDialFill(dialContainer, navDialInput.value || 0, navDialInput.max);
      }
      syncScannerCameraTheme(theme);
      document.querySelectorAll('input[type="range"].slider').forEach((slider) => setSliderFill(slider));
    }

    function ensureGaugeLeds() {
      if (ledsInitialized) return;
      document.querySelectorAll('.gauge').forEach((gauge) => {
        if (!gauge.querySelector('.gauge-led-strip')) {
          const strip = document.createElement('div');
          strip.className = 'gauge-led-strip';
          strip.setAttribute('aria-hidden', 'true');
          const face = gauge.querySelector('.face');
          if (face) {
            gauge.insertBefore(strip, face);
          } else {
            gauge.appendChild(strip);
          }
        }
        if (!gauge.querySelector('.gauge-led-scale')) {
          const scale = document.createElement('div');
          scale.className = 'gauge-led-scale';
          const minLabel = document.createElement('span');
          const maxLabel = document.createElement('span');
          const minText = gauge.querySelector('.gauge-min')?.textContent?.trim() || '0';
          const maxText = gauge.querySelector('.gauge-max')?.textContent?.trim() || '100';
          minLabel.textContent = minText;
          maxLabel.textContent = maxText;
          scale.append(minLabel, maxLabel);
          gauge.appendChild(scale);
        }
      });
      ledsInitialized = true;
      updateGaugeLedArrays();
    }

    function updateGaugeLedArrays() {
      const gauges = document.querySelectorAll('.gauge');
      gauges.forEach((gauge) => {
        const strip = gauge.querySelector('.gauge-led-strip');
        if (!strip) return;
        let rawValue = gauge.style.getPropertyValue('--value');
        if (!rawValue) {
          const progressEl = gauge.querySelector('progress');
          rawValue = progressEl ? progressEl.value : '0';
        }
        const value = Math.max(0, Math.min(100, parseFloat(rawValue) || 0));
        strip.style.setProperty('--led-value', value.toString());
        if (document.documentElement.getAttribute('data-theme') === 'dark') {
          const computed = getComputedStyle(gauge);
          const getNumberVar = (name, fallback) => {
            const raw = (gauge.style.getPropertyValue(name) || computed.getPropertyValue(name) || '').trim();
            const parsed = parseFloat(raw);
            return Number.isFinite(parsed) ? parsed : fallback;
          };
          const getColorVar = (name, fallback) => {
            const raw = (gauge.style.getPropertyValue(name) || computed.getPropertyValue(name) || '').trim();
            return raw || fallback;
          };
          const zone1End = getNumberVar('--zone1-end', 33);
          const zone2End = getNumberVar('--zone2-end', 66);
          const zone1Color = getColorVar('--zone1-color', 'rgba(255, 82, 134, 0.98)');
          const zone2Color = getColorVar('--zone2-color', 'rgba(156, 235, 255, 0.98)');
          const zone3Color = getColorVar('--zone3-color', 'rgba(112, 255, 188, 0.98)');
          let zoneColor = zone3Color;
          if (value <= zone1End) {
            zoneColor = zone1Color;
          } else if (value <= zone2End) {
            zoneColor = zone2Color;
          }
          strip.style.setProperty('--led-color', zoneColor);
          strip.style.setProperty('--led-color-dim', dimCssColor(zoneColor, 0.46));
          strip.style.setProperty('--led-color-boost', boostCssColor(zoneColor, 1.2));
        } else {
          strip.style.removeProperty('--led-color');
          strip.style.removeProperty('--led-color-dim');
          strip.style.removeProperty('--led-color-boost');
        }
      });
    }

    function setDialFill(dialElement, value, maxValue) {
      if (!dialElement) return;
      const parsedMax = Math.max(1, Number(maxValue ?? dialElement.dataset.steps ?? 1));
      const percent = Math.max(0, Math.min(100, (Number(value) / parsedMax) * 100));
      dialElement.style.setProperty('--fill', `${percent}%`);
      dialElement.style.setProperty('--slider-fill', `${percent}%`);
      const dialInput = dialElement.querySelector('input[type="range"]');
      if (dialInput) {
        dialInput.style.setProperty('--slider-fill', `${percent}%`);
      }
    }

    function setSliderFill(slider) {
      if (!slider) return;
      const min = Number(slider.min || 0);
      const max = Number(slider.max || 100);
      const span = Math.max(1, max - min);
      const value = Number(slider.value || min);
      const percent = Math.max(0, Math.min(100, ((value - min) / span) * 100));
      slider.style.setProperty('--slider-fill', `${percent}%`);
    }

    // ============================================================================
    // FULLSCREEN TOGGLE
    // ============================================================================

    const fullscreenToggle = document.getElementById('fullscreen-toggle');
    
    fullscreenToggle.addEventListener('change', function() {
      if (this.checked) {
        // Request fullscreen with navigation UI hidden (immersive mode)
        const docEl = document.documentElement;
        
        if (docEl.requestFullscreen) {
          docEl.requestFullscreen({ navigationUI: "hide" }).catch(err => {
            console.warn('Fullscreen request failed:', err);
          });
        } else if (docEl.webkitRequestFullscreen) {
          docEl.webkitRequestFullscreen();
        } else if (docEl.msRequestFullscreen) {
          docEl.msRequestFullscreen();
        }
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
    });

    // Listen for fullscreen changes (e.g., user pressing ESC or swiping up nav)
    document.addEventListener('fullscreenchange', syncFullscreenToggle);
    document.addEventListener('webkitfullscreenchange', syncFullscreenToggle);
    document.addEventListener('msfullscreenchange', syncFullscreenToggle);

    function syncFullscreenToggle() {
      const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      fullscreenToggle.checked = isFullscreen;
    }

    // ============================================================================
    // COCKPIT PIN TOGGLE
    // ============================================================================
    
    const cockpitPinToggle = document.getElementById('cockpit-pin-toggle');
    const cockpitPanel = document.querySelector('.cockpit-panel');
    
    // Initialize as unpinned (unchecked by default)
    cockpitPinToggle.checked = false;
    cockpitPanel.classList.add('unpinned');
    
    cockpitPinToggle.addEventListener('change', function() {
      if (this.checked) {
        // Pin the cockpit (enable sticky)
        cockpitPanel.classList.remove('unpinned');
      } else {
        // Unpin the cockpit (disable sticky)
        cockpitPanel.classList.add('unpinned');
        cockpitPanel.classList.remove('stuck'); // Remove stuck styling
      }
    });
    
    // Use Intersection Observer to detect when panel is stuck at top
    // This adds enhanced shadow when the panel is floating
    const observerOptions = {
      threshold: [1],
      rootMargin: '-1px 0px 0px 0px' // Offset by top position
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        // When the panel is NOT fully intersecting (i.e., it's stuck at top)
        if (!entry.isIntersecting && cockpitPinToggle.checked) {
          cockpitPanel.classList.add('stuck');
        } else {
          cockpitPanel.classList.remove('stuck');
        }
      });
    }, observerOptions);
    
    // Create a sentinel element just before the cockpit panel to observe
    const sentinel = document.createElement('div');
    sentinel.style.height = '1px';
    sentinel.style.marginBottom = '-1px';
    sentinel.style.pointerEvents = 'none';
    cockpitPanel.parentNode.insertBefore(sentinel, cockpitPanel);
    observer.observe(sentinel);
    
    // ============================================================================
    // PREVENT CONTEXT MENU ON ALL DIALS (MOBILE LONG-PRESS)
    // ============================================================================
    
    document.querySelectorAll('.dial').forEach(dial => {
      // Prevent context menu
      dial.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
      
      // Also prevent on child elements
      dial.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }, true); // Use capture phase
    });
    
  </script>
</body>
</html>
