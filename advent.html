<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="description" content="A cozy advent calendar filled with daily mini-games and festive surprises. Progress is saved locally so you can unwrap each day at your own pace.">
  <title>Festive Advent Calendar</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <style>
    :root {
      --bg-top: #fef6ff;
      --bg-bottom: #e4f4ff;
      --panel-bg: rgba(255, 255, 255, 0.78);
      --panel-border: rgba(255, 255, 255, 0.9);
      --text-primary: #243047;
      --accent-berry: #ff6f91;
      --accent-mint: #4ad7d1;
      --accent-gold: #f9a826;
      --door-closed: #ffd4d8;
      --door-open: #c2f9ff;
      --door-locked: #d0d7ff;
      --shadow-soft: rgba(36, 48, 71, 0.18);
      --shadow-strong: rgba(36, 48, 71, 0.28);
    }

    body {
      margin: 0;
      font-family: 'Nunito', 'Segoe UI', Tahoma, sans-serif;
      background: linear-gradient(180deg, var(--bg-top) 0%, var(--bg-bottom) 60%, #ffffff 100%);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    body.modal-open {
      overflow: hidden;
    }

    [hidden] {
      display: none !important;
    }

    .top-bar {
      position: sticky;
      top: 0;
      z-index: 30;
      padding: 1.5rem clamp(1rem, 4vw, 3rem);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      background: rgba(255, 255, 255, 0.78);
      border-bottom: 1px solid var(--panel-border);
      box-shadow: 0 10px 30px var(--shadow-soft);
      backdrop-filter: blur(12px);
    }

    .brand {
      font-size: clamp(1.6rem, 4vw, 2.4rem);
      font-weight: 800;
      letter-spacing: 0.02em;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .brand span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-berry), var(--accent-mint));
      box-shadow: 0 6px 16px rgba(255, 111, 145, 0.4);
    }

    .status-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      font-size: 0.95rem;
    }

    #today-label {
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      background: rgba(74, 215, 209, 0.12);
      border: 1px solid rgba(74, 215, 209, 0.4);
    }

    #debug-indicator {
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 111, 145, 0.16);
      border: 1px dashed rgba(255, 111, 145, 0.68);
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--accent-berry);
    }

    button {
      font-family: inherit;
    }

    .button-secondary {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.1rem;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, rgba(36, 48, 71, 0.08), rgba(36, 48, 71, 0.02));
      box-shadow: 0 6px 16px rgba(36, 48, 71, 0.12);
      color: var(--text-primary);
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .button-secondary:hover,
    .button-secondary:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 12px 20px rgba(36, 48, 71, 0.18);
    }

    main {
      flex: 1 1 auto;
      padding: clamp(1.5rem, 5vw, 3rem) clamp(1rem, 5vw, 3.5rem) 4rem;
    }

    .calendar-section {
      max-width: 1100px;
      margin: 0 auto;
    }

    .intro {
      font-size: 1.05rem;
      line-height: 1.7;
      max-width: 760px;
      margin: 0 auto 2rem;
      text-align: center;
      background: rgba(255, 255, 255, 0.74);
      padding: 1.25rem 1.5rem;
      border-radius: 1.2rem;
      box-shadow: 0 12px 28px var(--shadow-soft);
      backdrop-filter: blur(10px);
    }

    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: clamp(1rem, 3vw, 1.75rem);
    }

    .calendar-door {
      position: relative;
      border: none;
      border-radius: 1.2rem;
      padding: 1.4rem 1rem 1.6rem;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.88), rgba(255, 255, 255, 0.68));
      box-shadow: 0 12px 24px var(--shadow-soft);
      text-align: left;
      cursor: pointer;
      min-height: 180px;
      color: inherit;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .calendar-door:hover,
    .calendar-door:focus-visible {
      transform: translateY(-6px);
      box-shadow: 0 18px 36px var(--shadow-strong);
    }

    .calendar-door.opened {
      background: linear-gradient(135deg, var(--door-open) 0%, #f6fffe 100%);
    }

    .calendar-door.locked {
      background: linear-gradient(135deg, var(--door-locked) 0%, #f3f5ff 100%);
    }

    .calendar-door .door-badge {
      position: absolute;
      top: 0.9rem;
      right: 1.1rem;
      background: var(--accent-berry);
      color: #fff;
      padding: 0.2rem 0.65rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      box-shadow: 0 6px 14px rgba(255, 111, 145, 0.4);
    }

    .calendar-door.locked .door-badge {
      background: #7488ff;
    }

    .calendar-door.opened .door-badge {
      background: var(--accent-mint);
      color: #1b2a35;
    }

    .door-front {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    .door-number {
      font-size: 2.4rem;
      font-weight: 800;
      letter-spacing: 0.04em;
    }

    .door-title {
      font-size: 1rem;
      font-weight: 700;
      line-height: 1.4;
      min-height: 2.6rem;
    }

    .door-status {
      font-size: 0.92rem;
      opacity: 0.8;
    }

    .calendar-door.locked .door-status {
      color: #5261b8;
    }

    .calendar-door.opened .door-status {
      color: #12807f;
    }

    .calendar-door[data-gamepad-focus="true"] {
      outline: 3px solid var(--accent-berry);
      outline-offset: 4px;
    }

    .calendar-door.wiggle {
      animation: wiggle 0.45s ease;
    }

    @keyframes wiggle {
      0% { transform: translateX(0); }
      25% { transform: translateX(-6px) rotate(-1deg); }
      50% { transform: translateX(6px) rotate(1deg); }
      75% { transform: translateX(-4px) rotate(-1deg); }
      100% { transform: translateX(0); }
    }

    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(1.5rem, 5vw, 3rem);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 60;
    }

    .modal.is-open {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(36, 48, 71, 0.48);
      backdrop-filter: blur(8px);
    }

    .modal-dialog {
      position: relative;
      z-index: 1;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 1.6rem;
      max-width: min(720px, 92vw);
      width: 100%;
      padding: clamp(1.6rem, 4vw, 2.6rem);
      box-shadow: 0 26px 52px rgba(36, 48, 71, 0.32);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: none;
      background: rgba(36, 48, 71, 0.08);
      font-size: 1.4rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    .modal-close:hover,
    .modal-close:focus-visible {
      background: rgba(36, 48, 71, 0.16);
      transform: scale(1.05);
    }

    .modal-title {
      font-size: clamp(1.35rem, 3.2vw, 1.9rem);
      margin: 0;
    }

    .modal-summary {
      font-size: 1rem;
      line-height: 1.6;
      margin: 0 0 0.5rem;
      color: rgba(36, 48, 71, 0.82);
    }

    .mini-game {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      align-items: center;
    }

    .game-help {
      font-size: 0.95rem;
      line-height: 1.5;
      text-align: center;
      color: rgba(36, 48, 71, 0.78);
      margin: 0;
      max-width: 520px;
    }

    .snowflake-game {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }

    .snowflake-button {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      border: none;
      font-size: 3rem;
      cursor: pointer;
      background: radial-gradient(circle at 50% 30%, #ffffff 0%, #e1f6ff 45%, #c0ecff 100%);
      box-shadow: 0 12px 24px rgba(74, 215, 209, 0.35);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .snowflake-button:hover,
    .snowflake-button:focus-visible {
      transform: scale(1.06);
      box-shadow: 0 16px 28px rgba(74, 215, 209, 0.45);
    }

    .snowflake-button.activated {
      background: radial-gradient(circle at 50% 30%, #ffffff 0%, #d4f6ff 55%, #a8f3ff 100%);
      box-shadow: 0 16px 30px rgba(74, 215, 209, 0.5);
    }

    .cookie-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.2rem;
    }

    .cookie {
      position: relative;
      width: clamp(180px, 40vw, 220px);
      aspect-ratio: 1;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fde4be 0%, #f6b673 62%, #d9893f 100%);
      box-shadow: inset 0 12px 24px rgba(0, 0, 0, 0.18);
      overflow: hidden;
    }

    .cookie::before {
      content: '';
      position: absolute;
      inset: 16%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.35) 0%, rgba(255, 255, 255, 0) 65%);
    }

    .cookie .topping {
      position: absolute;
      inset: 0;
      opacity: 0;
      transition: opacity 0.35s ease;
      mix-blend-mode: screen;
    }

    .cookie .topping.active {
      opacity: 1;
    }

    .cookie .topping.sprinkles {
      background-image: repeating-linear-gradient(45deg, rgba(255, 118, 117, 0.85) 0 7px, transparent 7px 14px), repeating-linear-gradient(-45deg, rgba(116, 185, 255, 0.82) 0 7px, transparent 7px 14px);
    }

    .cookie .topping.icing {
      background-image: radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.78) 0 16%, transparent 17%), radial-gradient(circle at 70% 40%, rgba(255, 255, 255, 0.82) 0 18%, transparent 19%), radial-gradient(circle at 50% 70%, rgba(255, 255, 255, 0.72) 0 20%, transparent 21%);
    }

    .cookie .topping.stars {
      background-image: radial-gradient(circle, rgba(255, 255, 255, 0.96) 0 3px, transparent 4px);
      background-size: 48px 48px;
      background-position: 8px 12px, 32px 32px, 60px 18px, 92px 54px;
    }

    .cookie-controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .cookie-toggle {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.1rem;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.96), rgba(255, 255, 255, 0.75));
      box-shadow: 0 8px 20px rgba(36, 48, 71, 0.16);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .cookie-toggle:hover,
    .cookie-toggle:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(36, 48, 71, 0.22);
    }

    .cookie-toggle.active {
      background: linear-gradient(135deg, rgba(249, 168, 38, 0.9), rgba(255, 230, 153, 0.95));
      color: #2f2100;
    }

    .lights-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .lights-preview,
    .lights-row {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .light-bulb {
      position: relative;
      width: 48px;
      height: 68px;
      border-radius: 22px 22px 16px 16px;
      border: none;
      cursor: pointer;
      background: linear-gradient(160deg, #ffe5f0 0%, #ffc8d9 100%);
      box-shadow: 0 10px 18px rgba(255, 111, 145, 0.28);
      transition: transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease;
    }

    .light-bulb::after {
      content: '';
      position: absolute;
      top: -12px;
      left: 50%;
      width: 26px;
      height: 14px;
      border-radius: 4px;
      background: #4a4a4a;
      transform: translateX(-50%);
    }

    .light-bulb.on {
      background: linear-gradient(160deg, #fffadc 0%, #ffe066 100%);
      box-shadow: 0 0 16px rgba(255, 240, 140, 0.8), 0 12px 22px rgba(255, 203, 107, 0.3);
      filter: saturate(1.15);
    }

    .light-bulb[data-role="preview"] {
      pointer-events: none;
      border: 2px dashed rgba(36, 48, 71, 0.2);
      box-shadow: none;
      cursor: default;
    }

    .light-bulb:focus-visible {
      outline: 3px solid var(--accent-gold);
      outline-offset: 3px;
    }

    .music-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.2rem;
    }

    .music-keys {
      display: flex;
      gap: 0.85rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .bell-button {
      border: none;
      border-radius: 1.1rem;
      width: 88px;
      height: 88px;
      font-weight: 700;
      color: #1c2738;
      cursor: pointer;
      background: linear-gradient(155deg, var(--bell-color, #ffd6e8) 0%, rgba(255, 255, 255, 0.95) 70%);
      box-shadow: 0 10px 22px rgba(36, 48, 71, 0.2);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .bell-button:hover,
    .bell-button:focus-visible {
      transform: translateY(-4px);
      box-shadow: 0 16px 28px rgba(36, 48, 71, 0.28);
    }

    .music-progress {
      display: flex;
      gap: 0.4rem;
    }

    .music-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(36, 48, 71, 0.18);
    }

    .music-dot.active {
      background: var(--accent-mint);
      box-shadow: 0 0 8px rgba(74, 215, 209, 0.6);
    }

    .story-game {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      align-items: center;
      text-align: center;
    }

    .story-card {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.96), rgba(237, 247, 255, 0.9));
      border-radius: 1.2rem;
      padding: 1.5rem;
      box-shadow: 0 16px 30px rgba(36, 48, 71, 0.18);
      max-width: 520px;
      font-size: 1.02rem;
      line-height: 1.6;
      position: relative;
    }

    .story-emoji {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .story-controls {
      display: flex;
      gap: 0.75rem;
    }

    .story-next {
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.4rem;
      cursor: pointer;
      font-weight: 600;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.7));
      box-shadow: 0 12px 24px rgba(36, 48, 71, 0.2);
    }

    .story-next:hover,
    .story-next:focus-visible {
      transform: translateY(-3px);
      box-shadow: 0 18px 30px rgba(36, 48, 71, 0.26);
    }

    .snowball-game {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
      width: 100%;
    }

    .snowball-stage {
      position: relative;
      width: min(360px, 100%);
      height: 260px;
      border-radius: 1.2rem;
      background: linear-gradient(180deg, #e4f4ff 0%, #ffffff 80%);
      border: 2px solid rgba(36, 48, 71, 0.08);
      box-shadow: inset 0 12px 24px rgba(255, 255, 255, 0.6), 0 18px 36px rgba(36, 48, 71, 0.2);
      overflow: hidden;
      touch-action: none;
    }

    .snowball-crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      border: 2px dashed rgba(36, 48, 71, 0.55);
      transform: translate(-50%, -50%);
      pointer-events: none;
      box-shadow: 0 0 0 6px rgba(36, 48, 71, 0.08);
    }

    .snowball-target {
      position: absolute;
      left: 50%;
      top: 35%;
      width: 76px;
      height: 76px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle at 45% 30%, #ffffff 0%, #ffe4f1 55%, #ff8fb6 100%);
      box-shadow: 0 12px 22px rgba(255, 143, 182, 0.3);
      font-size: 2.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .snowball-splat {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      transform: translate(-50%, -50%) scale(0.2);
      animation: splat 0.5s ease forwards;
    }

    .snowball-splat.success {
      background: rgba(74, 215, 209, 0.85);
    }

    @keyframes splat {
      0% { transform: translate(-50%, -50%) scale(0.2); opacity: 0.9; }
      70% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.95; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }

    #toast {
      position: fixed;
      bottom: 1.6rem;
      left: 50%;
      transform: translate(-50%, 20px);
      background: rgba(255, 255, 255, 0.95);
      padding: 0.75rem 1.4rem;
      border-radius: 999px;
      box-shadow: 0 14px 28px rgba(36, 48, 71, 0.24);
      font-weight: 600;
      color: var(--text-primary);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 70;
    }

    #toast.is-visible {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .snow-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.6s ease;
      z-index: 40;
    }

    .snow-layer[data-active="true"] {
      opacity: 1;
    }

    .snow-layer .flake {
      position: absolute;
      top: -10vh;
      left: var(--x);
      font-size: var(--size, 1rem);
      animation: snow-fall var(--duration, 8s) linear infinite;
      animation-delay: var(--delay, 0s);
      opacity: 0.9;
      filter: drop-shadow(0 4px 8px rgba(36, 48, 71, 0.18));
    }

    @keyframes snow-fall {
      0% { transform: translate3d(0, -10vh, 0); }
      100% { transform: translate3d(var(--drift, 0), 110vh, 0); }
    }

    @media (max-width: 780px) {
      .calendar-door {
        min-height: 160px;
      }

      .door-title {
        min-height: 2.4rem;
      }
    }

    @media (max-width: 540px) {
      .top-bar {
        flex-direction: column;
        align-items: flex-start;
      }

      .brand {
        font-size: 1.8rem;
      }

      .modal-dialog {
        padding: 1.4rem;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .snow-layer {
        display: none;
      }
    }
  </style>
</head>

<body>
  <header class="top-bar">
    <div class="brand"><span>üéÅ</span>Festive Advent Surprise</div>
    <div class="status-group">
      <span id="today-label">Today</span>
      <span id="debug-indicator" hidden>Debug mode</span>
      <button id="reset-progress" class="button-secondary" type="button">Reset progress</button>
    </div>
  </header>
  <main>
    <section class="calendar-section">
      <p class="intro">Open a window each day (or catch up later!) to reveal a tiny festive mini-game. Your progress lives in this browser.</p>
  <div id="calendar-grid" class="calendar-grid" aria-label="Advent calendar windows"></div>
    </section>
  </main>

  <div id="modal" class="modal" aria-hidden="true">
    <div id="modal-backdrop" class="modal-backdrop" aria-hidden="true"></div>
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      <button id="modal-close" class="modal-close" type="button" aria-label="Close mini-game">√ó</button>
      <h2 id="modal-title" class="modal-title"></h2>
      <p id="modal-summary" class="modal-summary"></p>
      <div id="mini-game" class="mini-game"></div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>
  <div id="snow-layer" class="snow-layer" aria-hidden="true"></div>

  <script type="module">
    const STORAGE_KEY = 'idlegames-advent-2025';
    const DEBUG_SEQUENCE = 'debug';
    const DAY_MS = 24 * 60 * 60 * 1000;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    const snowLayer = document.getElementById('snow-layer');
    const toastEl = document.getElementById('toast');
    const todayLabel = document.getElementById('today-label');
    const debugIndicator = document.getElementById('debug-indicator');
    const resetBtn = document.getElementById('reset-progress');
    const modal = document.getElementById('modal');
    const modalBackdrop = document.getElementById('modal-backdrop');
    const modalTitle = document.getElementById('modal-title');
    const modalSummary = document.getElementById('modal-summary');
    const modalClose = document.getElementById('modal-close');
    const miniGameContainer = document.getElementById('mini-game');

    const windowTemplates = [
      { title: 'Snowflake Ballet', summary: 'Tap the shimmering snowflake to release a gentle snowfall for the whole page.', game: 'snowflake', storyEmoji: '‚ùÑÔ∏è' },
      { title: 'Cookie Canvas', summary: 'Frost and decorate the ginger cookie with sprinkles and stars.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Peppermint Sprinkles', className: 'sprinkles' },
        { id: 'icing', label: 'Vanilla Ribbon', className: 'icing' },
        { id: 'stars', label: 'Sugar Stardust', className: 'stars' }
      ] },
      { title: 'Snowball Arcade', summary: 'Aim the crosshair and pelt the wiggly snow pal three times to win.', game: 'snowball', targetEmoji: '‚òÉÔ∏è' },
      { title: 'Twinkle Tangle', summary: 'Match the preview pattern to untangle the fairy lights.', game: 'lights', pattern: '101101', clue: 'Every bulb glowing in the preview should shine on your strand.' },
      { title: 'North Pole Post', summary: 'Deliver a comforting note from the workshop crew.', game: 'story', storyEmoji: 'üì¨', storySteps: [
        'A basket of letters arrives under a swirl of aurora dust.',
        'You sip cocoa and write back in looping, cozy script.',
        'Somewhere north, a sleepy child smiles at your reply.'
      ] },
      { title: 'Peppermint Chimes', summary: 'Ring the bells to play the candy cane melody.', game: 'music', melody: [0, 3, 1, 2] },
      { title: 'Cranberry Crumble', summary: 'Add cranberry crunch to finish today\'s cookie.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Cranberry Crunch', className: 'sprinkles' },
        { id: 'icing', label: 'Cinnamon Icing', className: 'icing' },
        { id: 'stars', label: 'Frost Flakes', className: 'stars' }
      ] },
      { title: 'Candy Cane Cluster', summary: 'Light up every other bulb in a candy cane rhythm.', game: 'lights', pattern: '010101', clue: 'Alternate bulbs should glow like candy cane stripes.' },
      { title: 'Yeti Dodge', summary: 'Can you tag the giggling yeti with three snowy throws?', game: 'snowball', targetEmoji: 'üßä' },
      { title: 'Workshop Whispers', summary: 'A tinkerer shares a whispered workshop secret.', game: 'story', storyEmoji: 'üõ†Ô∏è', storySteps: [
        'You peek into the workshop where tools hum softly.',
        'A sprite whispers: ‚ÄúAdd kindness to every toy screw.‚Äù',
        'You nod and promise to pass the secret along.'
      ] },
      { title: 'Cinnamon Sketch', summary: 'Decorate the cinnamon cookie with icing loops.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Cinnamon Sugar', className: 'sprinkles' },
        { id: 'icing', label: 'Maple Swirl', className: 'icing' },
        { id: 'stars', label: 'Sparkle Chips', className: 'stars' }
      ] },
      { title: 'Aurora Arpeggio', summary: 'Replay the aurora melody before it fades.', game: 'music', melody: [2, 1, 3, 0] },
      { title: 'Reindeer Report', summary: 'Read the latest sprint from the reindeer team.', game: 'story', storyEmoji: 'ü¶å', storySteps: [
        'Blitzen scribbles lap times with snow-dusted hooves.',
        'Dasher suggests extra carrot breaks for morale.',
        'You stamp the report approved with a jingling seal.'
      ] },
      { title: 'Frosted Garland', summary: 'Sparkle the garland exactly like the preview.', game: 'lights', pattern: '110011', clue: 'The twins at each end should glow together.' },
      { title: 'Powder Puff Challenge', summary: 'Snowballs fly fast ‚Äî land three to win!', game: 'snowball', targetEmoji: 'üéØ' },
      { title: 'Starlit Shortbread', summary: 'Finish the shortbread with glittering sugar.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Star Confetti', className: 'sprinkles' },
        { id: 'icing', label: 'Moonbeam Icing', className: 'icing' },
        { id: 'stars', label: 'Galaxy Dust', className: 'stars' }
      ] },
      { title: 'Hot Cocoa Harmonies', summary: 'Warm up the bells with this cocoa harmony.', game: 'music', melody: [1, 1, 2, 3] },
      { title: 'Frostbite Fables', summary: 'A storyteller shares a chilly bedtime fable.', game: 'story', storyEmoji: 'üìñ', storySteps: [
        'An elder stirs frost with a cedar wand as stars listen.',
        'They weave a tale of a lantern guiding lost snowflakes home.',
        'You tuck the tale away for tonight\'s bedside share.'
      ] },
      { title: 'Icicle Lattice', summary: 'Mirror the icicle lattice lights.', game: 'lights', pattern: '100111', clue: 'Let the last trio shimmer together.' },
      { title: 'Blizzard Blitz', summary: 'It\'s a blizzard ‚Äî stay sharp and land your throws.', game: 'snowball', targetEmoji: 'üå®Ô∏è' },
      { title: 'Cozy Crinkle', summary: 'Add every topping to the cozy crinkle cookie.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Toffee Pebbles', className: 'sprinkles' },
        { id: 'icing', label: 'Buttered Frost', className: 'icing' },
        { id: 'stars', label: 'Coal Glitter', className: 'stars' }
      ] },
      { title: 'Jingle Jam Studio', summary: 'Jam along with the elves in four bright bell hits.', game: 'music', melody: [3, 2, 0, 1] },
      { title: 'Final Postcard', summary: 'Send final greetings before the big night.', game: 'story', storyEmoji: 'üíå', storySteps: [
        'Stacks of postcards wait for their final sparkle.',
        'You seal each one with glitter and a hopeful wish.',
        'The mail sled glides away toward twinkling chimneys.'
      ] },
      { title: 'North Star Finale', summary: 'Light every bulb to crown the tree with a star.', game: 'lights', pattern: '111111', clue: 'Everything should glow in dazzling unity.' }
    ];

    const baseDateUtc = Date.UTC(2025, 11, 1, 0, 0, 0);
    const closingDateUtc = Date.UTC(2026, 0, 15, 23, 59, 59);

    const WINDOWS = windowTemplates.map((tpl, index) => {
      const availableFrom = new Date(baseDateUtc + index * DAY_MS);
      const availableTo = new Date(closingDateUtc);
      return {
        ...tpl,
        day: index + 1,
        availableFrom,
        availableTo,
        availableFromISO: availableFrom.toISOString(),
        availableToISO: availableTo.toISOString()
      };
    });

    const GAME_BUILDERS = {
      snowflake: buildSnowflakeGame,
      cookie: buildCookieGame,
      snowball: buildSnowballGame,
      lights: buildLightsGame,
      story: buildStoryGame,
      music: buildMusicGame
    };

    const defaultToppings = [
      { id: 'sprinkles', label: 'Rainbow Sprinkles', className: 'sprinkles' },
      { id: 'icing', label: 'Vanilla Icing', className: 'icing' },
      { id: 'stars', label: 'Starlight Sugar', className: 'stars' }
    ];

    const bellNotes = [
      { label: 'Peppermint', color: '#ffb2d8', freq: 523.25 },
      { label: 'Snowfall', color: '#b9efff', freq: 587.33 },
      { label: 'Cocoa', color: '#ffd1a9', freq: 659.25 },
      { label: 'Starlight', color: '#fff3a7', freq: 698.46 }
    ];

    const doorDateFormatter = (() => {
      try {
        return new Intl.DateTimeFormat(undefined, { month: 'short', day: 'numeric' });
      } catch (err) {
        return { format: date => date.toISOString().slice(5, 10) };
      }
    })();

    const todayFormatter = (() => {
      try {
        return new Intl.DateTimeFormat(undefined, { weekday: 'long', month: 'short', day: 'numeric' });
      } catch (err) {
        return { format: date => date.toDateString() };
      }
    })();

    let progress = loadProgress();
    let debugMode = false;
    let snowfallActive = false;
    let toastTimer = 0;
    let codeBuffer = '';
    let doorButtons = [];
    let focusedDoorIndex = 0;
    let lastFocusedDoor = null;
    let lastOpenedDay = null;
    let activeGameCleanup = null;
    let activeGamepadHandler = null;
    let previousButtonState = [];
    let navCooldown = 0;
    let gamepadLoopRunning = false;
    let gamepadConnected = false;
    let lastGamepadTimestamp = 0;
    let audioCtx = null;

    if (progress.effects && progress.effects.snowfall) {
      startSnowfall({ silent: true });
    }

    renderCalendar();
    updateTodayLabel();
    updateDebugIndicator();
    setInterval(() => {
      updateTodayLabel();
      if (!isModalOpen()) {
        renderCalendar();
      }
    }, 60 * 1000);

    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (!confirm('Reset advent calendar progress? This clears opened windows and snowfall.')) return;
        progress = { opened: {}, effects: {} };
        saveProgress();
        snowfallActive = false;
        delete snowLayer.dataset.active;
        snowLayer.removeAttribute('data-active');
        snowLayer.innerHTML = '';
        lastOpenedDay = null;
        lastFocusedDoor = null;
        renderCalendar();
        showToast('Progress reset ‚Äî happy adventuring!', 3400);
      });
    }

    modalClose.addEventListener('click', closeModal);
    modalBackdrop.addEventListener('click', closeModal);

    window.addEventListener('keydown', handleGlobalKeydown, { passive: false });

    window.addEventListener('gamepadconnected', () => {
      gamepadConnected = true;
      ensureGamepadLoop();
      showToast('Gamepad connected ‚Äî explore with the stick or D-pad!');
      if (doorButtons.length) {
        focusDoor(focusedDoorIndex);
      }
    });

    window.addEventListener('gamepaddisconnected', () => {
      const pads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
      gamepadConnected = pads.length > 0;
      if (!gamepadConnected) {
        doorButtons.forEach(btn => btn.dataset.gamepadFocus = 'false');
      }
    });

    ensureGamepadLoop();

    function loadProgress() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { opened: {}, effects: {} };
        const parsed = JSON.parse(raw);
        return {
          opened: parsed && parsed.opened ? parsed.opened : {},
          effects: parsed && parsed.effects ? parsed.effects : {}
        };
      } catch (err) {
        console.warn('Unable to load advent progress', err);
        return { opened: {}, effects: {} };
      }
    }

    function saveProgress() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
      } catch (err) {
        console.warn('Unable to save advent progress', err);
      }
    }

    function formatDate(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return 'soon';
      return doorDateFormatter.format(date);
    }

    function canOpen(win) {
      if (debugMode) return true;
      const now = new Date();
      return now >= win.availableFrom;
    }

    function renderCalendar() {
      const grid = document.getElementById('calendar-grid');
      if (!grid) return;
      const previouslyFocusedDay = doorButtons[focusedDoorIndex] ? doorButtons[focusedDoorIndex].dataset.day : null;
      grid.innerHTML = '';
      WINDOWS.forEach(win => {
        const door = document.createElement('button');
        door.type = 'button';
        door.className = 'calendar-door';
        door.dataset.day = String(win.day);
        door.setAttribute('data-available-from', win.availableFromISO);
        door.setAttribute('data-available-to', win.availableToISO);
        door.setAttribute('aria-haspopup', 'dialog');
        door.setAttribute('aria-controls', 'modal');
        door.title = `Day ${win.day}: ${win.title}`;
        door.innerHTML = `
          <span class="door-badge">Soon</span>
          <span class="door-front">
            <span class="door-number">${String(win.day).padStart(2, '0')}</span>
            <span class="door-title">${win.title}</span>
            <span class="door-status"></span>
          </span>`;
        applyDoorState(door, win);
        door.addEventListener('click', () => handleDoor(win, door));
        grid.appendChild(door);
      });
      updateDoorCollection(previouslyFocusedDay);
      if (typeof lastOpenedDay === 'number') {
        const match = doorButtons.find(btn => Number(btn.dataset.day) === lastOpenedDay);
        if (match) {
          lastFocusedDoor = match;
        }
      }
    }

    function applyDoorState(door, win) {
      const key = String(win.day);
      const openedEntry = progress.opened[key];
      const opened = !!openedEntry;
      const unlocked = canOpen(win) || opened;
      door.classList.toggle('opened', opened);
      door.classList.toggle('locked', !unlocked);
      door.setAttribute('data-available-now', unlocked ? 'true' : 'false');
      const statusEl = door.querySelector('.door-status');
      const badgeEl = door.querySelector('.door-badge');
      if (!statusEl) return;
      if (opened) {
        const openedAt = openedEntry && openedEntry.openedAt ? new Date(openedEntry.openedAt) : null;
        statusEl.textContent = openedAt ? `Opened ${formatDate(openedAt)}` : 'Opened!';
        if (badgeEl) badgeEl.textContent = 'Opened';
      } else if (unlocked) {
        statusEl.textContent = 'Ready!';
        if (badgeEl) badgeEl.textContent = 'Ready';
      } else {
        statusEl.textContent = `Opens ${formatDate(win.availableFrom)}`;
        if (badgeEl) badgeEl.textContent = 'Locked';
      }
      door.setAttribute('aria-label', `Day ${win.day}: ${win.title}. ${statusEl.textContent}`);
    }

    function handleDoor(win, door) {
      const key = String(win.day);
      const opened = !!progress.opened[key];
      const unlocked = canOpen(win) || opened;
      if (!unlocked) {
        door.classList.add('wiggle');
        setTimeout(() => door.classList.remove('wiggle'), 460);
        showToast(`That window opens on ${formatDate(win.availableFrom)}.`);
        return;
      }
      if (!opened) {
        progress.opened[key] = { openedAt: new Date().toISOString() };
        saveProgress();
        applyDoorState(door, win);
      }
      lastFocusedDoor = door;
      lastOpenedDay = win.day;
      openModal(win);
    }

    function openModal(win) {
      if (activeGameCleanup) {
        activeGameCleanup();
        activeGameCleanup = null;
      }
      setActiveGamepadHandler(null);
      miniGameContainer.innerHTML = '';
      modalTitle.textContent = `Day ${win.day}: ${win.title}`;
      modalSummary.textContent = win.summary || '';
      const builder = GAME_BUILDERS[win.game];
      let builderResult = null;
      if (builder) {
        builderResult = builder(miniGameContainer, win) || null;
      } else {
        const fallback = document.createElement('p');
        fallback.className = 'game-help';
        fallback.textContent = 'This surprise is still baking. Please check back soon!';
        miniGameContainer.appendChild(fallback);
      }
      if (builderResult && typeof builderResult.cleanup === 'function') {
        activeGameCleanup = builderResult.cleanup;
      } else {
        activeGameCleanup = null;
      }
      if (builderResult && typeof builderResult.gamepadHandler === 'function') {
        setActiveGamepadHandler(builderResult.gamepadHandler);
      }
      modal.classList.add('is-open');
      modal.setAttribute('aria-hidden', 'false');
      document.body.classList.add('modal-open');
      modalClose.focus({ preventScroll: true });
    }

    function closeModal() {
      if (!isModalOpen()) return;
      modal.classList.remove('is-open');
      modal.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('modal-open');
      if (activeGameCleanup) {
        activeGameCleanup();
        activeGameCleanup = null;
      }
      setActiveGamepadHandler(null);
      miniGameContainer.innerHTML = '';
      if (lastFocusedDoor && document.body.contains(lastFocusedDoor)) {
        lastFocusedDoor.focus({ preventScroll: true });
      } else if (typeof lastOpenedDay === 'number') {
        const fallback = doorButtons.find(btn => Number(btn.dataset.day) === lastOpenedDay);
        fallback?.focus({ preventScroll: true });
      }
      lastFocusedDoor = null;
      lastOpenedDay = null;
    }

    function isModalOpen() {
      return modal.classList.contains('is-open');
    }

    function updateDoorCollection(preferredDay) {
      doorButtons = Array.from(document.querySelectorAll('.calendar-door'));
      doorButtons.forEach(btn => btn.dataset.gamepadFocus = 'false');
      if (preferredDay) {
        const idx = doorButtons.findIndex(btn => btn.dataset.day === preferredDay);
        focusedDoorIndex = idx >= 0 ? idx : 0;
      } else {
        focusedDoorIndex = Math.min(focusedDoorIndex, Math.max(doorButtons.length - 1, 0));
      }
      if (gamepadConnected && doorButtons.length) {
        focusDoor(focusedDoorIndex);
      }
    }

    function focusDoor(index) {
      if (!doorButtons[index]) return;
      doorButtons.forEach((btn, idx) => {
        btn.dataset.gamepadFocus = idx === index ? 'true' : 'false';
      });
      doorButtons[index].focus({ preventScroll: true });
    }

    function updateTodayLabel() {
      if (!todayLabel) return;
      todayLabel.textContent = todayFormatter.format(new Date());
    }

    function updateDebugIndicator() {
      if (!debugIndicator) return;
      debugIndicator.hidden = !debugMode;
      if (debugMode) {
        debugIndicator.textContent = 'Debug mode active';
      }
    }

    function showToast(message, duration = 3000) {
      if (!toastEl) return;
      toastEl.textContent = message;
      toastEl.classList.add('is-visible');
      clearTimeout(toastTimer);
      toastTimer = window.setTimeout(() => {
        toastEl.classList.remove('is-visible');
      }, duration);
    }

    function handleGlobalKeydown(event) {
      if (event.key === 'Escape' && isModalOpen()) {
        event.preventDefault();
        closeModal();
        return;
      }
      const targetTag = (event.target && event.target.tagName) || '';
      if (targetTag === 'INPUT' || targetTag === 'TEXTAREA' || targetTag === 'SELECT') {
        return;
      }
      if (event.key && event.key.length === 1 && /^[a-zA-Z]$/.test(event.key)) {
        codeBuffer = (codeBuffer + event.key.toLowerCase()).slice(-DEBUG_SEQUENCE.length);
        if (codeBuffer === DEBUG_SEQUENCE) {
          toggleDebugMode();
          codeBuffer = '';
        }
      }
    }

    function toggleDebugMode() {
      debugMode = !debugMode;
      updateDebugIndicator();
      renderCalendar();
      showToast(debugMode ? 'Debug mode enabled ‚Äî every window is unlocked.' : 'Debug mode disabled.');
    }

    function startSnowfall(options = {}) {
      const { silent = false } = options;
      if (snowfallActive) {
        if (!silent) showToast('Snow is already drifting!');
        return;
      }
      if (prefersReducedMotion) {
        snowfallActive = true;
        return;
      }
      ensureSnowflakes();
      snowLayer.dataset.active = 'true';
      snowfallActive = true;
      if (!silent) {
        showToast('Snow is now falling across the page!');
      }
    }

    function ensureSnowflakes() {
      if (prefersReducedMotion) return;
      if (snowLayer.childElementCount) return;
      const flakeCount = 80;
      for (let i = 0; i < flakeCount; i += 1) {
        const flake = document.createElement('span');
        flake.className = 'flake';
        const left = (Math.random() * 100).toFixed(2);
        const size = (0.6 + Math.random() * 1.4).toFixed(2);
        const duration = (6 + Math.random() * 8).toFixed(2);
        const delay = (-Math.random() * 12).toFixed(2);
        const drift = (Math.random() * 20 - 10).toFixed(2) + 'vw';
        flake.style.setProperty('--x', `${left}vw`);
        flake.style.setProperty('--size', `${size}rem`);
        flake.style.setProperty('--duration', `${duration}s`);
        flake.style.setProperty('--delay', `${delay}s`);
        flake.style.setProperty('--drift', drift);
        flake.textContent = Math.random() > 0.6 ? '‚ùÑÔ∏è' : '‚úº';
        snowLayer.appendChild(flake);
      }
    }

    function setActiveGamepadHandler(handler) {
      activeGamepadHandler = typeof handler === 'function' ? handler : null;
    }

    function ensureGamepadLoop() {
      if (gamepadLoopRunning) return;
      gamepadLoopRunning = true;
      requestAnimationFrame(pollGamepad);
    }

    function pollGamepad(timestamp) {
      if (!gamepadLoopRunning) return;
      const pads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
      const pad = pads[0] || null;
      const delta = lastGamepadTimestamp ? (timestamp - lastGamepadTimestamp) : 16;
      lastGamepadTimestamp = timestamp;
      if (pad) {
        if (!gamepadConnected) {
          gamepadConnected = true;
          if (doorButtons.length) {
            focusDoor(focusedDoorIndex);
          }
        }
        const buttons = pad.buttons.map(btn => !!(btn && btn.pressed));
        if (isModalOpen()) {
          if (typeof activeGamepadHandler === 'function') {
            activeGamepadHandler({ pad, buttons, prevButtons: previousButtonState, delta });
          }
          if (buttons[1] && !(previousButtonState[1])) {
            closeModal();
          }
        } else {
          handleDoorNavigation({ pad, buttons, prevButtons: previousButtonState, delta });
        }
        previousButtonState = buttons;
      } else {
        if (gamepadConnected) {
          doorButtons.forEach(btn => btn.dataset.gamepadFocus = 'false');
        }
        gamepadConnected = false;
        previousButtonState = [];
      }
      requestAnimationFrame(pollGamepad);
    }

    function handleDoorNavigation({ pad, buttons, prevButtons, delta }) {
      if (!doorButtons.length) return;
      const axisX = pad.axes[0] || 0;
      const axisY = pad.axes[1] || 0;
      const prev = Array.isArray(prevButtons) ? prevButtons : [];
      navCooldown = Math.max(0, navCooldown - delta);
      const pressRight = buttons[15] && !prev[15];
      const pressLeft = buttons[14] && !prev[14];
      const pressDown = buttons[13] && !prev[13];
      const pressUp = buttons[12] && !prev[12];
      const threshold = 0.45;
      const ready = navCooldown <= 0;
      if (ready) {
        if (axisX > threshold || pressRight) {
          moveFocus('right');
          navCooldown = 180;
        } else if (axisX < -threshold || pressLeft) {
          moveFocus('left');
          navCooldown = 180;
        } else if (axisY > threshold || pressDown) {
          moveFocus('down');
          navCooldown = 180;
        } else if (axisY < -threshold || pressUp) {
          moveFocus('up');
          navCooldown = 180;
        }
      }
      if (buttons[0] && !prev[0]) {
        const target = doorButtons[focusedDoorIndex];
        target?.click();
      }
    }

    function moveFocus(direction) {
      if (!doorButtons.length) return;
      if (!doorButtons[focusedDoorIndex]) {
        focusedDoorIndex = 0;
      }
      const current = doorButtons[focusedDoorIndex];
      const currentRect = current.getBoundingClientRect();
      const currentCenter = {
        x: currentRect.left + currentRect.width / 2,
        y: currentRect.top + currentRect.height / 2
      };
      let bestIdx = focusedDoorIndex;
      let bestScore = Infinity;
      doorButtons.forEach((btn, idx) => {
        if (idx === focusedDoorIndex) return;
        const rect = btn.getBoundingClientRect();
        const center = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        const deltaX = center.x - currentCenter.x;
        const deltaY = center.y - currentCenter.y;
        if (direction === 'left' && deltaX < -10) {
          const score = Math.abs(deltaX) + Math.abs(deltaY) * 0.6;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        } else if (direction === 'right' && deltaX > 10) {
          const score = Math.abs(deltaX) + Math.abs(deltaY) * 0.6;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        } else if (direction === 'up' && deltaY < -10) {
          const score = Math.abs(deltaY) + Math.abs(deltaX) * 0.5;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        } else if (direction === 'down' && deltaY > 10) {
          const score = Math.abs(deltaY) + Math.abs(deltaX) * 0.5;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        }
      });
      if (bestIdx !== focusedDoorIndex) {
        focusedDoorIndex = bestIdx;
        focusDoor(focusedDoorIndex);
      }
    }

    function launchMiniGame(win, container) {
      const builder = GAME_BUILDERS[win.game];
      if (!builder) {
        container.innerHTML = '<p class="game-help">This surprise is still baking. Please check back soon!</p>';
        return { cleanup: () => {} };
      }
      return builder(container, win);
    }

    function buildSnowflakeGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'snowflake-game';
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'snowflake-button';
      button.textContent = '‚ùÑÔ∏è';
      button.setAttribute('aria-label', 'Tap to start snowfall');
      const help = document.createElement('p');
      help.className = 'game-help';
      help.textContent = 'Tap the snowflake or press Enter to let the snow drift across the whole site.';
      wrapper.append(button, help);
      container.appendChild(wrapper);
      if (snowfallActive) {
        button.classList.add('activated');
        button.disabled = true;
        help.textContent = 'Snow is already dancing across the page!';
      }
      const onActivate = () => {
        startSnowfall();
        progress.effects.snowfall = true;
        saveProgress();
        button.classList.add('activated');
        button.disabled = true;
        help.textContent = 'Snow is swirling ‚Äî enjoy the cozy flurries!';
      };
      button.addEventListener('click', onActivate);
      setTimeout(() => button.focus({ preventScroll: true }), 60);
      return {
        cleanup: () => {
          button.removeEventListener('click', onActivate);
        }
      };
    }

    function buildCookieGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'cookie-game';
      const cookie = document.createElement('div');
      cookie.className = 'cookie';
      const toppings = Array.isArray(win.toppings) && win.toppings.length ? win.toppings : defaultToppings;
      const layers = new Map();
      toppings.forEach(topping => {
        const layer = document.createElement('div');
        layer.className = `topping ${topping.className}`;
        layer.setAttribute('aria-hidden', 'true');
        cookie.appendChild(layer);
        layers.set(topping.id, layer);
      });
      const controls = document.createElement('div');
      controls.className = 'cookie-controls';
      const status = document.createElement('p');
      status.className = 'game-help';
      status.textContent = 'Add every topping to share a fresh cookie.';
      const buttons = [];
      const handlers = new Map();
      const active = new Set();
      toppings.forEach(topping => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'cookie-toggle';
        btn.dataset.id = topping.id;
        btn.textContent = topping.label;
        btn.setAttribute('aria-pressed', 'false');
        const handler = () => {
          if (active.has(topping.id)) {
            active.delete(topping.id);
            btn.classList.remove('active');
            layers.get(topping.id)?.classList.remove('active');
            btn.setAttribute('aria-pressed', 'false');
          } else {
            active.add(topping.id);
            btn.classList.add('active');
            layers.get(topping.id)?.classList.add('active');
            btn.setAttribute('aria-pressed', 'true');
          }
          if (active.size === toppings.length) {
            status.textContent = 'Perfect! The cookie is ready to share.';
            showToast('Cookie decorated ‚Äî yum!');
          } else {
            status.textContent = `Toppings added: ${active.size}/${toppings.length}.`;
          }
        };
        btn.addEventListener('click', handler);
        handlers.set(btn, handler);
        buttons.push(btn);
        controls.appendChild(btn);
      });
      wrapper.append(cookie, controls, status);
      container.appendChild(wrapper);
      setTimeout(() => buttons[0]?.focus({ preventScroll: true }), 80);
      return {
        cleanup: () => {
          handlers.forEach((handler, btn) => btn.removeEventListener('click', handler));
        }
      };
    }

    function buildLightsGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'lights-game';
      const clue = document.createElement('p');
      clue.className = 'game-help';
      clue.textContent = win.clue || 'Match the preview to untangle the lights.';
      const previewRow = document.createElement('div');
      previewRow.className = 'lights-preview';
      const bulbsRow = document.createElement('div');
      bulbsRow.className = 'lights-row';
      const patternString = typeof win.pattern === 'string' && win.pattern.length ? win.pattern : randomLightPattern(6);
      const pattern = patternString.split('').map(char => char === '1');
      const states = pattern.map(() => false);
      pattern.forEach(on => {
        const bulb = document.createElement('span');
        bulb.className = 'light-bulb';
        bulb.dataset.role = 'preview';
        if (on) bulb.classList.add('on');
        previewRow.appendChild(bulb);
      });
      const handlers = [];
      const buttons = pattern.map((_, index) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'light-bulb';
        btn.dataset.index = String(index);
        btn.setAttribute('aria-pressed', 'false');
        btn.setAttribute('aria-label', `Light ${index + 1}`);
        bulbsRow.appendChild(btn);
        const handler = () => {
          states[index] = !states[index];
          updateButton(index);
          checkWin();
        };
        btn.addEventListener('click', handler);
        handlers[index] = handler;
        return btn;
      });
      wrapper.append(clue, previewRow, bulbsRow);
      const status = document.createElement('p');
      status.className = 'game-help';
      status.textContent = 'Tap bulbs to make the string match the preview.';
      container.append(wrapper, status);

      function updateButton(index) {
        const on = states[index];
        buttons[index].classList.toggle('on', on);
        buttons[index].setAttribute('aria-pressed', on ? 'true' : 'false');
      }

      function checkWin() {
        const solved = states.every((value, idx) => value === pattern[idx]);
        if (solved) {
          status.textContent = 'Gleaming! The lights are perfectly matched.';
          buttons.forEach(btn => btn.disabled = true);
          showToast('Lights matched ‚Äî twinkle on!');
        }
      }

      buttons.forEach((_, index) => updateButton(index));
      setTimeout(() => buttons[0]?.focus({ preventScroll: true }), 80);

      return {
        cleanup: () => {
          buttons.forEach((btn, idx) => {
            const handler = handlers[idx];
            if (handler) btn.removeEventListener('click', handler);
          });
        }
      };
    }

    function buildStoryGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'story-game';
      const card = document.createElement('div');
      card.className = 'story-card';
      if (win.storyEmoji) {
        const emoji = document.createElement('div');
        emoji.className = 'story-emoji';
        emoji.textContent = win.storyEmoji;
        card.appendChild(emoji);
      }
      const steps = Array.isArray(win.storySteps) && win.storySteps.length ? win.storySteps : [win.summary || 'A cozy tale unfolds.'];
      const text = document.createElement('p');
      text.textContent = steps[0];
      card.appendChild(text);
      wrapper.appendChild(card);
      const controls = document.createElement('div');
      controls.className = 'story-controls';
      const nextBtn = document.createElement('button');
      nextBtn.type = 'button';
      nextBtn.className = 'story-next';
      nextBtn.textContent = steps.length > 1 ? 'Continue' : 'Close Story';
      controls.appendChild(nextBtn);
      wrapper.appendChild(controls);
      container.appendChild(wrapper);
      let index = 0;
      const onNext = () => {
        if (index < steps.length - 1) {
          index += 1;
          text.textContent = steps[index];
          if (index === steps.length - 1) {
            nextBtn.textContent = 'All done';
          }
        } else {
          showToast('Story delivered ‚Äî thanks for reading!');
          nextBtn.disabled = true;
        }
      };
      nextBtn.addEventListener('click', onNext);
      setTimeout(() => nextBtn.focus({ preventScroll: true }), 50);
      return {
        cleanup: () => {
          nextBtn.removeEventListener('click', onNext);
        }
      };
    }

    function buildMusicGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'music-game';
      const melody = Array.isArray(win.melody) && win.melody.length ? win.melody : [0, 2, 3, 1];
      const remainingNames = melody.map(index => bellNotes[index]?.label || `Note ${index + 1}`);
      const instructions = document.createElement('p');
      instructions.className = 'game-help';
      instructions.textContent = `Play this jolly pattern: ${remainingNames.join(' ‚Üí ')}.`;
      const keys = document.createElement('div');
      keys.className = 'music-keys';
      const buttons = bellNotes.map((note, index) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'bell-button';
        btn.style.setProperty('--bell-color', note.color);
        btn.dataset.index = String(index);
        btn.textContent = note.label;
        keys.appendChild(btn);
        return btn;
      });
      const progressRow = document.createElement('div');
      progressRow.className = 'music-progress';
      progressRow.innerHTML = melody.map(() => '<span class="music-dot"></span>').join('');
      const dots = Array.from(progressRow.children);
      wrapper.append(instructions, keys, progressRow);
      container.appendChild(wrapper);
      let solved = false;
      let sequence = [];
      const onPress = event => {
        const index = Number(event.currentTarget.dataset.index);
        playTone(bellNotes[index].freq);
        if (solved) return;
        sequence.push(index);
        updateDots();
        const step = sequence.length - 1;
        if (melody[step] !== index) {
          sequence = [];
          updateDots();
          instructions.textContent = 'Oops! Try the melody again from the start.';
          return;
        }
        if (sequence.length === melody.length) {
          solved = true;
          instructions.textContent = 'Beautiful! The bells are pealing in harmony.';
          showToast('Melody mastered ‚Äî the bells ring bright!');
        } else {
          const remaining = remainingNames.slice(sequence.length).join(' ‚Üí ');
          instructions.textContent = `Great! Keep playing: ${remaining}.`;
        }
      };
      function updateDots() {
        dots.forEach((dot, idx) => {
          dot.classList.toggle('active', idx < sequence.length);
        });
      }
      buttons.forEach(btn => btn.addEventListener('click', onPress));
      setTimeout(() => buttons[0]?.focus({ preventScroll: true }), 80);
      return {
        cleanup: () => {
          buttons.forEach(btn => btn.removeEventListener('click', onPress));
        }
      };
    }

    function buildSnowballGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'snowball-game';
      const stage = document.createElement('div');
      stage.className = 'snowball-stage';
      stage.setAttribute('role', 'application');
      stage.tabIndex = 0;
    stage.setAttribute('aria-label', 'Snowball mini-game area');
      const crosshair = document.createElement('div');
      crosshair.className = 'snowball-crosshair';
      const target = document.createElement('div');
      target.className = 'snowball-target';
      target.textContent = win.targetEmoji || '‚òÉÔ∏è';
      stage.append(crosshair, target);
    const scoreboard = document.createElement('p');
    scoreboard.className = 'game-help';
      wrapper.append(stage, scoreboard);
      container.appendChild(wrapper);

      let stageRect = stage.getBoundingClientRect();
      const crosshairPos = { x: stageRect.width / 2, y: stageRect.height * 0.7 };
      const targetPos = { x: stageRect.width / 2, y: stageRect.height * 0.35 };
      let hits = 0;
      let throws = 0;
      let solved = false;
      let targetTimer = null;

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function updateStageRect() {
        stageRect = stage.getBoundingClientRect();
        setCrosshair(crosshairPos.x, crosshairPos.y);
        positionTarget(targetPos.x, targetPos.y);
      }

      function setCrosshair(x, y) {
        const clampedX = clamp(x, 32, stageRect.width - 32);
        const clampedY = clamp(y, 32, stageRect.height - 32);
        crosshairPos.x = clampedX;
        crosshairPos.y = clampedY;
        crosshair.style.left = `${clampedX}px`;
        crosshair.style.top = `${clampedY}px`;
      }

      function positionTarget(x, y) {
        targetPos.x = clamp(x, 36, stageRect.width - 36);
        targetPos.y = clamp(y, 36, stageRect.height - 36);
        target.style.left = `${targetPos.x}px`;
        target.style.top = `${targetPos.y}px`;
      }

      function randomizeTarget() {
        if (solved) return;
        const newX = 36 + Math.random() * (stageRect.width - 72);
        const newY = 36 + Math.random() * (stageRect.height - 92);
        positionTarget(newX, newY);
      }

      function updateScoreboard() {
        scoreboard.textContent = solved
          ? 'Victory! The snow pal tips its hat to your aim.'
          : `Hits: ${hits}/3 ‚Ä¢ Throws: ${throws}. Use arrows, mouse, touch, or A to throw.`;
      }

      function spawnSplat(x, y, success) {
        const splat = document.createElement('span');
        splat.className = `snowball-splat ${success ? 'success' : ''}`;
        splat.style.left = `${x}px`;
        splat.style.top = `${y}px`;
        stage.appendChild(splat);
        splat.addEventListener('animationend', () => splat.remove(), { once: true });
      }

      function throwSnowball() {
        if (solved) return;
        throws += 1;
        const distance = Math.hypot(crosshairPos.x - targetPos.x, crosshairPos.y - targetPos.y);
        const hit = distance <= 48;
        spawnSplat(crosshairPos.x, crosshairPos.y, hit);
        if (hit) {
          hits += 1;
          randomizeTarget();
          if (hits >= 3) {
            solved = true;
            if (targetTimer) {
              window.clearInterval(targetTimer);
              targetTimer = null;
            }
            showToast('Snowball showdown complete!');
          }
        }
        updateScoreboard();
      }

      function onPointerMove(event) {
        const rect = stage.getBoundingClientRect();
        stageRect = rect;
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        setCrosshair(x, y);
      }

      function onPointerDown(event) {
        stage.setPointerCapture(event.pointerId);
        onPointerMove(event);
        throwSnowball();
      }

      function onPointerUp(event) {
        stage.releasePointerCapture(event.pointerId);
      }

      function onPointerCancel(event) {
        stage.releasePointerCapture(event.pointerId);
      }

      stage.addEventListener('pointermove', onPointerMove);
      stage.addEventListener('pointerdown', onPointerDown);
      stage.addEventListener('pointerup', onPointerUp);
      stage.addEventListener('pointercancel', onPointerCancel);

      function onKey(event) {
        const step = event.shiftKey ? 28 : 18;
        let handled = false;
        if (event.key === 'ArrowUp') {
          setCrosshair(crosshairPos.x, crosshairPos.y - step);
          handled = true;
        } else if (event.key === 'ArrowDown') {
          setCrosshair(crosshairPos.x, crosshairPos.y + step);
          handled = true;
        } else if (event.key === 'ArrowLeft') {
          setCrosshair(crosshairPos.x - step, crosshairPos.y);
          handled = true;
        } else if (event.key === 'ArrowRight') {
          setCrosshair(crosshairPos.x + step, crosshairPos.y);
          handled = true;
        } else if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
          throwSnowball();
          handled = true;
        }
        if (handled) {
          event.preventDefault();
        }
      }

      stage.addEventListener('keydown', onKey);

      function refresh() {
        updateStageRect();
        setCrosshair(stageRect.width / 2, stageRect.height * 0.7);
        positionTarget(stageRect.width / 2, stageRect.height * 0.35);
        randomizeTarget();
        updateScoreboard();
      }

      refresh();
      window.addEventListener('resize', updateStageRect);
      targetTimer = window.setInterval(randomizeTarget, 1600);
      setTimeout(() => stage.focus({ preventScroll: true }), 120);

      const gamepadHandler = ({ pad, buttons, prevButtons, delta }) => {
        if (!pad || solved) return;
        const axisX = pad.axes[0] || 0;
        const axisY = pad.axes[1] || 0;
        const prev = Array.isArray(prevButtons) ? prevButtons : [];
        if (Math.abs(axisX) > 0.18 || Math.abs(axisY) > 0.18) {
          const movement = delta * 0.2;
          setCrosshair(crosshairPos.x + axisX * movement, crosshairPos.y + axisY * movement);
        }
        if (buttons[0] && !prev[0]) {
          throwSnowball();
        }
      };

      return {
        cleanup: () => {
          stage.removeEventListener('pointermove', onPointerMove);
          stage.removeEventListener('pointerdown', onPointerDown);
          stage.removeEventListener('pointerup', onPointerUp);
          stage.removeEventListener('pointercancel', onPointerCancel);
          stage.removeEventListener('keydown', onKey);
          window.removeEventListener('resize', updateStageRect);
          if (targetTimer) window.clearInterval(targetTimer);
        },
        gamepadHandler
      };
    }

    function randomLightPattern(length) {
      let result = '';
      let lit = 0;
      for (let i = 0; i < length; i += 1) {
        const on = Math.random() > 0.5;
        if (on) lit += 1;
        result += on ? '1' : '0';
      }
      if (lit === 0) {
        const index = Math.floor(Math.random() * length);
        result = result.slice(0, index) + '1' + result.slice(index + 1);
      }
      return result;
    }

    function playTone(freq) {
      const ctx = ensureAudioContext();
      if (!ctx) return;
      if (ctx.state === 'suspended') {
        ctx.resume().catch(() => {});
      }
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, ctx.currentTime);
      gain.gain.linearRampToValueAtTime(0.25, ctx.currentTime + 0.02);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.35);
      osc.connect(gain).connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.4);
    }

    function ensureAudioContext() {
      if (audioCtx) return audioCtx;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return null;
      audioCtx = new Ctx();
      return audioCtx;
    }
  </script>
  <script src="parental.js"></script>
</body>

</html>
