<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="description" content="A cozy advent calendar filled with daily mini-games and festive surprises. Progress is saved locally so you can unwrap each day at your own pace.">
  <title>Festive Advent Calendar</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <style>
    :root {
      --bg-top: #fef6ff;
      --bg-bottom: #e4f4ff;
      --panel-bg: rgba(255, 255, 255, 0.78);
      --panel-border: rgba(255, 255, 255, 0.9);
      --text-primary: #243047;
      --accent-berry: #ff6f91;
      --accent-mint: #4ad7d1;
      --accent-gold: #f9a826;
      --door-closed: #ffd4d8;
      --door-open: #c2f9ff;
      --door-locked: #d0d7ff;
      --shadow-soft: rgba(36, 48, 71, 0.18);
      --shadow-strong: rgba(36, 48, 71, 0.28);
    }

    body {
      margin: 0;
      font-family: 'Nunito', 'Segoe UI', Tahoma, sans-serif;
      background: linear-gradient(180deg, var(--bg-top) 0%, var(--bg-bottom) 60%, #ffffff 100%);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    body.modal-open {
      overflow: hidden;
    }

    [hidden] {
      display: none !important;
    }

    .top-bar {
      position: sticky;
      top: 0;
      z-index: 30;
      padding: 1.5rem clamp(1rem, 4vw, 3rem);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      background: rgba(255, 255, 255, 0.78);
      border-bottom: 1px solid var(--panel-border);
      box-shadow: 0 10px 30px var(--shadow-soft);
      backdrop-filter: blur(12px);
    }

    .brand {
      font-size: clamp(1.6rem, 4vw, 2.4rem);
      font-weight: 800;
      letter-spacing: 0.02em;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    .brand span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent-berry), var(--accent-mint));
      box-shadow: 0 6px 16px rgba(255, 111, 145, 0.4);
    }

    .status-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      font-size: 0.95rem;
    }

    #today-label {
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      background: rgba(74, 215, 209, 0.12);
      border: 1px solid rgba(74, 215, 209, 0.4);
    }

    #debug-indicator {
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      background: rgba(255, 111, 145, 0.16);
      border: 1px dashed rgba(255, 111, 145, 0.68);
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--accent-berry);
    }

    button {
      font-family: inherit;
    }

    .button-secondary {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.1rem;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, rgba(36, 48, 71, 0.08), rgba(36, 48, 71, 0.02));
      box-shadow: 0 6px 16px rgba(36, 48, 71, 0.12);
      color: var(--text-primary);
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .button-secondary:hover,
    .button-secondary:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 12px 20px rgba(36, 48, 71, 0.18);
    }

    main {
      flex: 1 1 auto;
      padding: clamp(1.5rem, 5vw, 3rem) clamp(1rem, 5vw, 3.5rem) 4rem;
    }

    .calendar-section {
      max-width: 1100px;
      margin: 0 auto;
    }

    .intro {
      font-size: 1.05rem;
      line-height: 1.7;
      max-width: 760px;
      margin: 0 auto 2rem;
      text-align: center;
      background: rgba(255, 255, 255, 0.74);
      padding: 1.25rem 1.5rem;
      border-radius: 1.2rem;
      box-shadow: 0 12px 28px var(--shadow-soft);
      backdrop-filter: blur(10px);
    }

    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: clamp(1rem, 3vw, 1.75rem);
    }

    .calendar-door {
      position: relative;
      border: none;
      border-radius: 1.2rem;
      padding: 1.4rem 1rem 1.6rem;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.88), rgba(255, 255, 255, 0.68));
      box-shadow: 0 12px 24px var(--shadow-soft);
      text-align: left;
      cursor: pointer;
      min-height: 180px;
      color: inherit;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .calendar-door:hover,
    .calendar-door:focus-visible {
      transform: translateY(-6px);
      box-shadow: 0 18px 36px var(--shadow-strong);
    }

    .calendar-door.opened {
      background: linear-gradient(135deg, var(--door-open) 0%, #f6fffe 100%);
    }

    .calendar-door.locked {
      background: linear-gradient(135deg, var(--door-locked) 0%, #f3f5ff 100%);
    }

    .calendar-door .door-badge {
      position: absolute;
      top: 0.9rem;
      right: 1.1rem;
      background: var(--accent-berry);
      color: #fff;
      padding: 0.2rem 0.65rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      box-shadow: 0 6px 14px rgba(255, 111, 145, 0.4);
    }

    .calendar-door.locked .door-badge {
      background: #7488ff;
    }

    .calendar-door.opened .door-badge {
      background: var(--accent-mint);
      color: #1b2a35;
    }

    .door-front {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    .door-number {
      font-size: 2.4rem;
      font-weight: 800;
      letter-spacing: 0.04em;
    }

    .door-title {
      font-size: 1rem;
      font-weight: 700;
      line-height: 1.4;
      min-height: 2.6rem;
    }

    .door-status {
      font-size: 0.92rem;
      opacity: 0.8;
    }

    .calendar-door.locked .door-status {
      color: #5261b8;
    }

    .calendar-door.opened .door-status {
      color: #12807f;
    }

    .calendar-door[data-gamepad-focus="true"] {
      outline: 3px solid var(--accent-berry);
      outline-offset: 4px;
    }

    .calendar-door.wiggle {
      animation: wiggle 0.45s ease;
    }

    @keyframes wiggle {
      0% { transform: translateX(0); }
      25% { transform: translateX(-6px) rotate(-1deg); }
      50% { transform: translateX(6px) rotate(1deg); }
      75% { transform: translateX(-4px) rotate(-1deg); }
      100% { transform: translateX(0); }
    }

    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(1.5rem, 5vw, 3rem);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 60;
    }

    .modal.is-open {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(36, 48, 71, 0.48);
      backdrop-filter: blur(8px);
    }

    .modal-dialog {
      position: relative;
      z-index: 1;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 1.6rem;
      max-width: min(720px, 92vw);
      width: 100%;
      padding: clamp(1.6rem, 4vw, 2.6rem);
      box-shadow: 0 26px 52px rgba(36, 48, 71, 0.32);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: none;
      background: rgba(36, 48, 71, 0.08);
      font-size: 1.4rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    .modal-close:hover,
    .modal-close:focus-visible {
      background: rgba(36, 48, 71, 0.16);
      transform: scale(1.05);
    }

    .modal-title {
      font-size: clamp(1.35rem, 3.2vw, 1.9rem);
      margin: 0;
    }

    .modal-summary {
      font-size: 1rem;
      line-height: 1.6;
      margin: 0 0 0.5rem;
      color: rgba(36, 48, 71, 0.82);
    }

    .mini-game {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      align-items: center;
    }

    .game-help {
      font-size: 0.95rem;
      line-height: 1.5;
      text-align: center;
      color: rgba(36, 48, 71, 0.78);
      margin: 0;
      max-width: 520px;
    }

    .snowflake-game {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }

    .snowflake-button {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      border: none;
      font-size: 3rem;
      cursor: pointer;
      background: radial-gradient(circle at 50% 30%, #ffffff 0%, #e1f6ff 45%, #c0ecff 100%);
      box-shadow: 0 12px 24px rgba(74, 215, 209, 0.35);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .snowflake-button:hover,
    .snowflake-button:focus-visible {
      transform: scale(1.06);
      box-shadow: 0 16px 28px rgba(74, 215, 209, 0.45);
    }

    .snowflake-button.activated {
      background: radial-gradient(circle at 50% 30%, #ffffff 0%, #d4f6ff 55%, #a8f3ff 100%);
      box-shadow: 0 16px 30px rgba(74, 215, 209, 0.5);
    }

    .cookie-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.2rem;
    }

    .cookie {
      position: relative;
      width: clamp(180px, 40vw, 220px);
      aspect-ratio: 1;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fde4be 0%, #f6b673 62%, #d9893f 100%);
      box-shadow: inset 0 12px 24px rgba(0, 0, 0, 0.18);
      overflow: hidden;
    }

    .cookie::before {
      content: '';
      position: absolute;
      inset: 16%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.35) 0%, rgba(255, 255, 255, 0) 65%);
    }

    .cookie .topping {
      position: absolute;
      inset: 0;
      opacity: 0;
      transition: opacity 0.35s ease;
      mix-blend-mode: screen;
    }

    .cookie .topping.active {
      opacity: 1;
    }

    .cookie .topping.sprinkles {
      background-image: repeating-linear-gradient(45deg, rgba(255, 118, 117, 0.85) 0 7px, transparent 7px 14px), repeating-linear-gradient(-45deg, rgba(116, 185, 255, 0.82) 0 7px, transparent 7px 14px);
    }

    .cookie .topping.icing {
      background-image: radial-gradient(circle at 30% 25%, rgba(255, 255, 255, 0.78) 0 16%, transparent 17%), radial-gradient(circle at 70% 40%, rgba(255, 255, 255, 0.82) 0 18%, transparent 19%), radial-gradient(circle at 50% 70%, rgba(255, 255, 255, 0.72) 0 20%, transparent 21%);
    }

    .cookie .topping.stars {
      background-image: radial-gradient(circle, rgba(255, 255, 255, 0.96) 0 3px, transparent 4px);
      background-size: 48px 48px;
      background-position: 8px 12px, 32px 32px, 60px 18px, 92px 54px;
    }

    .cookie-controls {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .cookie-toggle {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.1rem;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.96), rgba(255, 255, 255, 0.75));
      box-shadow: 0 8px 20px rgba(36, 48, 71, 0.16);
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .cookie-toggle:hover,
    .cookie-toggle:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 12px 24px rgba(36, 48, 71, 0.22);
    }

    .cookie-toggle.active {
      background: linear-gradient(135deg, rgba(249, 168, 38, 0.9), rgba(255, 230, 153, 0.95));
      color: #2f2100;
    }

    .lights-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .lights-preview,
    .lights-row {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .light-bulb {
      position: relative;
      width: 48px;
      height: 68px;
      border-radius: 22px 22px 16px 16px;
      border: none;
      cursor: pointer;
      background: linear-gradient(160deg, #ffe5f0 0%, #ffc8d9 100%);
      box-shadow: 0 10px 18px rgba(255, 111, 145, 0.28);
      transition: transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease;
    }

    .light-bulb::after {
      content: '';
      position: absolute;
      top: -12px;
      left: 50%;
      width: 26px;
      height: 14px;
      border-radius: 4px;
      background: #4a4a4a;
      transform: translateX(-50%);
    }

    .light-bulb.on {
      background: linear-gradient(160deg, #fffadc 0%, #ffe066 100%);
      box-shadow: 0 0 16px rgba(255, 240, 140, 0.8), 0 12px 22px rgba(255, 203, 107, 0.3);
      filter: saturate(1.15);
    }

    .light-bulb[data-role="preview"] {
      pointer-events: none;
      border: 2px dashed rgba(36, 48, 71, 0.2);
      box-shadow: none;
      cursor: default;
    }

    .light-bulb:focus-visible {
      outline: 3px solid var(--accent-gold);
      outline-offset: 3px;
    }

    .music-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.2rem;
    }

    .music-keys {
      display: flex;
      gap: 0.85rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .bell-button {
      border: none;
      border-radius: 1.1rem;
      width: 88px;
      height: 88px;
      font-weight: 700;
      color: #1c2738;
      cursor: pointer;
      background: linear-gradient(155deg, var(--bell-color, #ffd6e8) 0%, rgba(255, 255, 255, 0.95) 70%);
      box-shadow: 0 10px 22px rgba(36, 48, 71, 0.2);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .bell-button:hover,
    .bell-button:focus-visible {
      transform: translateY(-4px);
      box-shadow: 0 16px 28px rgba(36, 48, 71, 0.28);
    }

    .music-progress {
      display: flex;
      gap: 0.4rem;
    }

    .music-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(36, 48, 71, 0.18);
    }

    .music-dot.active {
      background: var(--accent-mint);
      box-shadow: 0 0 8px rgba(74, 215, 209, 0.6);
    }

    .story-game {
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      align-items: center;
      text-align: center;
    }

    .story-card {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.96), rgba(237, 247, 255, 0.9));
      border-radius: 1.2rem;
      padding: 1.5rem;
      box-shadow: 0 16px 30px rgba(36, 48, 71, 0.18);
      max-width: 520px;
      font-size: 1.02rem;
      line-height: 1.6;
      position: relative;
    }

    .story-emoji {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .story-controls {
      display: flex;
      gap: 0.75rem;
    }

    .story-next {
      border: none;
      border-radius: 999px;
      padding: 0.6rem 1.4rem;
      cursor: pointer;
      font-weight: 600;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.7));
      box-shadow: 0 12px 24px rgba(36, 48, 71, 0.2);
    }

    .story-next:hover,
    .story-next:focus-visible {
      transform: translateY(-3px);
      box-shadow: 0 18px 30px rgba(36, 48, 71, 0.26);
    }

    .memory-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .memory-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.6rem;
      perspective: 600px;
    }

    .memory-card {
      width: 64px;
      height: 64px;
      border: none;
      border-radius: 0.8rem;
      background: #eef2ff;
      cursor: pointer;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.4s;
      box-shadow: 0 4px 8px rgba(36, 48, 71, 0.1);
    }

    .memory-card.flipped,
    .memory-card.matched {
      transform: rotateY(180deg);
      background: #fff;
      box-shadow: 0 4px 12px rgba(36, 48, 71, 0.15);
    }

    .memory-card.matched {
      background: #e0fbf9;
      cursor: default;
    }

    .memory-card-front,
    .memory-card-back {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      border-radius: 0.8rem;
    }

    .memory-card-front {
      background: linear-gradient(135deg, #7488ff, #5261b8);
      color: rgba(255, 255, 255, 0.4);
      font-size: 1.2rem;
    }

    .memory-card-back {
      transform: rotateY(180deg);
    }

    .trivia-game {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      align-items: center;
      text-align: center;
      max-width: 480px;
    }

    .trivia-question {
      font-size: 1.2rem;
      font-weight: 700;
      line-height: 1.4;
    }

    .trivia-options {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      width: 100%;
    }

    .trivia-btn {
      border: 2px solid rgba(36, 48, 71, 0.1);
      border-radius: 1rem;
      padding: 1rem;
      background: #fff;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .trivia-btn:hover,
    .trivia-btn:focus-visible {
      border-color: var(--accent-berry);
      background: #fff5f8;
      transform: translateY(-2px);
    }

    .trivia-btn.correct {
      background: #d1fae5;
      border-color: #10b981;
      color: #065f46;
    }

    .trivia-btn.wrong {
      background: #fee2e2;
      border-color: #ef4444;
      color: #991b1b;
    }

    .joke-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
      text-align: center;
    }

    .cracker-btn {
      position: relative;
      width: 280px;
      height: 80px;
      border: none;
      background: none;
      cursor: pointer;
      transition: transform 0.1s;
    }

    .cracker-body {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #ff6f91 0%, #ff8fb6 50%, #ff6f91 100%);
      border-radius: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 800;
      font-size: 1.2rem;
      box-shadow: 0 8px 20px rgba(255, 111, 145, 0.4);
    }

    .cracker-btn:active .cracker-body {
      transform: scale(0.96);
    }

    .joke-reveal {
      font-size: 1.1rem;
      line-height: 1.6;
      padding: 1.5rem;
      background: #fff;
      border-radius: 1rem;
      box-shadow: 0 8px 24px rgba(36, 48, 71, 0.12);
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.4s ease;
    }

    .joke-reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .tree-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .tree-stage {
      position: relative;
      width: 260px;
      height: 320px;
    }

    .tree-img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 10px 20px rgba(36, 48, 71, 0.2));
    }

    .star-drag {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 3.5rem;
      cursor: grab;
      transition: transform 0.2s;
      filter: drop-shadow(0 4px 8px rgba(249, 168, 38, 0.4));
    }

    .star-drag:active {
      cursor: grabbing;
      transform: translateX(-50%) scale(1.1);
    }

    .star-drag.placed {
      top: -10px;
      bottom: auto;
      cursor: default;
      animation: star-pulse 2s infinite;
    }

    @keyframes star-pulse {
      0%, 100% { transform: translateX(-50%) scale(1); filter: drop-shadow(0 0 10px rgba(249, 168, 38, 0.6)); }
      50% { transform: translateX(-50%) scale(1.1); filter: drop-shadow(0 0 20px rgba(249, 168, 38, 0.8)); }
    }

    .pattern-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
    }

    .pattern-row {
      display: flex;
      gap: 0.8rem;
      font-size: 2.5rem;
      background: #fff;
      padding: 1rem 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 8px 20px rgba(36, 48, 71, 0.1);
    }

    .pattern-options {
      display: flex;
      gap: 1.5rem;
    }

    .pattern-btn {
      font-size: 3rem;
      width: 80px;
      height: 80px;
      border: none;
      border-radius: 1rem;
      background: #f0f4f8;
      cursor: pointer;
      transition: transform 0.2s, background 0.2s;
    }

    .pattern-btn:hover,
    .pattern-btn:focus-visible {
      transform: scale(1.1);
      background: #e1e8f0;
    }

    .globe-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .globe-stage {
      position: relative;
      width: 260px;
      height: 260px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 30%, #e0f7fa, #b2ebf2);
      box-shadow: inset 0 -10px 20px rgba(0, 100, 120, 0.1), 0 12px 30px rgba(36, 48, 71, 0.2);
      overflow: hidden;
      cursor: pointer;
    }

    .globe-content {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 5rem;
    }

    .globe-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.92);
      backdrop-filter: blur(12px);
      transition: opacity 0.1s;
      z-index: 10;
    }

    .globe-particles {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 5;
      overflow: hidden;
      border-radius: 50%;
    }

    .globe-particle {
      position: absolute;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
      animation: globe-swirl 3s infinite ease-in-out;
    }

    @keyframes globe-swirl {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(8px, -8px); }
      50% { transform: translate(0, -16px); }
      75% { transform: translate(-8px, -8px); }
    }

    .globe-base {
      width: 180px;
      height: 40px;
      background: #5d4037;
      border-radius: 0 0 20px 20px;
      margin-top: -20px;
      z-index: -1;
    }

    .snack-game {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    .snack-table {
      position: relative;
      width: 300px;
      height: 180px;
      background: #8d6e63;
      border-radius: 1rem;
      box-shadow: 0 12px 24px rgba(62, 39, 35, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
    }

    .snack-item {
      font-size: 3.5rem;
      opacity: 0.2;
      filter: grayscale(1);
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      cursor: pointer;
    }

    .snack-item.placed {
      opacity: 1;
      filter: grayscale(0);
      transform: scale(1.1);
      cursor: default;
    }

    #toast {
      position: fixed;
      bottom: 1.6rem;
      left: 50%;
      transform: translate(-50%, 20px);
      background: rgba(255, 255, 255, 0.95);
      padding: 0.75rem 1.4rem;
      border-radius: 999px;
      box-shadow: 0 14px 28px rgba(36, 48, 71, 0.24);
      font-weight: 600;
      color: var(--text-primary);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 70;
    }

    #toast.is-visible {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .snow-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.6s ease;
      z-index: 40;
    }

    .snow-layer[data-active="true"] {
      opacity: 1;
    }

    .snow-layer .flake {
      position: absolute;
      top: -10vh;
      left: var(--x);
      font-size: var(--size, 1rem);
      animation: snow-fall var(--duration, 8s) linear infinite;
      animation-delay: var(--delay, 0s);
      opacity: 0.9;
      filter: drop-shadow(0 4px 8px rgba(36, 48, 71, 0.18));
    }

    @keyframes snow-fall {
      0% { transform: translate3d(0, -10vh, 0); }
      100% { transform: translate3d(var(--drift, 0), 110vh, 0); }
    }

    @media (max-width: 780px) {
      .calendar-door {
        min-height: 160px;
      }

      .door-title {
        min-height: 2.4rem;
      }
    }

    @media (max-width: 540px) {
      .top-bar {
        flex-direction: column;
        align-items: flex-start;
      }

      .brand {
        font-size: 1.8rem;
      }

      .modal-dialog {
        padding: 1.4rem;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .snow-layer {
        display: none;
      }
    }
  </style>
</head>

<body>
  <header class="top-bar">
    <div class="brand"><span>üéÅ</span>Festive Advent Surprise</div>
    <div class="status-group">
      <span id="today-label">Today</span>
      <span id="debug-indicator" hidden>Debug mode</span>
      <button id="reset-progress" class="button-secondary" type="button">Reset progress</button>
    </div>
  </header>
  <main>
    <section class="calendar-section">
      <p class="intro">Open a window each day (or catch up later!) to reveal a tiny festive mini-game. Your progress lives in this browser.</p>
  <div id="calendar-grid" class="calendar-grid" aria-label="Advent calendar windows"></div>
    </section>
  </main>

  <div id="modal" class="modal" aria-hidden="true">
    <div id="modal-backdrop" class="modal-backdrop" aria-hidden="true"></div>
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      <button id="modal-close" class="modal-close" type="button" aria-label="Close mini-game">√ó</button>
      <h2 id="modal-title" class="modal-title"></h2>
      <p id="modal-summary" class="modal-summary"></p>
      <div id="mini-game" class="mini-game"></div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>
  <div id="snow-layer" class="snow-layer" aria-hidden="true"></div>

  <script type="module">
    const STORAGE_KEY = 'idlegames-advent-2025';
    const DEBUG_SEQUENCE = 'debug';
    const DAY_MS = 24 * 60 * 60 * 1000;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    const snowLayer = document.getElementById('snow-layer');
    const toastEl = document.getElementById('toast');
    const todayLabel = document.getElementById('today-label');
    const debugIndicator = document.getElementById('debug-indicator');
    const resetBtn = document.getElementById('reset-progress');
    const modal = document.getElementById('modal');
    const modalBackdrop = document.getElementById('modal-backdrop');
    const modalTitle = document.getElementById('modal-title');
    const modalSummary = document.getElementById('modal-summary');
    const modalClose = document.getElementById('modal-close');
    const miniGameContainer = document.getElementById('mini-game');

    const windowTemplates = [
      { title: 'Snowflake Ballet', summary: 'Tap the shimmering snowflake to release a gentle snowfall for the whole page.', game: 'snowflake', storyEmoji: '‚ùÑÔ∏è' },
      { title: 'Cookie Canvas', summary: 'Frost and decorate the ginger cookie with sprinkles and stars.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Peppermint Sprinkles', className: 'sprinkles' },
        { id: 'icing', label: 'Vanilla Ribbon', className: 'icing' },
        { id: 'stars', label: 'Sugar Stardust', className: 'stars' }
      ] },
      { title: 'Twinkle Tangle', summary: 'Match the preview pattern to untangle the fairy lights.', game: 'lights', pattern: '101101', clue: 'Every bulb glowing in the preview should shine on your strand.' },
      { title: 'North Pole Post', summary: 'Deliver a comforting note from the workshop crew.', game: 'story', storyEmoji: 'üì¨', storySteps: [
        'A basket of letters arrives under a swirl of aurora dust.',
        'You sip cocoa and write back in looping, cozy script.',
        'Somewhere north, a sleepy child smiles at your reply.'
      ] },
      { title: 'Peppermint Chimes', summary: 'Ring the bells to play the candy cane melody.', game: 'music', melody: [0, 3, 1, 2] },
      { title: 'Frosty Pairs', summary: 'Find the matching pairs of festive friends.', game: 'memory', pairs: ['üéÑ', 'üéÖ', 'üéÅ', 'ü¶å', '‚õÑ', '‚ùÑÔ∏è'] },
      { title: 'Reindeer Riddle', summary: 'Can you solve this chilly brain teaser?', game: 'trivia', question: 'What has a carrot nose and loves the cold?', options: ['A Reindeer', 'A Snowman', 'An Elf'], answer: 1 },
      { title: 'Festive Cracker', summary: 'Pull the cracker to reveal a terrible joke!', game: 'joke', setup: 'What do you get if you cross Santa with a duck?', punchline: 'A Christmas Quacker!' },
      { title: 'Pattern Pop', summary: 'Complete the festive sequence.', game: 'pattern', sequence: ['üî¥', 'üü¢', 'üî¥', '?'], options: ['üü¢', 'üü°'], answer: 0 },
      { title: 'Snow Globe Surprise', summary: 'Rub the glass to reveal the scene inside.', game: 'globe', scene: 'üêß' },
      { title: 'Cranberry Crumble', summary: 'Add cranberry crunch to finish today\'s cookie.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Cranberry Crunch', className: 'sprinkles' },
        { id: 'icing', label: 'Cinnamon Icing', className: 'icing' },
        { id: 'stars', label: 'Frost Flakes', className: 'stars' }
      ] },
      { title: 'Candy Cane Cluster', summary: 'Light up every other bulb in a candy cane rhythm.', game: 'lights', pattern: '010101', clue: 'Alternate bulbs should glow like candy cane stripes.' },
      { title: 'Arctic Memory', summary: 'Match the icy icons to clear the board.', game: 'memory', pairs: ['üßä', 'üß§', 'üß£', '‚õ∏Ô∏è', 'üèîÔ∏è', 'üêª‚Äç‚ùÑÔ∏è'] },
      { title: 'Workshop Whispers', summary: 'A tinkerer shares a whispered workshop secret.', game: 'story', storyEmoji: 'üõ†Ô∏è', storySteps: [
        'You peek into the workshop where tools hum softly.',
        'A sprite whispers: ‚ÄúAdd kindness to every toy screw.‚Äù',
        'You nod and promise to pass the secret along.'
      ] },
      { title: 'Elf Exam', summary: 'Test your holiday knowledge.', game: 'trivia', question: 'Where does Santa live?', options: ['South Pole', 'North Pole', 'East Pole'], answer: 1 },
      { title: 'Jolly Joke', summary: 'Another cracker to pull!', game: 'joke', setup: 'Who is Santa\'s favorite singer?', punchline: 'Elf-is Presley!' },
      { title: 'Aurora Arpeggio', summary: 'Replay the aurora melody before it fades.', game: 'music', melody: [2, 1, 3, 0] },
      { title: 'Gift Wrap Logic', summary: 'Which bow comes next?', game: 'pattern', sequence: ['üéÅ', 'üéÄ', 'üéÅ', '?'], options: ['üéÄ', 'üß∏'], answer: 0 },
      { title: 'Crystal Globe', summary: 'Clear the frost to see who is hiding.', game: 'globe', scene: 'üè†' },
      { title: 'Starlit Shortbread', summary: 'Finish the shortbread with glittering sugar.', game: 'cookie', toppings: [
        { id: 'sprinkles', label: 'Star Confetti', className: 'sprinkles' },
        { id: 'icing', label: 'Moonbeam Icing', className: 'icing' },
        { id: 'stars', label: 'Galaxy Dust', className: 'stars' }
      ] },
      { title: 'Icicle Lattice', summary: 'Mirror the icicle lattice lights.', game: 'lights', pattern: '100111', clue: 'Let the last trio shimmer together.' },
      { title: 'Trim the Tree', summary: 'Place the star on top of the tree.', game: 'tree' },
      { title: 'Final Postcard', summary: 'Send final greetings before the big night.', game: 'story', storyEmoji: 'üíå', storySteps: [
        'Stacks of postcards wait for their final sparkle.',
        'You seal each one with glitter and a hopeful wish.',
        'The mail sled glides away toward twinkling chimneys.'
      ] },
      { title: 'Santa\'s Snack', summary: 'Leave out milk and cookies for the big visitor.', game: 'snack' }
    ];

    const baseDateUtc = Date.UTC(2025, 11, 1, 0, 0, 0);
    const closingDateUtc = Date.UTC(2026, 0, 15, 23, 59, 59);

    const WINDOWS = windowTemplates.map((tpl, index) => {
      const availableFrom = new Date(baseDateUtc + index * DAY_MS);
      const availableTo = new Date(closingDateUtc);
      return {
        ...tpl,
        day: index + 1,
        availableFrom,
        availableTo,
        availableFromISO: availableFrom.toISOString(),
        availableToISO: availableTo.toISOString()
      };
    });

    const GAME_BUILDERS = {
      snowflake: buildSnowflakeGame,
      cookie: buildCookieGame,
      lights: buildLightsGame,
      story: buildStoryGame,
      music: buildMusicGame,
      memory: buildMemoryGame,
      trivia: buildTriviaGame,
      joke: buildJokeGame,
      tree: buildTreeGame,
      pattern: buildPatternGame,
      globe: buildGlobeGame,
      snack: buildSnackGame
    };

    const defaultToppings = [
      { id: 'sprinkles', label: 'Rainbow Sprinkles', className: 'sprinkles' },
      { id: 'icing', label: 'Vanilla Icing', className: 'icing' },
      { id: 'stars', label: 'Starlight Sugar', className: 'stars' }
    ];

    const bellNotes = [
      { label: 'Peppermint', color: '#ffb2d8', freq: 523.25 },
      { label: 'Snowfall', color: '#b9efff', freq: 587.33 },
      { label: 'Cocoa', color: '#ffd1a9', freq: 659.25 },
      { label: 'Starlight', color: '#fff3a7', freq: 698.46 }
    ];

    const doorDateFormatter = (() => {
      try {
        return new Intl.DateTimeFormat(undefined, { month: 'short', day: 'numeric' });
      } catch (err) {
        return { format: date => date.toISOString().slice(5, 10) };
      }
    })();

    const todayFormatter = (() => {
      try {
        return new Intl.DateTimeFormat(undefined, { weekday: 'long', month: 'short', day: 'numeric' });
      } catch (err) {
        return { format: date => date.toDateString() };
      }
    })();

    let progress = loadProgress();
    let debugMode = false;
    let snowfallActive = false;
    let toastTimer = 0;
    let codeBuffer = '';
    let doorButtons = [];
    let focusedDoorIndex = 0;
    let lastFocusedDoor = null;
    let lastOpenedDay = null;
    let activeGameCleanup = null;
    let activeGamepadHandler = null;
    let previousButtonState = [];
    let navCooldown = 0;
    let gamepadLoopRunning = false;
    let gamepadConnected = false;
    let lastGamepadTimestamp = 0;
    let audioCtx = null;

    if (progress.effects && progress.effects.snowfall) {
      startSnowfall({ silent: true });
    }

    renderCalendar();
    updateTodayLabel();
    updateDebugIndicator();
    setInterval(() => {
      updateTodayLabel();
      if (!isModalOpen()) {
        renderCalendar();
      }
    }, 60 * 1000);

    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (!confirm('Reset advent calendar progress? This clears opened windows and snowfall.')) return;
        progress = { opened: {}, effects: {} };
        saveProgress();
        snowfallActive = false;
        delete snowLayer.dataset.active;
        snowLayer.removeAttribute('data-active');
        snowLayer.innerHTML = '';
        lastOpenedDay = null;
        lastFocusedDoor = null;
        renderCalendar();
        showToast('Progress reset ‚Äî happy adventuring!', 3400);
      });
    }

    modalClose.addEventListener('click', closeModal);
    modalBackdrop.addEventListener('click', closeModal);

    window.addEventListener('keydown', handleGlobalKeydown, { passive: false });

    window.addEventListener('gamepadconnected', () => {
      gamepadConnected = true;
      ensureGamepadLoop();
      showToast('Gamepad connected ‚Äî explore with the stick or D-pad!');
      if (doorButtons.length) {
        focusDoor(focusedDoorIndex);
      }
    });

    window.addEventListener('gamepaddisconnected', () => {
      const pads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
      gamepadConnected = pads.length > 0;
      if (!gamepadConnected) {
        doorButtons.forEach(btn => btn.dataset.gamepadFocus = 'false');
      }
    });

    ensureGamepadLoop();

    function loadProgress() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { opened: {}, effects: {} };
        const parsed = JSON.parse(raw);
        return {
          opened: parsed && parsed.opened ? parsed.opened : {},
          effects: parsed && parsed.effects ? parsed.effects : {}
        };
      } catch (err) {
        console.warn('Unable to load advent progress', err);
        return { opened: {}, effects: {} };
      }
    }

    function saveProgress() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
      } catch (err) {
        console.warn('Unable to save advent progress', err);
      }
    }

    function formatDate(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return 'soon';
      return doorDateFormatter.format(date);
    }

    function canOpen(win) {
      if (debugMode) return true;
      const now = new Date();
      return now >= win.availableFrom;
    }

    function renderCalendar() {
      const grid = document.getElementById('calendar-grid');
      if (!grid) return;
      const previouslyFocusedDay = doorButtons[focusedDoorIndex] ? doorButtons[focusedDoorIndex].dataset.day : null;
      grid.innerHTML = '';
      WINDOWS.forEach(win => {
        const door = document.createElement('button');
        door.type = 'button';
        door.className = 'calendar-door';
        door.dataset.day = String(win.day);
        door.setAttribute('data-available-from', win.availableFromISO);
        door.setAttribute('data-available-to', win.availableToISO);
        door.setAttribute('aria-haspopup', 'dialog');
        door.setAttribute('aria-controls', 'modal');
        door.title = `Day ${win.day}: ${win.title}`;
        door.innerHTML = `
          <span class="door-badge">Soon</span>
          <span class="door-front">
            <span class="door-number">${String(win.day).padStart(2, '0')}</span>
            <span class="door-title">${win.title}</span>
            <span class="door-status"></span>
          </span>`;
        applyDoorState(door, win);
        door.addEventListener('click', () => handleDoor(win, door));
        grid.appendChild(door);
      });
      updateDoorCollection(previouslyFocusedDay);
      if (typeof lastOpenedDay === 'number') {
        const match = doorButtons.find(btn => Number(btn.dataset.day) === lastOpenedDay);
        if (match) {
          lastFocusedDoor = match;
        }
      }
    }

    function applyDoorState(door, win) {
      const key = String(win.day);
      const openedEntry = progress.opened[key];
      const opened = !!openedEntry;
      const unlocked = canOpen(win) || opened;
      door.classList.toggle('opened', opened);
      door.classList.toggle('locked', !unlocked);
      door.setAttribute('data-available-now', unlocked ? 'true' : 'false');
      const statusEl = door.querySelector('.door-status');
      const badgeEl = door.querySelector('.door-badge');
      if (!statusEl) return;
      if (opened) {
        const openedAt = openedEntry && openedEntry.openedAt ? new Date(openedEntry.openedAt) : null;
        statusEl.textContent = openedAt ? `Opened ${formatDate(openedAt)}` : 'Opened!';
        if (badgeEl) badgeEl.textContent = 'Opened';
      } else if (unlocked) {
        statusEl.textContent = 'Ready!';
        if (badgeEl) badgeEl.textContent = 'Ready';
      } else {
        statusEl.textContent = `Opens ${formatDate(win.availableFrom)}`;
        if (badgeEl) badgeEl.textContent = 'Locked';
      }
      door.setAttribute('aria-label', `Day ${win.day}: ${win.title}. ${statusEl.textContent}`);
    }

    function handleDoor(win, door) {
      const key = String(win.day);
      const opened = !!progress.opened[key];
      const unlocked = canOpen(win) || opened;
      if (!unlocked) {
        door.classList.add('wiggle');
        setTimeout(() => door.classList.remove('wiggle'), 460);
        showToast(`That window opens on ${formatDate(win.availableFrom)}.`);
        return;
      }
      if (!opened) {
        progress.opened[key] = { openedAt: new Date().toISOString() };
        saveProgress();
        applyDoorState(door, win);
      }
      lastFocusedDoor = door;
      lastOpenedDay = win.day;
      openModal(win);
    }

    function openModal(win) {
      if (activeGameCleanup) {
        activeGameCleanup();
        activeGameCleanup = null;
      }
      setActiveGamepadHandler(null);
      miniGameContainer.innerHTML = '';
      modalTitle.textContent = `Day ${win.day}: ${win.title}`;
      modalSummary.textContent = win.summary || '';
      const builder = GAME_BUILDERS[win.game];
      let builderResult = null;
      if (builder) {
        builderResult = builder(miniGameContainer, win) || null;
      } else {
        const fallback = document.createElement('p');
        fallback.className = 'game-help';
        fallback.textContent = 'This surprise is still baking. Please check back soon!';
        miniGameContainer.appendChild(fallback);
      }
      if (builderResult && typeof builderResult.cleanup === 'function') {
        activeGameCleanup = builderResult.cleanup;
      } else {
        activeGameCleanup = null;
      }
      if (builderResult && typeof builderResult.gamepadHandler === 'function') {
        setActiveGamepadHandler(builderResult.gamepadHandler);
      }
      modal.classList.add('is-open');
      modal.setAttribute('aria-hidden', 'false');
      document.body.classList.add('modal-open');
      modalClose.focus({ preventScroll: true });
    }

    function closeModal() {
      if (!isModalOpen()) return;
      modal.classList.remove('is-open');
      modal.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('modal-open');
      if (activeGameCleanup) {
        activeGameCleanup();
        activeGameCleanup = null;
      }
      setActiveGamepadHandler(null);
      miniGameContainer.innerHTML = '';
      if (lastFocusedDoor && document.body.contains(lastFocusedDoor)) {
        lastFocusedDoor.focus({ preventScroll: true });
      } else if (typeof lastOpenedDay === 'number') {
        const fallback = doorButtons.find(btn => Number(btn.dataset.day) === lastOpenedDay);
        fallback?.focus({ preventScroll: true });
      }
      lastFocusedDoor = null;
      lastOpenedDay = null;
    }

    function isModalOpen() {
      return modal.classList.contains('is-open');
    }

    function updateDoorCollection(preferredDay) {
      doorButtons = Array.from(document.querySelectorAll('.calendar-door'));
      doorButtons.forEach(btn => btn.dataset.gamepadFocus = 'false');
      if (preferredDay) {
        const idx = doorButtons.findIndex(btn => btn.dataset.day === preferredDay);
        focusedDoorIndex = idx >= 0 ? idx : 0;
      } else {
        focusedDoorIndex = Math.min(focusedDoorIndex, Math.max(doorButtons.length - 1, 0));
      }
      if (gamepadConnected && doorButtons.length) {
        focusDoor(focusedDoorIndex);
      }
    }

    function focusDoor(index) {
      if (!doorButtons[index]) return;
      doorButtons.forEach((btn, idx) => {
        btn.dataset.gamepadFocus = idx === index ? 'true' : 'false';
      });
      doorButtons[index].focus({ preventScroll: true });
    }

    function updateTodayLabel() {
      if (!todayLabel) return;
      todayLabel.textContent = todayFormatter.format(new Date());
    }

    function updateDebugIndicator() {
      if (!debugIndicator) return;
      debugIndicator.hidden = !debugMode;
      if (debugMode) {
        debugIndicator.textContent = 'Debug mode active';
      }
    }

    function showToast(message, duration = 3000) {
      if (!toastEl) return;
      toastEl.textContent = message;
      toastEl.classList.add('is-visible');
      clearTimeout(toastTimer);
      toastTimer = window.setTimeout(() => {
        toastEl.classList.remove('is-visible');
      }, duration);
    }

    function handleGlobalKeydown(event) {
      if (event.key === 'Escape' && isModalOpen()) {
        event.preventDefault();
        closeModal();
        return;
      }
      const targetTag = (event.target && event.target.tagName) || '';
      if (targetTag === 'INPUT' || targetTag === 'TEXTAREA' || targetTag === 'SELECT') {
        return;
      }
      if (event.key && event.key.length === 1 && /^[a-zA-Z]$/.test(event.key)) {
        codeBuffer = (codeBuffer + event.key.toLowerCase()).slice(-DEBUG_SEQUENCE.length);
        if (codeBuffer === DEBUG_SEQUENCE) {
          toggleDebugMode();
          codeBuffer = '';
        }
      }
    }

    function toggleDebugMode() {
      debugMode = !debugMode;
      updateDebugIndicator();
      renderCalendar();
      showToast(debugMode ? 'Debug mode enabled ‚Äî every window is unlocked.' : 'Debug mode disabled.');
    }

    function startSnowfall(options = {}) {
      const { silent = false } = options;
      if (snowfallActive) {
        if (!silent) showToast('Snow is already drifting!');
        return;
      }
      if (prefersReducedMotion) {
        snowfallActive = true;
        return;
      }
      ensureSnowflakes();
      snowLayer.dataset.active = 'true';
      snowfallActive = true;
      if (!silent) {
        showToast('Snow is now falling across the page!');
      }
    }

    function ensureSnowflakes() {
      if (prefersReducedMotion) return;
      if (snowLayer.childElementCount) return;
      const flakeCount = 80;
      for (let i = 0; i < flakeCount; i += 1) {
        const flake = document.createElement('span');
        flake.className = 'flake';
        const left = (Math.random() * 100).toFixed(2);
        const size = (0.6 + Math.random() * 1.4).toFixed(2);
        const duration = (6 + Math.random() * 8).toFixed(2);
        const delay = (-Math.random() * 12).toFixed(2);
        const drift = (Math.random() * 20 - 10).toFixed(2) + 'vw';
        flake.style.setProperty('--x', `${left}vw`);
        flake.style.setProperty('--size', `${size}rem`);
        flake.style.setProperty('--duration', `${duration}s`);
        flake.style.setProperty('--delay', `${delay}s`);
        flake.style.setProperty('--drift', drift);
        flake.textContent = Math.random() > 0.6 ? '‚ùÑÔ∏è' : '‚úº';
        snowLayer.appendChild(flake);
      }
    }

    function setActiveGamepadHandler(handler) {
      activeGamepadHandler = typeof handler === 'function' ? handler : null;
    }

    function ensureGamepadLoop() {
      if (gamepadLoopRunning) return;
      gamepadLoopRunning = true;
      requestAnimationFrame(pollGamepad);
    }

    function pollGamepad(timestamp) {
      if (!gamepadLoopRunning) return;
      const pads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
      const pad = pads[0] || null;
      const delta = lastGamepadTimestamp ? (timestamp - lastGamepadTimestamp) : 16;
      lastGamepadTimestamp = timestamp;
      if (pad) {
        if (!gamepadConnected) {
          gamepadConnected = true;
          if (doorButtons.length) {
            focusDoor(focusedDoorIndex);
          }
        }
        const buttons = pad.buttons.map(btn => !!(btn && btn.pressed));
        if (isModalOpen()) {
          if (typeof activeGamepadHandler === 'function') {
            activeGamepadHandler({ pad, buttons, prevButtons: previousButtonState, delta });
          }
          if (buttons[1] && !(previousButtonState[1])) {
            closeModal();
          }
        } else {
          handleDoorNavigation({ pad, buttons, prevButtons: previousButtonState, delta });
        }
        previousButtonState = buttons;
      } else {
        if (gamepadConnected) {
          doorButtons.forEach(btn => btn.dataset.gamepadFocus = 'false');
        }
        gamepadConnected = false;
        previousButtonState = [];
      }
      requestAnimationFrame(pollGamepad);
    }

    function handleDoorNavigation({ pad, buttons, prevButtons, delta }) {
      if (!doorButtons.length) return;
      const axisX = pad.axes[0] || 0;
      const axisY = pad.axes[1] || 0;
      const prev = Array.isArray(prevButtons) ? prevButtons : [];
      navCooldown = Math.max(0, navCooldown - delta);
      const pressRight = buttons[15] && !prev[15];
      const pressLeft = buttons[14] && !prev[14];
      const pressDown = buttons[13] && !prev[13];
      const pressUp = buttons[12] && !prev[12];
      const threshold = 0.45;
      const ready = navCooldown <= 0;
      if (ready) {
        if (axisX > threshold || pressRight) {
          moveFocus('right');
          navCooldown = 180;
        } else if (axisX < -threshold || pressLeft) {
          moveFocus('left');
          navCooldown = 180;
        } else if (axisY > threshold || pressDown) {
          moveFocus('down');
          navCooldown = 180;
        } else if (axisY < -threshold || pressUp) {
          moveFocus('up');
          navCooldown = 180;
        }
      }
      if (buttons[0] && !prev[0]) {
        const target = doorButtons[focusedDoorIndex];
        target?.click();
      }
    }

    function moveFocus(direction) {
      if (!doorButtons.length) return;
      if (!doorButtons[focusedDoorIndex]) {
        focusedDoorIndex = 0;
      }
      const current = doorButtons[focusedDoorIndex];
      const currentRect = current.getBoundingClientRect();
      const currentCenter = {
        x: currentRect.left + currentRect.width / 2,
        y: currentRect.top + currentRect.height / 2
      };
      let bestIdx = focusedDoorIndex;
      let bestScore = Infinity;
      doorButtons.forEach((btn, idx) => {
        if (idx === focusedDoorIndex) return;
        const rect = btn.getBoundingClientRect();
        const center = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        const deltaX = center.x - currentCenter.x;
        const deltaY = center.y - currentCenter.y;
        if (direction === 'left' && deltaX < -10) {
          const score = Math.abs(deltaX) + Math.abs(deltaY) * 0.6;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        } else if (direction === 'right' && deltaX > 10) {
          const score = Math.abs(deltaX) + Math.abs(deltaY) * 0.6;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        } else if (direction === 'up' && deltaY < -10) {
          const score = Math.abs(deltaY) + Math.abs(deltaX) * 0.5;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        } else if (direction === 'down' && deltaY > 10) {
          const score = Math.abs(deltaY) + Math.abs(deltaX) * 0.5;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = idx;
          }
        }
      });
      if (bestIdx !== focusedDoorIndex) {
        focusedDoorIndex = bestIdx;
        focusDoor(focusedDoorIndex);
      }
    }

    function launchMiniGame(win, container) {
      const builder = GAME_BUILDERS[win.game];
      if (!builder) {
        container.innerHTML = '<p class="game-help">This surprise is still baking. Please check back soon!</p>';
        return { cleanup: () => {} };
      }
      return builder(container, win);
    }

    function buildSnowflakeGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'snowflake-game';
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'snowflake-button';
      button.textContent = '‚ùÑÔ∏è';
      button.setAttribute('aria-label', 'Tap to start snowfall');
      const help = document.createElement('p');
      help.className = 'game-help';
      help.textContent = 'Tap the snowflake or press Enter to let the snow drift across the whole site.';
      wrapper.append(button, help);
      container.appendChild(wrapper);
      if (snowfallActive) {
        button.classList.add('activated');
        button.disabled = true;
        help.textContent = 'Snow is already dancing across the page!';
      }
      const onActivate = () => {
        startSnowfall();
        progress.effects.snowfall = true;
        saveProgress();
        button.classList.add('activated');
        button.disabled = true;
        help.textContent = 'Snow is swirling ‚Äî enjoy the cozy flurries!';
      };
      button.addEventListener('click', onActivate);
      setTimeout(() => button.focus({ preventScroll: true }), 60);
      return {
        cleanup: () => {
          button.removeEventListener('click', onActivate);
        }
      };
    }

    function buildCookieGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'cookie-game';
      const cookie = document.createElement('div');
      cookie.className = 'cookie';
      const toppings = Array.isArray(win.toppings) && win.toppings.length ? win.toppings : defaultToppings;
      const layers = new Map();
      toppings.forEach(topping => {
        const layer = document.createElement('div');
        layer.className = `topping ${topping.className}`;
        layer.setAttribute('aria-hidden', 'true');
        cookie.appendChild(layer);
        layers.set(topping.id, layer);
      });
      const controls = document.createElement('div');
      controls.className = 'cookie-controls';
      const status = document.createElement('p');
      status.className = 'game-help';
      status.textContent = 'Add every topping to share a fresh cookie.';
      const buttons = [];
      const handlers = new Map();
      const active = new Set();
      toppings.forEach(topping => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'cookie-toggle';
        btn.dataset.id = topping.id;
        btn.textContent = topping.label;
        btn.setAttribute('aria-pressed', 'false');
        const handler = () => {
          if (active.has(topping.id)) {
            active.delete(topping.id);
            btn.classList.remove('active');
            layers.get(topping.id)?.classList.remove('active');
            btn.setAttribute('aria-pressed', 'false');
          } else {
            active.add(topping.id);
            btn.classList.add('active');
            layers.get(topping.id)?.classList.add('active');
            btn.setAttribute('aria-pressed', 'true');
          }
          if (active.size === toppings.length) {
            status.textContent = 'Perfect! The cookie is ready to share.';
            showToast('Cookie decorated ‚Äî yum!');
          } else {
            status.textContent = `Toppings added: ${active.size}/${toppings.length}.`;
          }
        };
        btn.addEventListener('click', handler);
        handlers.set(btn, handler);
        buttons.push(btn);
        controls.appendChild(btn);
      });
      wrapper.append(cookie, controls, status);
      container.appendChild(wrapper);
      setTimeout(() => buttons[0]?.focus({ preventScroll: true }), 80);
      return {
        cleanup: () => {
          handlers.forEach((handler, btn) => btn.removeEventListener('click', handler));
        }
      };
    }

    function buildLightsGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'lights-game';
      const clue = document.createElement('p');
      clue.className = 'game-help';
      clue.textContent = win.clue || 'Match the preview to untangle the lights.';
      const previewRow = document.createElement('div');
      previewRow.className = 'lights-preview';
      const bulbsRow = document.createElement('div');
      bulbsRow.className = 'lights-row';
      const patternString = typeof win.pattern === 'string' && win.pattern.length ? win.pattern : randomLightPattern(6);
      const pattern = patternString.split('').map(char => char === '1');
      const states = pattern.map(() => false);
      pattern.forEach(on => {
        const bulb = document.createElement('span');
        bulb.className = 'light-bulb';
        bulb.dataset.role = 'preview';
        if (on) bulb.classList.add('on');
        previewRow.appendChild(bulb);
      });
      const handlers = [];
      const buttons = pattern.map((_, index) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'light-bulb';
        btn.dataset.index = String(index);
        btn.setAttribute('aria-pressed', 'false');
        btn.setAttribute('aria-label', `Light ${index + 1}`);
        bulbsRow.appendChild(btn);
        const handler = () => {
          states[index] = !states[index];
          updateButton(index);
          checkWin();
        };
        btn.addEventListener('click', handler);
        handlers[index] = handler;
        return btn;
      });
      wrapper.append(clue, previewRow, bulbsRow);
      const status = document.createElement('p');
      status.className = 'game-help';
      status.textContent = 'Tap bulbs to make the string match the preview.';
      container.append(wrapper, status);

      function updateButton(index) {
        const on = states[index];
        buttons[index].classList.toggle('on', on);
        buttons[index].setAttribute('aria-pressed', on ? 'true' : 'false');
      }

      function checkWin() {
        const solved = states.every((value, idx) => value === pattern[idx]);
        if (solved) {
          status.textContent = 'Gleaming! The lights are perfectly matched.';
          buttons.forEach(btn => btn.disabled = true);
          showToast('Lights matched ‚Äî twinkle on!');
        }
      }

      buttons.forEach((_, index) => updateButton(index));
      setTimeout(() => buttons[0]?.focus({ preventScroll: true }), 80);

      return {
        cleanup: () => {
          buttons.forEach((btn, idx) => {
            const handler = handlers[idx];
            if (handler) btn.removeEventListener('click', handler);
          });
        }
      };
    }

    function buildStoryGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'story-game';
      const card = document.createElement('div');
      card.className = 'story-card';
      if (win.storyEmoji) {
        const emoji = document.createElement('div');
        emoji.className = 'story-emoji';
        emoji.textContent = win.storyEmoji;
        card.appendChild(emoji);
      }
      const steps = Array.isArray(win.storySteps) && win.storySteps.length ? win.storySteps : [win.summary || 'A cozy tale unfolds.'];
      const text = document.createElement('p');
      text.textContent = steps[0];
      card.appendChild(text);
      wrapper.appendChild(card);
      const controls = document.createElement('div');
      controls.className = 'story-controls';
      const nextBtn = document.createElement('button');
      nextBtn.type = 'button';
      nextBtn.className = 'story-next';
      nextBtn.textContent = steps.length > 1 ? 'Continue' : 'Close Story';
      controls.appendChild(nextBtn);
      wrapper.appendChild(controls);
      container.appendChild(wrapper);
      let index = 0;
      const onNext = () => {
        if (index < steps.length - 1) {
          index += 1;
          text.textContent = steps[index];
          if (index === steps.length - 1) {
            nextBtn.textContent = 'All done';
          }
        } else {
          showToast('Story delivered ‚Äî thanks for reading!');
          nextBtn.disabled = true;
        }
      };
      nextBtn.addEventListener('click', onNext);
      setTimeout(() => nextBtn.focus({ preventScroll: true }), 50);
      return {
        cleanup: () => {
          nextBtn.removeEventListener('click', onNext);
        }
      };
    }

    function buildMusicGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'music-game';
      const melody = Array.isArray(win.melody) && win.melody.length ? win.melody : [0, 2, 3, 1];
      const remainingNames = melody.map(index => bellNotes[index]?.label || `Note ${index + 1}`);
      const instructions = document.createElement('p');
      instructions.className = 'game-help';
      instructions.textContent = `Play this jolly pattern: ${remainingNames.join(' ‚Üí ')}.`;
      const keys = document.createElement('div');
      keys.className = 'music-keys';
      const buttons = bellNotes.map((note, index) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'bell-button';
        btn.style.setProperty('--bell-color', note.color);
        btn.dataset.index = String(index);
        btn.textContent = note.label;
        keys.appendChild(btn);
        return btn;
      });
      const progressRow = document.createElement('div');
      progressRow.className = 'music-progress';
      progressRow.innerHTML = melody.map(() => '<span class="music-dot"></span>').join('');
      const dots = Array.from(progressRow.children);
      wrapper.append(instructions, keys, progressRow);
      container.appendChild(wrapper);
      let solved = false;
      let sequence = [];
      const onPress = event => {
        const index = Number(event.currentTarget.dataset.index);
        playTone(bellNotes[index].freq);
        if (solved) return;
        sequence.push(index);
        updateDots();
        const step = sequence.length - 1;
        if (melody[step] !== index) {
          sequence = [];
          updateDots();
          instructions.textContent = 'Oops! Try the melody again from the start.';
          return;
        }
        if (sequence.length === melody.length) {
          solved = true;
          instructions.textContent = 'Beautiful! The bells are pealing in harmony.';
          showToast('Melody mastered ‚Äî the bells ring bright!');
        } else {
          const remaining = remainingNames.slice(sequence.length).join(' ‚Üí ');
          instructions.textContent = `Great! Keep playing: ${remaining}.`;
        }
      };
      function updateDots() {
        dots.forEach((dot, idx) => {
          dot.classList.toggle('active', idx < sequence.length);
        });
      }
      buttons.forEach(btn => btn.addEventListener('click', onPress));
      setTimeout(() => buttons[0]?.focus({ preventScroll: true }), 80);
      return {
        cleanup: () => {
          buttons.forEach(btn => btn.removeEventListener('click', onPress));
        }
      };
    }

    function buildMemoryGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'memory-game';
      const grid = document.createElement('div');
      grid.className = 'memory-grid';
      const pairs = win.pairs || ['üéÑ', 'üéÖ', 'üéÅ', 'ü¶å', '‚õÑ', '‚ùÑÔ∏è'];
      const cards = [...pairs, ...pairs].sort(() => Math.random() - 0.5);
      let flipped = [];
      let matched = 0;
      const cardEls = cards.map((emoji, index) => {
        const card = document.createElement('button');
        card.className = 'memory-card';
        card.type = 'button';
        card.innerHTML = `
          <div class="memory-card-front">?</div>
          <div class="memory-card-back">${emoji}</div>
        `;
        card.addEventListener('click', () => {
          if (card.classList.contains('flipped') || card.classList.contains('matched') || flipped.length >= 2) return;
          card.classList.add('flipped');
          flipped.push({ card, emoji });
          if (flipped.length === 2) {
            const [first, second] = flipped;
            if (first.emoji === second.emoji) {
              first.card.classList.add('matched');
              second.card.classList.add('matched');
              matched += 1;
              flipped = [];
              if (matched === pairs.length) {
                showToast('Memory matched ‚Äî sharp eyes!');
              }
            } else {
              setTimeout(() => {
                first.card.classList.remove('flipped');
                second.card.classList.remove('flipped');
                flipped = [];
              }, 1000);
            }
          }
        });
        grid.appendChild(card);
        return card;
      });
      wrapper.appendChild(grid);
      container.appendChild(wrapper);
      return {};
    }

    function buildTriviaGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'trivia-game';
      const question = document.createElement('p');
      question.className = 'trivia-question';
      question.textContent = win.question;
      const optionsDiv = document.createElement('div');
      optionsDiv.className = 'trivia-options';
      win.options.forEach((opt, idx) => {
        const btn = document.createElement('button');
        btn.className = 'trivia-btn';
        btn.textContent = opt;
        btn.type = 'button';
        btn.addEventListener('click', () => {
          if (idx === win.answer) {
            btn.classList.add('correct');
            showToast('Correct! You know your festive facts.');
            Array.from(optionsDiv.children).forEach(b => b.disabled = true);
          } else {
            btn.classList.add('wrong');
            showToast('Not quite ‚Äî try again!');
          }
        });
        optionsDiv.appendChild(btn);
      });
      wrapper.append(question, optionsDiv);
      container.appendChild(wrapper);
      return {};
    }

    function buildJokeGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'joke-game';
      const btn = document.createElement('button');
      btn.className = 'cracker-btn';
      btn.type = 'button';
      btn.innerHTML = '<div class="cracker-body">PULL ME!</div>';
      const reveal = document.createElement('div');
      reveal.className = 'joke-reveal';
      reveal.innerHTML = `<strong>${win.setup}</strong><br><br>${win.punchline}`;
      btn.addEventListener('click', () => {
        reveal.classList.add('visible');
        btn.style.transform = 'scale(0.9) rotate(5deg)';
        btn.disabled = true;
        showToast('Pop! A terrible joke appears.');
      });
      wrapper.append(btn, reveal);
      container.appendChild(wrapper);
      return {};
    }

    function buildTreeGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'tree-game';
      const stage = document.createElement('div');
      stage.className = 'tree-stage';
      stage.innerHTML = '<div style="font-size: 10rem; line-height: 1; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%);">üéÑ</div>';
      const star = document.createElement('div');
      star.className = 'star-drag';
      star.textContent = '‚≠ê';
      let isDragging = false;
      const onMove = (e) => {
        if (!isDragging) return;
        const x = e.clientX || e.touches[0].clientX;
        const y = e.clientY || e.touches[0].clientY;
        const rect = stage.getBoundingClientRect();
        star.style.left = `${x - rect.left}px`;
        star.style.top = `${y - rect.top}px`;
        star.style.transform = 'translate(-50%, -50%) scale(1.2)';
      };
      const onEnd = (e) => {
        if (!isDragging) return;
        isDragging = false;
        const rect = stage.getBoundingClientRect();
        const starRect = star.getBoundingClientRect();
        const relY = starRect.top - rect.top;
        if (relY < 100 && relY > -50) {
           star.classList.add('placed');
           star.style.left = '50%';
           star.style.top = '-10px';
           star.style.transform = 'translateX(-50%)';
           showToast('The tree is complete!');
           window.removeEventListener('mousemove', onMove);
           window.removeEventListener('mouseup', onEnd);
           window.removeEventListener('touchmove', onMove);
           window.removeEventListener('touchend', onEnd);
        } else {
           star.style.left = '50%';
           star.style.top = '';
           star.style.bottom = '10px';
           star.style.transform = 'translateX(-50%)';
        }
      };
      const onStart = (e) => {
        isDragging = true;
        e.preventDefault();
      };
      star.addEventListener('mousedown', onStart);
      star.addEventListener('touchstart', onStart);
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onEnd);
      window.addEventListener('touchmove', onMove, { passive: false });
      window.addEventListener('touchend', onEnd);
      stage.appendChild(star);
      wrapper.appendChild(stage);
      container.appendChild(wrapper);
      return {
        cleanup: () => {
           window.removeEventListener('mousemove', onMove);
           window.removeEventListener('mouseup', onEnd);
           window.removeEventListener('touchmove', onMove);
           window.removeEventListener('touchend', onEnd);
        }
      };
    }

    function buildPatternGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'pattern-game';
      const row = document.createElement('div');
      row.className = 'pattern-row';
      row.textContent = win.sequence.join(' ');
      const optionsDiv = document.createElement('div');
      optionsDiv.className = 'pattern-options';
      win.options.forEach((opt, idx) => {
        const btn = document.createElement('button');
        btn.className = 'pattern-btn';
        btn.textContent = opt;
        btn.type = 'button';
        btn.addEventListener('click', () => {
          if (idx === win.answer) {
            row.textContent = win.sequence.map(c => c === '?' ? opt : c).join(' ');
            showToast('Pattern complete!');
            Array.from(optionsDiv.children).forEach(b => b.disabled = true);
          } else {
            showToast('Not that one...');
          }
        });
        optionsDiv.appendChild(btn);
      });
      wrapper.append(row, optionsDiv);
      container.appendChild(wrapper);
      return {};
    }

    function buildGlobeGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'globe-game';
      const stage = document.createElement('div');
      stage.className = 'globe-stage';
      
      const content = document.createElement('div');
      content.className = 'globe-content';
      content.textContent = win.scene;
      
      const particlesContainer = document.createElement('div');
      particlesContainer.className = 'globe-particles';
      
      const particleCount = 150;
      const particles = [];
      for (let i = 0; i < particleCount; i += 1) {
        const p = document.createElement('div');
        p.className = 'globe-particle';
        const size = 8 + Math.random() * 10;
        p.style.width = `${size}px`;
        p.style.height = `${size}px`;
        p.style.left = `${Math.random() * 100}%`;
        p.style.top = `${Math.random() * 100}%`;
        p.style.animationDuration = `${2 + Math.random() * 3}s`;
        p.style.animationDelay = `-${Math.random() * 2}s`;
        particlesContainer.appendChild(p);
        particles.push(p);
      }

      const overlay = document.createElement('div');
      overlay.className = 'globe-overlay';
      overlay.style.opacity = '1';

      const base = document.createElement('div');
      base.className = 'globe-base';
      
      stage.append(content, particlesContainer, overlay);
      wrapper.append(stage, base);
      
      let opacity = 1;
      let revealed = false;

      const updateState = () => {
        if (opacity <= 0) return;
        opacity -= 0.004;
        if (opacity < 0) opacity = 0;
        overlay.style.opacity = opacity;
        
        // Remove particles as we wipe
        const keepCount = Math.floor(particleCount * opacity);
        while (particlesContainer.childElementCount > keepCount) {
          if (particlesContainer.lastChild) {
            particlesContainer.lastChild.remove();
          } else {
            break;
          }
        }

        if (opacity <= 0 && !revealed) {
          revealed = true;
          showToast('A magical scene revealed!');
        }
      };

      stage.addEventListener('mousemove', updateState);
      stage.addEventListener('touchmove', (e) => {
        e.preventDefault(); // Prevent scrolling while rubbing
        updateState();
      }, { passive: false });
      
      stage.addEventListener('click', () => {
         opacity -= 0.05;
         updateState();
      });
      
      container.appendChild(wrapper);
      return {};
    }

    function buildSnackGame(container, win) {
      container.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'snack-game';
      const table = document.createElement('div');
      table.className = 'snack-table';
      const milk = document.createElement('div');
      milk.className = 'snack-item';
      milk.textContent = 'ü•õ';
      milk.title = 'Place Milk';
      const cookie = document.createElement('div');
      cookie.className = 'snack-item';
      cookie.textContent = 'üç™';
      cookie.title = 'Place Cookie';
      let placed = 0;
      const onClick = (e) => {
        const item = e.target;
        if (item.classList.contains('placed')) return;
        item.classList.add('placed');
        placed += 1;
        if (placed === 2) {
          showToast('Santa will be so happy!');
        }
      };
      milk.addEventListener('click', onClick);
      cookie.addEventListener('click', onClick);
      table.append(milk, cookie);
      const help = document.createElement('p');
      help.className = 'game-help';
      help.textContent = 'Tap the treats to set them out for Santa.';
      wrapper.append(table, help);
      container.appendChild(wrapper);
      return {};
    }

    function randomLightPattern(length) {
      let result = '';
      let lit = 0;
      for (let i = 0; i < length; i += 1) {
        const on = Math.random() > 0.5;
        if (on) lit += 1;
        result += on ? '1' : '0';
      }
      if (lit === 0) {
        const index = Math.floor(Math.random() * length);
        result = result.slice(0, index) + '1' + result.slice(index + 1);
      }
      return result;
    }

    function playTone(freq) {
      const ctx = ensureAudioContext();
      if (!ctx) return;
      if (ctx.state === 'suspended') {
        ctx.resume().catch(() => {});
      }
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, ctx.currentTime);
      gain.gain.linearRampToValueAtTime(0.25, ctx.currentTime + 0.02);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.35);
      osc.connect(gain).connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.4);
    }

    function ensureAudioContext() {
      if (audioCtx) return audioCtx;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return null;
      audioCtx = new Ctx();
      return audioCtx;
    }
  </script>
  <script src="parental.js"></script>
</body>

</html>
