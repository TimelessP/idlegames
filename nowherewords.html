<!DOCTYPE html>
<html lang="en" data-theme="system">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="color-scheme" content="light dark" />
  <meta name="theme-color" content="#111827" media="(prefers-color-scheme: dark)" />
  <meta name="theme-color" content="#f3f4f6" media="(prefers-color-scheme: light)" />
  <meta name="application-name" content="IdleGames" />
  <meta name="description" content="Nowherewords — multiplayer deduction inspired by Werewords with Upstash-powered lobbies." />
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" href="favicon.ico" />
  <script src="assets/js/pwa.js" defer></script>
  <title>Nowherewords</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f8fafc;
      --bg-muted: #e2e8f0;
      --card: #ffffff;
      --card-muted: #f1f5f9;
      --fg: #0f172a;
      --fg-muted: #475569;
      --accent: #2563eb;
      --accent-strong: #1e3a8a;
      --border: #cbd5f5;
      --danger: #be123c;
      --success: #047857;
      --shadow: 0 10px 25px rgba(15, 23, 42, 0.12);
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.5;
    }

    html[data-theme="dark"] {
      --bg: #0b1120;
      --bg-muted: #111c3a;
      --card: #111826;
      --card-muted: #1e293b;
      --fg: #e2e8f0;
      --fg-muted: #94a3b8;
      --accent: #60a5fa;
      --accent-strong: #bfdbfe;
      --border: #1e293b;
      --shadow: 0 10px 35px rgba(15, 23, 42, 0.45);
    }

    @media (prefers-color-scheme: dark) {
      html[data-theme="system"] {
        --bg: #0b1120;
        --bg-muted: #111c3a;
        --card: #111826;
        --card-muted: #1f2937;
        --fg: #e2e8f0;
        --fg-muted: #9ca3af;
        --accent: #7dd3fc;
        --accent-strong: #f0f9ff;
        --border: #1e293b;
        --shadow: 0 10px 35px rgba(15, 23, 42, 0.55);
      }
    }

    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--fg);
      display: flex;
      flex-direction: column;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .skip-link {
      position: absolute;
      left: 1rem;
      top: 1rem;
      padding: 0.5rem 1rem;
      background: var(--accent);
      color: #fff;
      transform: translateY(-150%);
      transition: transform 0.2s ease;
      z-index: 10;
    }
    .skip-link:focus { transform: translateY(0); }

    header {
      padding: 1.5rem clamp(1rem, 4vw, 3rem);
      background: var(--bg-muted);
      border-bottom: 1px solid var(--border);
      box-shadow: inset 0 -1px 0 rgba(15, 23, 42, 0.1);
    }
    header .title-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
    }
    .panel-tabs {
      margin-top: 1rem;
      display: inline-flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .panel-tabs button {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--fg);
      padding: 0.4rem 0.9rem;
      border-radius: 999px;
      box-shadow: none;
      font-size: 0.85rem;
    }
    .panel-tabs button:focus-visible {
      outline-offset: 3px;
    }
    .panel-tabs button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .app-title {
      font-size: clamp(1.6rem, 4vw, 2.2rem);
      margin: 0;
    }
    .mode-tag {
      font-size: 0.875rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 0.3rem 0.8rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--fg-muted);
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      padding: clamp(1rem, 3vw, 2rem);
    }

    section {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.25rem;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    h2, h3 { margin: 0; }
    p { margin: 0; }
    .section-head {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
    }
    .section-head .panel-close {
      margin-left: auto;
    }
    .panel-close {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--fg-muted);
      padding: 0.2rem 0.75rem;
      border-radius: 999px;
      font-size: 0.8rem;
      box-shadow: none;
    }
    .panel-close:hover { color: var(--fg); }
    label {
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      color: var(--fg-muted);
    }
    input, select, textarea, button {
      font: inherit;
      padding: 0.65rem 0.8rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: var(--card-muted);
      color: var(--fg);
    }
    input:focus-visible, select:focus-visible, textarea:focus-visible, button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    textarea { resize: vertical; min-height: 5rem; }
    button {
      cursor: pointer;
      border: none;
      background: var(--accent);
      color: #fff;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 8px 18px rgba(37,99,235,0.25);
    }
    button:hover:not(:disabled) { transform: translateY(-1px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn-secondary { background: var(--card-muted); color: var(--fg); box-shadow: none; border: 1px solid var(--border); }
    .btn-danger { background: var(--danger); box-shadow: 0 10px 18px rgba(190,18,60,0.3); }
    .btn-ghost {
      background: transparent;
      border: none;
      padding: 0.35rem 0.5rem;
      color: var(--fg-muted);
      box-shadow: none;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.35rem 0.8rem;
      border-radius: 999px;
      font-size: 0.85rem;
      border: 1px solid var(--border);
    }
    .status-pill[data-tone="success"] { border-color: var(--success); color: var(--success); }
    .status-pill[data-tone="danger"] { border-color: var(--danger); color: var(--danger); }
    .status-pill[data-tone="warning"] { border-color: #c2410c; color: #c2410c; }

    .stack {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .log {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: 50vh;
      overflow: auto;
      scroll-behavior: smooth;
    }
    .log li {
      border-bottom: 1px solid rgba(148,163,184,0.3);
      padding: 0.65rem 0;
      display: grid;
      gap: 0.2rem;
    }
    .log li:last-child { border-bottom: none; }
    .log small { color: var(--fg-muted); }
    .log strong { font-size: 0.95rem; }

    .question-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
    }
    .question-actions button {
      flex: 1;
      min-width: 4.5rem;
      font-size: 0.82rem;
    }

    .inline-help { font-size: 0.85rem; color: var(--fg-muted); }

    .hidden { display: none !important; }
    .collapsed { display: none !important; }

    .theme-switch {
      display: inline-flex;
      gap: 0.3rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .theme-switch label {
      flex-direction: row;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.85rem;
      color: var(--fg);
    }

    .badge {
      background: var(--accent);
      color: #fff;
      padding: 0.2rem 0.6rem;
      border-radius: 0.6rem;
      font-size: 0.78rem;
    }

    .gameplay-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.25rem;
      align-items: start;
    }
    .gameplay-card {
      background: var(--card-muted);
      border: 1px solid var(--border);
      border-radius: 0.9rem;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    #sessionMeta {
      background: var(--card-muted);
      border: 1px solid var(--border);
      border-radius: 0.9rem;
      padding: 1rem;
    }
    #roleCard {
      background: var(--card);
      border: 1px dashed var(--border);
      border-radius: 0.9rem;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .role-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-weight: 600;
    }
    .role-select select {
      max-width: 240px;
    }
    .chat-panel {
      max-height: 60vh;
    }
    .chat-log {
      list-style: none;
      margin: 0;
      padding: 0;
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      background: var(--card);
      flex: 1;
      overflow: auto;
      min-height: 8rem;
    }
    .chat-log li {
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid rgba(148,163,184,0.3);
    }
    .chat-log li:last-child { border-bottom: none; }
    #chatForm {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    #chatForm input {
      flex: 1;
    }
    #chatForm button { flex: 0 0 auto; }
    #eventLog {
      max-height: 60vh;
    }
    .vote-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 0.65rem;
    }
    .vote-grid button {
      width: 100%;
    }

    @media (max-width: 720px) {
      header { text-align: center; }
      header .title-row { justify-content: center; }
      main { grid-template-columns: 1fr; }
    }

    @media (prefers-reduced-motion: reduce) {
      * { transition: none !important; scroll-behavior: auto !important; animation: none !important; }
    }
  </style>
</head>
<body>
  <a href="#app-main" class="skip-link">Skip to content</a>
  <header>
    <div class="title-row" role="banner">
      <div>
        <p class="mode-tag">IdleGames Experimental</p>
        <h1 class="app-title">Nowherewords</h1>
        <p id="modeDescriptor" class="inline-help">Deduction trivia inspired by Werewords with Upstash-backed lobbies.</p>
      </div>
      <div class="theme-switch" role="group" aria-label="Theme">
        <label><input type="radio" name="theme" value="system" checked> System</label>
        <label><input type="radio" name="theme" value="light"> Light</label>
        <label><input type="radio" name="theme" value="dark"> Dark</label>
      </div>
    </div>
    <nav id="panelTabs" class="panel-tabs" aria-label="Setup panels">
      <button type="button" data-panel="upstashSection">Connection</button>
      <button type="button" data-panel="profileSection">Identity</button>
      <button type="button" data-panel="sessionSection">Lobby setup</button>
      <button type="button" data-panel="inviteSection" disabled>Invite</button>
    </nav>
  </header>

  <main id="app-main">
    <section id="upstashSection" aria-labelledby="upstashTitle" tabindex="-1">
      <div class="section-head">
        <div>
          <h2 id="upstashTitle">Upstash connection</h2>
          <p class="inline-help">We only use Upstash Redis (free tier). Data auto-expires, but we still tidy up on exit.</p>
        </div>
        <button type="button" class="panel-close" data-close="upstashSection" aria-label="Close connection panel">Close</button>
      </div>
      <form id="upstashForm" class="stack" autocomplete="off">
        <label>REST endpoint
          <input id="endpointInput" name="endpoint" required placeholder="https://your-instance.upstash.io" />
        </label>
        <label>Read/Write token
          <input id="tokenInput" name="token" required aria-describedby="tokenHint" />
        </label>
        <label>Port (optional)
          <input id="portInput" name="port" inputmode="numeric" placeholder="443" />
        </label>
        <p id="tokenHint" class="inline-help">Tokens are stored locally only; invite links include them by design.</p>
        <details class="inline-help">
          <summary>Need a free Upstash Redis?</summary>
          <ol>
            <li><a href="https://upstash.com/redis" target="_blank" rel="noreferrer noopener">Create a free Upstash account</a> and choose Redis.</li>
            <li>Provision a single-region database on the free tier; no credit card required.</li>
            <li>Open the database, copy the <strong>REST endpoint</strong> and the <strong>default full-access token</strong>, then paste them above.</li>
          </ol>
          <p>Sharing the link will temporarily pass the host's endpoint + token to guests so they can send events, but their copy self-cleans after inactivity.</p>
        </details>
        <div class="card-grid">
          <button type="submit">Save connection</button>
          <button type="button" id="clearConfigBtn" class="btn-secondary">Reset saved config</button>
        </div>
      </form>
      <div id="configSummary" class="stack hidden" aria-live="polite"></div>
    </section>

    <section id="profileSection" aria-labelledby="profileTitle" tabindex="-1">
      <div class="section-head">
        <h2 id="profileTitle">Identity & access</h2>
        <button type="button" class="panel-close" data-close="profileSection" aria-label="Close identity panel">Close</button>
      </div>
      <form id="profileForm" class="stack">
        <label>Display name
          <input id="nameInput" name="displayName" required maxlength="40" placeholder="Mayor Aurum" />
        </label>
        <label>Preferred role
          <select id="roleSelect" name="roleSelect">
            <option value="flex">I can host or join</option>
            <option value="host">Mostly hosting</option>
            <option value="villager">Mostly joining</option>
          </select>
        </label>
        <p class="inline-help">Select <strong>Mostly hosting</strong> if you'll act as Mayor (the person running the round). Otherwise pick the joining option so we nudge you toward the player workflow.</p>
        <button type="submit">Save profile</button>
      </form>
      <div id="profileSummary" class="stack hidden" aria-live="polite"></div>
    </section>

    <section id="sessionSection" aria-labelledby="sessionTitle" tabindex="-1">
      <div class="section-head">
        <div>
          <h2 id="sessionTitle">Lobbies & invites</h2>
          <p class="inline-help">Two play styles: <strong>Screen-share assist</strong> (voice chat elsewhere) or <strong>Remote only</strong> (chat + actions here).</p>
        </div>
        <button type="button" class="panel-close" data-close="sessionSection" aria-label="Close lobby panel">Close</button>
      </div>
      <div id="hostTools" class="stack">
        <h3>Host a lobby</h3>
        <form id="hostForm" class="stack">
          <label>Round duration (seconds)
            <input type="number" id="durationInput" name="durationInput" min="30" max="600" step="30" value="240" />
          </label>
          <label>Yes/No tokens available
            <input type="number" id="tokenCountInput" name="tokenCountInput" min="10" max="40" step="1" value="20" />
          </label>
          <label>Maybe tokens available
            <input type="number" id="maybeCountInput" name="maybeCountInput" min="1" max="10" value="3" />
          </label>
          <label>Game mode
            <select id="modeSelect" name="modeSelect" required>
              <option value="screenshare">Screen-share assist</option>
              <option value="remote">Remote only (chat enforced)</option>
            </select>
          </label>
          <button type="submit">Create lobby</button>
        </form>
      </div>
      <div id="joinTools" class="stack">
        <h3>Join an invite</h3>
        <form id="joinForm" class="stack">
          <label>Invite code
            <input id="inviteInput" autocomplete="off" maxlength="8" placeholder="AB42FX" required />
          </label>
          <button type="submit">Join lobby</button>
        </form>
        <p class="inline-help">Invite URLs bundle the endpoint + token + code, so a refresh lands you back in the same lobby.</p>
      </div>
      <div id="activeSession" class="stack hidden" aria-live="polite"></div>
    </section>

    <section id="inviteSection" aria-labelledby="inviteTitle" class="collapsed" tabindex="-1">
      <div class="section-head">
        <div>
          <h2 id="inviteTitle">Invite & share</h2>
          <p class="inline-help">Open this tab to copy the invite link or code for your current lobby.</p>
        </div>
        <button type="button" class="panel-close" data-close="inviteSection" aria-label="Close invite panel">Close</button>
      </div>
      <div id="inviteBody" class="stack">
        <p class="inline-help">Create or join a lobby to populate this panel.</p>
      </div>
    </section>

    <section id="gameplaySection" aria-labelledby="gameplayTitle" class="hidden" tabindex="-1">
      <div class="title-row">
        <h2 id="gameplayTitle">Session cockpit</h2>
        <span id="gameplayStatus" class="status-pill" data-tone="info">Idle</span>
      </div>
      <p id="statusHelp" class="inline-help"></p>
      <div id="sessionMeta" class="stack"></div>
      <div id="roleCard">
        <div>
          <h3>My secret role</h3>
          <p id="roleSummary" class="badge role-badge">Hidden</p>
        </div>
        <p id="roleContext" class="inline-help">Pick the role you were dealt to see what they know and how they should act.</p>
        <label class="role-select">Set privately after cards are dealt (stored locally only).
          <select id="roleTagSelect">
            <option value="unknown">Hidden</option>
            <option value="villager">Villager</option>
            <option value="seer">Seer</option>
            <option value="werewolf">Werewolf</option>
            <option value="mayor">Mayor</option>
          </select>
        </label>
      </div>
      <div class="gameplay-grid">
        <div class="stack" id="interactionColumn">
          <div class="gameplay-card">
            <h3>Actions</h3>
            <div id="actionButtons" class="stack"></div>
          </div>
          <div class="gameplay-card">
            <h3>Ask the Mayor</h3>
            <form id="questionForm" class="stack">
              <label>Question text
                <textarea id="questionInput" maxlength="220" placeholder="Is it bigger than a breadbox?" required></textarea>
              </label>
              <button type="submit">Send question</button>
            </form>
          </div>
        </div>
        <div class="stack" id="discussionColumn">
          <div class="gameplay-card chat-panel">
            <div class="section-head">
              <h3>Instance chat</h3>
              <small class="inline-help">Available when lobby is in remote mode.</small>
            </div>
            <ul id="chatLog" class="chat-log" aria-live="polite"></ul>
            <form id="chatForm" class="stack hidden">
              <input id="chatInput" maxlength="180" placeholder="Status update" aria-label="Chat message" />
              <button type="submit">Send chat</button>
            </form>
          </div>
          <div class="gameplay-card">
            <h3>Feed</h3>
            <ul id="eventLog" class="log" aria-live="polite"></ul>
          </div>
          <div class="gameplay-card hidden" id="votingCard">
            <div class="section-head">
              <h3>Voting</h3>
              <small id="votingHelp" class="inline-help"></small>
            </div>
            <div id="votingButtons" class="vote-grid"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    (() => {
      const STORAGE = {
        config: "idlegames-nowherewords-config",
        profile: "idlegames-nowherewords-profile",
        session: "idlegames-nowherewords-session"
      };

      const LOCAL_ROLE_KEY = "idlegames-nowherewords-role";
      const LAST_SESSION_META_KEY = "idlegames-nowherewords-last-session";
      const SESSION_RETENTION_MS = 24 * 60 * 60 * 1000;

      const manualCollapsed = new Set(["inviteSection"]);

      const ROLE_LABELS = {
        unknown: "Hidden",
        villager: "Villager",
        seer: "Seer",
        werewolf: "Werewolf",
        mayor: "Mayor"
      };

      const ROLE_CONTEXT_COPY = {
        unknown: "Track your dealt role privately so the interface can remind you what that seat knows.",
        villager: "Villagers ask questions, track tokens, and ultimately vote for a Werewolf. They never know the magic word or who the Werewolves are.",
        seer: "The Mayor quietly shows you the magic word during setup. You still do not know the Werewolves—stay subtle so they cannot find you.",
        werewolf: "Werewolves coordinate privately, already know the word, and try to burn through the Mayor's tokens. They only know the word and any other Werewolves, not the Seer.",
        mayor: "Mayor is effectively the host or MC: you reveal the word to the Seer and Werewolves, manage timers and tokens, and log the round's outcome."
      };

      const PANELS = ["upstashSection", "profileSection", "sessionSection", "inviteSection"];

      const STATUS_INFO = {
        lobby: {
          label: "Lobby open",
          help: "Invite players, share the link, and begin the questioning phase when the table is ready.",
          tone: "info"
        },
        questioning: {
          label: "Questioning",
          help: "Players ask yes/no questions. Spend tokens as you answer; mark whether the word was guessed or not.",
          tone: "info"
        },
        "word-guessed": {
          label: "Word guessed",
          help: "Werewolves now have one shot to identify the Seer. Log the result when they decide.",
          tone: "success"
        },
        "village-vote": {
          label: "Village vote",
          help: "The word was not guessed. Everyone votes for a Werewolf. Record whether the village was correct.",
          tone: "warning"
        },
        "village-win": {
          label: "Village victory",
          help: "Villagers prevailed! Debrief, then reset to open a fresh lobby when ready.",
          tone: "success"
        },
        "werewolves-win": {
          label: "Werewolf victory",
          help: "Werewolves clinched the round. Debrief, then reset to return to the lobby.",
          tone: "danger"
        },
        default: {
          label: "Active",
          help: "",
          tone: "info"
        }
      };

      const state = {
        config: loadJSON(STORAGE.config),
        profile: loadJSON(STORAGE.profile),
        session: loadJSON(STORAGE.session),
        lastSessionMeta: loadJSON(LAST_SESSION_META_KEY),
        pollHandle: null,
        lastEventStamp: 0,
        events: [],
        localRole: localStorage.getItem(LOCAL_ROLE_KEY) || "unknown"
      };

      const qs = new URLSearchParams(location.search);
      if (qs.get("endpoint") && qs.get("token")) {
        state.config = {
          endpoint: decodeURIComponentSafe(qs.get("endpoint")),
          token: decodeURIComponentSafe(qs.get("token")),
          port: qs.get("port") ? decodeURIComponentSafe(qs.get("port")) : ""
        };
        saveJSON(STORAGE.config, state.config);
      }
      if (qs.get("invite")) {
        const invite = qs.get("invite").toUpperCase();
        document.addEventListener("DOMContentLoaded", () => {
          document.getElementById("inviteInput").value = invite;
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        enforceConfigRetentionPolicy();
        initThemeControls();
        renderConfig();
        renderProfile();
        renderSession();
        bindForms();
        initPanelTabs();
        bindPanelCloseButtons();
        initRoleSelector();
        updatePanelTabs();
        renderInvitePanel(null);
        refreshPanelVisibility();
        if (state.session) {
          startPolling();
        }
      });

      function bindForms() {
        document.getElementById("upstashForm").addEventListener("submit", evt => {
          evt.preventDefault();
          if (!evt.target.reportValidity()) return;
          const formData = new FormData(evt.target);
          state.config = {
            endpoint: (formData.get("endpoint") || "").trim(),
            token: (formData.get("token") || "").trim(),
            port: (formData.get("port") || "").trim()
          };
          saveJSON(STORAGE.config, state.config);
          renderConfig(true);
        });
        document.getElementById("clearConfigBtn").addEventListener("click", () => {
          clearStoredConfig({ deferRender: true });
          stopPolling();
          renderConfig(false);
          renderSession();
        });
        document.getElementById("profileForm").addEventListener("submit", evt => {
          evt.preventDefault();
          if (!evt.target.reportValidity()) return;
          const fd = new FormData(evt.target);
          state.profile = {
            name: (fd.get("displayName") || "").trim(),
            rolePref: fd.get("roleSelect") || "flex"
          };
          saveJSON(STORAGE.profile, state.profile);
          renderProfile(true);
        });
        document.getElementById("hostForm").addEventListener("submit", async evt => {
          evt.preventDefault();
          if (!evt.target.reportValidity()) return;
          if (!ensureConfig()) return;
          const fd = new FormData(evt.target);
          const payload = {
            duration: Number(fd.get("durationInput")) || 240,
            yesTokens: Number(fd.get("tokenCountInput")) || 20,
            maybeTokens: Number(fd.get("maybeCountInput")) || 3,
            mode: fd.get("modeSelect")
          };
          await createLobby(payload);
        });
        document.getElementById("joinForm").addEventListener("submit", async evt => {
          evt.preventDefault();
          if (!evt.target.reportValidity()) return;
          if (!ensureConfig()) return;
          const invite = document.getElementById("inviteInput").value.trim().toUpperCase();
          await joinLobby(invite);
        });
        document.getElementById("questionForm").addEventListener("submit", async evt => {
          evt.preventDefault();
          if (!evt.target.reportValidity()) return;
          const text = document.getElementById("questionInput").value.trim();
          if (!text) return;
          document.getElementById("questionInput").value = "";
          await pushEvent({ type: "question", text });
        });
        document.getElementById("chatForm").addEventListener("submit", async evt => {
          evt.preventDefault();
          const text = document.getElementById("chatInput").value.trim();
          if (!text) return;
          document.getElementById("chatInput").value = "";
          await pushEvent({ type: "chat", text });
        });
      }

      function bindPanelCloseButtons() {
        document.querySelectorAll(".panel-close").forEach(btn => {
          btn.addEventListener("click", () => {
            const target = btn.dataset.close;
            if (!target) return;
            manualCollapsed.add(target);
            collapsePanel(target);
          });
        });
      }

      function initRoleSelector() {
        const select = document.getElementById("roleTagSelect");
        if (!select) return;
        select.value = ROLE_LABELS[state.localRole] ? state.localRole : "unknown";
        select.addEventListener("change", () => {
          state.localRole = select.value;
          localStorage.setItem(LOCAL_ROLE_KEY, state.localRole);
          renderRoleBadge();
        });
        renderRoleBadge();
      }

      function renderRoleBadge() {
        const summary = document.getElementById("roleSummary");
        const select = document.getElementById("roleTagSelect");
        const context = document.getElementById("roleContext");
        if (!summary || !select) return;
        const roleKey = ROLE_LABELS[state.localRole] ? state.localRole : "unknown";
        summary.textContent = ROLE_LABELS[roleKey] || ROLE_LABELS.unknown;
        summary.dataset.role = roleKey;
        select.value = roleKey;
        if (context) {
          const seat = state.session ? (state.session.kind === "host" ? "Mayor" : "player") : null;
          const seatPrefix = seat ? `You are currently the ${seat} for this lobby. ` : "";
          const roleExplainer = ROLE_CONTEXT_COPY[roleKey] || ROLE_CONTEXT_COPY.unknown;
          context.textContent = `${seatPrefix}${roleExplainer}`;
        }
      }

      function updatePanelTabs() {
        document.querySelectorAll("#panelTabs button[data-panel]").forEach(btn => {
          if (btn.dataset.panel === "inviteSection") {
            const disabled = !state.session?.inviteCode;
            btn.disabled = disabled;
            btn.setAttribute("aria-disabled", disabled);
          }
        });
      }

      function renderConfig(success) {
        const form = document.getElementById("upstashForm");
        const summary = document.getElementById("configSummary");
        if (state.config?.endpoint && state.config?.token) {
          form.classList.add("hidden");
          summary.classList.remove("hidden");
          summary.innerHTML = `
            <p><strong>Endpoint:</strong> ${escapeHTML(state.config.endpoint)}</p>
            <p><strong>Port:</strong> ${state.config.port || "(default)"}</p>
            <p><strong>Token:</strong> <span class="badge">${maskToken(state.config.token)}</span></p>
            <button class="btn-secondary" type="button" id="editConfigBtn">Edit connection</button>
          `;
          summary.querySelector("#editConfigBtn").addEventListener("click", () => {
            summary.classList.add("hidden");
            form.classList.remove("hidden");
            form.endpoint.value = state.config.endpoint;
            form.token.value = state.config.token;
            form.port.value = state.config.port;
            expandPanel("upstashSection");
          });
          collapsePanel("upstashSection", { silent: true });
        } else {
          form.classList.remove("hidden");
          summary.classList.add("hidden");
        }
        if (success) {
          announce("Upstash settings saved.");
        }
        refreshPanelVisibility();
      }

      function renderProfile(success) {
        const form = document.getElementById("profileForm");
        const summary = document.getElementById("profileSummary");
        if (state.profile?.name) {
          form.classList.add("hidden");
          summary.classList.remove("hidden");
          summary.innerHTML = `
            <p><strong>Name:</strong> ${escapeHTML(state.profile.name)}</p>
            <p><strong>Preference:</strong> ${escapeHTML(state.profile.rolePref)}</p>
            <button class="btn-secondary" type="button" id="editProfileBtn">Edit profile</button>
          `;
          summary.querySelector("#editProfileBtn").addEventListener("click", () => {
            summary.classList.add("hidden");
            form.classList.remove("hidden");
            form.displayName.value = state.profile.name;
            form.roleSelect.value = state.profile.rolePref;
            expandPanel("profileSection");
          });
          collapsePanel("profileSection", { silent: true });
        } else {
          form.classList.remove("hidden");
          summary.classList.add("hidden");
        }
        if (success) {
          announce("Profile saved.");
        }
        refreshPanelVisibility();
      }

      function renderSession() {
        const active = document.getElementById("activeSession");
        if (state.session?.inviteCode) {
          active.classList.remove("hidden");
          active.innerHTML = `
            <p class="inline-help">Session pinned locally. Reloading will resume automatically.</p>
            <p><strong>Invite:</strong> <span class="badge">${state.session.inviteCode}</span></p>
            <p><strong>Mode:</strong> ${state.session.mode}</p>
            <p><strong>Role:</strong> ${state.session.kind}</p>
            <p class="inline-help">Head to the Invite tab any time you need the share link.</p>
            <div class="card-grid">
              <button type="button" class="btn-secondary" id="leaveSessionBtn">Leave session</button>
            </div>
          `;
          active.querySelector("#leaveSessionBtn").addEventListener("click", () => {
            if (state.session?.kind === "host") {
              const ok = confirm("Delete lobby from Redis as well?");
              leaveSession(ok);
            } else {
              leaveSession(false);
            }
          });
          document.getElementById("gameplaySection").classList.remove("hidden");
          document.getElementById("chatForm").classList.toggle("hidden", state.session.mode !== "remote");
          collapsePanel("sessionSection", { silent: true });
          renderInvitePanel(state.session);
        } else {
          active.classList.add("hidden");
          document.getElementById("gameplaySection").classList.add("hidden");
          renderInvitePanel(null);
        }
        refreshPanelVisibility();
      }

      function renderInvitePanel(remoteState) {
        const body = document.getElementById("inviteBody");
        if (!body) return;
        if (!state.session?.inviteCode) {
          body.innerHTML = `<p class="inline-help">Create or join a lobby to unlock sharing tools.</p>`;
          collapsePanel("inviteSection", { silent: true });
          updatePanelTabs();
          refreshPanelVisibility();
          return;
        }
        const inviteCode = state.session.inviteCode;
        const snapshot = remoteState || {};
        const inviteUrl = buildInviteURL(inviteCode);
        const tokenInfo = snapshot.yesTokens != null ? `${snapshot.yesTokens} yes/no | ${snapshot.maybeTokens ?? "?"} maybe` : "Syncing…";
        body.innerHTML = `
          <p><strong>Invite code:</strong> <span class="badge">${inviteCode}</span></p>
          <p><strong>Mode:</strong> ${snapshot.mode || state.session.mode || "(unknown)"}</p>
          <p><strong>Mayor:</strong> ${snapshot.host || state.profile?.name || "Host"}</p>
          <p><strong>Tokens:</strong> ${tokenInfo}</p>
          <label>Share link<input readonly value="${inviteUrl}" /></label>
          <div class="card-grid">
            <button type="button" id="copyInviteLink">Copy invite link</button>
            <button type="button" class="btn-secondary" id="copyInviteCode">Copy code</button>
          </div>
        `;
        body.querySelector("#copyInviteLink")?.addEventListener("click", () => {
          navigator.clipboard?.writeText(inviteUrl).then(() => announce("Invite copied"));
        });
        body.querySelector("#copyInviteCode")?.addEventListener("click", () => {
          navigator.clipboard?.writeText(inviteCode).then(() => announce("Code copied"));
        });
        updatePanelTabs();
      }

      function initThemeControls() {
        const radios = document.querySelectorAll('input[name="theme"]');
        const saved = localStorage.getItem("idlegames-nowherewords-theme") || "system";
        document.documentElement.setAttribute("data-theme", saved);
        radios.forEach(r => {
          if (r.value === saved) r.checked = true;
          r.addEventListener("change", () => {
            document.documentElement.setAttribute("data-theme", r.value);
            localStorage.setItem("idlegames-nowherewords-theme", r.value);
          });
        });
      }

      function initPanelTabs() {
        const tabs = document.getElementById("panelTabs");
        if (!tabs) return;
        tabs.addEventListener("click", evt => {
          const btn = evt.target.closest("button[data-panel]");
          if (!btn) return;
          const targetId = btn.dataset.panel;
          expandPanel(targetId);
        });
      }

      function refreshPanelVisibility() {
        PANELS.forEach(panelId => {
          const el = document.getElementById(panelId);
          if (!el) return;
          let shouldCollapse = manualCollapsed.has(panelId);
          if (!shouldCollapse) {
            if (panelId === "upstashSection") {
              shouldCollapse = Boolean(state.config?.endpoint && state.config?.token);
            } else if (panelId === "profileSection") {
              shouldCollapse = Boolean(state.profile?.name);
            } else if (panelId === "sessionSection") {
              shouldCollapse = Boolean(state.session?.inviteCode);
            } else if (panelId === "inviteSection") {
              shouldCollapse = !state.session?.inviteCode;
            }
          }
          if (shouldCollapse) {
            collapsePanel(panelId, { silent: true });
          } else {
            expandPanel(panelId, { silent: true });
          }
        });
      }

      function collapsePanel(id, options = {}) {
        const el = document.getElementById(id);
        if (!el) return;
        el.classList.add("collapsed");
      }

      function expandPanel(id, options = {}) {
        const el = document.getElementById(id);
        if (!el) return;
        manualCollapsed.delete(id);
        el.classList.remove("collapsed");
        if (!options.silent) {
          el.focus({ preventScroll: true });
          el.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      }

      function ensureConfig() {
        if (!state.config?.endpoint || !state.config?.token) {
          alert("Please save your Upstash endpoint and token first.");
          return false;
        }
        return true;
      }

      async function createLobby(options) {
        const inviteCode = randomCode();
        const session = {
          inviteCode,
          kind: "host",
          mode: options.mode,
          createdAt: Date.now()
        };
        const statePayload = {
          inviteCode,
          host: state.profile?.name || "Host",
          mode: options.mode,
          duration: options.duration,
          yesTokens: options.yesTokens,
          maybeTokens: options.maybeTokens,
          initialYesTokens: options.yesTokens,
          initialMaybeTokens: options.maybeTokens,
          status: "lobby",
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        const commands = [
          ["SET", redisKey(inviteCode, "state"), JSON.stringify(statePayload)],
          ["EXPIRE", redisKey(inviteCode, "state"), "10800"],
          ["DEL", redisKey(inviteCode, "events")],
          ["EXPIRE", redisKey(inviteCode, "events"), "10800"],
          ["RPUSH", redisKey(inviteCode, "events"), JSON.stringify(eventEnvelope({ type: "status", text: `${statePayload.host} opened the lobby.` }))]
        ];
        await redisPipeline(commands);
        state.session = session;
        saveJSON(STORAGE.session, state.session);
        recordLastSessionMeta(null);
        renderSession();
        startPolling();
      }

      async function joinLobby(inviteCode) {
        const snapshot = await fetchState(inviteCode);
        if (!snapshot.state) {
          alert("Lobby not found or expired.");
          return;
        }
        state.session = {
          inviteCode,
          kind: snapshot.state.host === (state.profile?.name || "") ? "host" : "player",
          mode: snapshot.state.mode,
          joinedAt: Date.now()
        };
        saveJSON(STORAGE.session, state.session);
        recordLastSessionMeta(null);
        await pushEvent({ type: "status", text: `${state.profile?.name || "Player"} joined the lobby.` }, inviteCode);
        renderSession();
        startPolling();
      }

      function leaveSession(deleteRemote) {
        stopPolling();
        const previousSession = state.session;
        if (deleteRemote && previousSession?.inviteCode) {
          redisPipeline([
            ["DEL", redisKey(previousSession.inviteCode, "state")],
            ["DEL", redisKey(previousSession.inviteCode, "events")]
          ]).catch(console.error);
        }
        if (previousSession?.kind !== "host") {
          clearStoredConfig({ deferRender: true });
          clearInviteInput();
        }
        state.session = null;
        localStorage.removeItem(STORAGE.session);
        recordLastSessionMeta(previousSession);
        state.events = [];
        renderConfig(false);
        renderSession();
        renderLogs();
      }

      function startPolling() {
        stopPolling();
        if (!state.session) return;
        const run = async () => {
          try {
            await syncSession();
            state.pollHandle = setTimeout(run, 4000);
          } catch (err) {
            console.error(err);
            setStatusIndicators("default");
            const pill = document.getElementById("gameplayStatus");
            if (pill) {
              pill.textContent = "Connection issue";
              pill.dataset.tone = "danger";
            }
            const statusHelp = document.getElementById("statusHelp");
            if (statusHelp) {
              statusHelp.textContent = "Retrying sync with Upstash.";
            }
            state.pollHandle = setTimeout(run, 6000);
          }
        };
        run();
      }

      function stopPolling() {
        if (state.pollHandle) {
          clearTimeout(state.pollHandle);
          state.pollHandle = null;
        }
      }

      async function syncSession() {
        if (!state.session) return;
        const { state: remoteState, events } = await fetchState(state.session.inviteCode);
        if (!remoteState) {
          handleExpiredLobby();
          return;
        }
        renderSessionMeta(remoteState);
        const parsedEvents = (events || []).map(entry => safeParse(entry));
        state.events = parsedEvents.filter(Boolean).slice(-200);
        renderLogs();
        renderActions(remoteState);
        if (state.session.mode === "remote") {
          document.getElementById("chatForm").classList.remove("hidden");
        }
      }

      function renderSessionMeta(remoteState) {
        const meta = document.getElementById("sessionMeta");
        const tokenText = `${remoteState.yesTokens} yes/no | ${remoteState.maybeTokens} maybe`;
        meta.innerHTML = `
          <p><strong>Invite:</strong> <span class="badge">${remoteState.inviteCode}</span></p>
          <p><strong>Mode:</strong> ${remoteState.mode}</p>
          <p><strong>Mayor:</strong> ${remoteState.host}</p>
          <p><strong>Tokens:</strong> ${tokenText}</p>
          <p><strong>Timer:</strong> ${remoteState.duration}s</p>
        `;
        setStatusIndicators(remoteState.status);
        renderInvitePanel(remoteState);
        renderVotingControls(remoteState);
      }

      function setStatusIndicators(statusKey) {
        const info = STATUS_INFO[statusKey] || STATUS_INFO.default;
        const pill = document.getElementById("gameplayStatus");
        if (pill) {
          pill.textContent = info.label;
          pill.dataset.tone = info.tone || "info";
        }
        const statusHelp = document.getElementById("statusHelp");
        if (statusHelp) {
          statusHelp.textContent = info.help || "";
        }
      }

      function renderActions(remoteState) {
        const container = document.getElementById("actionButtons");
        container.innerHTML = "";
        const actions = [];
        if (state.session?.kind === "host") {
          switch (remoteState.status) {
            case "lobby":
              actions.push({ label: "Begin questioning", handler: () => setStatus("questioning", `${state.profile?.name || "Host"} started the questioning phase.`) });
              actions.push({ label: "Cleanup lobby", handler: () => leaveSession(true) });
              break;
            case "questioning":
              actions.push({ label: "Word guessed", handler: () => setStatus("word-guessed", "Magic word guessed! Werewolves now guess the Seer.") });
              actions.push({ label: "No guess (start vote)", handler: () => setStatus("village-vote", "Time's up! Begin the village vote.") });
              break;
            case "word-guessed":
              actions.push({ label: "Werewolves found Seer", handler: () => setStatus("werewolves-win", "Werewolves found the Seer. They win!") });
              actions.push({ label: "Werewolves missed", handler: () => setStatus("village-win", "Werewolves failed to find the Seer. Village wins!") });
              break;
            case "village-vote":
              actions.push({ label: "Village caught Werewolf", handler: () => setStatus("village-win", "Village found a Werewolf. They win!") });
              actions.push({ label: "Village missed", handler: () => setStatus("werewolves-win", "Village missed. Werewolves win!") });
              break;
            case "village-win":
            case "werewolves-win":
              actions.push({ label: "Reset for new round", handler: () => resetRound(remoteState) });
              actions.push({ label: "Cleanup lobby", handler: () => leaveSession(true) });
              break;
            default:
              actions.push({ label: "Cleanup lobby", handler: () => leaveSession(true) });
          }
          actions.push({ label: "Spend Yes/No token", handler: () => adjustTokens("yesTokens", -1, remoteState) });
          actions.push({ label: "Spend Maybe token", handler: () => adjustTokens("maybeTokens", -1, remoteState) });
          actions.push({ label: "Refund Yes/No token", handler: () => adjustTokens("yesTokens", 1, remoteState) });
          actions.push({ label: "Refund Maybe token", handler: () => adjustTokens("maybeTokens", 1, remoteState) });
        } else {
          actions.push({ label: "Refresh now", handler: () => syncSession() });
          if (state.session.mode === "remote") {
            document.getElementById("chatForm").classList.remove("hidden");
          }
        }
        actions.forEach(action => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = action.label;
          btn.addEventListener("click", action.handler);
          container.appendChild(btn);
        });
      }

      function renderVotingControls(remoteState) {
        const card = document.getElementById("votingCard");
        const help = document.getElementById("votingHelp");
        const buttons = document.getElementById("votingButtons");
        if (!card || !help || !buttons) return;
        buttons.innerHTML = "";
        const status = remoteState?.status;
        const isHost = state.session?.kind === "host";
        const role = state.localRole;
        const canVoteWerewolf = status === "village-vote" && !isHost && role !== "werewolf";
        const canVoteSeer = status === "word-guessed" && !isHost && role === "werewolf";
        if (!canVoteWerewolf && !canVoteSeer) {
          card.classList.add("hidden");
          help.textContent = "";
          return;
        }
        const ballot = canVoteSeer ? "seer" : "werewolf";
        help.textContent = canVoteSeer
          ? "Werewolves only: tap who you believe is the Seer."
          : "Villagers (including the Seer) never know for sure who the Werewolves are—discuss, then lock in your accusation.";
        const selfName = (state.profile?.name || "").trim();
        const participants = deriveParticipants(remoteState).filter(name => name && name !== selfName);
        if (!participants.length) {
          buttons.innerHTML = "<p class=\"inline-help\">Waiting for player names. Chat once so we can list you here.</p>";
        } else {
          participants.forEach(name => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "btn-secondary";
            btn.textContent = name;
            btn.addEventListener("click", () => submitVote(name, ballot));
            buttons.appendChild(btn);
          });
        }
        card.classList.remove("hidden");
      }

      function renderLogs() {
        renderActivityLog();
        renderChatStream();
      }

      function renderActivityLog() {
        const log = document.getElementById("eventLog");
        if (!log) return;
        const activity = state.events.filter(evt => evt.type !== "chat");
        if (!activity.length) {
          log.innerHTML = "<li><small>No activity yet.</small></li>";
          return;
        }
        log.innerHTML = activity.map(evt => {
          const time = new Date(evt.ts || Date.now()).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          let actions = "";
          if (evt.type === "question" && state.session?.kind === "host") {
            actions = `
              <div class="question-actions">
                <button type="button" data-answer="yes" data-id="${evt.id}">Yes</button>
                <button type="button" data-answer="no" data-id="${evt.id}">No</button>
                <button type="button" data-answer="maybe" data-id="${evt.id}">Maybe</button>
                <button type="button" data-answer="close" data-id="${evt.id}">So close</button>
                <button type="button" data-answer="off" data-id="${evt.id}">Way off</button>
              </div>`;
          }
          return `
            <li>
              <small>${time} — ${escapeHTML(evt.actor || "")}</small>
              <strong>${escapeHTML(renderEventLine(evt))}</strong>
              ${actions}
            </li>
          `;
        }).join("");
        if (state.session?.kind === "host") {
          log.querySelectorAll("[data-answer]").forEach(btn => {
            btn.addEventListener("click", () => respondQuestion(btn.dataset.id, btn.dataset.answer));
          });
        }
      }

      function renderChatStream() {
        const chatLog = document.getElementById("chatLog");
        if (!chatLog) return;
        const chats = state.events.filter(evt => evt.type === "chat");
        const stickToBottom = chatLog.scrollHeight - chatLog.scrollTop - chatLog.clientHeight < 40;
        if (!chats.length) {
          chatLog.innerHTML = "<li><small>No chat yet.</small></li>";
        } else {
          chatLog.innerHTML = chats.map(evt => {
            const time = new Date(evt.ts || Date.now()).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
            return `<li><strong>${escapeHTML(evt.actor || "Player")}</strong> — <small>${time}</small><div>${escapeHTML(evt.text || "")}</div></li>`;
          }).join("");
        }
        if (stickToBottom) {
          chatLog.scrollTop = chatLog.scrollHeight;
        }
      }

      async function submitVote(target, ballot) {
        if (!target || !ballot) return;
        await pushEvent({ type: "vote", ballot, target, voterRole: state.localRole });
      }

      function deriveParticipants(remoteState) {
        const names = new Set();
        if (remoteState?.host) {
          names.add(remoteState.host);
        }
        state.events.forEach(evt => {
          if (evt.actor) {
            names.add(evt.actor);
          }
          if (evt.type === "vote" && evt.target) {
            names.add(evt.target);
          }
        });
        if (state.profile?.name) {
          names.add(state.profile.name);
        }
        return Array.from(names).filter(Boolean).sort((a, b) => a.localeCompare(b));
      }

      async function respondQuestion(id, answer) {
        const answerText = {
          yes: "Yes",
          no: "No",
          maybe: "Maybe",
          close: "So close",
          off: "Way, way off"
        }[answer] || answer;
        await pushEvent({ type: "answer", ref: id, text: answerText });
      }

      function renderEventLine(evt) {
        switch (evt.type) {
          case "chat":
            return `${evt.actor || "Player"}: ${evt.text}`;
          case "status":
            return evt.text;
          case "question":
            return `Q: ${evt.text}`;
          case "answer":
            return `A: ${evt.text}`;
          case "vote":
            if (evt.ballot === "seer") {
              return `Vote (Seer guess): ${evt.target}`;
            }
            if (evt.ballot === "werewolf") {
              return `Vote (Werewolf hunt): ${evt.target}`;
            }
            return `Vote: ${evt.target || ""}`;
          default:
            return evt.text || "Activity";
        }
      }

      async function adjustTokens(key, delta, remoteState) {
        const next = Math.max(0, (remoteState[key] || 0) + delta);
        const merged = Object.assign({}, remoteState, { [key]: next, updatedAt: Date.now() });
        await updateState(merged);
      }

      async function setStatus(status, statusMessage) {
        await updateState({ status, updatedAt: Date.now() });
        if (statusMessage) {
          await pushEvent({ type: "status", text: statusMessage });
        }
      }

      async function updateState(patch) {
        if (!state.session) return;
        const { state: remoteState } = await fetchState(state.session.inviteCode);
        if (!remoteState) return;
        const merged = Object.assign({}, remoteState, patch);
        await redisPipeline([["SET", redisKey(state.session.inviteCode, "state"), JSON.stringify(merged)]]);
        await syncSession();
      }

      async function pushEvent(evt, inviteOverride) {
        if (!state.session && !inviteOverride) return;
        const envelope = eventEnvelope(evt);
        await redisPipeline([
          ["RPUSH", redisKey(inviteOverride || state.session.inviteCode, "events"), JSON.stringify(envelope)],
          ["LTRIM", redisKey(inviteOverride || state.session.inviteCode, "events"), "-200", "-1"],
          ["EXPIRE", redisKey(inviteOverride || state.session.inviteCode, "events"), "10800"]
        ]);
        announce("Event sent");
        await syncSession();
      }

      async function resetRound(remoteState) {
        const payload = {
          status: "lobby",
          yesTokens: remoteState.initialYesTokens ?? remoteState.yesTokens,
          maybeTokens: remoteState.initialMaybeTokens ?? remoteState.maybeTokens,
          updatedAt: Date.now()
        };
        await updateState(payload);
        await pushEvent({ type: "status", text: "Lobby reset for a new round." });
      }

      function eventEnvelope(evt) {
        return {
          id: crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2),
          actor: state.profile?.name || (state.session?.kind === "host" ? "Host" : "Villager"),
          ts: Date.now(),
          ...evt
        };
      }

      async function fetchState(inviteCode) {
        if (!ensureConfig()) return { state: null, events: [] };
        const responses = await redisPipeline([
          ["GET", redisKey(inviteCode, "state")],
          ["LRANGE", redisKey(inviteCode, "events"), "-200", "-1"]
        ]);
        const stateValue = responses[0]?.result;
        const eventsValue = responses[1]?.result || [];
        return {
          state: stateValue ? safeParse(stateValue) : null,
          events: eventsValue
        };
      }

      async function redisPipeline(commands) {
        const base = buildBaseUrl();
        const res = await fetch(`${base}/pipeline`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${state.config.token}`
          },
          body: JSON.stringify(commands)
        });
        if (!res.ok) {
          throw new Error("Upstash pipeline failed");
        }
        const data = await res.json();
        return data;
      }

      function buildBaseUrl() {
        const endpoint = state.config.endpoint.replace(/\/$/, "");
        if (state.config.port) {
          return `${endpoint}:${state.config.port}`;
        }
        return endpoint;
      }

      function redisKey(invite, suffix) {
        return `idlegames:nowherewords:${invite}:${suffix}`;
      }

      function maskToken(token) {
        if (token.length < 8) return token;
        return `${token.slice(0, 4)}…${token.slice(-4)}`;
      }

      function randomCode() {
        return Math.random().toString(36).replace(/[^a-z0-9]/gi, "").slice(0, 6).toUpperCase();
      }

      function loadJSON(key) {
        try {
          const raw = localStorage.getItem(key);
          return raw ? JSON.parse(raw) : null;
        } catch {
          return null;
        }
      }

      function saveJSON(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
      }

      function safeParse(str) {
        try { return JSON.parse(str); } catch { return null; }
      }

      function decodeURIComponentSafe(value) {
        try { return decodeURIComponent(value); } catch { return value; }
      }

      function escapeHTML(str = "") {
        return str.replace(/[&<>"']/g, ch => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[ch] || ch));
      }

      function announce(msg) {
        const region = document.getElementById("modeDescriptor");
        region.textContent = msg;
        setTimeout(() => {
          region.textContent = "Deduction trivia inspired by Werewords with Upstash-backed lobbies.";
        }, 2500);
      }

      function buildInviteURL(code) {
        const baseUrl = location.origin + location.pathname;
        const params = new URLSearchParams({ invite: code });
        if (state.config?.endpoint && state.config?.token) {
          params.set("endpoint", state.config.endpoint);
          params.set("token", state.config.token);
          if (state.config.port) {
            params.set("port", state.config.port);
          }
        }
        return `${baseUrl}?${params.toString()}`;
      }

      function getSessionAnchor(session) {
        if (!session) return null;
        const hostTime = session.createdAt || session.joinedAt;
        const playerTime = session.joinedAt || session.createdAt;
        return session.kind === "host" ? hostTime : playerTime;
      }

      function enforceConfigRetentionPolicy() {
        const now = Date.now();
        if (state.session && state.session.kind !== "host") {
          const anchor = getSessionAnchor(state.session);
          if (anchor && now - anchor > SESSION_RETENTION_MS) {
            leaveSession(false);
            return;
          }
        }
        if (!state.session && state.lastSessionMeta && state.lastSessionMeta.kind !== "host") {
          const elapsed = state.lastSessionMeta.endedAt ? now - state.lastSessionMeta.endedAt : 0;
          if (elapsed > SESSION_RETENTION_MS) {
            clearStoredConfig({ deferRender: true });
            recordLastSessionMeta(null);
          }
        }
      }

      function clearStoredConfig(options = {}) {
        if (!state.config) return;
        state.config = null;
        localStorage.removeItem(STORAGE.config);
        if (!options.deferRender) {
          renderConfig(false);
        }
      }

      function clearInviteInput() {
        const input = document.getElementById("inviteInput");
        if (input) {
          input.value = "";
        }
      }

      function handleExpiredLobby() {
        const wasHost = state.session?.kind === "host";
        const pill = document.getElementById("gameplayStatus");
        if (pill) {
          pill.textContent = wasHost ? "Lobby removed" : "Host left";
          pill.dataset.tone = "danger";
        }
        const statusHelp = document.getElementById("statusHelp");
        if (statusHelp) {
          statusHelp.textContent = wasHost
            ? "Your lobby has been cleaned up. Spin up a new one when ready."
            : "Host cleaned up the lobby. We cleared their Upstash info from this device.";
        }
        if (state.session) {
          leaveSession(false);
        }
      }

      function recordLastSessionMeta(session, endedAt = Date.now()) {
        if (!session) {
          localStorage.removeItem(LAST_SESSION_META_KEY);
          state.lastSessionMeta = null;
          return;
        }
        const meta = {
          kind: session.kind,
          endedAt
        };
        saveJSON(LAST_SESSION_META_KEY, meta);
        state.lastSessionMeta = meta;
      }
    })();
  </script>
  <script src="parental.js" defer></script>
</body>
</html>
