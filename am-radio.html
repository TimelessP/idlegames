<!DOCTYPE html>
<html lang="en" data-theme="system">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AM Radio</title>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
    }

    :root {
      color-scheme: light;
      --bg: #f0ede2;
      --panel: #fdfaf2;
      --panel-border: rgba(44, 22, 12, 0.25);
      --text: #2f2317;
      --muted: rgba(47, 35, 23, 0.64);
      --accent: #b66b2c;
      --gauge-backlight: rgba(240, 221, 171, 0.72);
      --gauge-off: rgba(26, 18, 12, 0.25);
      --dial-face: radial-gradient(circle at 30% 30%, #f8f1dc, #d9c79c 65%, #c1a56b 100%);
      --dial-indicator: #452b11;
      --meter-bg: #2e2419;
      --meter-bar: #e0a34f;
      --meter-glass: linear-gradient(180deg, rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0));
      --button-bg: rgba(255, 255, 255, 0.92);
      --button-border: rgba(47, 35, 23, 0.25);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
        --bg: #15100b;
        --panel: #1f1912;
        --panel-border: rgba(209, 162, 94, 0.28);
        --text: #ead7bd;
        --muted: rgba(234, 215, 189, 0.62);
        --accent: #e69a4c;
        --gauge-backlight: rgba(236, 190, 120, 0.58);
        --gauge-off: rgba(7, 5, 3, 0.45);
        --dial-face: radial-gradient(circle at 30% 30%, #514029, #2f2417 70%, #23190f 100%);
        --dial-indicator: #f3d59a;
        --meter-bg: #070503;
        --meter-bar: #ffaa3b;
        --meter-glass: linear-gradient(180deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0));
        --button-bg: rgba(46, 36, 24, 0.92);
        --button-border: rgba(230, 196, 140, 0.25);
      }
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Montserrat", "Gill Sans", "Avenir Next", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: grid;
      place-items: center;
      padding: clamp(24px, 6vh, 64px) clamp(18px, 6vw, 72px);
    }

    .radio-shell {
      width: min(960px, 100%);
      display: grid;
      gap: clamp(18px, 3vw, 32px);
    }

    .gauge {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: clamp(18px, 3vw, 28px);
      display: grid;
      gap: clamp(12px, 2vw, 18px);
      position: relative;
      box-shadow: 0 24px 48px rgba(0,0,0,0.08);
      transition: background 0.35s ease;
    }

    .gauge::before {
      content: "";
      position: absolute;
      inset: clamp(10px, 2vw, 18px);
      border-radius: 12px;
      background: var(--gauge-backlight);
      opacity: 0.75;
      pointer-events: none;
      transition: opacity 0.35s ease;
      filter: blur(0.6px);
    }

    .gauge.off::before {
      opacity: 0;
      background: var(--gauge-off);
    }

    .gauge-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }

    .frequency-readout {
      font-size: clamp(1.4rem, 4vw, 2.1rem);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-weight: 600;
    }

    .station-status {
      font-size: clamp(0.8rem, 2vw, 1rem);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .dial-track {
      width: 100%;
      height: clamp(64px, 10vw, 92px);
      background: repeating-linear-gradient(90deg,
        rgba(0,0,0,0.18) 0 2px,
        transparent 2px 14px);
      border-radius: 48px;
      padding: clamp(20px, 3vw, 28px) clamp(54px, 8vw, 64px);
      display: grid;
      place-items: center;
      position: relative;
      overflow: visible;
      border: 1px solid rgba(0,0,0,0.08);
    }

    .dial-track,
    .dial-input,
    .knob,
    .knob input[type="range"] {
      -webkit-touch-callout: none;
      user-select: none;
    }

    .dial-input,
    .knob input[type="range"] {
      touch-action: none;
    }

    .dial-track::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(255,255,255,0.3), rgba(255,255,255,0));
      pointer-events: none;
    }

    .dial-input {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      max-width: 680px;
      background: transparent;
      position: relative;
      z-index: 2;
    }

    .dial-input:focus-visible {
      outline: none;
    }

    .dial-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: clamp(78px, 10vw, 112px);
      aspect-ratio: 1;
      border-radius: 50%;
      background: var(--dial-face);
      box-shadow:
        inset -12px -12px 18px rgba(0,0,0,0.22),
        inset 8px 8px 12px rgba(255,255,255,0.25),
        0 6px 12px rgba(0,0,0,0.25);
      border: 2px solid rgba(0,0,0,0.22);
      cursor: grab;
      position: relative;
    }

    .dial-input:active::-webkit-slider-thumb {
      cursor: grabbing;
    }

    .dial-input::-webkit-slider-thumb::before {
      content: "";
      position: absolute;
      inset: 18% 47%;
      background: var(--dial-indicator);
      border-radius: 999px;
      box-shadow: 0 0 1px rgba(0,0,0,0.45);
    }

    .dial-input::-moz-range-thumb {
      width: clamp(78px, 10vw, 112px);
      height: clamp(78px, 10vw, 112px);
      border-radius: 50%;
      border: none;
      background: var(--dial-face);
      box-shadow:
        inset -12px -12px 18px rgba(0,0,0,0.22),
        inset 8px 8px 12px rgba(255,255,255,0.25),
        0 6px 12px rgba(0,0,0,0.25);
      cursor: grab;
    }

    .dial-input::-moz-range-thumb:active {
      cursor: grabbing;
    }

    .dial-scale {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 clamp(54px, 8vw, 64px);
      pointer-events: none;
      font-size: clamp(0.75rem, 2vw, 0.95rem);
      letter-spacing: 0.08em;
      color: rgba(0,0,0,0.45);
      text-transform: uppercase;
    }

    .dial-glow {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle, rgba(255, 210, 140, 0.35), transparent 55%);
      opacity: 0.6;
      transition: opacity 0.25s ease;
    }

    .gauge.off .dial-glow {
      opacity: 0.18;
    }

    .controls-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: clamp(18px, 3vw, 28px);
    }

    .control-card {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: clamp(18px, 3vw, 28px);
      display: grid;
      gap: clamp(12px, 1.6vw, 18px);
      justify-items: center;
      text-align: center;
      box-shadow: 0 18px 36px rgba(0,0,0,0.08);
    }

    .control-card h2 {
      margin: 0;
      font-size: clamp(1rem, 2.6vw, 1.4rem);
      letter-spacing: 0.14em;
      text-transform: uppercase;
    }

    .knob {
      position: relative;
      width: clamp(140px, 18vw, 180px);
      aspect-ratio: 1;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.35), transparent 55%),
                  radial-gradient(circle at 70% 70%, rgba(0,0,0,0.25), transparent 55%),
                  #caa572;
      box-shadow:
        inset -18px -18px 28px rgba(0,0,0,0.28),
        inset 14px 14px 24px rgba(255,255,255,0.22),
        0 12px 24px rgba(0,0,0,0.35);
      border: 2px solid rgba(0,0,0,0.25);
      display: grid;
      place-items: center;
    }

    @media (prefers-color-scheme: dark) {
      .knob {
        background: radial-gradient(circle at 30% 25%, rgba(255,255,255,0.18), transparent 55%),
                    radial-gradient(circle at 70% 70%, rgba(0,0,0,0.35), transparent 55%),
                    #362615;
      }
    }

    .knob input[type="range"] {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: grab;
    }

    .knob input[type="range"]:active {
      cursor: grabbing;
    }

    .knob-indicator {
      position: absolute;
      width: 10px;
      height: 38%;
      top: 12%;
      border-radius: 999px;
      background: var(--dial-indicator);
      box-shadow: 0 0 6px rgba(0,0,0,0.35);
      transform-origin: center bottom;
      pointer-events: none;
    }

    .meter-shell {
      width: 100%;
      height: clamp(28px, 6vw, 48px);
      border-radius: 10px;
      background: var(--meter-bg);
      border: 1px solid rgba(0,0,0,0.35);
      position: relative;
      overflow: hidden;
    }

    .meter-shell::after {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--meter-glass);
      pointer-events: none;
    }

    #level-meter {
      width: 100%;
      height: 100%;
      display: block;
    }

    .upload-modal {
      position: fixed;
      inset: 0;
      background: rgba(9, 6, 4, 0.78);
      display: none;
      align-items: center;
      justify-content: center;
      padding: clamp(24px, 6vw, 48px);
      z-index: 10;
    }

    .upload-modal.open {
      display: flex;
    }

    .upload-card {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 24px;
      padding: clamp(28px, 6vw, 42px);
      width: min(520px, 100%);
      display: grid;
      gap: clamp(18px, 3vw, 26px);
      text-align: center;
      position: relative;
    }

    .upload-card h1 {
      margin: 0;
      font-size: clamp(1.4rem, 3.6vw, 2.2rem);
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .drop-zone {
      border: 2px dashed rgba(0,0,0,0.28);
      border-radius: 18px;
      padding: clamp(32px, 6vw, 48px);
      background: rgba(255, 255, 255, 0.6);
      display: grid;
      gap: 12px;
      cursor: pointer;
      transition: border-color 0.3s ease, background 0.3s ease;
    }

    .drop-zone:hover,
    .drop-zone.drag-hover {
      border-color: var(--accent);
      background: rgba(255, 220, 180, 0.45);
    }

    .drop-zone p {
      margin: 0;
      font-size: clamp(0.95rem, 2.2vw, 1.1rem);
      color: var(--muted);
    }

    .ghost-button {
      justify-self: center;
      font-size: 0.92rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      padding: 12px 20px;
      border-radius: 999px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .ghost-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 18px rgba(0,0,0,0.12);
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .status-line {
      font-size: clamp(0.75rem, 2vw, 0.95rem);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
      text-align: center;
    }

    .reopen {
      text-align: center;
      margin-top: clamp(12px, 2vw, 18px);
    }

    .reopen button {
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 18px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
    }

    .reopen button:hover {
      box-shadow: 0 10px 16px rgba(0,0,0,0.12);
    }

    @media (hover: none) {
      .dial-input::-webkit-slider-thumb,
      .dial-input::-moz-range-thumb,
      .knob input[type="range"] {
        cursor: pointer;
      }
    }
  </style>
</head>
<body>
  <div class="upload-modal open" id="upload-modal" aria-hidden="false">
    <div class="upload-card" role="dialog" aria-modal="true" aria-labelledby="upload-title">
      <h1 id="upload-title">Load Your Broadcast</h1>
      <p class="status-line">Drop an audio file to power the AM dial</p>
      <div class="drop-zone" id="drop-zone" tabindex="0" role="button" aria-describedby="upload-help">
        <p><strong>Drop or tap to choose</strong></p>
        <p id="upload-help">Supports MP3, WAV, OGG &bull; Any length &bull; Loops automatically</p>
      </div>
      <button class="ghost-button" id="browse-button" type="button">Browse Library</button>
      <input class="sr-only" type="file" accept="audio/mpeg,audio/ogg,audio/wav,audio/x-wav,audio/x-m4a" id="file-input">
    </div>
  </div>

  <main class="radio-shell" aria-live="polite">
    <section class="gauge off" id="frequency-gauge">
      <div class="gauge-header">
        <span class="frequency-readout" id="frequency-readout">---</span>
        <span class="station-status" id="station-status">Awaiting signal</span>
      </div>
      <div class="dial-track">
        <div class="dial-glow"></div>
        <input class="dial-input" id="tuner" type="range" min="520" max="1710" step="1" value="1000" aria-label="Tuner frequency in kilohertz">
        <div class="dial-scale" aria-hidden="true">
          <span>520</span>
          <span>800</span>
          <span>1000</span>
          <span>1200</span>
          <span>1400</span>
          <span>1710</span>
        </div>
      </div>
    </section>

    <section class="controls-row" aria-label="Radio controls">
      <div class="control-card" id="volume-card">
        <h2>Volume</h2>
        <div class="knob">
          <input id="volume" type="range" min="0" max="100" value="60" aria-label="Volume control">
          <div class="knob-indicator" id="volume-indicator" style="transform: rotate(-90deg);"></div>
        </div>
        <div class="status-line" id="volume-status">On air · 60%</div>
      </div>

      <div class="control-card">
        <h2>Spectrum</h2>
        <div class="meter-shell">
          <canvas id="level-meter" width="400" height="80" role="img" aria-label="Audio level meter"></canvas>
        </div>
        <div class="status-line" id="tuning-status">No carrier</div>
      </div>
    </section>

    <section class="reopen">
      <button type="button" id="reopen-button">Load a different track</button>
    </section>
  </main>

  <script>
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const browseButton = document.getElementById('browse-button');
    const uploadModal = document.getElementById('upload-modal');
    const tuner = document.getElementById('tuner');
    const volumeControl = document.getElementById('volume');
    const volumeIndicator = document.getElementById('volume-indicator');
    const volumeStatus = document.getElementById('volume-status');
    const frequencyReadout = document.getElementById('frequency-readout');
    const stationStatus = document.getElementById('station-status');
    const tuningStatus = document.getElementById('tuning-status');
    const frequencyGauge = document.getElementById('frequency-gauge');
    const reopenButton = document.getElementById('reopen-button');
    const levelCanvas = document.getElementById('level-meter');
    const levelCtx = levelCanvas.getContext('2d');
  const dialTrack = document.querySelector('.dial-track');

    let audioCtx = null;
    let sourceNode = null;
    let analyserNode = null;
    let masterGain = null;
    let clarityGain = null;
    let noiseGain = null;
    let muffleFilter = null;
    let noiseSource = null;
    let currentBuffer = null;
    let animationFrameId = null;
  let isSourcePlaying = false;
  let playbackStartTime = 0;
  let pauseOffset = 0;
  let tunerPointerState = null;
    let tunerFineAccumulator = 0;

    const STATION_MIN = 520;
    const STATION_MAX = 1710;
    const STATION_WIDTH = 30; // kHz window that counts as tuned
    const STATION_FALLOFF = 130; // beyond this the signal is mostly noise
  const PAUSE_THRESHOLD = 0.05;
  const SILENCE_THRESHOLD = 0.0005;
  const FINE_TUNING_DISTANCE_SCALE = 1.2;
  const FINE_TUNING_MIN_MULTIPLIER = 0.08;
    const PERFECT_TUNING_THRESHOLD = 0.999;
  const KEY_FINE_MULTIPLIER = 0.2;
  const compactMedia = window.matchMedia('(max-width: 560px)');
    const STATUS_COPY = {
      locked: {
        primary: (compact, center) => compact ? `Locked ${center}k` : `Locked on ${center} kHz`,
        secondary: (compact) => compact ? 'Clear' : 'Crystal clear'
      },
      close: {
        primary: (compact, center) => compact ? `Close ${center}k` : `Close to ${center} kHz`,
        secondary: (compact) => compact ? 'Nudge' : 'Tune gently'
      },
      weak: {
        primary: (compact, center) => compact ? `Weak ${center}k` : `Weak near ${center} kHz`,
        secondary: (compact) => compact ? 'Static' : 'Static rising'
      },
      searching: {
        primary: (compact) => compact ? 'Scanning' : 'Searching for signal',
        secondary: (compact) => compact ? 'Snow' : 'Snow storm'
      }
    };

    let stationCenter = Math.floor(randomInRange(STATION_MIN + 40, STATION_MAX - 40));

    function randomInRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function openFilePicker() {
      fileInput.value = '';
      fileInput.click();
    }

    browseButton.addEventListener('click', openFilePicker);
    reopenButton.addEventListener('click', () => {
      stopPlayback();
      showUploadModal();
    });

    dropZone.addEventListener('click', openFilePicker);
    dropZone.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        openFilePicker();
      }
    });

    dropZone.addEventListener('dragover', (event) => {
      event.preventDefault();
      dropZone.classList.add('drag-hover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('drag-hover');
    });

    dropZone.addEventListener('drop', (event) => {
      event.preventDefault();
      dropZone.classList.remove('drag-hover');
      const files = event.dataTransfer.files;
      if (files && files[0]) {
        handleFile(files[0]);
      }
    });

    fileInput.addEventListener('change', () => {
      const file = fileInput.files && fileInput.files[0];
      if (file) {
        handleFile(file);
      }
    });

    function showUploadModal() {
      uploadModal.classList.add('open');
      uploadModal.setAttribute('aria-hidden', 'false');
      if ('inert' in uploadModal) {
        uploadModal.inert = false;
      } else {
        uploadModal.removeAttribute('inert');
      }
      const compact = compactMedia.matches;
      stationStatus.textContent = compact ? 'Await signal' : 'Awaiting signal';
      tuningStatus.textContent = compact ? 'No signal' : 'No carrier';
      frequencyReadout.textContent = '---';
      frequencyGauge.classList.add('off');
      requestAnimationFrame(() => {
        dropZone.focus({ preventScroll: true });
      });
    }

    function hideUploadModal() {
      uploadModal.classList.remove('open');
      const active = document.activeElement;
      if (active && uploadModal.contains(active) && typeof active.blur === 'function') {
        active.blur();
      }
      uploadModal.setAttribute('aria-hidden', 'true');
      if ('inert' in uploadModal) {
        uploadModal.inert = true;
      } else {
        uploadModal.setAttribute('inert', '');
      }
      requestAnimationFrame(() => {
        if (typeof tuner.focus === 'function') {
          tuner.focus({ preventScroll: true });
        }
      });
    }

    function setupAudioContext() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      masterGain = audioCtx.createGain();
      clarityGain = audioCtx.createGain();
      noiseGain = audioCtx.createGain();
      muffleFilter = audioCtx.createBiquadFilter();
      muffleFilter.type = 'lowshelf';
      muffleFilter.frequency.value = 1000;
      muffleFilter.gain.value = -6;

      masterGain.gain.value = 0;
      clarityGain.gain.value = 0;
      noiseGain.gain.value = 0;

      analyserNode = audioCtx.createAnalyser();
      analyserNode.fftSize = 1024;
      analyserNode.smoothingTimeConstant = 0.8;

      clarityGain.connect(muffleFilter);
      muffleFilter.connect(masterGain);
      noiseGain.connect(masterGain);
      masterGain.connect(analyserNode);
      analyserNode.connect(audioCtx.destination);

      createNoiseSource();
    }

    function createNoiseSource() {
      if (!audioCtx) return;
      const bufferSize = audioCtx.sampleRate * 2;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1);
      }
      noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.loop = true;
      noiseSource.connect(noiseGain);
      noiseSource.start(0);
      noiseGain.gain.value = 0;
    }

    function stopPlayback() {
      pauseSource(true);
      sourceNode = null;
      currentBuffer = null;
      isSourcePlaying = false;

      if (noiseSource) {
        try { noiseSource.stop(); } catch (e) { /* ignore */ }
        noiseSource.disconnect();
      }
      noiseSource = null;
      pauseOffset = 0;

      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    function handleFile(file) {
      if (!file) return;

      setupAudioContext();
      stopPlayback();
      createNoiseSource();

      const reader = new FileReader();
      reader.onload = async (event) => {
        const arrayBuffer = event.target.result;
        try {
          currentBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          stationCenter = Math.floor(randomInRange(STATION_MIN + 40, STATION_MAX - 40));
          startPlayback();
          hideUploadModal();
        } catch (error) {
          console.error('Unable to decode audio', error);
          const compact = compactMedia.matches;
          stationStatus.textContent = compact ? 'Load error' : 'File error';
          tuningStatus.textContent = compact ? 'Retry' : 'Try again';
        }
      };
      reader.readAsArrayBuffer(file);
    }

    function startPlayback() {
      if (!currentBuffer) return;
      pauseOffset = 0;
      isSourcePlaying = false;
      updateVolume(volumeControl.value);
      updateTuningDisplay();
      updateClarity();
      drawLevelMeter();
    }

    function startSource(atOffset = 0) {
      if (!audioCtx || !currentBuffer) return;
      if (sourceNode) {
        try { sourceNode.stop(); } catch (e) { /* ignore */ }
        sourceNode.disconnect();
      }
      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = currentBuffer;
      sourceNode.loop = true;
      sourceNode.connect(clarityGain);
      playbackStartTime = audioCtx.currentTime - atOffset;
      sourceNode.start(0, atOffset);
      isSourcePlaying = true;
    }

    function pauseSource(forceReset = false) {
      if (sourceNode) {
        if (!forceReset && currentBuffer && audioCtx) {
          const elapsed = audioCtx.currentTime - playbackStartTime;
          pauseOffset = ((elapsed % currentBuffer.duration) + currentBuffer.duration) % currentBuffer.duration;
        } else {
          pauseOffset = 0;
        }
        try { sourceNode.stop(); } catch (e) { /* ignore */ }
        sourceNode.disconnect();
      }
      sourceNode = null;
      isSourcePlaying = false;
      if (forceReset) {
        pauseOffset = 0;
      }
    }

    function syncPlayback(closeness) {
      if (!currentBuffer || !audioCtx) return;
      const volumeLevel = masterGain ? masterGain.gain.value : 0;
      const inBand = closeness > PAUSE_THRESHOLD;
      const audible = volumeLevel > SILENCE_THRESHOLD;

      if (inBand && audible) {
        if (!isSourcePlaying) {
          const offset = currentBuffer.duration ? pauseOffset % currentBuffer.duration : 0;
          startSource(offset);
        }
      } else if (isSourcePlaying) {
        pauseSource();
      }
    }

    function drawLevelMeter() {
      const width = levelCanvas.width;
      const height = levelCanvas.height;
      const bufferLength = analyserNode.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      levelCtx.clearRect(0, 0, width, height);

      function draw() {
        animationFrameId = requestAnimationFrame(draw);
        analyserNode.getByteTimeDomainData(dataArray);

        levelCtx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        levelCtx.fillRect(0, 0, width, height);

        levelCtx.lineWidth = 2;
        levelCtx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
        levelCtx.beginPath();

        const sliceWidth = width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const v = dataArray[i] / 128.0;
          const y = v * height / 2;

          if (i === 0) {
            levelCtx.moveTo(x, y);
          } else {
            levelCtx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        levelCtx.stroke();

        // overlay LED style bars
        const closeness = computeCloseness();
        const barCount = 20;
        const barSpacing = width / barCount;
        const activeBars = Math.round(barCount * closeness);
        for (let i = 0; i < barCount; i++) {
          levelCtx.fillStyle = i < activeBars
            ? `rgba(255, ${200 - i * 3}, ${120 - i * 2}, 0.85)`
            : 'rgba(80, 60, 40, 0.18)';
          levelCtx.fillRect(i * barSpacing + 1, height - 12, barSpacing - 4, 8);
        }
      }

      draw();
    }

    function computeCloseness() {
      const tuned = Number(tuner.value);
      const diff = Math.abs(tuned - stationCenter);
      if (diff <= STATION_WIDTH) {
        return 1;
      }
      const factor = Math.max(0, 1 - (diff - STATION_WIDTH) / STATION_FALLOFF);
      return Math.max(0, Math.min(1, factor));
    }

    function updateClarity() {
      if (!masterGain) return 0;
      const closeness = computeCloseness();

      clarityGain.gain.value = closeness;
      const noiseLevel = closeness >= PERFECT_TUNING_THRESHOLD
        ? 0
        : 0.05 + (1 - closeness) * 0.35;
      noiseGain.gain.value = noiseLevel;

      const shelfGain = (closeness * 12) - 6; // boost highs when tuned
      muffleFilter.gain.value = shelfGain;

      updateStatus(closeness);
      syncPlayback(closeness);
      return closeness;
    }

    function updateStatus(closeness) {
      const freq = Number(tuner.value);
      frequencyReadout.textContent = `${freq} kHz`;

      const delta = Math.abs(freq - stationCenter);
      const compact = compactMedia.matches;
      const statusKey = delta <= STATION_WIDTH / 2
        ? 'locked'
        : closeness > 0.6
          ? 'close'
          : closeness > 0.25
            ? 'weak'
            : 'searching';
      const copy = STATUS_COPY[statusKey];
      stationStatus.textContent = copy.primary(compact, stationCenter);
      tuningStatus.textContent = copy.secondary(compact);
    }

    function updateVolume(value) {
      if (!masterGain) return;
      const numeric = Number(value);
      const normalized = numeric / 100;
      const eased = Math.pow(normalized, 2.2);
      masterGain.gain.value = eased;
      frequencyGauge.classList.toggle('off', eased < 0.001);

      const angle = -120 + normalized * 240;
      volumeIndicator.style.transform = `rotate(${angle}deg)`;
      volumeStatus.textContent = eased < 0.001 ? 'Standby' : `On air · ${numeric}%`;
      syncPlayback(computeCloseness());
    }

    function updateTuningDisplay() {
      const freq = Number(tuner.value);
      frequencyReadout.textContent = `${freq} kHz`;
    }

    function adjustTunerBySteps(stepCount, { fine = false } = {}) {
      if (!tuner) return false;
      const step = Number(tuner.step) || 1;
      const min = Number(tuner.min);
      const max = Number(tuner.max);
      const currentValue = Number(tuner.value);
      if (!Number.isFinite(currentValue)) return false;

      let delta = stepCount * step;

      if (fine) {
        const scaledDelta = delta * KEY_FINE_MULTIPLIER;
        tunerFineAccumulator += scaledDelta;
        const direction = Math.sign(tunerFineAccumulator);
        const magnitude = Math.abs(tunerFineAccumulator);
        if (magnitude >= step) {
          const stepsToApply = Math.floor(magnitude / step) * direction;
          delta = stepsToApply * step;
          tunerFineAccumulator -= stepsToApply * step;
        } else {
          delta = 0;
        }
      } else {
        tunerFineAccumulator = 0;
      }

      if (delta === 0) return false;

      const nextValue = clamp(currentValue + delta, min, max);
      if (nextValue === currentValue) {
        tunerFineAccumulator = 0;
        return false;
      }

      tuner.value = nextValue;
      updateTuningDisplay();
      updateClarity();
      return true;
    }

    tuner.addEventListener('pointerdown', (event) => {
      if (!dialTrack) return;
      if (event.pointerType === 'mouse' && event.button !== 0) return;
      if (tunerPointerState) return;
      const rect = dialTrack.getBoundingClientRect();
      tunerPointerState = {
        pointerId: event.pointerId,
        lastX: event.clientX,
        rectWidth: rect.width || 1,
        min: Number(tuner.min),
        max: Number(tuner.max),
        step: Number(tuner.step) || 1
      };
      if (typeof tuner.setPointerCapture === 'function') {
        tuner.setPointerCapture(event.pointerId);
      }
      event.preventDefault();
    }, { passive: false });

    tuner.addEventListener('pointermove', (event) => {
      if (!tunerPointerState || event.pointerId !== tunerPointerState.pointerId) return;
      if (!dialTrack) return;

      const rect = dialTrack.getBoundingClientRect();
      const width = rect.width || tunerPointerState.rectWidth || 1;
      tunerPointerState.rectWidth = width;

      const deltaX = event.clientX - tunerPointerState.lastX;
      tunerPointerState.lastX = event.clientX;

      const valueRange = tunerPointerState.max - tunerPointerState.min;
      const perPixel = valueRange / width;
      if (!Number.isFinite(perPixel) || perPixel === 0) {
        event.preventDefault();
        return;
      }

      const distanceBelow = Math.max(0, event.clientY - rect.bottom);
      const normalization = Math.max(1, rect.height * FINE_TUNING_DISTANCE_SCALE);
      const normalizedDistance = distanceBelow / normalization;
      const dynamicScale = 1 / (1 + normalizedDistance);
      const multiplier = perPixel * Math.max(FINE_TUNING_MIN_MULTIPLIER, dynamicScale);

      const currentValue = Number(tuner.value);
      const rawValue = currentValue + deltaX * multiplier;
      const snapped = Math.round(rawValue / tunerPointerState.step) * tunerPointerState.step;
      const finalValue = clamp(snapped, tunerPointerState.min, tunerPointerState.max);

      if (finalValue !== currentValue) {
        tuner.value = finalValue;
        updateTuningDisplay();
        updateClarity();
        tunerFineAccumulator = 0;
      }

      event.preventDefault();
    }, { passive: false });

    function releaseTunerPointer(event) {
      if (!tunerPointerState || event.pointerId !== tunerPointerState.pointerId) return;
      if (tuner.hasPointerCapture && tuner.hasPointerCapture(event.pointerId)) {
        tuner.releasePointerCapture(event.pointerId);
      }
      tunerPointerState = null;
      updateClarity();
      event.preventDefault();
    }

    tuner.addEventListener('pointerup', releaseTunerPointer, { passive: false });
    tuner.addEventListener('pointercancel', releaseTunerPointer, { passive: false });
    tuner.addEventListener('lostpointercapture', () => {
      tunerPointerState = null;
      updateClarity();
    });

    tuner.addEventListener('input', () => {
      updateTuningDisplay();
      updateClarity();
    });

    tuner.addEventListener('keydown', (event) => {
      const key = event.key;
      const shift = event.shiftKey;
      let handled = false;

      switch (key) {
        case 'ArrowLeft':
        case 'ArrowDown':
          handled = adjustTunerBySteps(-1, { fine: shift });
          break;
        case 'ArrowRight':
        case 'ArrowUp':
          handled = adjustTunerBySteps(1, { fine: shift });
          break;
        case 'Tab':
          handled = adjustTunerBySteps(shift ? -1 : 1, { fine: true });
          break;
        default:
          break;
      }

      if (handled) {
        event.preventDefault();
      }
    });

    tuner.addEventListener('wheel', (event) => {
      if (!Number.isFinite(Number(tuner.value))) return;
      const deltaReference = Math.abs(event.deltaY) > Math.abs(event.deltaX) ? event.deltaY : event.deltaX;
      if (!deltaReference) return;
      event.preventDefault();
      const step = Number(tuner.step) || 1;
      const min = Number(tuner.min);
      const max = Number(tuner.max);
      const currentValue = Number(tuner.value);
      const direction = deltaReference > 0 ? -1 : 1;
      const nextValue = clamp(currentValue + direction * step, min, max);
      if (nextValue !== currentValue) {
        tuner.value = nextValue;
        updateTuningDisplay();
        updateClarity();
        tunerFineAccumulator = 0;
      }
    }, { passive: false });

    volumeControl.addEventListener('input', () => {
      updateVolume(volumeControl.value);
    });

    volumeControl.addEventListener('wheel', (event) => {
      const deltaReference = Math.abs(event.deltaY) > Math.abs(event.deltaX) ? event.deltaY : event.deltaX;
      if (!deltaReference) return;
      event.preventDefault();
      const step = Number(volumeControl.step) || 1;
      const min = volumeControl.min === '' ? 0 : Number(volumeControl.min);
      const max = volumeControl.max === '' ? 100 : Number(volumeControl.max);
      const currentValue = Number(volumeControl.value);
      const direction = deltaReference > 0 ? -1 : 1;
      const nextValue = clamp(currentValue + direction * step, min, max);
      if (nextValue !== currentValue) {
        volumeControl.value = nextValue;
        updateVolume(volumeControl.value);
      }
    }, { passive: false });

    [tuner, volumeControl].forEach((control) => {
      control.addEventListener('contextmenu', (event) => {
        event.preventDefault();
      }, { passive: false });
    });

    function handleCompactChange() {
      if (uploadModal.classList.contains('open')) {
        const compact = compactMedia.matches;
        stationStatus.textContent = compact ? 'Await signal' : 'Awaiting signal';
        tuningStatus.textContent = compact ? 'No signal' : 'No carrier';
      } else {
        updateStatus(computeCloseness());
      }
    }

    if (typeof compactMedia.addEventListener === 'function') {
      compactMedia.addEventListener('change', handleCompactChange);
    } else if (typeof compactMedia.addListener === 'function') {
      compactMedia.addListener(handleCompactChange);
    }

    window.addEventListener('focus', () => {
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    });

    showUploadModal();
  </script>
  <script src="parental.js"></script>
</body>
</html>
