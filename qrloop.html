<!DOCTYPE html>
<html lang="en" data-theme="system">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>QR Loop - File Transfer via QR Codes</title>
  <meta name="description" content="Transfer files of any size using chunked QR code transmission" />
  <meta name="color-scheme" content="light dark" />
  <link rel="icon" href="favicon.ico" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 0px;
      background: #f5f5f5;
      color: #333;
      line-height: 1.6;
      min-height: 100vh;
    }
    
    @media (prefers-color-scheme: dark) {
      body {
        background: #1a1a1a;
        color: #e0e0e0;
      }
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .header h1 {
      margin: 0;
      font-size: 2.5rem;
      font-weight: 300;
      color: #0066cc;
    }
    
    .header p {
      margin: 10px 0 0;
      opacity: 0.7;
      font-size: 1.1rem;
    }
    
    .main-area {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
    }
    
    @media (max-width: 768px) {
      .main-area {
        grid-template-columns: 1fr;
        gap: 20px;
      }
    }
    
    .panel {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    
    @media (prefers-color-scheme: dark) {
      .panel {
        background: #2a2a2a;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
    }
    
    .panel h2 {
      margin-top: 0;
      font-size: 1.4rem;
      color: #0066cc;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .text-input {
      width: 100%;
      min-height: 120px;
      padding: 15px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
      resize: vertical;
      background: white;
      color: #333;
      margin-bottom: 15px;
    }
    
    @media (prefers-color-scheme: dark) {
      .text-input {
        background: #333;
        color: #e0e0e0;
        border-color: #555;
      }
    }
    
    .text-input:focus {
      outline: none;
      border-color: #0066cc;
      box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
    }
    
    .file-input-area {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      margin-bottom: 15px;
      cursor: pointer;
      transition: border-color 0.3s ease;
    }
    
    .file-input-area:hover {
      border-color: #0066cc;
    }
    
    @media (prefers-color-scheme: dark) {
      .file-input-area {
        border-color: #555;
      }
      .file-input-area:hover {
        border-color: #0066cc;
      }
    }
    
    .qr-display {
      min-height: 300px;
      background: #f9f9f9;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
      position: relative;
    }
    
    @media (prefers-color-scheme: dark) {
      .qr-display {
        background: #333;
        border-color: #555;
      }
    }
    
    .qr-display canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      background: white;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges; 
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    .camera-view {
      position: relative;
      min-height: 300px;
      max-height: 400px;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #video {
      /* Render video at 1:1 pixel ratio for maximum QR detection resolution */
      width: auto;
      height: auto;
      /* Center the video and let the container clip it */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.3s ease;
      /* Ensure video doesn't exceed reasonable bounds */
      max-width: 200%;
      max-height: 200%;
    }
    
    #video.mirrored {
      transform: translate(-50%, -50%) scaleX(-1);
    }
    
    .camera-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      border: 3px solid #00ff00;
      border-radius: 12px;
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    }
    
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .control-row {
      display: flex;
      gap: 10px;
    }
    
    .btn {
      padding: 12px 16px;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #0066cc;
      color: white;
      flex: 1;
    }
    
    .btn:hover:not(:disabled) {
      background: #0052a3;
      transform: translateY(-1px);
    }
    
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      opacity: 0.6;
    }
    
    .btn.secondary {
      background: #6c757d;
    }
    
    .btn.secondary:hover:not(:disabled) {
      background: #545b62;
    }
    
    .btn.success {
      background: #28a745;
    }
    
    .btn.success:hover:not(:disabled) {
      background: #218838;
    }
    
    .btn.danger {
      background: #dc3545;
    }
    
    .btn.danger:hover:not(:disabled) {
      background: #c82333;
    }
    
    .progress {
      width: 100%;
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    
    @media (prefers-color-scheme: dark) {
      .progress {
        background: #555;
      }
    }
    
    .progress-bar {
      height: 100%;
      background: #28a745;
      transition: width 0.3s ease;
    }
    
    .chunks-bar-container {
      width: 100%;
      margin-bottom: 10px;
    }
    
    .chunks-bar {
      display: flex;
      height: 12px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      gap: 1px;
    }
    
    @media (prefers-color-scheme: dark) {
      .chunks-bar {
        background: #555;
      }
    }
    
    .chunk-segment {
      flex: 1;
      background: #f0f0f0;
      transition: background-color 0.3s ease;
      min-width: 2px;
    }
    
    @media (prefers-color-scheme: dark) {
      .chunk-segment {
        background: #666;
      }
    }
    
    .chunk-segment.received {
      background: #28a745;
    }
    
    .chunk-segment.duplicate {
      background: #17a2b8;
      animation: duplicate-pulse 0.5s ease-in-out;
    }
    
    .chunk-segment.receiving {
      background: #ffc107;
      animation: pulse 0.8s ease-in-out infinite alternate;
    }
    
    @keyframes pulse {
      from { background-color: #ffc107; }
      to { background-color: #ffeb3b; }
    }
    
    @keyframes duplicate-pulse {
      0% { background-color: #17a2b8; transform: scale(1); }
      50% { background-color: #20c997; transform: scale(1.05); }
      100% { background-color: #28a745; transform: scale(1); }
    }
    
    .status {
      padding: 10px 15px;
      border-radius: 8px;
      border-left: 4px solid #0066cc;
      background: rgba(0, 102, 204, 0.1);
      font-size: 14px;
      margin-bottom: 10px;
    }
    
    .status.error {
      border-color: #dc3545;
      background: rgba(220, 53, 69, 0.1);
      color: #dc3545;
    }
    
    .status.success {
      border-color: #28a745;
      background: rgba(40, 167, 69, 0.1);
      color: #28a745;
    }
    
    .status.warning {
      border-color: #ffc107;
      background: rgba(255, 193, 7, 0.1);
      color: #856404;
    }
    
    .hidden {
      display: none !important;
    }
    
    .chunk-info {
      text-align: center;
      background: white;
      border: 1px solid #e0e0e0;
      color: #333;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-family: monospace;
      font-weight: 600;
      margin-bottom: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    @media (prefers-color-scheme: dark) {
      .chunk-info {
        background: #2a2a2a;
        border-color: #555;
        color: #e0e0e0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      }
    }
    
    .filename-input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 14px;
      font-family: monospace;
      background: white;
      color: #333;
      margin-bottom: 10px;
    }
    
    @media (prefers-color-scheme: dark) {
      .filename-input {
        background: #333;
        color: #e0e0e0;
        border-color: #555;
      }
    }
    
    .filename-input:focus {
      outline: none;
      border-color: #0066cc;
      box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
    }
    
    .file-info {
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 10px;
    }
    
    /* Fullscreen QR Modal */
    .qr-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    
    .qr-modal.active {
      display: flex;
    }
    
    .qr-modal-content {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    
    .qr-modal canvas {
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      /* Scale to fit the smallest dimension of the client area */
      width: min(90vw, 90vh);
      height: min(90vw, 90vh);
      /* Disable anti-aliasing for crisp QR code pixels */
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-crisp-edges;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    
    .qr-modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      pointer-events: auto;
      z-index: 10001;
    }
    
    .qr-modal-close:hover {
      background: rgba(255, 255, 255, 1);
      transform: scale(1.1);
    }
    
    .qr-modal-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      pointer-events: none;
      animation: fadeInUp 0.5s ease;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
    
    /* Mobile-specific adjustments for fullscreen QR */
    @media (max-width: 768px) {
      .qr-modal-content {
        max-width: 95vw;
        max-height: 95vh;
      }
      
      .qr-modal-close {
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        font-size: 20px;
      }
      
      .qr-modal-hint {
        bottom: 10px;
        font-size: 13px;
        padding: 6px 12px;
      }
    }
  </style>
  
  <!-- QR Code Libraries -->
  <script>
    const loadScript = (src, fallback) => {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = () => {
          if (fallback) {
            const fallbackScript = document.createElement('script');
            fallbackScript.src = fallback;
            fallbackScript.onload = resolve;
            fallbackScript.onerror = reject;
            document.head.appendChild(fallbackScript);
          } else {
            reject();
          }
        };
        document.head.appendChild(script);
      });
    };

    // Load QRious for generation
    Promise.resolve()
      .then(() => loadScript('https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js'))
      .catch(() => loadScript('https://unpkg.com/qrious@4.0.2/dist/qrious.min.js'))
      .catch(() => {
        console.warn('QRious CDNs failed - using fallback');
        window.QRious = class {
          constructor(options = {}) {
            this.element = options.element;
            this.value = options.value || '';
            this.size = options.size || 100;
            this._generateStub();
          }
          
          set(options) {
            Object.assign(this, options);
            this._generateStub();
          }
          
          _generateStub() {
            if (this.element) {
              const ctx = this.element.getContext('2d');
              ctx.fillStyle = '#fff';
              ctx.fillRect(0, 0, this.size, this.size);
              ctx.fillStyle = '#000';
              ctx.font = '14px monospace';
              ctx.textAlign = 'center';
              ctx.fillText('QR Generation', this.size/2, this.size/2 - 10);
              ctx.fillText('Not Available', this.size/2, this.size/2 + 10);
            }
          }
        };
      });

    // Load jsQR for scanning  
    Promise.resolve()
      .then(() => loadScript('https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js'))
      .catch(() => loadScript('https://unpkg.com/jsqr@1.4.0/dist/jsQR.js'))
      .catch(() => {
        console.warn('jsQR CDNs failed');
      });
  </script>
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>QR Loop</h1>
      <p>Transfer files of any size using chunked QR transmission</p>
    </header>

    <div class="main-area">
      <!-- Send Panel -->
      <div class="panel">
        <h2>üì§ Send Files</h2>
        
        <div class="file-input-area" id="fileDropArea">
          <div>üìÅ Click to select file or drag & drop</div>
          <div style="font-size: 12px; opacity: 0.7; margin-top: 5px;">Any file type, any size</div>
          <input type="file" id="fileInput" style="display: none;" />
        </div>
        
        <textarea 
          id="textInput" 
          class="text-input" 
          placeholder="Or enter text to send..."
        ></textarea>
        
        <div class="file-info" id="fileInfo"></div>
        
        <div class="qr-display" id="qrDisplay">
          <div style="opacity: 0.5; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 10px;">üîÑ</div>
            <div>QR codes will loop here</div>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">Select file or enter text above</div>
          </div>
        </div>
        
        <div class="chunk-info hidden" id="chunkInfo">Chunk 1/1</div>
        
        <div class="progress hidden" id="sendProgress">
          <div class="progress-bar" id="sendProgressBar"></div>
        </div>
        
        <div class="controls">
          <button class="btn success" id="startLoop" disabled>üîÑ Start Loop</button>
          <div class="control-row">
            <button class="btn danger" id="stopLoop" disabled>‚èπÔ∏è Stop</button>
            <button class="btn secondary" id="clearSend">üóëÔ∏è Clear</button>
          </div>
        </div>
      </div>

      <!-- Receive Panel -->
      <div class="panel">
        <h2>üì• Receive Files</h2>
        
        <div class="camera-view">
          <video id="video" autoplay muted playsinline></video>
          <div class="camera-overlay"></div>
        </div>
        
        <div class="chunks-bar-container hidden" id="receiveProgress">
          <div class="chunks-bar" id="receiveProgressBar"></div>
        </div>
        
        <div class="file-info" id="receiveInfo"></div>
        
        <div class="controls">
          <button class="btn success" id="startCamera">üì∑ Start Camera</button>
          <div class="control-row">
            <button class="btn secondary" id="useBackCamera" disabled>üì∑ Back</button>
            <button class="btn secondary" id="useFrontCamera" disabled>ü§≥ Front</button>
            <button class="btn secondary" id="mirrorCamera" disabled>ü™û Mirror</button>
          </div>
          <button class="btn secondary" id="stopCamera" disabled>‚èπÔ∏è Stop Camera</button>
          
          <input type="text" id="saveFilename" placeholder="filename.txt" class="filename-input" />
          <button class="btn" id="saveFile" disabled>üíæ Save File</button>
          
          <div class="control-row">
            <button class="btn secondary" id="clearReceive">üóëÔ∏è Clear</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Status Messages -->
    <div class="status hidden" id="status">
      Ready to transfer files via QR loops
    </div>
  </div>

  <!-- Fullscreen QR Modal -->
  <div class="qr-modal" id="qrModal" role="dialog" aria-label="Fullscreen QR Code">
    <button class="qr-modal-close" id="qrModalClose" aria-label="Close fullscreen">√ó</button>
    <div class="qr-modal-content" id="qrModalContent">
      <!-- QR code canvas will be inserted here -->
    </div>
    <div class="qr-modal-hint">Tap anywhere to close</div>
  </div>

  <script>
    class QRLoop {
      constructor() {
        // Transmission state
        this.currentData = null;
        this.chunks = [];
        this.currentChunk = 0;
        this.looping = false;
        this.loopInterval = null;
        
        // Reception state
        this.receivedChunks = new Map();
        this.expectedChunks = 0;
        this.currentTransmissionId = null;
        this.currentFilename = '';
        this.currentFileSize = 0;
        
        // Camera state
        this.video = null;
        this.stream = null;
        this.scanning = false;
        this.currentFacingMode = null;
        this.isMirrored = false;
        
        // Modal state
        this.modalOpen = false;
        
        this.initializeElements();
        this.setupEventHandlers();
        this.checkUrlParameters();
        this.updateUI();
      }
      
      initializeElements() {
        this.elements = {
          // Send elements
          fileDropArea: document.getElementById('fileDropArea'),
          fileInput: document.getElementById('fileInput'),
          textInput: document.getElementById('textInput'),
          fileInfo: document.getElementById('fileInfo'),
          qrDisplay: document.getElementById('qrDisplay'),
          chunkInfo: document.getElementById('chunkInfo'),
          sendProgress: document.getElementById('sendProgress'),
          sendProgressBar: document.getElementById('sendProgressBar'),
          startLoop: document.getElementById('startLoop'),
          stopLoop: document.getElementById('stopLoop'),
          clearSend: document.getElementById('clearSend'),
          
          // Receive elements
          video: document.getElementById('video'),
          receiveProgress: document.getElementById('receiveProgress'),
          receiveProgressBar: document.getElementById('receiveProgressBar'),
          receiveInfo: document.getElementById('receiveInfo'),
          startCamera: document.getElementById('startCamera'),
          useBackCamera: document.getElementById('useBackCamera'),
          useFrontCamera: document.getElementById('useFrontCamera'),
          mirrorCamera: document.getElementById('mirrorCamera'),
          stopCamera: document.getElementById('stopCamera'),
          saveFilename: document.getElementById('saveFilename'),
          saveFile: document.getElementById('saveFile'),
          clearReceive: document.getElementById('clearReceive'),
          
          status: document.getElementById('status'),
          
          // Modal elements
          qrModal: document.getElementById('qrModal'),
          qrModalClose: document.getElementById('qrModalClose'),
          qrModalContent: document.getElementById('qrModalContent')
        };
      }
      
      setupEventHandlers() {
        // File input handlers
        this.elements.fileDropArea.addEventListener('click', () => {
          this.elements.fileInput.click();
        });
        
        this.elements.fileInput.addEventListener('change', (e) => {
          this.loadFile(e.target.files[0]);
        });
        
        // Drag and drop
        this.elements.fileDropArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          this.elements.fileDropArea.style.borderColor = '#0066cc';
        });
        
        this.elements.fileDropArea.addEventListener('dragleave', () => {
          this.elements.fileDropArea.style.borderColor = '';
        });
        
        this.elements.fileDropArea.addEventListener('drop', (e) => {
          e.preventDefault();
          this.elements.fileDropArea.style.borderColor = '';
          if (e.dataTransfer.files.length > 0) {
            this.loadFile(e.dataTransfer.files[0]);
          }
        });
        
        this.elements.textInput.addEventListener('input', () => {
          this.loadText();
        });
        
        // Send control handlers
        this.elements.startLoop.addEventListener('click', () => {
          this.startTransmissionLoop();
        });
        
        this.elements.stopLoop.addEventListener('click', () => {
          this.stopTransmissionLoop();
        });
        
        this.elements.clearSend.addEventListener('click', () => {
          this.clearSend();
        });
        
        // Camera handlers
        this.elements.startCamera.addEventListener('click', () => {
          this.startCamera();
        });
        
        this.elements.useBackCamera.addEventListener('click', () => {
          this.switchCamera('environment');
        });
        
        this.elements.useFrontCamera.addEventListener('click', () => {
          this.switchCamera('user');
        });
        
        this.elements.mirrorCamera.addEventListener('click', () => {
          this.toggleMirror();
        });
        
        this.elements.stopCamera.addEventListener('click', () => {
          this.stopCamera();
        });
        
        // Receive handlers
        this.elements.saveFile.addEventListener('click', () => {
          this.saveReceivedFile();
        });
        
        this.elements.clearReceive.addEventListener('click', () => {
          this.clearReceive();
        });
        
        this.elements.saveFilename.addEventListener('input', () => {
          this.updateUI();
        });
        
        // Modal handlers
        this.elements.qrModal.addEventListener('click', (e) => {
          if (e.target === this.elements.qrModal) {
            this.closeQRModal();
          }
        });
        
        this.elements.qrModalClose.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeQRModal();
        });
        
        // Prevent modal content clicks from closing modal
        this.elements.qrModalContent.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        // Keyboard handlers for modal
        document.addEventListener('keydown', (e) => {
          if (this.elements.qrModal.classList.contains('active') && (e.key === 'Escape' || e.key === ' ' || e.key === 'Enter')) {
            e.preventDefault();
            this.closeQRModal();
          }
        });
        
        // QR display click to open modal
        this.elements.qrDisplay.addEventListener('click', (e) => {
          if (e.target.tagName === 'CANVAS') {
            this.openQRModal(e.target);
          }
        });
      }
      
      async loadFile(file) {
        if (!file) return;
        
        try {
          this.showStatus('Loading file...', 'info');
          
          const arrayBuffer = await file.arrayBuffer();
          const bytes = new Uint8Array(arrayBuffer);
          
          this.currentData = {
            filename: file.name,
            bytes: bytes,
            isFile: true
          };
          
          this.elements.textInput.value = '';
          this.prepareChunks();
          
          this.showStatus(`File loaded: ${file.name} (${this.formatBytes(bytes.length)})`, 'success');
          
        } catch (error) {
          this.showStatus('Failed to load file', 'error');
          console.error('File load error:', error);
        }
      }
      
      loadText() {
        const text = this.elements.textInput.value;
        
        if (!text.trim()) {
          this.currentData = null;
          this.chunks = [];
          this.updateUI();
          return;
        }
        
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        
        this.currentData = {
          filename: 'text.txt',
          bytes: bytes,
          isFile: false
        };
        
        this.prepareChunks();
        this.updateUI();
      }
      
      prepareChunks() {
        if (!this.currentData) return;
        
        const maxChunkSize = 256; // 256 bytes per chunk for more reliable scanning
        const bytes = this.currentData.bytes;
        const totalChunks = Math.ceil(bytes.length / maxChunkSize);
        const transmissionId = this.generateUUID();
        
        this.chunks = [];
        
        for (let i = 0; i < totalChunks; i++) {
          const start = i * maxChunkSize;
          const end = Math.min(start + maxChunkSize, bytes.length);
          const chunkData = bytes.slice(start, end);
          
          const metadata = {
            uuid: transmissionId,
            filename: this.currentData.filename,
            fileSize: bytes.length,
            chunkNumber: i + 1,
            totalChunks: totalChunks
          };
          
          // Combine metadata and chunk data
          const metadataJson = JSON.stringify(metadata);
          const metadataBytes = new TextEncoder().encode(metadataJson + '|');
          
          const fullChunk = new Uint8Array(metadataBytes.length + chunkData.length);
          fullChunk.set(metadataBytes, 0);
          fullChunk.set(chunkData, metadataBytes.length);
          
          this.chunks.push({
            metadata,
            data: fullChunk
          });
        }
        
        this.elements.fileInfo.textContent = `${this.currentData.filename} - ${this.formatBytes(bytes.length)} - ${totalChunks} chunks`;
        this.updateUI();
      }
      
      async startTransmissionLoop() {
        if (!this.chunks.length) return;
        
        this.looping = true;
        this.currentChunk = 0;
        this.elements.startLoop.disabled = true;
        this.elements.stopLoop.disabled = false;
        this.elements.sendProgress.classList.remove('hidden');
        
        this.showStatus('Starting transmission loop...', 'success');
        
        await this.displayNextChunk();
        this.loopInterval = setInterval(() => {
          this.displayNextChunk();
        }, 500); // 0.5 second per chunk for faster transmission
      }
      
      stopTransmissionLoop() {
        this.looping = false;
        if (this.loopInterval) {
          clearInterval(this.loopInterval);
          this.loopInterval = null;
        }
        
        this.elements.startLoop.disabled = false;
        this.elements.stopLoop.disabled = true;
        this.elements.sendProgress.classList.add('hidden');
        
        this.showStatus('Transmission loop stopped', 'info');
      }
      
      async displayNextChunk() {
        if (!this.looping || !this.chunks.length) return;
        
        const chunk = this.chunks[this.currentChunk];
        const base64Data = btoa(String.fromCharCode.apply(null, chunk.data));
        
        // Create URL with chunk data as parameters
        const currentUrl = new URL(window.location.href);
        currentUrl.hash = ''; // Remove any existing hash
        currentUrl.searchParams.set('receive', '1');
        currentUrl.searchParams.set('data', base64Data);
        
        const qrUrl = currentUrl.toString();
        
        // Log URL length for debugging
        if (chunk.metadata.chunkNumber <= 5 || chunk.metadata.chunkNumber % 50 === 0) {
          console.log(`Chunk ${chunk.metadata.chunkNumber}: URL length = ${qrUrl.length}`);
        }
        
        try {
          await this.waitForQRious();
          
          const tempCanvas = document.createElement('canvas');
          
          // Check if URL is too long for reliable QR encoding
          if (qrUrl.length > 2000) {
            console.warn(`Chunk ${chunk.metadata.chunkNumber}: URL too long (${qrUrl.length} chars), using direct base64`);
            // Fallback to direct base64 encoding
            const qr = new QRious({
              element: tempCanvas,
              value: base64Data,
              size: 400,
              level: 'L',
              foreground: '#000000',
              background: '#ffffff'
            });
          } else {
            // Create optimized QR code with URL
            const qr = new QRious({
              element: tempCanvas,
              value: qrUrl,
              size: 400,
              level: 'L', // Low error correction for max data
              foreground: '#000000',
              background: '#ffffff'
            });
          }
          
          const optimizedCanvas = this.postProcessQRCode(tempCanvas);
          
          // Update display
          this.elements.qrDisplay.innerHTML = '';
          this.elements.qrDisplay.appendChild(optimizedCanvas);
          
          // Update modal if it's open
          if (this.modalOpen) {
            this.updateModalCanvas(optimizedCanvas);
          }
          
          // Update chunk info (separate from QR display)
          this.elements.chunkInfo.textContent = `Chunk ${chunk.metadata.chunkNumber}/${chunk.metadata.totalChunks}`;
          this.elements.chunkInfo.classList.remove('hidden');
          
          // Update progress
          const progress = (this.currentChunk + 1) / this.chunks.length * 100;
          this.elements.sendProgressBar.style.width = `${progress}%`;
          
          // Move to next chunk
          this.currentChunk = (this.currentChunk + 1) % this.chunks.length;
          
        } catch (error) {
          console.error('QR generation failed:', error);
          this.showStatus('QR generation failed', 'error');
        }
      }
      
      postProcessQRCode(sourceCanvas) {
        const sourceCtx = sourceCanvas.getContext('2d');
        const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
        const data = imageData.data;
        
        // Find bounds of the actual QR code
        let minX = sourceCanvas.width, maxX = 0;
        let minY = sourceCanvas.height, maxY = 0;
        let foundQR = false;
        
        for (let y = 0; y < sourceCanvas.height; y++) {
          for (let x = 0; x < sourceCanvas.width; x++) {
            const index = (y * sourceCanvas.width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            
            if (r < 240 || g < 240 || b < 240) {
              foundQR = true;
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
              minY = Math.min(minY, y);
              maxY = Math.max(maxY, y);
            }
          }
        }
        
        if (!foundQR) return sourceCanvas;
        
        const qrSize = Math.max(maxX - minX + 1, maxY - minY + 1);
        const canvasSize = 512;
        
        const targetCanvas = document.createElement('canvas');
        targetCanvas.width = canvasSize;
        targetCanvas.height = canvasSize;
        
        const targetCtx = targetCanvas.getContext('2d');
        targetCtx.imageSmoothingEnabled = false;
        
        // Fill with white background
        targetCtx.fillStyle = '#ffffff';
        targetCtx.fillRect(0, 0, canvasSize, canvasSize);
        
        // Draw QR code with quiet zones
        const quietZone = Math.floor(canvasSize * 0.08);
        const qrRenderSize = canvasSize - (quietZone * 2);
        
        targetCtx.drawImage(
          sourceCanvas,
          minX, minY, qrSize, qrSize,
          quietZone, quietZone, qrRenderSize, qrRenderSize
        );
        
        return targetCanvas;
      }
      
      async startCamera(facingMode = null) {
        if (!navigator.mediaDevices?.getUserMedia) {
          this.showStatus('Camera not available. Please use HTTPS or localhost.', 'error');
          return;
        }
        
        const requestedMode = facingMode || this.getPreferredCamera();
        
        try {
          let constraints = {
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          };
          
          if (requestedMode) {
            constraints.video.facingMode = requestedMode;
          }
          
          this.stream = await navigator.mediaDevices.getUserMedia(constraints);
          this.elements.video.srcObject = this.stream;
          this.currentFacingMode = requestedMode;
          
          // Update button states
          this.elements.startCamera.disabled = true;
          this.elements.useBackCamera.disabled = false;
          this.elements.useFrontCamera.disabled = false;
          this.elements.mirrorCamera.disabled = false;
          this.elements.stopCamera.disabled = false;
          
          // Start scanning
          this.scanning = true;
          this.scanLoop();
          
          this.showStatus('Camera started. Point at QR codes to receive chunks.', 'success');
          
        } catch (error) {
          console.error('Camera error:', error);
          this.showStatus('Failed to start camera. Please check permissions.', 'error');
        }
      }
      
      async switchCamera(facingMode) {
        if (this.stream) {
          this.stopCamera();
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        await this.startCamera(facingMode);
      }
      
      stopCamera() {
        this.scanning = false;
        
        if (this.stream) {
          this.stream.getTracks().forEach(track => track.stop());
          this.stream = null;
        }
        
        if (this.elements.video) {
          this.elements.video.srcObject = null;
          this.elements.video.classList.remove('mirrored');
          this.isMirrored = false;
        }
        
        this.elements.startCamera.disabled = false;
        this.elements.useBackCamera.disabled = true;
        this.elements.useFrontCamera.disabled = true;
        this.elements.mirrorCamera.disabled = true;
        this.elements.stopCamera.disabled = true;
        
        this.showStatus('Camera stopped.', 'info');
      }
      
      toggleMirror() {
        if (!this.elements.video) return;
        
        this.isMirrored = !this.isMirrored;
        
        if (this.isMirrored) {
          this.elements.video.classList.add('mirrored');
          this.showStatus('Camera mirrored', 'success');
        } else {
          this.elements.video.classList.remove('mirrored');
          this.showStatus('Mirror disabled', 'success');
        }
      }
      
      getPreferredCamera() {
        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        return isMobile ? 'environment' : null;
      }
      
      scanLoop() {
        if (!this.scanning || !this.elements.video) return;
        
        requestAnimationFrame(() => {
          const result = this.detectQR();
          if (result) {
            this.handleQRDetection(result);
          }
          
          if (this.scanning) {
            this.scanLoop();
          }
        });
      }
      
      detectQR() {
        if (!this.elements.video || this.elements.video.readyState !== 4) return null;
        
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          canvas.width = this.elements.video.videoWidth;
          canvas.height = this.elements.video.videoHeight;
          
          if (canvas.width === 0 || canvas.height === 0) return null;
          
          ctx.drawImage(this.elements.video, 0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          
          if (typeof jsQR !== 'undefined') {
            const code = jsQR(imageData.data, imageData.width, imageData.height, {
              inversionAttempts: 'attemptBoth'  // Changed to try both normal and inverted
            });
            
            return code ? code.data : null;
          }
          
        } catch (error) {
          console.warn('QR detection error:', error);
          return null;
        }
        
        return null;
      }
      
      handleQRDetection(qrData) {
        try {
          let base64Data = null;
          
          // Check if QR data is a URL with our parameters
          if (qrData.includes('receive=1') && qrData.includes('data=')) {
            const url = new URL(qrData);
            
            // Verify this is our page URL (same origin and path)
            const currentUrl = new URL(window.location.href);
            if (url.origin === currentUrl.origin && 
                url.pathname === currentUrl.pathname) {
              base64Data = url.searchParams.get('data');
            }
          } else {
            // Fallback: treat as direct base64 data for backward compatibility
            base64Data = qrData;
          }
          
          if (!base64Data) return;
          
          // Decode base64 data with better error handling
          let binaryString;
          try {
            binaryString = atob(base64Data);
          } catch (e) {
            console.warn('Base64 decode failed:', e);
            return;
          }
          
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          
          // Find metadata separator with better validation
          const decoder = new TextDecoder('utf-8', { fatal: false });
          let metadataEnd = -1;
          for (let i = 1; i < bytes.length; i++) {
            if (bytes[i] === 124 && bytes[i-1] === 125) { // }|
              metadataEnd = i + 1;
              break;
            }
          }
          
          if (metadataEnd === -1) {
            console.warn('Metadata separator not found');
            return;
          }
          
          const metadataBytes = bytes.slice(0, metadataEnd - 1);
          const chunkData = bytes.slice(metadataEnd);
          
          let metadata;
          try {
            const metadataJson = decoder.decode(metadataBytes);
            metadata = JSON.parse(metadataJson);
          } catch (e) {
            console.warn('Metadata parse failed:', e);
            return;
          }
          
          // Validate metadata structure
          if (!metadata.uuid || !metadata.chunkNumber || !metadata.totalChunks) {
            console.warn('Invalid metadata structure:', metadata);
            return;
          }
          
          this.processReceivedChunk(metadata, chunkData);
          
        } catch (error) {
          console.warn('QR handling error:', error);
        }
      }
      
      processReceivedChunk(metadata, chunkData) {
        const { uuid, filename, fileSize, chunkNumber, totalChunks } = metadata;
        
        // Check if this is a new transmission
        if (this.currentTransmissionId !== uuid) {
          this.receivedChunks.clear();
          this.currentTransmissionId = uuid;
          this.currentFilename = filename;
          this.currentFileSize = fileSize;
          this.expectedChunks = totalChunks;
          this.elements.receiveProgress.classList.remove('hidden');
          this.initializeChunksBar(totalChunks);
          this.showStatus(`Receiving: ${filename}`, 'info');
        }
        
        const isNewChunk = !this.receivedChunks.has(chunkNumber);
        
        if (isNewChunk) {
          // Store new chunk
          this.receivedChunks.set(chunkNumber, chunkData);
          
          // Update chunks bar for new chunk
          this.updateChunksBar(chunkNumber, false);
          
          this.elements.receiveInfo.textContent = 
            `${this.currentFilename} - ${this.formatBytes(this.currentFileSize)} - ` +
            `${this.receivedChunks.size}/${this.expectedChunks} chunks`;
          
          // Log missing chunks for debugging
          if (this.receivedChunks.size > 0 && this.receivedChunks.size % 20 === 0) {
            this.logMissingChunks();
          }
          
          // Flash camera overlay green for new chunks
          const overlay = document.querySelector('.camera-overlay');
          if (overlay) {
            overlay.style.borderColor = '#00ff00';
            overlay.style.boxShadow = '0 0 30px rgba(0, 255, 0, 0.8)';
            setTimeout(() => {
              overlay.style.borderColor = '#00ff00';
              overlay.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.3)';
            }, 200);
          }
          
          // Check if transmission is complete
          if (this.receivedChunks.size === this.expectedChunks) {
            this.completeReception();
          }
        } else {
          // Handle duplicate chunk - show cyan briefly
          this.updateChunksBar(chunkNumber, true);
          
          // Flash camera overlay cyan for duplicates
          const overlay = document.querySelector('.camera-overlay');
          if (overlay) {
            overlay.style.borderColor = '#17a2b8';
            overlay.style.boxShadow = '0 0 30px rgba(23, 162, 184, 0.8)';
            setTimeout(() => {
              overlay.style.borderColor = '#00ff00';
              overlay.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.3)';
            }, 200);
          }
        }
      }
      
      completeReception() {
        // Assemble file from chunks
        const totalSize = Array.from(this.receivedChunks.values())
          .reduce((sum, chunk) => sum + chunk.length, 0);
        
        const fileData = new Uint8Array(totalSize);
        let offset = 0;
        
        for (let i = 1; i <= this.expectedChunks; i++) {
          const chunk = this.receivedChunks.get(i);
          if (chunk) {
            fileData.set(chunk, offset);
            offset += chunk.length;
          }
        }
        
        this.receivedFileData = fileData;
        this.elements.saveFilename.value = this.currentFilename;
        this.updateUI();
        
        this.showStatus(`File received complete! Ready to save: ${this.currentFilename}`, 'success');
      }
      
      saveReceivedFile() {
        if (!this.receivedFileData || !this.elements.saveFilename.value.trim()) return;
        
        const filename = this.elements.saveFilename.value.trim();
        const blob = new Blob([this.receivedFileData]);
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        URL.revokeObjectURL(url);
        
        this.showStatus(`File saved: ${filename}`, 'success');
      }
      
      clearSend() {
        this.stopTransmissionLoop();
        this.currentData = null;
        this.chunks = [];
        this.elements.fileInput.value = '';
        this.elements.textInput.value = '';
        this.elements.fileInfo.textContent = '';
        this.elements.qrDisplay.innerHTML = `
          <div style="opacity: 0.5; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 10px;">üîÑ</div>
            <div>QR codes will loop here</div>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">Select file or enter text above</div>
          </div>
        `;
        this.elements.chunkInfo.classList.add('hidden');
        this.elements.sendProgress.classList.add('hidden');
        this.updateUI();
        this.showStatus('Send data cleared', 'info');
      }
      
      clearReceive() {
        this.receivedChunks.clear();
        this.currentTransmissionId = null;
        this.receivedFileData = null;
        this.elements.receiveInfo.textContent = '';
        this.elements.receiveProgress.classList.add('hidden');
        this.elements.saveFilename.value = '';
        this.updateUI();
        this.showStatus('Receive data cleared', 'info');
      }
      
      updateUI() {
        const hasData = this.currentData && this.chunks.length > 0;
        const hasReceivedFile = this.receivedFileData && this.elements.saveFilename.value.trim();
        
        this.elements.startLoop.disabled = !hasData || this.looping;
        this.elements.saveFile.disabled = !hasReceivedFile;
      }
      
      async waitForQRious() {
        let attempts = 0;
        while (attempts < 10 && typeof QRious === 'undefined') {
          await new Promise(resolve => setTimeout(resolve, 200));
          attempts++;
        }
        if (typeof QRious === 'undefined') {
          throw new Error('QRious library not available');
        }
      }
      
      generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }
      
      initializeChunksBar(totalChunks) {
        // Clear and recreate the chunks bar
        this.elements.receiveProgressBar.innerHTML = '';
        
        // Create individual chunk segments
        for (let i = 1; i <= totalChunks; i++) {
          const segment = document.createElement('div');
          segment.className = 'chunk-segment';
          segment.setAttribute('data-chunk', i);
          segment.title = `Chunk ${i}/${totalChunks}`;
          this.elements.receiveProgressBar.appendChild(segment);
        }
      }
      
      updateChunksBar(chunkNumber, isDuplicate = false) {
        const segment = this.elements.receiveProgressBar.querySelector(`[data-chunk="${chunkNumber}"]`);
        if (!segment) return;
        
        if (isDuplicate) {
          // Show duplicate state briefly, then revert to received
          segment.classList.remove('receiving', 'received');
          segment.classList.add('duplicate');
          
          // Revert to received after animation completes
          setTimeout(() => {
            segment.classList.remove('duplicate');
            segment.classList.add('received');
          }, 500); // Match animation duration
        } else {
          // Mark as received for new chunks
          segment.classList.remove('receiving', 'duplicate');
          segment.classList.add('received');
        }
      }
      
      logMissingChunks() {
        if (!this.currentTransmissionId || this.expectedChunks === 0) return;
        
        const missing = [];
        for (let i = 1; i <= this.expectedChunks; i++) {
          if (!this.receivedChunks.has(i)) {
            missing.push(i);
          }
        }
        
        if (missing.length > 0) {
          const ranges = this.chunksToRanges(missing);
          console.log(`Missing chunks (${missing.length}/${this.expectedChunks}):`, ranges.join(', '));
          
          // Calculate rough percentages for gaps
          const percentages = missing.map(chunk => Math.round((chunk / this.expectedChunks) * 100));
          console.log('Gap percentages:', [...new Set(percentages)].sort((a, b) => a - b));
        }
      }
      
      chunksToRanges(chunks) {
        if (chunks.length === 0) return [];
        
        chunks.sort((a, b) => a - b);
        const ranges = [];
        let start = chunks[0];
        let end = chunks[0];
        
        for (let i = 1; i < chunks.length; i++) {
          if (chunks[i] === end + 1) {
            end = chunks[i];
          } else {
            ranges.push(start === end ? `${start}` : `${start}-${end}`);
            start = chunks[i];
            end = chunks[i];
          }
        }
        ranges.push(start === end ? `${start}` : `${start}-${end}`);
        
        return ranges;
      }
      
      formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }
      
      checkUrlParameters() {
        const urlParams = new URLSearchParams(window.location.search);
        
        if (urlParams.get('receive') === '1') {
          // Auto-start camera when coming from QR link
          this.showStatus('QR link detected! Starting camera to receive file chunks...', 'success');
          
          // Clear URL parameters to clean up address bar
          const cleanUrl = new URL(window.location.href);
          cleanUrl.search = '';
          window.history.replaceState({}, document.title, cleanUrl.toString());
          
          // Auto-start camera after a short delay
          setTimeout(() => {
            this.startCamera();
          }, 1000);
          
          // Process the data parameter if present
          const data = urlParams.get('data');
          if (data) {
            // Simulate QR detection for the initial chunk
            setTimeout(() => {
              this.handleQRDetection(data);
            }, 2000);
          }
        }
      }
      
      showStatus(message, type = 'info') {
        this.elements.status.textContent = message;
        this.elements.status.className = 'status';
        if (type !== 'info') {
          this.elements.status.classList.add(type);
        }
        this.elements.status.classList.remove('hidden');
        
        if (type === 'success' || type === 'info') {
          setTimeout(() => {
            this.elements.status.classList.add('hidden');
          }, 4000);
        }
      }
      
      async openQRModal(canvas) {
        try {
          // Request fullscreen
          const element = document.documentElement;
          if (element.requestFullscreen) {
            await element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            await element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            await element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            await element.msRequestFullscreen();
          }
        } catch (error) {
          console.warn('Fullscreen not supported or denied:', error);
          // Continue anyway - modal will still work without fullscreen
        }
        
        // Store modal state
        this.modalOpen = true;
        
        // Initial modal canvas setup
        this.updateModalCanvas(canvas);
        
        // Show modal
        this.elements.qrModal.classList.add('active');
        
        // Prevent body scroll while modal is open
        document.body.style.overflow = 'hidden';
        
        this.showStatus('QR code opened in fullscreen. Tap anywhere to close.', 'success');
      }
      
      updateModalCanvas(canvas) {
        if (!this.modalOpen) return;
        
        // Create a new canvas for the fullscreen modal
        const modalCanvas = document.createElement('canvas');
        
        // Set modal canvas to high resolution (1024x1024) - let CSS handle scaling
        const canvasSize = 1024;
        
        modalCanvas.width = canvasSize;
        modalCanvas.height = canvasSize;
        // CSS will handle the scaling via .qr-modal canvas rules
        
        const modalCtx = modalCanvas.getContext('2d');
        
        // Disable anti-aliasing for crisp QR code rendering
        modalCtx.imageSmoothingEnabled = false;
        modalCtx.webkitImageSmoothingEnabled = false;
        modalCtx.mozImageSmoothingEnabled = false;
        modalCtx.msImageSmoothingEnabled = false;
        
        // Fill with white background
        modalCtx.fillStyle = '#ffffff';
        modalCtx.fillRect(0, 0, canvasSize, canvasSize);
        
        // Calculate quiet zone for fullscreen (about 6% for better visibility)
        const quietZone = Math.floor(canvasSize * 0.06);
        const qrRenderSize = canvasSize - (quietZone * 2);
        
        // Draw the preview canvas scaled to fullscreen size with proper quiet zones
        modalCtx.drawImage(
          canvas,
          0, 0, canvas.width, canvas.height, // Source: entire preview canvas
          quietZone, quietZone, qrRenderSize, qrRenderSize // Target: centered with quiet zones
        );
        
        // Clear modal content and add the new canvas
        this.elements.qrModalContent.innerHTML = '';
        this.elements.qrModalContent.appendChild(modalCanvas);
      }
      
      closeQRModal() {
        // Set modal state to closed
        this.modalOpen = false;
        
        // Hide modal
        this.elements.qrModal.classList.remove('active');
        
        // Restore body scroll
        document.body.style.overflow = '';
        
        // Exit fullscreen if active
        try {
          if (document.fullscreenElement || document.webkitFullscreenElement || 
              document.mozFullScreenElement || document.msFullscreenElement) {
            if (document.exitFullscreen) {
              document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
              document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
              document.msExitFullscreen();
            }
          }
        } catch (error) {
          console.warn('Error exiting fullscreen:', error);
        }
        
        this.showStatus('Fullscreen QR closed.', 'success');
      }
    }
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.qrloop = new QRLoop();
    });
  </script>
</body>
<script src="parental.js"></script>
</html>