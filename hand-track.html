<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="description" content="Hand tracking tech demo using webcam">
    <title>Hand Track - Idle Games</title>
    <link rel="icon" type="image/png" sizes="512x512" href="assets/appicons/idle-games-512x512px.png">
    <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512px.png">
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --accent: #0f3460;
            --highlight: #e94560;
            --text: #eaeaea;
            --text-dim: #888;
            --success: #4ecca3;
            --warning: #ffc107;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        h1 {
            font-size: 1.5rem;
            color: var(--highlight);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        h1 .icon {
            font-size: 1.8rem;
        }

        .status-bar {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.85rem;
            padding: 0.3rem 0.6rem;
            background: var(--bg-secondary);
            border-radius: 1rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-dim);
        }

        .status-dot.active {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .status-dot.warning {
            background: var(--warning);
        }

        .main-area {
            display: grid;
            grid-template-columns: 1fr 280px 280px;
            gap: 1rem;
            min-height: calc(100vh - 150px);
        }

        @media (max-width: 1200px) {
            .main-area {
                grid-template-columns: 1fr 280px;
            }
            .hands-column {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 900px) {
            .main-area {
                grid-template-columns: 1fr;
            }
        }

        .hands-column {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .video-container {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 4/3;
            max-height: 70vh;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-dim);
        }

        .video-placeholder .icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        #start-btn {
            margin-top: 1rem;
            padding: 0.8rem 2rem;
            font-size: 1rem;
            background: var(--highlight);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(233, 69, 96, 0.4);
        }

        #start-btn:disabled {
            background: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1rem;
        }

        .panel h2 {
            font-size: 1rem;
            color: var(--highlight);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hands-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .hand-card {
            background: var(--accent);
            border-radius: 8px;
            padding: 0.75rem;
            transition: all 0.3s;
        }

        .hand-card.left {
            border-left: 3px solid #3498db;
        }

        .hand-card.right {
            border-left: 3px solid #e74c3c;
        }

        .hand-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .hand-label {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .hand-confidence {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .gesture-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background: var(--highlight);
            border-radius: 4px;
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        .no-hands {
            color: var(--text-dim);
            font-style: italic;
            font-size: 0.9rem;
            text-align: center;
            padding: 1rem;
        }

        .interaction-zone {
            position: relative;
            height: 150px;
            background: linear-gradient(135deg, var(--accent) 0%, var(--bg-primary) 100%);
            border-radius: 8px;
            overflow: hidden;
        }

        .interaction-target {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--highlight);
            opacity: 0.8;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: transform 0.1s, box-shadow 0.1s;
            cursor: pointer;
        }

        .interaction-target.hovered {
            transform: scale(1.2);
            box-shadow: 0 0 20px var(--highlight);
        }

        .interaction-target.grabbed {
            transform: scale(0.9);
            background: var(--success);
        }

        .interaction-target.pressed {
            transform: scale(0.85);
            background: var(--warning);
            box-shadow: 0 0 25px var(--warning);
        }

        .interaction-target.clicked {
            animation: click-pulse 0.3s ease-out;
        }

        @keyframes click-pulse {
            0% { transform: scale(1.2); box-shadow: 0 0 20px var(--highlight); }
            50% { transform: scale(1.3); box-shadow: 0 0 40px var(--success); background: var(--success); }
            100% { transform: scale(1.2); box-shadow: 0 0 20px var(--highlight); }
        }

        .cursor-point {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: all 0.05s linear;
        }

        .cursor-point.index {
            background: rgba(52, 152, 219, 0.8);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        .cursor-point.palm {
            background: rgba(155, 89, 182, 0.8);
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }

        .cursor-point.pointing {
            background: rgba(241, 196, 15, 0.9);
            box-shadow: 0 0 12px rgba(241, 196, 15, 0.6);
            width: 12px;
            height: 12px;
        }

        .cursor-point.pinch {
            background: rgba(46, 204, 113, 0.9);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.6);
            width: 24px;
            height: 24px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            font-size: 0.8rem;
        }

        .stat-item {
            background: var(--accent);
            padding: 0.5rem;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--success);
        }

        .stat-label {
            color: var(--text-dim);
            font-size: 0.7rem;
        }

        .gesture-history {
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
        }

        .gesture-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--accent);
            display: flex;
            justify-content: space-between;
        }

        .gesture-entry:last-child {
            border-bottom: none;
        }

        .finger-display {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .finger {
            width: 20px;
            height: 30px;
            background: var(--bg-primary);
            border-radius: 10px 10px 4px 4px;
            transition: all 0.15s;
        }

        .finger.extended {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .finger.thumb {
            height: 25px;
            width: 18px;
        }

        /* 3D visualization panel */
        .viz-3d {
            height: 200px;
            background: #0a0a15;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        #hand-3d-canvas {
            width: 100%;
            height: 100%;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--accent);
            border-top-color: var(--highlight);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 1rem;
            color: var(--text-dim);
        }

        footer {
            text-align: center;
            padding: 1rem;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        footer a {
            color: var(--highlight);
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading-overlay">
        <div class="spinner"></div>
        <p class="loading-text">Loading hand tracking model...</p>
    </div>

    <div class="container">
        <header>
            <h1><span class="icon">üñêÔ∏è</span> Hand Track</h1>
            <div class="status-bar">
                <div class="status-indicator">
                    <span class="status-dot" id="camera-status"></span>
                    <span>Camera</span>
                </div>
                <div class="status-indicator">
                    <span class="status-dot" id="model-status"></span>
                    <span>Model</span>
                </div>
                <div class="status-indicator">
                    <span class="status-dot" id="tracking-status"></span>
                    <span id="fps-display">0 FPS</span>
                </div>
            </div>
        </header>

        <div class="main-area">
            <div class="video-container" id="video-container">
                <video id="webcam" autoplay playsinline></video>
                <canvas id="canvas-overlay"></canvas>
                <div class="video-placeholder" id="video-placeholder">
                    <div class="icon">üì∑</div>
                    <p>Camera access required for hand tracking</p>
                    <button id="start-btn">Start Camera</button>
                </div>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <h2>üéØ Interaction Demo</h2>
                    <div class="interaction-zone" id="interaction-zone">
                        <div class="interaction-target" id="target-1" style="left: 30px; top: 50px;">üéæ</div>
                        <div class="interaction-target" id="target-2" style="left: 120px; top: 80px;">‚≠ê</div>
                        <div class="interaction-target" id="target-3" style="left: 200px; top: 40px;">üîÆ</div>
                    </div>
                </div>

                <div class="panel">
                    <h2>üìä Stats</h2>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="stat-hands">0</div>
                            <div class="stat-label">Hands</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-gestures">0</div>
                            <div class="stat-label">Gestures</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-pinches">0</div>
                            <div class="stat-label">Pinches</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stat-grabs">0</div>
                            <div class="stat-label">Grabs</div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h2>üïπÔ∏è 3D Hand View</h2>
                    <div class="viz-3d">
                        <canvas id="hand-3d-canvas"></canvas>
                    </div>
                </div>

                <div class="panel">
                    <h2>üìú Gesture Log</h2>
                    <div class="gesture-history" id="gesture-history">
                        <div class="no-hands">Awaiting gestures...</div>
                    </div>
                </div>
            </div>

            <div class="hands-column">
                <div class="panel">
                    <h2>üëã Detected Hands</h2>
                    <div class="hands-list" id="hands-list">
                        <div class="no-hands">No hands detected</div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <a href="index.html">‚Üê Back to Idle Games</a> | Hand tracking powered by MediaPipe
        </footer>
    </div>

    <!-- Load MediaPipe scripts (UMD, not ES modules) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>

    <script>
        // MediaPipe exposes globals
        const { Hands, HAND_CONNECTIONS } = window;
        const { drawConnectors, drawLandmarks } = window;
        const { Camera } = window;

        // ============================================
        // State Management
        // ============================================
        const state = {
            isRunning: false,
            hands: [],
            stats: {
                gestures: 0,
                pinches: 0,
                grabs: 0
            },
            gestureLog: [],
            fps: 0,
            frameCount: 0,
            lastFpsUpdate: Date.now(),
            interactionTargets: [],
            // Map of handId -> { target, offset: {x, y} } for multi-hand grab support
            activeGrabs: new Map(),
            // Map of handId -> { target, startTime } for tracking pointer press state
            activePointers: new Map()
        };

        // Dynamic reachability calibration - tracks observed hand position range
        const reachability = {
            minX: 0.5,  // Start at center, will expand as we observe positions
            maxX: 0.5,
            minY: 0.5,
            maxY: 0.5,
            padding: 0.05,  // Extra padding to prevent edge sticking
            smoothing: 0.02, // How fast bounds expand (0-1, lower = slower)
            initialized: false
        };

        // Gesture stabilization - prevents flickering between gestures
        const gestureStabilizer = {
            // Per-hand gesture history: handKey -> { current, candidate, frameCount }
            handStates: new Map(),
            requiredFrames: 4,  // Frames a new gesture must be stable before switching
            cooldownFrames: 8  // Frames to wait after a gesture change before allowing another
        };

        function stabilizeGestures(gestures, handKey, isPinching, isGrabbing) {
            let handState = gestureStabilizer.handStates.get(handKey);
            
            if (!handState) {
                handState = {
                    currentGestures: [],
                    currentPinching: false,
                    currentGrabbing: false,
                    candidateGestures: [],
                    candidatePinching: false,
                    candidateGrabbing: false,
                    stableFrames: 0,
                    cooldown: 0
                };
                gestureStabilizer.handStates.set(handKey, handState);
            }
            
            // Decrease cooldown
            if (handState.cooldown > 0) {
                handState.cooldown--;
            }
            
            // Check if the new gestures match the candidate
            const gesturesMatch = (a, b) => {
                if (a.length !== b.length) return false;
                return a.every((g, i) => g === b[i]);
            };
            
            const rawGesturesSorted = [...gestures].sort();
            const candidateSorted = [...handState.candidateGestures].sort();
            const currentSorted = [...handState.currentGestures].sort();
            
            // Check if raw input matches current stable state
            const matchesCurrent = gesturesMatch(rawGesturesSorted, currentSorted) &&
                                   isPinching === handState.currentPinching &&
                                   isGrabbing === handState.currentGrabbing;
            
            // Check if raw input matches candidate
            const matchesCandidate = gesturesMatch(rawGesturesSorted, candidateSorted) &&
                                     isPinching === handState.candidatePinching &&
                                     isGrabbing === handState.candidateGrabbing;
            
            if (matchesCurrent) {
                // Input matches current stable state - reset candidate
                handState.candidateGestures = [];
                handState.stableFrames = 0;
            } else if (matchesCandidate) {
                // Input matches candidate - increment stability counter
                handState.stableFrames++;
                
                // If stable enough and not in cooldown, switch to new gesture
                if (handState.stableFrames >= gestureStabilizer.requiredFrames && handState.cooldown === 0) {
                    handState.currentGestures = [...gestures];
                    handState.currentPinching = isPinching;
                    handState.currentGrabbing = isGrabbing;
                    handState.candidateGestures = [];
                    handState.stableFrames = 0;
                    handState.cooldown = gestureStabilizer.cooldownFrames;
                }
            } else {
                // New candidate detected
                handState.candidateGestures = [...gestures];
                handState.candidatePinching = isPinching;
                handState.candidateGrabbing = isGrabbing;
                handState.stableFrames = 1;
            }
            
            return {
                gestures: handState.currentGestures,
                isPinching: handState.currentPinching,
                isGrabbing: handState.currentGrabbing
            };
        }

        // Landmark indices for reference
        const LANDMARKS = {
            WRIST: 0,
            THUMB_CMC: 1, THUMB_MCP: 2, THUMB_IP: 3, THUMB_TIP: 4,
            INDEX_MCP: 5, INDEX_PIP: 6, INDEX_DIP: 7, INDEX_TIP: 8,
            MIDDLE_MCP: 9, MIDDLE_PIP: 10, MIDDLE_DIP: 11, MIDDLE_TIP: 12,
            RING_MCP: 13, RING_PIP: 14, RING_DIP: 15, RING_TIP: 16,
            PINKY_MCP: 17, PINKY_PIP: 18, PINKY_DIP: 19, PINKY_TIP: 20
        };

        // ============================================
        // DOM Elements
        // ============================================
        const elements = {
            video: document.getElementById('webcam'),
            canvas: document.getElementById('canvas-overlay'),
            placeholder: document.getElementById('video-placeholder'),
            startBtn: document.getElementById('start-btn'),
            loadingOverlay: document.getElementById('loading-overlay'),
            handsList: document.getElementById('hands-list'),
            interactionZone: document.getElementById('interaction-zone'),
            gestureHistory: document.getElementById('gesture-history'),
            cameraStatus: document.getElementById('camera-status'),
            modelStatus: document.getElementById('model-status'),
            trackingStatus: document.getElementById('tracking-status'),
            fpsDisplay: document.getElementById('fps-display'),
            statHands: document.getElementById('stat-hands'),
            statGestures: document.getElementById('stat-gestures'),
            statPinches: document.getElementById('stat-pinches'),
            statGrabs: document.getElementById('stat-grabs'),
            canvas3d: document.getElementById('hand-3d-canvas')
        };

        const ctx = elements.canvas.getContext('2d');
        const ctx3d = elements.canvas3d.getContext('2d');

        // ============================================
        // 3D Visualization (Simple orthographic projection)
        // ============================================
        class Hand3DVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.rotation = 0;
                this.autoRotate = true;
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            project(x, y, z, centerX, centerY, scale) {
                // Simple rotation around Y axis
                const cos = Math.cos(this.rotation);
                const sin = Math.sin(this.rotation);
                const rx = x * cos - z * sin;
                const rz = x * sin + z * cos;
                
                // Orthographic projection with depth shading
                const depth = (rz + 0.5) / 1; // Normalize depth
                return {
                    x: centerX + rx * scale,
                    y: centerY + y * scale,
                    depth: depth
                };
            }

            render(landmarks) {
                this.resize();
                const { width, height } = this.canvas;
                this.ctx.fillStyle = '#0a0a15';
                this.ctx.fillRect(0, 0, width, height);

                if (!landmarks || landmarks.length === 0) {
                    this.ctx.fillStyle = '#444';
                    this.ctx.font = '12px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('No hand data', width / 2, height / 2);
                    return;
                }

                if (this.autoRotate) {
                    this.rotation += 0.02;
                }

                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) * 0.8;

                // Center the hand
                let avgX = 0, avgY = 0, avgZ = 0;
                landmarks.forEach(lm => {
                    avgX += lm.x;
                    avgY += lm.y;
                    avgZ += lm.z;
                });
                avgX /= landmarks.length;
                avgY /= landmarks.length;
                avgZ /= landmarks.length;

                // Project all points
                const projected = landmarks.map(lm => {
                    return this.project(
                        lm.x - avgX,
                        lm.y - avgY,
                        (lm.z || 0) * 2, // Amplify Z for visibility
                        centerX,
                        centerY,
                        scale
                    );
                });

                // Draw connections
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8], // Index
                    [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                    [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [5, 9], [9, 13], [13, 17] // Palm
                ];

                connections.forEach(([i, j]) => {
                    const p1 = projected[i];
                    const p2 = projected[j];
                    const avgDepth = (p1.depth + p2.depth) / 2;
                    const alpha = 0.3 + avgDepth * 0.7;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(p1.x, p1.y);
                    this.ctx.lineTo(p2.x, p2.y);
                    this.ctx.strokeStyle = `rgba(233, 69, 96, ${alpha})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });

                // Draw landmarks
                projected.forEach((p, i) => {
                    const radius = 3 + p.depth * 3;
                    const alpha = 0.5 + p.depth * 0.5;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                    
                    // Fingertips get special color
                    if ([4, 8, 12, 16, 20].includes(i)) {
                        this.ctx.fillStyle = `rgba(78, 204, 163, ${alpha})`;
                    } else {
                        this.ctx.fillStyle = `rgba(234, 234, 234, ${alpha})`;
                    }
                    this.ctx.fill();
                });
            }
        }

        const viz3d = new Hand3DVisualizer(elements.canvas3d);

        // ============================================
        // Gesture Detection
        // ============================================
        function distance3D(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dz = (p1.z || 0) - (p2.z || 0);
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function isFingerExtended(landmarks, fingerTip, fingerPip, fingerMcp) {
            const tipY = landmarks[fingerTip].y;
            const pipY = landmarks[fingerPip].y;
            const mcpY = landmarks[fingerMcp].y;
            return tipY < pipY && pipY < mcpY;
        }

        function isThumbExtended(landmarks) {
            const tip = landmarks[LANDMARKS.THUMB_TIP];
            const ip = landmarks[LANDMARKS.THUMB_IP];
            const mcp = landmarks[LANDMARKS.THUMB_MCP];
            // For thumb, check x distance (extended = further from palm)
            return Math.abs(tip.x - mcp.x) > Math.abs(ip.x - mcp.x);
        }

        function detectGestures(landmarks, handedness) {
            const gestures = [];
            
            // Finger states
            const fingers = {
                thumb: isThumbExtended(landmarks),
                index: isFingerExtended(landmarks, LANDMARKS.INDEX_TIP, LANDMARKS.INDEX_PIP, LANDMARKS.INDEX_MCP),
                middle: isFingerExtended(landmarks, LANDMARKS.MIDDLE_TIP, LANDMARKS.MIDDLE_PIP, LANDMARKS.MIDDLE_MCP),
                ring: isFingerExtended(landmarks, LANDMARKS.RING_TIP, LANDMARKS.RING_PIP, LANDMARKS.RING_MCP),
                pinky: isFingerExtended(landmarks, LANDMARKS.PINKY_TIP, LANDMARKS.PINKY_PIP, LANDMARKS.PINKY_MCP)
            };

            const extendedCount = Object.values(fingers).filter(Boolean).length;

            // Pinch detection (thumb tip to index tip distance)
            const pinchDistance = distance3D(
                landmarks[LANDMARKS.THUMB_TIP],
                landmarks[LANDMARKS.INDEX_TIP]
            );
            const isPinching = pinchDistance < 0.06;

            // Grab detection (all fingers curled)
            const isGrabbing = extendedCount <= 1 && !fingers.index && !fingers.middle;

            // Open palm
            const isOpenPalm = extendedCount >= 4;

            // Point gesture (only index extended)
            const isPointing = fingers.index && !fingers.middle && !fingers.ring && !fingers.pinky;

            // Peace sign
            const isPeace = fingers.index && fingers.middle && !fingers.ring && !fingers.pinky;

            // Thumbs up
            const isThumbsUp = fingers.thumb && !fingers.index && !fingers.middle && !fingers.ring && !fingers.pinky;

            // Rock gesture ü§ò
            const isRock = fingers.index && fingers.pinky && !fingers.middle && !fingers.ring;

            // Build gesture list
            if (isPinching) gestures.push('pinch');
            if (isGrabbing) gestures.push('grab');
            if (isOpenPalm) gestures.push('open');
            if (isPointing) gestures.push('point');
            if (isPeace) gestures.push('peace');
            if (isThumbsUp) gestures.push('thumbs-up');
            if (isRock) gestures.push('rock');

            return {
                gestures,
                fingers,
                isPinching,
                isGrabbing,
                pinchDistance,
                extendedCount
            };
        }

        // ============================================
        // Hand Tracking & ID Management
        // ============================================
        function assignHandId(handedness, index) {
            // Create unique ID combining handedness and detection index
            // This handles multiple hands of same type (e.g., two left hands from two people)
            // Left hands: 1, 3 | Right hands: 2, 4
            const baseId = handedness === 'Left' ? 1 : 2;
            return baseId + (index * 2);
        }

        // ============================================
        // Rendering
        // ============================================
        // Store video-to-canvas mapping for object-fit: cover
        let videoMapping = { offsetX: 0, offsetY: 0, scale: 1 };

        function resizeCanvas() {
            const rect = elements.video.getBoundingClientRect();
            elements.canvas.width = rect.width;
            elements.canvas.height = rect.height;
            
            // Calculate the mapping for object-fit: cover
            // The video element's intrinsic size vs displayed size
            const video = elements.video;
            if (video.videoWidth && video.videoHeight) {
                const containerAspect = rect.width / rect.height;
                const videoAspect = video.videoWidth / video.videoHeight;
                
                if (videoAspect > containerAspect) {
                    // Video is wider - it's cropped horizontally
                    const displayedHeight = rect.height;
                    const displayedWidth = rect.height * videoAspect;
                    videoMapping.scale = displayedHeight / video.videoHeight;
                    videoMapping.offsetX = (displayedWidth - rect.width) / 2;
                    videoMapping.offsetY = 0;
                } else {
                    // Video is taller - it's cropped vertically
                    const displayedWidth = rect.width;
                    const displayedHeight = rect.width / videoAspect;
                    videoMapping.scale = displayedWidth / video.videoWidth;
                    videoMapping.offsetX = 0;
                    videoMapping.offsetY = (displayedHeight - rect.height) / 2;
                }
            }
        }

        // Convert normalized landmark coords to canvas coords (accounting for object-fit: cover)
        function landmarkToCanvas(landmark, canvasWidth, canvasHeight) {
            const video = elements.video;
            if (!video.videoWidth || !video.videoHeight) {
                return { x: landmark.x * canvasWidth, y: landmark.y * canvasHeight };
            }
            
            // Landmark is in normalized video coordinates (0-1)
            // Convert to actual video pixel coordinates
            const videoX = landmark.x * video.videoWidth;
            const videoY = landmark.y * video.videoHeight;
            
            // Apply scale and offset from object-fit: cover
            const canvasX = videoX * videoMapping.scale - videoMapping.offsetX;
            const canvasY = videoY * videoMapping.scale - videoMapping.offsetY;
            
            return { x: canvasX, y: canvasY };
        }

        function drawHand(landmarks, handedness, gestureInfo, handId) {
            const { width, height } = elements.canvas;
            
            // Color based on handedness
            const isLeft = handedness === 'Left';
            const baseColor = isLeft ? '#3498db' : '#e74c3c';
            const accentColor = isLeft ? 'rgba(52, 152, 219, 0.6)' : 'rgba(231, 76, 60, 0.6)';

            // Draw connections
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 3;
            
            const connections = HAND_CONNECTIONS;
            for (const [start, end] of connections) {
                const p1 = landmarkToCanvas(landmarks[start], width, height);
                const p2 = landmarkToCanvas(landmarks[end], width, height);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            // Draw landmarks
            landmarks.forEach((landmark, i) => {
                const { x, y } = landmarkToCanvas(landmark, width, height);
                
                ctx.beginPath();
                
                // Fingertips larger
                const isTip = [4, 8, 12, 16, 20].includes(i);
                const radius = isTip ? 8 : 5;
                
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                
                if (isTip) {
                    ctx.fillStyle = gestureInfo.isPinching && i === 8 ? '#2ecc71' : baseColor;
                } else {
                    ctx.fillStyle = '#fff';
                }
                ctx.fill();
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw pinch indicator
            if (gestureInfo.isPinching) {
                const thumbPos = landmarkToCanvas(landmarks[LANDMARKS.THUMB_TIP], width, height);
                const indexPos = landmarkToCanvas(landmarks[LANDMARKS.INDEX_TIP], width, height);
                const midX = (thumbPos.x + indexPos.x) / 2;
                const midY = (thumbPos.y + indexPos.y) / 2;
                
                ctx.beginPath();
                ctx.arc(midX, midY, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(46, 204, 113, 0.5)';
                ctx.fill();
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw hand ID label
            const wristPos = landmarkToCanvas(landmarks[LANDMARKS.WRIST], width, height);
            ctx.font = 'bold 14px sans-serif';
            ctx.fillStyle = baseColor;
            ctx.fillText(`${handedness} #${handId}`, wristPos.x - 20, wristPos.y + 25);
        }

        // ============================================
        // UI Updates
        // ============================================
        function updateHandsUI(hands) {
            if (hands.length === 0) {
                elements.handsList.innerHTML = '<div class="no-hands">No hands detected</div>';
                return;
            }

            elements.handsList.innerHTML = hands.map(hand => `
                <div class="hand-card ${hand.handedness.toLowerCase()}">
                    <div class="hand-header">
                        <span class="hand-label">${hand.handedness} Hand #${hand.id}</span>
                        <span class="hand-confidence">${Math.round(hand.score * 100)}%</span>
                    </div>
                    <div class="finger-state-label">Finger State</div>
                    <div class="finger-display">
                        <div class="finger thumb ${hand.gestureInfo.fingers.thumb ? 'extended' : ''}"></div>
                        <div class="finger ${hand.gestureInfo.fingers.index ? 'extended' : ''}"></div>
                        <div class="finger ${hand.gestureInfo.fingers.middle ? 'extended' : ''}"></div>
                        <div class="finger ${hand.gestureInfo.fingers.ring ? 'extended' : ''}"></div>
                        <div class="finger ${hand.gestureInfo.fingers.pinky ? 'extended' : ''}"></div>
                    </div>
                    ${hand.gestureInfo.gestures.length > 0 ? 
                        hand.gestureInfo.gestures.map(g => `<span class="gesture-badge">${g}</span>`).join(' ') : 
                        '<span class="gesture-badge" style="background: var(--accent)">neutral</span>'
                    }
                </div>
            `).join('');
        }

        function logGesture(gesture, hand) {
            const entry = {
                gesture,
                hand: hand.handedness,
                time: new Date().toLocaleTimeString()
            };
            
            state.stats.gestures++;
            state.gestureLog.unshift(entry);
            if (state.gestureLog.length > 10) state.gestureLog.pop();
            
            elements.gestureHistory.innerHTML = state.gestureLog.map(e => `
                <div class="gesture-entry">
                    <span>${e.gesture} (${e.hand})</span>
                    <span style="color: var(--text-dim)">${e.time}</span>
                </div>
            `).join('');
        }

        function updateStats() {
            elements.statHands.textContent = state.hands.length;
            elements.statGestures.textContent = state.stats.gestures;
            elements.statPinches.textContent = state.stats.pinches;
            elements.statGrabs.textContent = state.stats.grabs;
        }

        function updateFps() {
            state.frameCount++;
            const now = Date.now();
            if (now - state.lastFpsUpdate >= 1000) {
                state.fps = state.frameCount;
                state.frameCount = 0;
                state.lastFpsUpdate = now;
                elements.fpsDisplay.textContent = `${state.fps} FPS`;
            }
        }

        // ============================================
        // Interaction Zone
        // ============================================
        function setupInteractionTargets() {
            const targets = elements.interactionZone.querySelectorAll('.interaction-target');
            targets.forEach(target => {
                state.interactionTargets.push({
                    element: target,
                    x: target.offsetLeft + 25,
                    y: target.offsetTop + 25,
                    grabbed: false
                });
            });
        }

        function updateInteractions(hands) {
            const zone = elements.interactionZone.getBoundingClientRect();
            
            // Remove old cursors
            elements.interactionZone.querySelectorAll('.cursor-point').forEach(c => c.remove());
            
            // Track which targets are hovered by ANY hand this frame
            const hoveredTargets = new Set();
            // Track which hands we see this frame (to detect disappeared hands)
            const seenHandIds = new Set();
            
            hands.forEach(hand => {
                // Calculate palm center (always used for reachability calibration and base position)
                const wrist = hand.landmarks[LANDMARKS.WRIST];
                const indexMcp = hand.landmarks[LANDMARKS.INDEX_MCP];
                const middleMcp = hand.landmarks[LANDMARKS.MIDDLE_MCP];
                const ringMcp = hand.landmarks[LANDMARKS.RING_MCP];
                const pinkyMcp = hand.landmarks[LANDMARKS.PINKY_MCP];
                
                const palmX = (wrist.x + indexMcp.x + middleMcp.x + ringMcp.x + pinkyMcp.x) / 5;
                const palmY = (wrist.y + indexMcp.y + middleMcp.y + ringMcp.y + pinkyMcp.y) / 5;
                
                // Determine if pointing gesture
                const isPointing = hand.gestureInfo.gestures.includes('point');
                
                // Always use palm center for cursor position (stable and consistent)
                const rawX = palmX;
                const rawY = palmY;
                
                // Update dynamic reachability bounds based on PALM position (always stable)
                if (!reachability.initialized) {
                    // First observation - initialize around current position
                    reachability.minX = rawX - 0.1;
                    reachability.maxX = rawX + 0.1;
                    reachability.minY = rawY - 0.1;
                    reachability.maxY = rawY + 0.1;
                    reachability.initialized = true;
                } else {
                    // Expand bounds based on PALM position (stable reference point)
                    // Use smoothing to gradually expand (prevents jumpy behavior)
                    if (palmX < reachability.minX) {
                        reachability.minX += (palmX - reachability.minX) * reachability.smoothing;
                    }
                    if (palmX > reachability.maxX) {
                        reachability.maxX += (palmX - reachability.maxX) * reachability.smoothing;
                    }
                    if (palmY < reachability.minY) {
                        reachability.minY += (palmY - reachability.minY) * reachability.smoothing;
                    }
                    if (palmY > reachability.maxY) {
                        reachability.maxY += (palmY - reachability.maxY) * reachability.smoothing;
                    }
                }
                
                // Calculate the effective range with padding
                const rangeX = Math.max(0.1, reachability.maxX - reachability.minX);
                const rangeY = Math.max(0.1, reachability.maxY - reachability.minY);
                
                // Normalize position within observed range (0 to 1)
                // Flip X because video is mirrored
                const normalizedX = 1 - ((rawX - reachability.minX) / rangeX);
                const normalizedY = (rawY - reachability.minY) / rangeY;
                
                // Add padding so cursor doesn't stick to edges
                const paddedX = reachability.padding + normalizedX * (1 - 2 * reachability.padding);
                const paddedY = reachability.padding + normalizedY * (1 - 2 * reachability.padding);
                
                // Clamp to reasonable range
                const clampedX = Math.max(0, Math.min(1, paddedX));
                const clampedY = Math.max(0, Math.min(1, paddedY));
                
                // Map to interaction zone dimensions
                const handX = clampedX * zone.width;
                const handY = clampedY * zone.height;
                
                // Determine if hand is in "grab mode" (pinch OR grab gesture)
                const isGrabbing = hand.gestureInfo.isPinching || hand.gestureInfo.isGrabbing;
                
                // Create cursor - different styles for pointing vs palm-based tracking
                const cursor = document.createElement('div');
                let cursorClass = 'cursor-point';
                if (isGrabbing) {
                    cursorClass += ' pinch';
                } else if (isPointing) {
                    cursorClass += ' pointing';
                } else {
                    cursorClass += ' palm';
                }
                cursor.className = cursorClass;
                cursor.style.left = `${handX}px`;
                cursor.style.top = `${handY}px`;
                elements.interactionZone.appendChild(cursor);
                
                // Check target interactions
                state.interactionTargets.forEach(target => {
                    // Always update target position from actual element position
                    // This ensures we're checking against current position, not stale data
                    target.x = target.element.offsetLeft + 25;
                    target.y = target.element.offsetTop + 25;
                    
                    const dist = Math.sqrt(
                        Math.pow(handX - target.x, 2) + 
                        Math.pow(handY - target.y, 2)
                    );
                    
                    if (dist < 40) {
                        // Mark as hovered - we'll apply classes after processing all hands
                        hoveredTargets.add(target);
                        
                        // Pointer press detection (like mousedown/mouseup)
                        if (isPointing) {
                            const pointerInfo = state.activePointers.get(hand.id);
                            
                            if (!pointerInfo) {
                                // Pointer down - start press on this target
                                state.activePointers.set(hand.id, {
                                    target: target,
                                    startTime: Date.now()
                                });
                                target.element.classList.add('pressed');
                                logGesture('pointerdown', { handedness: hand.handedness, target: target.element.id });
                            }
                            // If already pressing, the release logic is handled below
                        }
                        
                        // Only grab if: we're grabbing, this target isn't already grabbed by another hand,
                        // AND this hand isn't already holding something
                        const alreadyGrabbedByOther = Array.from(state.activeGrabs.values()).some(g => g.target === target);
                        const thisHandAlreadyGrabbing = state.activeGrabs.has(hand.id);
                        
                        if (isGrabbing && !alreadyGrabbedByOther && !thisHandAlreadyGrabbing) {
                            target.element.classList.add('grabbed');
                            target.grabbed = true;
                            // Store grab info for this hand
                            state.activeGrabs.set(hand.id, {
                                target: target,
                                offset: {
                                    x: target.x - handX,
                                    y: target.y - handY
                                }
                            });
                        }
                    }
                });
                
                // Handle pointer release (pointerup / click detection)
                const pointerInfo = state.activePointers.get(hand.id);
                if (pointerInfo) {
                    // Check if we stopped pointing OR moved away from the pressed target
                    const stillOverTarget = hoveredTargets.has(pointerInfo.target);
                    
                    if (!isPointing) {
                        // Stopped pointing - this is pointer up
                        pointerInfo.target.element.classList.remove('pressed');
                        logGesture('pointerup', { handedness: hand.handedness, target: pointerInfo.target.element.id });
                        
                        // If still over the same target, it's a click!
                        if (stillOverTarget) {
                            pointerInfo.target.element.classList.remove('clicked');
                            void pointerInfo.target.element.offsetWidth; // Force reflow
                            pointerInfo.target.element.classList.add('clicked');
                            logGesture('click', { 
                                handedness: hand.handedness, 
                                target: pointerInfo.target.element.id,
                                duration: Date.now() - pointerInfo.startTime
                            });
                            setTimeout(() => {
                                pointerInfo.target.element.classList.remove('clicked');
                            }, 300);
                        }
                        
                        state.activePointers.delete(hand.id);
                    } else if (!stillOverTarget) {
                        // Moved away while still pointing - cancel the press
                        pointerInfo.target.element.classList.remove('pressed');
                        logGesture('pointercancel', { handedness: hand.handedness, target: pointerInfo.target.element.id });
                        state.activePointers.delete(hand.id);
                    }
                }
                
                // Move grabbed target with hand (if this hand is holding something)
                const grabInfo = state.activeGrabs.get(hand.id);
                if (grabInfo) {
                    if (isGrabbing) {
                        // Apply grab offset to maintain relative position from grab start
                        const targetX = handX + grabInfo.offset.x;
                        const targetY = handY + grabInfo.offset.y;
                        const newX = Math.max(0, Math.min(zone.width - 50, targetX - 25));
                        const newY = Math.max(0, Math.min(zone.height - 50, targetY - 25));
                        grabInfo.target.element.style.left = `${newX}px`;
                        grabInfo.target.element.style.top = `${newY}px`;
                        grabInfo.target.x = newX + 25;
                        grabInfo.target.y = newY + 25;
                    } else {
                        // Hand released - drop the object
                        grabInfo.target.element.classList.remove('grabbed');
                        grabInfo.target.grabbed = false;
                        state.activeGrabs.delete(hand.id);
                    }
                }
                
                // Track which hands we've seen this frame
                seenHandIds.add(hand.id);
            });
            
            // Apply hover states after processing all hands
            // This prevents flickering when multiple hands are detected
            state.interactionTargets.forEach(target => {
                const isGrabbed = Array.from(state.activeGrabs.values()).some(g => g.target === target);
                if (hoveredTargets.has(target) || isGrabbed) {
                    target.element.classList.add('hovered');
                } else {
                    target.element.classList.remove('hovered');
                }
            });
            
            // Release objects held by hands that disappeared
            for (const [handId, grabInfo] of state.activeGrabs.entries()) {
                if (!seenHandIds.has(handId)) {
                    grabInfo.target.element.classList.remove('grabbed');
                    grabInfo.target.grabbed = false;
                    state.activeGrabs.delete(handId);
                }
            }
            
            // Cancel pointers for hands that disappeared
            for (const [handId, pointerInfo] of state.activePointers.entries()) {
                if (!seenHandIds.has(handId)) {
                    pointerInfo.target.element.classList.remove('pressed');
                    logGesture('pointercancel', { handedness: 'unknown', target: pointerInfo.target.element.id, reason: 'hand-lost' });
                    state.activePointers.delete(handId);
                }
            }
            
            // Clear all states if no hands at all
            if (hands.length === 0) {
                state.interactionTargets.forEach(target => {
                    target.element.classList.remove('hovered', 'grabbed', 'pressed');
                    target.grabbed = false;
                });
                state.activeGrabs.clear();
                state.activePointers.clear();
            }
        }

        // ============================================
        // MediaPipe Setup
        // ============================================
        let hands;
        let camera;

        function onResults(results) {
            updateFps();
            resizeCanvas();
            
            ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            
            const processedHands = [];
            
            if (results.multiHandLandmarks && results.multiHandedness) {
                // Track how many of each hand type we've seen for unique IDs
                const handCounts = { Left: 0, Right: 0 };
                
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    // Flip handedness because video is mirrored - MediaPipe detects based on
                    // the original image, but user sees mirrored view
                    const rawHandedness = results.multiHandedness[i].label;
                    const handedness = rawHandedness === 'Left' ? 'Right' : 'Left';
                    const score = results.multiHandedness[i].score;
                    
                    // Get unique index for this hand type
                    const typeIndex = handCounts[handedness]++;
                    const handId = assignHandId(handedness, typeIndex);
                    const rawGestureInfo = detectGestures(landmarks, handedness);
                    
                    // Apply gesture stabilization to prevent flickering
                    // Use handId as key to keep each hand's stabilization separate
                    const handKey = `hand-${handId}`;
                    const stabilized = stabilizeGestures(
                        rawGestureInfo.gestures,
                        handKey,
                        rawGestureInfo.isPinching,
                        rawGestureInfo.isGrabbing
                    );
                    
                    // Create stabilized gesture info
                    const gestureInfo = {
                        ...rawGestureInfo,
                        gestures: stabilized.gestures,
                        isPinching: stabilized.isPinching,
                        isGrabbing: stabilized.isGrabbing
                    };
                    
                    // Track gesture stats (using stabilized values)
                    const prevHand = state.hands.find(h => h.id === handId);
                    if (gestureInfo.isPinching && (!prevHand || !prevHand.gestureInfo.isPinching)) {
                        state.stats.pinches++;
                        logGesture('pinch', { handedness });
                    }
                    if (gestureInfo.isGrabbing && (!prevHand || !prevHand.gestureInfo.isPinching && !prevHand.gestureInfo.isGrabbing)) {
                        state.stats.grabs++;
                        logGesture('grab', { handedness });
                    }
                    
                    processedHands.push({
                        id: handId,
                        handedness,
                        score,
                        landmarks,
                        gestureInfo
                    });
                    
                    drawHand(landmarks, handedness, gestureInfo, handId);
                }
            }
            
            state.hands = processedHands;
            elements.trackingStatus.classList.toggle('active', processedHands.length > 0);
            
            updateHandsUI(processedHands);
            updateStats();
            updateInteractions(processedHands);
            
            // Update 3D visualization with first hand
            if (processedHands.length > 0) {
                viz3d.render(processedHands[0].landmarks);
            } else {
                viz3d.render(null);
            }
        }

        async function initHandTracking() {
            elements.loadingOverlay.classList.remove('hidden');
            elements.modelStatus.classList.add('warning');
            
            try {
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 4,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);
                
                elements.modelStatus.classList.remove('warning');
                elements.modelStatus.classList.add('active');
                
                return true;
            } catch (error) {
                console.error('Failed to load hand tracking model:', error);
                elements.modelStatus.classList.remove('warning');
                return false;
            }
        }

        async function startCamera() {
            elements.startBtn.disabled = true;
            elements.startBtn.textContent = 'Starting...';
            
            const modelLoaded = await initHandTracking();
            if (!modelLoaded) {
                alert('Failed to load hand tracking model. Please refresh and try again.');
                elements.startBtn.disabled = false;
                elements.startBtn.textContent = 'Start Camera';
                return;
            }

            try {
                camera = new Camera(elements.video, {
                    onFrame: async () => {
                        await hands.send({ image: elements.video });
                    },
                    width: 1280,
                    height: 720
                });
                
                // Recalculate mapping when video metadata is available
                elements.video.addEventListener('loadedmetadata', () => {
                    resizeCanvas();
                });
                
                await camera.start();
                
                // Initial resize after camera starts
                resizeCanvas();
                
                elements.placeholder.style.display = 'none';
                elements.cameraStatus.classList.add('active');
                elements.loadingOverlay.classList.add('hidden');
                state.isRunning = true;
                
                setupInteractionTargets();
                
            } catch (error) {
                console.error('Camera access failed:', error);
                alert('Could not access camera. Please ensure you have granted camera permissions.');
                elements.startBtn.disabled = false;
                elements.startBtn.textContent = 'Start Camera';
                elements.loadingOverlay.classList.add('hidden');
            }
        }

        // ============================================
        // Event Listeners
        // ============================================
        elements.startBtn.addEventListener('click', startCamera);
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            viz3d.resize();
            // Recalculate interaction target positions
            state.interactionTargets.forEach(target => {
                target.x = target.element.offsetLeft + 25;
                target.y = target.element.offsetTop + 25;
            });
        });

        // Initial setup
        elements.loadingOverlay.classList.add('hidden');
        viz3d.resize();
        viz3d.render(null);
    </script>

    <script src="parental.js" defer></script>
    <script src="assets/js/pwa.js" defer></script>
</body>
</html>
