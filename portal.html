<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#87CEEB">
  <meta name="application-name" content="IdleGames">
  <script src="assets/js/pwa.js" defer></script>
  <title>Portal World</title>
  <style>
    :root {
      color-scheme: dark light;
      --bg: #87CEEB;
      --text: #1e293b;
      --panel-bg: rgba(255, 255, 255, 0.85);
      --panel-border: rgba(0, 0, 0, 0.1);
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      background: var(--bg);
      color: var(--text);
    }

    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #viewport {
      width: 100%;
      height: 100%;
      display: block;
    }

    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 12px 16px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      font-size: 13px;
      line-height: 1.6;
      z-index: 10;
      pointer-events: none;
      max-width: 280px;
    }

    #hud h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
      font-weight: 600;
    }

    #hud kbd {
      display: inline-block;
      padding: 2px 6px;
      background: rgba(0, 0, 0, 0.08);
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      border: 2px solid rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
      mix-blend-mode: difference;
    }

    #loadingOverlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #87CEEB 0%, #98D8C8 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.5s ease-out;
    }

    #loadingOverlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #loadingOverlay h1 {
      font-size: 32px;
      margin: 0 0 20px 0;
      color: #2d5a4a;
    }

    #loadingOverlay p {
      font-size: 16px;
      color: #3d6a5a;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(45, 90, 74, 0.2);
      border-top-color: #2d5a4a;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #clickToStart {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      cursor: pointer;
    }

    #clickToStart.hidden {
      display: none;
    }

    #clickToStart span {
      background: white;
      padding: 20px 40px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 600;
      color: #2d5a4a;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="viewport"></canvas>
    <div id="crosshair"></div>
    <div id="hud">
      <h3>ğŸŒ€ Portal World</h3>
      <div><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move</div>
      <div><kbd>Double-tap</kbd> Sprint</div>
      <div><kbd>Space</kbd> Jump</div>
      <div><kbd>Mouse</kbd> Look around</div>
      <div style="margin-top: 8px; opacity: 0.7; font-size: 12px;">
        Walk through portals to reach higher levels!
      </div>
    </div>
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <h1>Portal World</h1>
      <p>Loading assets...</p>
    </div>
    <div id="clickToStart">
      <span>Click to Play</span>
    </div>
  </div>

  <script type="module">
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THREE.JS IMPORT WITH FALLBACK
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CDN_THREE_BASE = 'https://cdn.jsdelivr.net/npm/three@0.160.0';

    async function importWithFallback(primary, fallback) {
      try {
        return await import(primary);
      } catch (error) {
        console.warn(`Failed to load ${primary}; attempting CDN fallback.`, error);
        if (!fallback) throw error;
        try {
          return await import(fallback);
        } catch (fallbackError) {
          console.error(`Fallback import for ${primary} also failed.`, fallbackError);
          throw fallbackError;
        }
      }
    }

    const THREE = await importWithFallback(
      './assets/vendor/three/three.module.js',
      `${CDN_THREE_BASE}/build/three.module.js`
    );

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CFFR COORDINATE SYSTEM CONSTANTS
    // Frame of Reference: +X = East, +Y = North, +Z = Up (like Second Life)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CFFR = {
      EAST: new THREE.Vector3(1, 0, 0),   // +X
      NORTH: new THREE.Vector3(0, 1, 0),  // +Y
      UP: new THREE.Vector3(0, 0, 1),     // +Z
      WEST: new THREE.Vector3(-1, 0, 0),
      SOUTH: new THREE.Vector3(0, -1, 0),
      DOWN: new THREE.Vector3(0, 0, -1),
    };

    // World dimensions in meters
    const WORLD = {
      SIZE_X: 100,  // East-West extent
      SIZE_Y: 100,  // North-South extent  
      SIZE_Z: 100,  // Vertical extent (Up-Down)
      CENTER: new THREE.Vector3(50, 50, 0),
    };

    // Player measurements (5'9" = 1.7526m)
    const PLAYER = {
      HEIGHT: 1.7526,
      EYE_HEIGHT: 1.62,           // Eyes slightly below top of head
      RADIUS: 0.3,               // Collision radius
      WALK_SPEED: 1.4,           // m/s (average walking speed)
      SPRINT_SPEED: 5.5,         // m/s (jogging speed)
      JUMP_VELOCITY: 5.0,        // m/s initial upward velocity
      GRAVITY: 9.81,             // m/sÂ²
      SHOULDER_OFFSET: 0.35,     // Camera offset to the right
      CAMERA_BACK: 2.5,          // Camera distance behind player
      CAMERA_UP: 0.3,            // Camera height above eye level
    };

    // Terrain level heights
    const TERRAIN_LEVELS = [
      { z: 0, name: 'Ground Level' },
      { z: 8, name: 'First Plateau' },
      { z: 18, name: 'Second Plateau' },
      { z: 30, name: 'Summit' },
    ];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITY FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Convert CFFR coordinates to Three.js coordinates
    // Three.js uses: +X right, +Y up, +Z toward camera
    // CFFR uses: +X East, +Y North, +Z Up
    // Mapping: CFFR.X -> Three.X, CFFR.Y -> Three.Z (negated), CFFR.Z -> Three.Y
    function cffrToThree(x, y, z) {
      return new THREE.Vector3(x, z, -y);
    }

    function cffrVecToThree(vec) {
      return new THREE.Vector3(vec.x, vec.z, -vec.y);
    }

    function threeVecToCffr(vec) {
      return new THREE.Vector3(vec.x, -vec.z, vec.y);
    }

    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCENE SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const canvas = document.getElementById('viewport');
    const scene = new THREE.Scene();
    
    // Sky color
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 50, 150);

    // Camera (will be positioned by player controller)
    const camera = new THREE.PerspectiveCamera(
      70,
      window.innerWidth / window.innerHeight,
      0.1,
      500
    );

    // Renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      powerPreference: 'high-performance'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LIGHTING (Sunlit Daytime)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const ambientLight = new THREE.AmbientLight(0x9DC8E8, 0.5);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xFFFAE6, 1.8);
    sunLight.position.copy(cffrToThree(80, 60, 100));
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 1;
    sunLight.shadow.camera.far = 200;
    sunLight.shadow.camera.left = -80;
    sunLight.shadow.camera.right = 80;
    sunLight.shadow.camera.top = 80;
    sunLight.shadow.camera.bottom = -80;
    sunLight.shadow.bias = -0.0005;
    scene.add(sunLight);
    scene.add(sunLight.target);
    sunLight.target.position.copy(cffrToThree(50, 50, 0));

    // Hemisphere light for natural sky/ground color blending
    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x556B2F, 0.4);
    scene.add(hemiLight);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MATERIALS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const materials = {
      grass: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
      grassDark: new THREE.MeshLambertMaterial({ color: 0x388E3C }),
      cliff: new THREE.MeshLambertMaterial({ color: 0x8B7355 }),
      cliffDark: new THREE.MeshLambertMaterial({ color: 0x6B5344 }),
      rock: new THREE.MeshLambertMaterial({ color: 0x808080 }),
      rockDark: new THREE.MeshLambertMaterial({ color: 0x606060 }),
      stone: new THREE.MeshLambertMaterial({ color: 0x9E9E9E }),
      stoneDark: new THREE.MeshLambertMaterial({ color: 0x757575 }),
      portalFrame: new THREE.MeshLambertMaterial({ color: 0x5D4E37 }),
      portalGlow: new THREE.MeshBasicMaterial({ 
        color: 0x00FFFF, 
        transparent: true, 
        opacity: 0.6,
        side: THREE.DoubleSide
      }),
      portalPlaceholder: new THREE.MeshBasicMaterial({
        color: 0x4488FF,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      }),
      player: new THREE.MeshLambertMaterial({ color: 0xE07B39 }),
      playerShirt: new THREE.MeshLambertMaterial({ color: 0x3498DB }),
      playerPants: new THREE.MeshLambertMaterial({ color: 0x2C3E50 }),
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PORTAL DEFINITIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Portal definitions: [fromLevel, toLevel, fromPos, fromRot, toPos, toRot]
    const PORTAL_DEFS = [
      // Ground to First Plateau
      // Ground portals positioned away from cliff bases, reachable from player start (50, 45)
      { from: { level: 0, x: 50, y: 15, rot: 0 },
        to: { level: 1, x: 30, y: 30, rot: Math.PI } },
      
      // Ground to First Plateau (alternate) - near the other plateau
      { from: { level: 0, x: 75, y: 85, rot: -Math.PI * 0.5 },
        to: { level: 1, x: 70, y: 65, rot: Math.PI * 0.5 } },
      
      // First Plateau to Second (from first plateau shape 0 to second plateau shape 0)
      { from: { level: 1, x: 38, y: 38, rot: Math.PI * 0.25 },
        to: { level: 2, x: 55, y: 40, rot: -Math.PI * 0.75 } },
      
      // First Plateau to Second (alternate - from first plateau shape 1 to second plateau shape 1)
      { from: { level: 1, x: 62, y: 58, rot: -Math.PI * 0.75 },
        to: { level: 2, x: 35, y: 65, rot: Math.PI * 0.25 } },
      
      // Second to Summit (from second plateau shape 0 to summit)
      { from: { level: 2, x: 50, y: 35, rot: Math.PI * 0.5 },
        to: { level: 3, x: 50, y: 52, rot: -Math.PI * 0.5 } },
    ];

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TERRAIN GENERATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const terrainGroup = new THREE.Group();
    scene.add(terrainGroup);

    // Ground collision data (for physics)
    const groundSegments = [];
    
    // Cliff collision data - stores ellipse boundaries for each level
    const cliffColliders = [];

    function createTerrainLevel(levelIndex) {
      const level = TERRAIN_LEVELS[levelIndex];
      const nextLevel = TERRAIN_LEVELS[levelIndex + 1];
      const group = new THREE.Group();
      
      // Define platform shapes for each level
      let platformShapes = [];
      
      if (levelIndex === 0) {
        // Ground level - large base
        platformShapes = [
          { cx: 50, cy: 50, rx: 45, ry: 45, type: 'ellipse' }
        ];
      } else if (levelIndex === 1) {
        // First plateau - medium platforms
        platformShapes = [
          { cx: 30, cy: 30, rx: 18, ry: 15, type: 'ellipse' },
          { cx: 70, cy: 65, rx: 20, ry: 18, type: 'ellipse' },
        ];
      } else if (levelIndex === 2) {
        // Second plateau - smaller platforms
        platformShapes = [
          { cx: 55, cy: 40, rx: 14, ry: 12, type: 'ellipse' },
          { cx: 35, cy: 70, rx: 12, ry: 10, type: 'ellipse' },
        ];
      } else if (levelIndex === 3) {
        // Summit - small platform
        platformShapes = [
          { cx: 50, cy: 55, rx: 10, ry: 8, type: 'ellipse' },
        ];
      }

      platformShapes.forEach((shape, shapeIndex) => {
        const segments = 16 + levelIndex * 4;
        const noiseValues = [];
        for (let i = 0; i < segments; i++) {
          noiseValues.push(0.9 + Math.random() * 0.2);
        }

        // Create grass top surface (low-poly)
        const topGeo = createLowPolyEllipse(shape.rx, shape.ry, segments, noiseValues);
        const topMesh = new THREE.Mesh(topGeo, levelIndex % 2 === 0 ? materials.grass : materials.grassDark);
        topMesh.position.copy(cffrToThree(shape.cx, shape.cy, level.z));
        topMesh.rotation.x = -Math.PI / 2;
        topMesh.receiveShadow = true;
        topMesh.castShadow = false;
        group.add(topMesh);

        // Store ground segment for collision
        groundSegments.push({
          type: 'ellipse',
          cx: shape.cx,
          cy: shape.cy,
          rx: shape.rx,
          ry: shape.ry,
          z: level.z,
          levelIndex
        });

        // Store cliff collider for horizontal collision detection
        if (levelIndex > 0) {
          cliffColliders.push({
            cx: shape.cx,
            cy: shape.cy,
            rx: shape.rx + 0.5,  // Slightly larger for collision
            ry: shape.ry + 0.5,
            baseZ: 0,
            topZ: level.z,
            levelIndex
          });
        }

        // Create cliff sides extending all the way to ground level
        const cliffHeight = levelIndex === 0 ? 3 : level.z;
        createCliffSides(group, shape, level.z, cliffHeight, levelIndex, segments, noiseValues);

        // Add grass edge overhang
        createGrassOverhang(group, shape, level.z, levelIndex, segments, noiseValues);

        // Add decorative rocks
        addRocks(group, shape, level.z, levelIndex);
      });

      return group;
    }

    function createLowPolyEllipse(rx, ry, segments, noiseValues) {
      const shape = new THREE.Shape();
      
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        // Use modulo to wrap around noise values for the last vertex
        const noise = noiseValues[i % segments];
        const x = Math.cos(angle) * rx * noise;
        const y = Math.sin(angle) * ry * noise;
        if (i === 0) shape.moveTo(x, y);
        else shape.lineTo(x, y);
      }
      return new THREE.ShapeGeometry(shape);
    }

    function createCliffSides(group, shape, topZ, height, levelIndex, segments, noiseValues) {
      const positions = [];
      const indices = [];
      
      // Pre-calculate bottom outsets
      const bottomOutsets = [];
      
      for (let i = 0; i < segments; i++) {
        bottomOutsets.push(0.5 + Math.random() * 0.5);
      }
      
      // Generate cliff vertices
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        const idx = i % segments;
        const noise = noiseValues[idx];
        const bottomOutset = bottomOutsets[idx];
        
        // Top edge (slightly inward for overhang effect)
        const topInset = 0.3;
        const topX = shape.cx + Math.cos(angle) * (shape.rx - topInset) * noise;
        const topY = shape.cy + Math.sin(angle) * (shape.ry - topInset) * noise;
        const topPos = cffrToThree(topX, topY, topZ);
        positions.push(topPos.x, topPos.y, topPos.z);
        
        // Bottom edge (outward for rugged cliff)
        const bottomX = shape.cx + Math.cos(angle) * (shape.rx + bottomOutset);
        const bottomY = shape.cy + Math.sin(angle) * (shape.ry + bottomOutset);
        const bottomPos = cffrToThree(bottomX, bottomY, topZ - height);
        positions.push(bottomPos.x, bottomPos.y, bottomPos.z);
      }

      // Create faces
      for (let i = 0; i < segments; i++) {
        const topLeft = i * 2;
        const bottomLeft = i * 2 + 1;
        const topRight = (i + 1) * 2;
        const bottomRight = (i + 1) * 2 + 1;
        
        indices.push(topLeft, bottomLeft, topRight);
        indices.push(bottomLeft, bottomRight, topRight);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      const cliffMesh = new THREE.Mesh(
        geometry, 
        levelIndex % 2 === 0 ? materials.cliff : materials.cliffDark
      );
      cliffMesh.castShadow = true;
      cliffMesh.receiveShadow = true;
      group.add(cliffMesh);
    }

    function createGrassOverhang(group, shape, topZ, levelIndex, segments, noiseValues) {
      const overhangWidth = 0.8;
      const overhangDrop = 0.15;
      
      for (let i = 0; i < segments; i++) {
        const angle1 = (i / segments) * Math.PI * 2;
        const angle2 = ((i + 1) / segments) * Math.PI * 2;
        
        // Random grass tufts along edge
        if (Math.random() > 0.3) {
          const midAngle = (angle1 + angle2) / 2;
          
          // Interpolate noise
          const n1 = noiseValues[i];
          const n2 = noiseValues[(i + 1) % segments];
          const noise = (n1 + n2) / 2;
          
          const edgeX = shape.cx + Math.cos(midAngle) * shape.rx * noise;
          const edgeY = shape.cy + Math.sin(midAngle) * shape.ry * noise;
          
          // Create grass tuft geometry
          const tuftGeo = new THREE.ConeGeometry(0.3 + Math.random() * 0.3, 0.5 + Math.random() * 0.3, 4);
          const tuft = new THREE.Mesh(tuftGeo, materials.grass);
          const pos = cffrToThree(edgeX, edgeY, topZ - 0.1);
          tuft.position.copy(pos);
          tuft.rotation.x = Math.PI; // Point down
          tuft.rotation.z = Math.random() * 0.3 - 0.15;
          tuft.castShadow = true;
          group.add(tuft);
        }
      }
    }

    function addRocks(group, shape, topZ, levelIndex) {
      const rockCount = 5 + Math.floor(Math.random() * 8);
      
      for (let i = 0; i < rockCount; i++) {
        // Position rock randomly within platform
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 0.7; // Keep within 70% of edge
        const x = shape.cx + Math.cos(angle) * shape.rx * dist;
        const y = shape.cy + Math.sin(angle) * shape.ry * dist;
        
        // Check distance to any portal on this level
        let tooClose = false;
        for (const def of PORTAL_DEFS) {
          // Check 'from' portal
          if (def.from.level === levelIndex) {
            const dx = x - def.from.x;
            const dy = y - def.from.y;
            if (dx*dx + dy*dy < 16) { // 4m radius
              tooClose = true;
              break;
            }
          }
          // Check 'to' portal
          if (def.to.level === levelIndex) {
            const dx = x - def.to.x;
            const dy = y - def.to.y;
            if (dx*dx + dy*dy < 16) { // 4m radius
              tooClose = true;
              break;
            }
          }
        }
        
        if (tooClose) continue;
        
        // Random rock size
        const size = 0.3 + Math.random() * 0.8;
        
        // Create low-poly rock (irregular icosahedron)
        const rockGeo = new THREE.IcosahedronGeometry(size, 0);
        // Distort vertices for more natural look
        distortGeometry(rockGeo, size * 0.3);
        
        const rock = new THREE.Mesh(
          rockGeo, 
          Math.random() > 0.5 ? materials.rock : materials.rockDark
        );
        const pos = cffrToThree(x, y, topZ + size * 0.3);
        rock.position.copy(pos);
        rock.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        rock.castShadow = true;
        rock.receiveShadow = true;
        group.add(rock);
      }
    }

    // Create all terrain levels
    TERRAIN_LEVELS.forEach((level, index) => {
      const levelGroup = createTerrainLevel(index);
      terrainGroup.add(levelGroup);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PORTAL SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const portals = [];
    const portalRenderTargets = new Map();

    // Helper to distort geometry while keeping it watertight
    function distortGeometry(geometry, amount) {
      const posAttribute = geometry.getAttribute('position');
      const vertexMap = new Map();
      const precision = 1000; // Round to 3 decimal places for matching

      // 1. Identify unique vertices and generate offsets
      for (let i = 0; i < posAttribute.count; i++) {
        const x = posAttribute.getX(i);
        const y = posAttribute.getY(i);
        const z = posAttribute.getZ(i);
        
        // Create a key based on position
        const key = `${Math.round(x * precision)},${Math.round(y * precision)},${Math.round(z * precision)}`;
        
        if (!vertexMap.has(key)) {
          vertexMap.set(key, {
            x: (Math.random() - 0.5) * amount,
            y: (Math.random() - 0.5) * amount,
            z: (Math.random() - 0.5) * amount
          });
        }
      }

      // 2. Apply offsets
      for (let i = 0; i < posAttribute.count; i++) {
        const x = posAttribute.getX(i);
        const y = posAttribute.getY(i);
        const z = posAttribute.getZ(i);
        const key = `${Math.round(x * precision)},${Math.round(y * precision)},${Math.round(z * precision)}`;
        const offset = vertexMap.get(key);
        
        posAttribute.setX(i, x + offset.x);
        posAttribute.setY(i, y + offset.y);
        posAttribute.setZ(i, z + offset.z);
      }
      
      posAttribute.needsUpdate = true;
      geometry.computeVertexNormals();
      return geometry;
    }

    class Portal {
      constructor(id, position, rotation, destination) {
        this.id = id;
        this.position = position.clone(); // CFFR coordinates
        this.rotation = rotation; // Rotation around Z axis (yaw)
        this.destination = destination; // Reference to destination portal
        this.destinationId = null; // For linking later
        
        this.group = new THREE.Group();
        this.portalPlane = null;
        this.isNearest = false;
        this.placeholderTime = 0;
        
        this.createMesh();
      }

      createMesh() {
        const frameWidth = 2.5;
        const frameHeight = 3.0;
        const frameDepth = 0.4;
        const stoneSize = 0.5;
        
        // Create stone frame pieces
        const createStone = (w, h, d) => {
          const geo = new THREE.BoxGeometry(w, h, d);
          // Distort for low-poly look using watertight helper
          distortGeometry(geo, 0.05);
          return geo;
        };

        // Left pillar
        const leftPillar = new THREE.Mesh(
          createStone(stoneSize, frameHeight, frameDepth),
          materials.stone
        );
        leftPillar.position.set(-frameWidth / 2, frameHeight / 2, 0);
        leftPillar.castShadow = true;
        leftPillar.receiveShadow = true;
        this.group.add(leftPillar);

        // Right pillar
        const rightPillar = new THREE.Mesh(
          createStone(stoneSize, frameHeight, frameDepth),
          materials.stone
        );
        rightPillar.position.set(frameWidth / 2, frameHeight / 2, 0);
        rightPillar.castShadow = true;
        rightPillar.receiveShadow = true;
        this.group.add(rightPillar);

        // Top lintel
        const lintel = new THREE.Mesh(
          createStone(frameWidth + stoneSize, stoneSize * 0.8, frameDepth),
          materials.stoneDark
        );
        lintel.position.set(0, frameHeight + stoneSize * 0.3, 0);
        lintel.castShadow = true;
        lintel.receiveShadow = true;
        this.group.add(lintel);

        // Add decorative cap stones
        const capLeft = new THREE.Mesh(
          createStone(stoneSize * 0.7, stoneSize * 0.5, stoneSize * 0.7),
          materials.stone
        );
        capLeft.position.set(-frameWidth / 2, frameHeight + stoneSize * 0.7, 0);
        capLeft.castShadow = true;
        this.group.add(capLeft);

        const capRight = new THREE.Mesh(
          createStone(stoneSize * 0.7, stoneSize * 0.5, stoneSize * 0.7),
          materials.stone
        );
        capRight.position.set(frameWidth / 2, frameHeight + stoneSize * 0.7, 0);
        capRight.castShadow = true;
        this.group.add(capRight);

        // Portal surface (the actual portal)
        const portalGeo = new THREE.PlaneGeometry(frameWidth - stoneSize * 0.5, frameHeight - 0.2);
        this.portalPlane = new THREE.Mesh(portalGeo, materials.portalPlaceholder.clone());
        this.portalPlane.position.set(0, frameHeight / 2, 0.05);
        this.portalPlane.receiveShadow = false; // Ensure portal view is not darkened by shadows
        this.portalPlane.castShadow = false;
        this.group.add(this.portalPlane);

        // Position the group in world space
        const threePos = cffrToThree(this.position.x, this.position.y, this.position.z);
        this.group.position.copy(threePos);
        this.group.rotation.y = -this.rotation; // Negative because of coordinate flip

        scene.add(this.group);
      }

      updatePlaceholder(time) {
        if (!this.isNearest && this.portalPlane) {
          // Animated placeholder effect
          const pulse = 0.3 + Math.sin(time * 2 + this.id) * 0.15;
          this.portalPlane.material.opacity = pulse;
          this.portalPlane.material.side = THREE.FrontSide; // Invisible from back
          
          // Swirling color effect
          const hue = (time * 0.1 + this.id * 0.2) % 1;
          this.portalPlane.material.color.setHSL(hue, 0.7, 0.5);
        }
      }

      setAsNearest(isNearest, renderTarget) {
        this.isNearest = isNearest;
        if (isNearest && renderTarget) {
          // Use shader for screen-space portal effect
          // The key is to sample the render target at screen-space coordinates
          // so the view through the portal matches exactly what would be seen
          this.portalPlane.material = new THREE.ShaderMaterial({
            uniforms: {
              map: { value: renderTarget.texture },
              resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
              varying vec4 vClipPos;
              void main() {
                vClipPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                gl_Position = vClipPos;
              }
            `,
            fragmentShader: `
              uniform sampler2D map;
              uniform vec2 resolution;
              varying vec4 vClipPos;
              
              // Linear to sRGB conversion
              vec4 linearToSRGB(vec4 color) {
                return vec4(pow(color.rgb, vec3(1.0 / 2.2)), color.a);
              }
              
              void main() {
                // Convert clip space to screen UV
                vec2 screenUV = (vClipPos.xy / vClipPos.w) * 0.5 + 0.5;
                
                // Sample the render target (contains linear color values)
                vec4 color = texture2D(map, screenUV);
                
                // Convert to sRGB for display
                gl_FragColor = linearToSRGB(color);
              }
            `,
            side: THREE.FrontSide,
            toneMapped: false
          });
        } else {
          // Use placeholder material
          this.portalPlane.material = materials.portalPlaceholder.clone();
          this.portalPlane.material.side = THREE.FrontSide; // Invisible from back
        }
      }

      getWorldPosition() {
        const pos = new THREE.Vector3();
        this.group.getWorldPosition(pos);
        return pos;
      }

      getWorldDirection() {
        const dir = new THREE.Vector3(0, 0, 1);
        this.group.localToWorld(dir);
        dir.sub(this.getWorldPosition()).normalize();
        return dir;
      }

      // Get the front position (where player exits) in CFFR coordinates
      getExitPosition() {
        // Exit just in front of portal plane, at ground level
        // Need to match the Three.js portal facing direction
        // Portal group has rotation.y = -this.rotation
        // Local +Z in Three.js becomes world direction after this rotation
        // Three.js +Z (0,0,1) rotated by -this.rotation around Y:
        //   x = sin(-this.rotation) = -sin(this.rotation)
        //   z = cos(-this.rotation) = cos(this.rotation)
        // Converting to CFFR (cffr.x = three.x, cffr.y = -three.z):
        //   cffr.x = -sin(this.rotation)
        //   cffr.y = -cos(this.rotation)
        const exitDist = 0.3; // Just past the portal plane to avoid re-triggering
        const exitX = this.position.x - Math.sin(this.rotation) * exitDist;
        const exitY = this.position.y - Math.cos(this.rotation) * exitDist;
        const exitZ = this.position.z; // Ground level (same as portal base)
        
        return new THREE.Vector3(exitX, exitY, exitZ);
      }
    }

    // Create portals linking levels
    function createPortals() {
      let portalId = 0;
      PORTAL_DEFS.forEach(def => {
        const fromZ = TERRAIN_LEVELS[def.from.level].z;
        const toZ = TERRAIN_LEVELS[def.to.level].z;
        
        const portalA = new Portal(
          portalId++,
          new THREE.Vector3(def.from.x, def.from.y, fromZ),
          def.from.rot,
          null
        );
        portalA.destinationId = portalId;
        
        const portalB = new Portal(
          portalId++,
          new THREE.Vector3(def.to.x, def.to.y, toZ),
          def.to.rot,
          null
        );
        portalB.destinationId = portalId - 2;
        
        portalA.destination = portalB;
        portalB.destination = portalA;
        
        portals.push(portalA);
        portals.push(portalB);

        // Create render target for this portal pair
        const rt = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
        });
        portalRenderTargets.set(portalA.id, rt);
        const rt2 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
        });
        portalRenderTargets.set(portalB.id, rt2);
      });
    }

    createPortals();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PLAYER CHARACTER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class PlayerCharacter {
      constructor() {
        // Position in CFFR coordinates
        this.position = new THREE.Vector3(50, 45, 0.01);
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.yaw = 0; // Rotation around Z (looking direction)
        this.pitch = 0; // Looking up/down
        
        this.isGrounded = true;
        this.isSprinting = false;
        
        // Double-tap detection
        this.lastKeyTimes = { w: 0, a: 0, s: 0, d: 0 };
        this.doubleTapThreshold = 300; // ms
        
        // Portal teleport cooldown
        this.teleportCooldown = 0;
        
        // Input state
        this.keys = { w: false, a: false, s: false, d: false, space: false };
        
        // Create visual mesh
        this.mesh = this.createMesh();
        scene.add(this.mesh);
      }

      createMesh() {
        const group = new THREE.Group();
        
        // Body (torso)
        const torsoHeight = PLAYER.HEIGHT * 0.35;
        const torsoGeo = new THREE.BoxGeometry(0.4, torsoHeight, 0.25);
        const torso = new THREE.Mesh(torsoGeo, materials.playerShirt);
        torso.position.y = PLAYER.HEIGHT * 0.55;
        torso.castShadow = true;
        group.add(torso);
        
        // Head
        const headSize = PLAYER.HEIGHT * 0.15;
        const headGeo = new THREE.BoxGeometry(headSize, headSize * 1.1, headSize * 0.9);
        const head = new THREE.Mesh(headGeo, materials.player);
        head.position.y = PLAYER.HEIGHT * 0.85;
        head.castShadow = true;
        group.add(head);
        
        // Legs
        const legHeight = PLAYER.HEIGHT * 0.45;
        const legGeo = new THREE.BoxGeometry(0.15, legHeight, 0.18);
        
        const leftLeg = new THREE.Mesh(legGeo, materials.playerPants);
        leftLeg.position.set(-0.1, legHeight / 2, 0);
        leftLeg.castShadow = true;
        group.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(legGeo, materials.playerPants);
        rightLeg.position.set(0.1, legHeight / 2, 0);
        rightLeg.castShadow = true;
        group.add(rightLeg);
        
        // Arms
        const armHeight = PLAYER.HEIGHT * 0.32;
        const armGeo = new THREE.BoxGeometry(0.12, armHeight, 0.12);
        
        const leftArm = new THREE.Mesh(armGeo, materials.playerShirt);
        leftArm.position.set(-0.28, PLAYER.HEIGHT * 0.55, 0);
        leftArm.castShadow = true;
        group.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeo, materials.playerShirt);
        rightArm.position.set(0.28, PLAYER.HEIGHT * 0.55, 0);
        rightArm.castShadow = true;
        group.add(rightArm);
        
        // Store references for animation
        this.bodyParts = { leftLeg, rightLeg, leftArm, rightArm, torso, head };
        
        return group;
      }

      handleKeyDown(key) {
        const k = key.toLowerCase();
        if (['w', 'a', 's', 'd'].includes(k)) {
          const now = Date.now();
          if (!this.keys[k] && now - this.lastKeyTimes[k] < this.doubleTapThreshold) {
            this.isSprinting = true;
          }
          this.lastKeyTimes[k] = now;
          this.keys[k] = true;
        }
        if (key === ' ' || key === 'Space') {
          this.keys.space = true;
        }
      }

      handleKeyUp(key) {
        const k = key.toLowerCase();
        if (['w', 'a', 's', 'd'].includes(k)) {
          this.keys[k] = false;
          // Stop sprinting if no movement keys held
          if (!this.keys.w && !this.keys.a && !this.keys.s && !this.keys.d) {
            this.isSprinting = false;
          }
        }
        if (key === ' ' || key === 'Space') {
          this.keys.space = false;
        }
      }

      update(dt) {
        // Calculate movement direction based on input and yaw
        const moveDir = new THREE.Vector3(0, 0, 0);
        
        if (this.keys.w) moveDir.y += 1; // Forward (North in CFFR)
        if (this.keys.s) moveDir.y -= 1; // Backward
        if (this.keys.a) moveDir.x -= 1; // Left (West)
        if (this.keys.d) moveDir.x += 1; // Right (East)
        
        if (moveDir.lengthSq() > 0) {
          moveDir.normalize();
          
          // Rotate movement direction by yaw (CW rotation to match visual yaw)
          const cos = Math.cos(this.yaw);
          const sin = Math.sin(this.yaw);
          const rotatedX = moveDir.x * cos + moveDir.y * sin;
          const rotatedY = -moveDir.x * sin + moveDir.y * cos;
          moveDir.x = rotatedX;
          moveDir.y = rotatedY;
          
          // Apply speed
          const speed = this.isSprinting ? PLAYER.SPRINT_SPEED : PLAYER.WALK_SPEED;
          this.velocity.x = moveDir.x * speed;
          this.velocity.y = moveDir.y * speed;
        } else {
          // Decelerate horizontal movement
          this.velocity.x *= 0.85;
          this.velocity.y *= 0.85;
        }
        
        // Jump
        if (this.keys.space && this.isGrounded) {
          this.velocity.z = PLAYER.JUMP_VELOCITY;
          this.isGrounded = false;
          this.keys.space = false; // Prevent continuous jumping
        }
        
        // Apply gravity
        if (!this.isGrounded) {
          this.velocity.z -= PLAYER.GRAVITY * dt;
        }
        
        // Store old position for collision resolution
        const oldX = this.position.x;
        const oldY = this.position.y;
        
        // Update position
        this.position.x += this.velocity.x * dt;
        this.position.y += this.velocity.y * dt;
        this.position.z += this.velocity.z * dt;
        
        // Cliff/wall collision - push player out of cliff ellipses
        this.handleCliffCollision(oldX, oldY);
        
        // Portal frame collision
        this.handlePortalFrameCollision(oldX, oldY);
        
        // Ground collision
        const groundZ = this.getGroundHeight(this.position.x, this.position.y);
        if (this.position.z <= groundZ) {
          this.position.z = groundZ;
          this.velocity.z = 0;
          this.isGrounded = true;
        } else {
          this.isGrounded = false;
        }
        
        // World bounds
        this.position.x = Math.max(5, Math.min(95, this.position.x));
        this.position.y = Math.max(5, Math.min(95, this.position.y));
        
        // Update mesh position and rotation
        const threePos = cffrToThree(this.position.x, this.position.y, this.position.z);
        this.mesh.position.copy(threePos);
        this.mesh.rotation.y = -this.yaw;
        
        // Animate walking
        this.animateWalk(dt);
        
        // Check portal collisions
        this.checkPortalCollision();
      }

      getGroundHeight(x, y) {
        // Find the highest ground segment the player is standing on
        let maxZ = -Infinity;
        
        for (const seg of groundSegments) {
          // Check if point is within ellipse
          const dx = x - seg.cx;
          const dy = y - seg.cy;
          const normalizedDist = (dx * dx) / (seg.rx * seg.rx) + (dy * dy) / (seg.ry * seg.ry);
          
          if (normalizedDist <= 1) {
            // Player is within this segment
            // Check if player can reach this height (not blocked by cliff)
            const currentZ = this.position.z;
            const segZ = seg.z;
            
            // Can only reach if already on this level or coming from below via portal
            // or if jumping and close enough
            if (segZ <= currentZ + 0.5 || segZ <= maxZ + 0.5) {
              maxZ = Math.max(maxZ, segZ);
            }
          }
        }
        
        return maxZ > -Infinity ? maxZ : 0;
      }

      handleCliffCollision(oldX, oldY) {
        const playerZ = this.position.z;
        const playerRadius = PLAYER.RADIUS;
        
        for (const cliff of cliffColliders) {
          // Only collide if player is below the cliff top
          if (playerZ >= cliff.topZ - 0.5) continue;
          
          // Check if player is trying to enter the cliff ellipse
          const dx = this.position.x - cliff.cx;
          const dy = this.position.y - cliff.cy;
          const rx = cliff.rx + playerRadius;
          const ry = cliff.ry + playerRadius;
          const normalizedDist = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry);
          
          if (normalizedDist < 1) {
            // Player is inside cliff - push them out
            // Find the nearest point on the ellipse boundary
            const angle = Math.atan2(dy / ry, dx / rx);
            const boundaryX = cliff.cx + rx * Math.cos(angle);
            const boundaryY = cliff.cy + ry * Math.sin(angle);
            
            this.position.x = boundaryX;
            this.position.y = boundaryY;
            
            // Kill velocity toward the cliff
            const normalX = Math.cos(angle);
            const normalY = Math.sin(angle);
            const velDot = this.velocity.x * normalX + this.velocity.y * normalY;
            if (velDot < 0) {
              this.velocity.x -= velDot * normalX;
              this.velocity.y -= velDot * normalY;
            }
          }
        }
      }

      handlePortalFrameCollision(oldX, oldY) {
        const playerRadius = PLAYER.RADIUS;
        const frameHalfWidth = 1.25 + playerRadius;  // Portal frame width
        const frameDepth = 0.4 + playerRadius;
        
        for (const portal of portals) {
          // Get player position relative to portal
          const dx = this.position.x - portal.position.x;
          const dy = this.position.y - portal.position.y;
          
          // Rotate into portal local space
          const portalForwardX = -Math.sin(portal.rotation);
          const portalForwardY = -Math.cos(portal.rotation);
          const portalRightX = -Math.cos(portal.rotation);
          const portalRightY = Math.sin(portal.rotation);
          
          const localForward = dx * portalForwardX + dy * portalForwardY;
          const localRight = dx * portalRightX + dy * portalRightY;
          
          // Check if in the frame zone (sides, not the portal opening)
          const inDepthRange = Math.abs(localForward) < frameDepth;
          const inFrameLeft = localRight < -1.0 + playerRadius && localRight > -frameHalfWidth;
          const inFrameRight = localRight > 1.0 - playerRadius && localRight < frameHalfWidth;
          
          // Check height - only collide with frame pillars
          const playerZ = this.position.z;
          const frameHeight = 3.5;
          const inHeightRange = playerZ < portal.position.z + frameHeight;
          
          if (inDepthRange && inHeightRange && (inFrameLeft || inFrameRight)) {
            // Push player out of frame pillar
            if (inFrameLeft) {
              const pushRight = (-1.0 + playerRadius) - localRight;
              this.position.x += portalRightX * pushRight;
              this.position.y += portalRightY * pushRight;
            } else {
              const pushLeft = localRight - (1.0 - playerRadius);
              this.position.x -= portalRightX * pushLeft;
              this.position.y -= portalRightY * pushLeft;
            }
          }
        }
      }

      animateWalk(dt) {
        const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
        if (speed > 0.1 && this.isGrounded) {
          const walkCycle = Date.now() * 0.01 * (this.isSprinting ? 1.5 : 1);
          const swing = Math.sin(walkCycle) * 0.4;
          
          this.bodyParts.leftLeg.rotation.x = swing;
          this.bodyParts.rightLeg.rotation.x = -swing;
          this.bodyParts.leftArm.rotation.x = -swing * 0.7;
          this.bodyParts.rightArm.rotation.x = swing * 0.7;
        } else {
          // Return to neutral
          this.bodyParts.leftLeg.rotation.x *= 0.9;
          this.bodyParts.rightLeg.rotation.x *= 0.9;
          this.bodyParts.leftArm.rotation.x *= 0.9;
          this.bodyParts.rightArm.rotation.x *= 0.9;
        }
      }

      checkPortalCollision() {
        // Skip if recently teleported (cooldown)
        if (this.teleportCooldown > 0) {
          this.teleportCooldown--;
          return;
        }
        
        const playerPos = this.position.clone();
        playerPos.z += PLAYER.HEIGHT / 2; // Check at player center height
        
        for (const portal of portals) {
          if (!portal.destination) continue;
          
          // Portal dimensions (must match createMesh)
          const portalHalfWidth = 1.0;  // Slightly less than frame
          const portalHeight = 2.8;      // Slightly less than frame height
          
          // Get player position relative to portal in portal's local space
          // Portal position is at ground level, portal plane is at local Z=0
          const relX = playerPos.x - portal.position.x;
          const relY = playerPos.y - portal.position.y;
          const relZ = playerPos.z - portal.position.z;
          
          // Portal's forward direction in CFFR (the direction it faces):
          // Based on Three.js: group.rotation.y = -portal.rotation
          // Local +Z in Three.js after rotation becomes: (-sin(rot), 0, cos(rot)) in Three.js world
          // Converting to CFFR: forward = (-sin(rot), -cos(rot))
          const portalForwardX = -Math.sin(portal.rotation);
          const portalForwardY = -Math.cos(portal.rotation);
          // Portal's right direction (90Â° clockwise from forward when viewed from above)
          const portalRightX = portalForwardY;   // = -cos(rot)
          const portalRightY = -portalForwardX;  // = sin(rot)
          
          // Project relative position onto portal's local axes
          const localForward = relX * portalForwardX + relY * portalForwardY;  // + = in front of portal
          const localRight = relX * portalRightX + relY * portalRightY;        // + = to portal's right
          const localUp = relZ;                           // Height above portal base
          
          // Check if player is within portal bounds
          const withinWidth = Math.abs(localRight) < portalHalfWidth;
          const withinHeight = localUp > 0 && localUp < portalHeight;
          const nearPlane = Math.abs(localForward) < 0.15; // Tight detection zone around portal plane
          
          if (withinWidth && withinHeight && nearPlane) {
            // Check if player is moving through the portal (into the portal)
            // Velocity projected onto portal forward direction
            const velLocalForward = this.velocity.x * portalForwardX + this.velocity.y * portalForwardY;
            
            // If moving into the portal (negative = moving opposite to portal's facing direction)
            if (velLocalForward < -0.1) {
              // Calculate entry offset for exit positioning
              const entryOffset = new THREE.Vector2(localRight, localUp);
              this.teleportToPortal(portal.destination, portal, entryOffset);
              break;
            }
          }
        }
      }

      teleportToPortal(destPortal, sourcePortal, entryOffset) {
        // Set cooldown to prevent immediate re-teleport (30 frames = 0.5 seconds at 60fps)
        this.teleportCooldown = 30;
        
        // Calculate exit position based on where player entered
        // entryOffset.x = lateral offset in source portal's local space
        //                 (positive = right side of portal when facing it)
        
        // When you walk through a portal:
        // - You face INTO the source portal
        // - You exit facing AWAY from the destination portal
        // - Your left stays your left, your right stays your right
        // 
        // But the portal coordinate systems are opposite (one faces you, one faces away)
        // So we need to NEGATE the lateral offset
        
        // Destination portal's facing direction in CFFR:
        const forwardX = -Math.sin(destPortal.rotation);
        const forwardY = -Math.cos(destPortal.rotation);
        // Right vector (perpendicular, 90Â° CW from forward)
        const rightX = -Math.cos(destPortal.rotation);
        const rightY = Math.sin(destPortal.rotation);
        
        // Exit just behind the portal plane (walking from back doesn't trigger teleport anyway)
        const exitDist = -0.15;
        const exitX = destPortal.position.x + forwardX * exitDist - rightX * entryOffset.x;
        const exitY = destPortal.position.y + forwardY * exitDist - rightY * entryOffset.x;
        const exitZ = destPortal.position.z; // Ground level
        
        // Calculate new yaw: preserves relative facing direction through portal
        const relativeYaw = this.yaw - sourcePortal.rotation;
        const newYaw = destPortal.rotation + relativeYaw + Math.PI;
        
        // Rotate velocity vector by the yaw difference
        const yawDiff = newYaw - this.yaw;
        const cos = Math.cos(yawDiff);
        const sin = Math.sin(yawDiff);
        const newVelX = this.velocity.x * cos + this.velocity.y * sin;
        const newVelY = -this.velocity.x * sin + this.velocity.y * cos;
        const newVelZ = this.velocity.z;
        
        // Apply teleport
        this.position.set(exitX, exitY, exitZ);
        this.velocity.x = newVelX;
        this.velocity.y = newVelY;
        this.velocity.z = newVelZ;
        this.yaw = newYaw;
        
        // Reset grounded state
        this.isGrounded = false;
        
        console.log(`Teleported from ${sourcePortal.id} to ${destPortal.id}`);
      }

      getCameraPosition() {
        // Over-the-shoulder third-person view
        const eyePos = new THREE.Vector3(
          this.position.x,
          this.position.y,
          this.position.z + PLAYER.EYE_HEIGHT
        );
        
        // Calculate camera offset behind and to the right
        const behindDist = PLAYER.CAMERA_BACK;
        const rightDist = PLAYER.SHOULDER_OFFSET;
        const upDist = PLAYER.CAMERA_UP;
        
        const behind = new THREE.Vector3(
          -Math.sin(this.yaw) * behindDist + Math.cos(this.yaw) * rightDist,
          -Math.cos(this.yaw) * behindDist - Math.sin(this.yaw) * rightDist,
          upDist
        );
        
        let camPos = eyePos.clone().add(behind);
        
        // Prevent camera from entering cliffs
        camPos = this.adjustCameraForCliffs(eyePos, camPos);
        
        return cffrToThree(camPos.x, camPos.y, camPos.z);
      }

      adjustCameraForCliffs(eyePos, camPos) {
        const playerZ = this.position.z;
        
        for (const cliff of cliffColliders) {
          // Only check if player is below the cliff top
          if (playerZ >= cliff.topZ - 0.5) continue;
          
          // Check if camera is inside the cliff ellipse
          const dx = camPos.x - cliff.cx;
          const dy = camPos.y - cliff.cy;
          const rx = cliff.rx + 0.3;  // Small buffer
          const ry = cliff.ry + 0.3;
          const normalizedDist = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry);
          
          if (normalizedDist < 1) {
            // Camera is inside cliff - move it along the line from player to camera
            // until it's outside the cliff
            const dirX = camPos.x - eyePos.x;
            const dirY = camPos.y - eyePos.y;
            const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
            
            if (dirLen > 0.01) {
              // Binary search for the point where camera exits cliff
              let minT = 0;
              let maxT = 1;
              
              for (let i = 0; i < 8; i++) {
                const midT = (minT + maxT) / 2;
                const testX = eyePos.x + dirX * midT;
                const testY = eyePos.y + dirY * midT;
                const testDx = testX - cliff.cx;
                const testDy = testY - cliff.cy;
                const testDist = (testDx * testDx) / (rx * rx) + (testDy * testDy) / (ry * ry);
                
                if (testDist < 1) {
                  maxT = midT;  // Still inside, search closer to player
                } else {
                  minT = midT;  // Outside, can search further
                }
              }
              
              // Use the safe position (just outside cliff)
              camPos.x = eyePos.x + dirX * minT;
              camPos.y = eyePos.y + dirY * minT;
            }
          }
        }
        
        return camPos;
      }

      getCameraTarget() {
        // Look ahead of player, slightly elevated
        const lookDist = 5;
        const target = new THREE.Vector3(
          this.position.x + Math.sin(this.yaw) * lookDist,
          this.position.y + Math.cos(this.yaw) * lookDist,
          this.position.z + PLAYER.EYE_HEIGHT + Math.sin(this.pitch) * lookDist
        );
        return cffrToThree(target.x, target.y, target.z);
      }
    }

    const player = new PlayerCharacter();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INPUT HANDLING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let isPointerLocked = false;

    document.addEventListener('keydown', (e) => {
      if (!isPointerLocked) return;
      player.handleKeyDown(e.key);
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      player.handleKeyUp(e.key);
    });

    document.addEventListener('mousemove', (e) => {
      if (!isPointerLocked) return;
      
      const sensitivity = 0.002;
      player.yaw += e.movementX * sensitivity;
      player.pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, player.pitch - e.movementY * sensitivity));
    });

    // Pointer lock for mouse look
    const clickToStart = document.getElementById('clickToStart');
    
    clickToStart.addEventListener('click', () => {
      canvas.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
      isPointerLocked = document.pointerLockElement === canvas;
      clickToStart.classList.toggle('hidden', isPointerLocked);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PORTAL RENDERING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function findNearestPortal() {
      const playerThreePos = player.getCameraPosition();
      let nearest = null;
      let nearestDist = Infinity;
      
      for (const portal of portals) {
        const dist = playerThreePos.distanceTo(portal.getWorldPosition());
        if (dist < nearestDist) {
          nearestDist = dist;
          nearest = portal;
        }
      }
      
      return { portal: nearest, distance: nearestDist };
    }

    function renderPortalView(portal, mainCamera) {
      if (!portal || !portal.destination) return;
      
      const rt = portalRenderTargets.get(portal.id);
      if (!rt) return;
      
      const destPortal = portal.destination;
      
      // Get player position relative to source portal (in world space)
      const playerPos = mainCamera.position.clone();
      const portalPos = portal.getWorldPosition();
      const relativePos = playerPos.clone().sub(portalPos);
      
      // Calculate the rotation needed to transform from source portal space to dest portal space
      // Portal.rotation is the CFFR yaw, which becomes -rotation in Three.js (around Y axis)
      // Source portal faces direction: -portal.rotation in Three.js
      // Dest portal faces direction: -destPortal.rotation in Three.js
      // To go from looking INTO source to looking OUT OF dest, we need to:
      // 1. Undo source portal rotation
      // 2. Add 180Â° (because we exit the other side)
      // 3. Apply dest portal rotation
      const sourceYaw = -portal.rotation;       // Three.js rotation of source portal
      const destYaw = -destPortal.rotation;     // Three.js rotation of dest portal
      const rotDiff = destYaw - sourceYaw + Math.PI;
      
      // Rotate relative position around Y axis
      relativePos.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotDiff);
      
      // Position virtual camera at destination
      const destPos = destPortal.getWorldPosition();
      const virtualCamPos = destPos.clone().add(relativePos);
      
      // Create virtual camera
      const virtualCam = mainCamera.clone();
      virtualCam.position.copy(virtualCamPos);
      
      // Rotate virtual camera's orientation by the same rotation difference
      virtualCam.quaternion.copy(mainCamera.quaternion);
      virtualCam.quaternion.premultiply(
        new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotDiff)
      );
      
      // Render to texture (hide both portals to avoid recursion/artifacts)
      portal.portalPlane.visible = false;
      destPortal.portalPlane.visible = false;
      
      renderer.setRenderTarget(rt);
      renderer.render(scene, virtualCam);
      renderer.setRenderTarget(null);
      
      portal.portalPlane.visible = true;
      destPortal.portalPlane.visible = true;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GAME LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let lastTime = 0;
    const fixedTimeStep = 1 / 60;
    let accumulator = 0;

    function gameLoop(currentTime) {
      requestAnimationFrame(gameLoop);
      
      const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
      lastTime = currentTime;
      
      // Fixed timestep for physics
      accumulator += dt;
      while (accumulator >= fixedTimeStep) {
        player.update(fixedTimeStep);
        accumulator -= fixedTimeStep;
      }
      
      // Update camera
      camera.position.copy(player.getCameraPosition());
      camera.lookAt(player.getCameraTarget());
      
      // Find and render nearest portal
      const { portal: nearest, distance } = findNearestPortal();
      
      // Update portal states
      portals.forEach(p => {
        const isNearest = p === nearest && distance < 30;
        if (isNearest !== p.isNearest) {
          const rt = portalRenderTargets.get(p.id);
          p.setAsNearest(isNearest, rt);
        }
        p.updatePlaceholder(currentTime / 1000);
      });
      
      // Render portal view for nearest portal
      if (nearest && distance < 30) {
        renderPortalView(nearest, camera);
      }
      
      // Main render
      renderer.render(scene, camera);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WINDOW RESIZE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Resize all portal render targets
      portalRenderTargets.forEach(rt => {
        rt.setSize(window.innerWidth, window.innerHeight);
      });
    }

    window.addEventListener('resize', onResize);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INITIALIZATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function init() {
      // Hide loading overlay
      const loadingOverlay = document.getElementById('loadingOverlay');
      loadingOverlay.classList.add('hidden');
      
      // Start game loop
      requestAnimationFrame(gameLoop);
    }

    // Start after a brief moment for assets to settle
    setTimeout(init, 500);
  </script>
  <script src="parental.js" defer></script>
</body>
</html>
