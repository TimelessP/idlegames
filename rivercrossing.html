<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="application-name" content="IdleGames">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="River Crossing">
    <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512px.png">
    <script src="assets/js/pwa.js" defer></script>
    <meta name="theme-color" content="#4a9e5c">
    <title>River Crossing</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        :root {
            color-scheme: light dark;
            --bg-body: #87CEEB;
            --bg-secondary: #ffffff;
            --text-main: #2d3748;
            --text-muted: #718096;
            --border-color: #e2e8f0;
            --accent-primary: #4a9e5c;
            --accent-hover: #3d8a4e;
            --modal-bg: rgba(0, 0, 0, 0.55);
            --success-color: #10b981;
            --error-color: #ef4444;
            --scrollbar-track: #e4ebf3;
            --scrollbar-thumb: #7da3d1;
            --scrollbar-thumb-hover: #668fbe;
        }

        [data-theme="dark"] {
            --bg-body: #1a2a3a;
            --bg-secondary: #16213e;
            --text-main: #eee;
            --text-muted: #a0aec0;
            --border-color: #2a3f5f;
            --scrollbar-track: #1d2a42;
            --scrollbar-thumb: #4f6f9c;
            --scrollbar-thumb-hover: #6388bc;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        *::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        *::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
        }

        *::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 999px;
            border: 2px solid var(--scrollbar-track);
        }

        *::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }

        html, body { width: 100%; height: 100%; overflow: hidden; }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: var(--bg-body);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            gap: 0.5rem;
            z-index: 10;
        }

        .header-title {
            font-size: 1.3rem;
            font-weight: 700;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        button {
            font-family: inherit;
            color: inherit;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.45rem;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 200ms ease, transform 150ms ease;
            user-select: none;
            -webkit-user-select: none;
        }

        button:not(.card):hover { background: var(--accent-primary); color: white; }
        button:active { transform: scale(0.95); }
        button:focus-visible { outline: 2px solid var(--accent-primary); outline-offset: 2px; }

        .icon-button { width: 2.4rem; height: 2.4rem; border-radius: 50%; }

        .primary-button {
            background: var(--accent-primary);
            color: white;
            padding: 0.55rem 1.2rem;
            border-radius: 0.375rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
        }
        .primary-button:hover { background: var(--accent-hover); }

        /* Stats bar */
        .stats {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.85);
            gap: 1.5rem;
            flex-shrink: 0;
            font-size: 0.85rem;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
        }
        [data-theme="dark"] .stats { background: rgba(22,33,62,0.9); }
        .stat-item { display: flex; align-items: center; gap: 0.3rem; }
        .stat-label { color: var(--text-muted); text-transform: uppercase; font-size: 0.7rem; letter-spacing: 0.5px; }
        .stat-value { font-size: 1rem; }

        /* Game viewport */
        .game-viewport {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            min-height: 0;
            position: relative;
            background: transparent;
        }

        .game-stage {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            z-index: 1;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD overlay */
        .hud {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.55);
            color: #fff;
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            font-size: 0.85rem;
            text-align: center;
            pointer-events: none;
            max-width: 90%;
            backdrop-filter: blur(4px);
            z-index: 5;
            transition: opacity 300ms;
        }

        .hud.hidden { opacity: 0; }

        .bottom-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            padding: 0.6rem 1rem calc(0.6rem + env(safe-area-inset-bottom));
            background: rgba(255,255,255,0.9);
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        [data-theme="dark"] .bottom-controls {
            background: rgba(22,33,62,0.95);
        }

        .control-btn {
            min-width: 4.2rem;
            height: 3.2rem;
            border-radius: 0.8rem;
            background: #ffffff;
            color: #16335a;
            border: 2px solid #325b93;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 700;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .control-btn:hover {
            background: #eaf3ff;
        }

        [data-theme="dark"] .control-btn {
            background: #27446c;
            color: #f1f7ff;
            border-color: #8fb8f2;
        }

        [data-theme="dark"] .control-btn:hover {
            background: #335a90;
        }

        .control-btn:active {
            transform: scale(0.92);
        }

        .action-btn {
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            background: #2f8e4b;
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
            border: 3px solid #d9f5de;
            touch-action: manipulation;
        }
        .action-btn:active { background: #236f3b; transform: scale(0.9); }

        [data-theme="dark"] .action-btn {
            background: #2b9f54;
            border-color: #c7f1d3;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--modal-bg);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }
        .modal.open { display: flex; }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            padding: 2rem 1.5rem;
            max-width: 440px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal-header { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; text-align: center; }
        .modal-body { font-size: 0.95rem; line-height: 1.6; margin-bottom: 1.5rem; }
        .modal-body p { margin-bottom: 0.75rem; }

        .modal-footer {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .btn-icon { display: flex; align-items: center; justify-content: center; }
        .btn-icon svg { width: 18px; height: 18px; }

        .share-status {
            text-align: center;
            font-size: 0.85rem;
            color: var(--success-color);
            min-height: 1.25rem;
            margin-top: 0.5rem;
        }

        .score-display {
            font-size: 2rem;
            font-weight: 700;
            color: var(--success-color);
            margin: 0.75rem 0;
            text-align: center;
        }

        .fail-display {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--error-color);
            margin: 0.75rem 0;
            text-align: center;
        }

        .completion-message { text-align: center; margin-bottom: 1rem; }

        .bmac-link { display: flex; justify-content: center; margin-top: 1rem; }
        .bmac-button img { height: 36px; width: auto; border-radius: 4px; transition: transform 200ms; }
        .bmac-button:hover img { transform: scale(1.05); }

        /* Key hints */
        .key-hints {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(0,0,0,0.45);
            color: #fff;
            padding: 0.4rem 0.7rem;
            border-radius: 0.5rem;
            font-size: 0.72rem;
            line-height: 1.5;
            pointer-events: none;
            z-index: 5;
            backdrop-filter: blur(4px);
        }
        .key-hints kbd {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            padding: 0 0.3rem;
            font-family: inherit;
            font-weight: 600;
        }

        @media (max-width: 600px) {
            .header { padding: 0.4rem 0.7rem; }
            .header-title { font-size: 1.1rem; }
            .stats { padding: 0.35rem 0.5rem; gap: 0.8rem; font-size: 0.75rem; }
            .stat-value { font-size: 0.85rem; }
            .key-hints { display: none; }
            .bottom-controls { gap: 0.7rem; padding-top: 0.45rem; }
            .control-btn { min-width: 3.6rem; height: 2.9rem; font-size: 1.05rem; }
            .action-btn { width: 3.6rem; height: 3.6rem; }
        }

        @media (max-height: 560px) and (orientation: landscape) {
            .header {
                padding: 0.25rem 0.55rem;
                gap: 0.35rem;
            }

            .header-title {
                font-size: 0.96rem;
            }

            .icon-button {
                width: 2rem;
                height: 2rem;
            }

            #newGameBtn {
                padding: 0.35rem 0.75rem;
                font-size: 0.82rem;
            }

            .stats {
                padding: 0.22rem 0.45rem;
                gap: 0.6rem;
                font-size: 0.7rem;
            }

            .stat-label {
                font-size: 0.6rem;
            }

            .stat-value {
                font-size: 0.76rem;
            }

            .bottom-controls {
                gap: 0.45rem;
                padding: 0.3rem 0.6rem calc(0.3rem + env(safe-area-inset-bottom));
            }

            .control-btn {
                min-width: 3.1rem;
                height: 2.45rem;
                font-size: 0.9rem;
                border-radius: 0.6rem;
            }

            .action-btn {
                width: 3rem;
                height: 3rem;
                font-size: 1.2rem;
            }

            .hud {
                font-size: 0.72rem;
                padding: 0.32rem 0.62rem;
                bottom: 0.45rem;
            }

            .key-hints {
                display: none;
            }
        }

        /* Play Again button green */
        #playAgainBtn { background: var(--success-color); }
        #playAgainBtn:hover { background: #0ea472; }

        .sr-only {
            position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
            overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border-width: 0;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1 class="header-title">üö£ River Crossing</h1>
        <div class="header-controls">
            <button class="primary-button" id="newGameBtn" aria-label="New game" title="New Game">New Game</button>
            <button class="icon-button" id="helpBtn" aria-label="How to play" title="How to play">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                    <line x1="12" y1="17" x2="12.01" y2="17"/>
                </svg>
            </button>
            <button class="icon-button" id="themeToggle" aria-label="Toggle theme" title="Toggle theme">
                <svg id="themeIcon" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                </svg>
            </button>
        </div>
    </header>

    <div class="stats">
        <div class="stat-item">
            <span class="stat-label">Moves</span>
            <span class="stat-value" id="movesCount">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Time</span>
            <span class="stat-value" id="timeCount">0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Crossings</span>
            <span class="stat-value" id="crossingsCount">0</span>
        </div>
    </div>

    <div class="game-viewport" id="gameViewport">
        <div class="game-stage" id="gameStage">
            <svg id="gameCanvas" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 224" preserveAspectRatio="xMidYMid meet"></svg>

            <div class="key-hints" id="keyHints">
                <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;
                <kbd>E</kbd> Interact
            </div>

            <div class="hud" id="hud">Use WASD or on-screen controls, E to interact</div>
        </div>
    </div>

    <div class="bottom-controls" id="touchControls" role="group" aria-label="Movement controls">
        <button class="control-btn" id="leftBtn" aria-label="Move left">‚óÄ</button>
        <button class="control-btn action-btn" id="actionBtn" aria-label="Interact">E</button>
        <button class="control-btn" id="rightBtn" aria-label="Move right">‚ñ∂</button>
    </div>

    <!-- How to Play Modal -->
    <div class="modal" id="helpModal" role="dialog" aria-modal="true" aria-label="How to play">
        <div class="modal-content">
            <div class="modal-header">üö£ How to Play</div>
            <div class="modal-body">
                <p>Get the <strong>wolf üê∫</strong>, <strong>goat üêê</strong>, and <strong>cabbage ü•¨</strong> safely across the river!</p>
                <p><strong>Rules:</strong></p>
                <ul style="margin-left:1.25rem; margin-bottom:1rem;">
                    <li>The cargo slot holds only <strong>one item</strong> at a time</li>
                    <li>You cannot attach to the helm while carrying an item</li>
                    <li>The <strong>wolf eats the goat</strong> if left alone together</li>
                    <li>The <strong>goat eats the cabbage</strong> if left alone together</li>
                    <li>Win by getting all three across, then dropping the final carried item on land</li>
                </ul>
                <p><strong>Controls:</strong></p>
                <ul style="margin-left:1.25rem; margin-bottom:1rem;">
                    <li><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> ‚Äî Move the farmer (or use on-screen ‚óÄ E ‚ñ∂)</li>
                    <li><kbd>E</kbd> near an item ‚Äî Pick up the nearest item by center</li>
                    <li><kbd>E</kbd> while carrying ‚Äî Drop the carried item</li>
                    <li>Walk onto a docked boat edge to board automatically; walk off shore-side edge to disembark</li>
                    <li>On boat at helm: <kbd>E</kbd> ‚Äî Attach / detach helm (empty hands only)</li>
                    <li>On boat at cargo end: <kbd>E</kbd> ‚Äî Place or pick up cargo item</li>
                    <li>While attached to helm: <kbd>A</kbd>/<kbd>D</kbd> ‚Äî Turn / start / stop the boat</li>
                </ul>
                <p>Created with ‚ù§Ô∏è as part of the Idle Games collection.</p>
                <div class="bmac-link">
                    <a href="https://buymeacoffee.com/timelessp" target="_blank" rel="noopener noreferrer" class="bmac-button" title="Buy us a coffee">
                        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee">
                    </a>
                </div>
            </div>
            <div class="modal-footer">
                <button class="primary-button" id="closeHelpBtn">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="modal" id="winModal" role="dialog" aria-modal="true" aria-label="You win!">
        <div class="modal-content">
            <div class="modal-header">üéâ You Did It!</div>
            <div class="modal-body">
                <div class="completion-message">
                    <p>Everyone crossed safely!</p>
                    <div class="score-display" id="finalScore">Score: 0</div>
                    <p id="finalStats"></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="primary-button" id="shareScoreBtn" aria-label="Share score" title="Share">
                    <span class="btn-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="18" cy="5" r="3"/>
                            <circle cx="6" cy="12" r="3"/>
                            <circle cx="18" cy="19" r="3"/>
                            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                        </svg>
                    </span>
                    <span class="btn-label">Share</span>
                </button>
                <button class="primary-button" id="viewResultBtn" aria-label="View score and close" title="View">
                    <span class="btn-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                    </span>
                    <span class="btn-label">View</span>
                </button>
                <button class="primary-button" id="playAgainBtn" aria-label="Play Again" title="Play Again">
                    <span class="btn-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 1 1-9-9"/>
                            <polyline points="21 3 21 9 15 9"/>
                            <path d="M21 9l-3.5-3.5"/>
                        </svg>
                    </span>
                    <span class="btn-label">Play Again</span>
                </button>
            </div>
            <div class="share-status" id="shareStatus" aria-live="polite"></div>
        </div>
    </div>

    <!-- Fail Modal -->
    <div class="modal" id="failModal" role="dialog" aria-modal="true" aria-label="Game over">
        <div class="modal-content">
            <div class="modal-header">üò± Oh No!</div>
            <div class="modal-body">
                <div class="completion-message">
                    <div class="fail-display" id="failMessage">Something was eaten!</div>
                    <p id="failDetails"></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="primary-button" id="viewFailResultBtn" aria-label="View result and close" title="View">
                    <span class="btn-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                    </span>
                    <span class="btn-label">View</span>
                </button>
                <button class="primary-button" id="tryAgainBtn" aria-label="Try Again" title="Try Again">
                    <span class="btn-icon" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 12a9 9 0 1 1-9-9"/>
                            <polyline points="21 3 21 9 15 9"/>
                            <path d="M21 9l-3.5-3.5"/>
                        </svg>
                    </span>
                    <span class="btn-label">Try Again</span>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // ========================================
        // CONSTANTS & WORLD LAYOUT
        // ========================================
        const CHARACTER_HEIGHT = 56;
        const W = 320, H = CHARACTER_HEIGHT * 4;
        const RIVER_LEFT = 100, RIVER_RIGHT = 220;
        const RIVER_MID = (RIVER_LEFT + RIVER_RIGHT) / 2;
        const GROUND_Y = H / 2;   // horizon midline in gameplay rectangle
        const WATER_Y = H / 2;    // water top aligned with grass/sandbank top
        const TREE_LINE_Y = GROUND_Y + 8;
        const PATH_MARGIN_TOP = 14;
        const PATH_HEIGHT = 20;
        const PATH_TOP = GROUND_Y + PATH_MARGIN_TOP;
        const PATH_CENTER_Y = PATH_TOP + PATH_HEIGHT / 2;
        const PATH_BOTTOM = PATH_TOP + PATH_HEIGHT;
        const BUSH_LINE_Y = PATH_BOTTOM + 14;
        const FLOWER_LINE_Y = BUSH_LINE_Y + 16;
        const BOAT_KEEL_Y = PATH_BOTTOM;
        const BOAT_HULL_BOTTOM = 8;
        const SHORE_LEFT_X = 50;  // centre of left shore
        const SHORE_RIGHT_X = 270;
        const BOAT_LEFT_X = RIVER_LEFT + 28;
        const BOAT_RIGHT_X = RIVER_RIGHT - 28;
        const FARMER_SPEED = 1.2;
        const BOAT_SPEED = 1.8;
        const FARMER_FEET_OFFSET = 17;
        const WOLF_FEET_OFFSET = 16;
        const GOAT_FEET_OFFSET = 14;
        const CABBAGE_FEET_OFFSET = 12;
        const FIXED_FPS = 20;
        const FIXED_DT = 1 / FIXED_FPS;
        const BASE_FPS = 60;

        // Item spots on each shore (x offsets from shore centre)
        const ITEM_SPOTS = [-60, 0, 60];

        // ========================================
        // GAME STATE
        // ========================================
        let state = {};

        function freshState() {
            return {
                farmer: { x: SHORE_LEFT_X, y: PATH_CENTER_Y - FARMER_FEET_OFFSET, side: 'left', onBoat: false, carrying: null, facing: 1, helmAttached: false },
                wolf:     { x: SHORE_LEFT_X - 30, y: PATH_CENTER_Y - WOLF_FEET_OFFSET, side: 'left', onBoat: false },
                goat:     { x: SHORE_LEFT_X,      y: PATH_CENTER_Y - GOAT_FEET_OFFSET, side: 'left', onBoat: false },
                cabbage:  { x: SHORE_LEFT_X + 30,  y: PATH_CENTER_Y - CABBAGE_FEET_OFFSET, side: 'left', onBoat: false },
                boat: { x: BOAT_LEFT_X, y: BOAT_KEEL_Y - BOAT_HULL_BOTTOM, side: 'left', facing: 1, motionDir: 0, justArrived: false },
                moves: 0,
                crossings: 0,
                startTime: 0,
                elapsed: 0,
                timerRunning: false,
                gameOver: false,
                won: false,
                animFrame: 0,
                bobPhase: Math.random() * Math.PI * 2,
                walkCycle: 0,
                boatCargoItem: null,
            };
        }

        state = freshState();

        // ========================================
        // INPUT STATE
        // ========================================
        const keys = { w: false, a: false, s: false, d: false, e: false };
        let eJustPressed = false;
        let aJustPressed = false;
        let dJustPressed = false;

        document.addEventListener('keydown', (ev) => {
            const k = ev.key.toLowerCase();
            if (k in keys) {
                if (!keys[k] && k === 'e') eJustPressed = true;
                if (!keys[k] && k === 'a') aJustPressed = true;
                if (!keys[k] && k === 'd') dJustPressed = true;
                keys[k] = true;
                ev.preventDefault();
            }
            if (k === 'enter') {
                if (!keys.e) eJustPressed = true;
                keys.e = true;
                ev.preventDefault();
            }
            if (k === 'arrowup') { if (!keys.w) keys.w = true; ev.preventDefault(); }
            if (k === 'arrowdown') { if (!keys.s) keys.s = true; ev.preventDefault(); }
            if (k === 'arrowleft') {
                if (!keys.a) aJustPressed = true;
                keys.a = true;
                ev.preventDefault();
            }
            if (k === 'arrowright') {
                if (!keys.d) dJustPressed = true;
                keys.d = true;
                ev.preventDefault();
            }
        });
        document.addEventListener('keyup', (ev) => {
            const k = ev.key.toLowerCase();
            if (k in keys) { keys[k] = false; }
            if (k === 'enter') keys.e = false;
            if (k === 'arrowup') keys.w = false;
            if (k === 'arrowdown') keys.s = false;
            if (k === 'arrowleft') keys.a = false;
            if (k === 'arrowright') keys.d = false;
        });

        // ========================================
        // TOUCH / ON-SCREEN CONTROLS
        // ========================================
        function bindDirectionalButton(button, key) {
            const start = (ev) => {
                ev.preventDefault();
                if (!keys[key] && key === 'a') aJustPressed = true;
                if (!keys[key] && key === 'd') dJustPressed = true;
                keys[key] = true;
            };
            const end = (ev) => {
                ev.preventDefault();
                keys[key] = false;
            };

            button.addEventListener('touchstart', start, { passive: false });
            button.addEventListener('touchend', end, { passive: false });
            button.addEventListener('touchcancel', end, { passive: false });
            button.addEventListener('mousedown', start);
            button.addEventListener('mouseup', end);
            button.addEventListener('mouseleave', end);
        }

        bindDirectionalButton(document.getElementById('leftBtn'), 'a');
        bindDirectionalButton(document.getElementById('rightBtn'), 'd');

        // Action button (always visible)
        const actionBtn = document.getElementById('actionBtn');
        actionBtn.addEventListener('touchstart', (ev) => { ev.preventDefault(); eJustPressed = true; keys.e = true; }, { passive: false });
        actionBtn.addEventListener('touchend', (ev) => { ev.preventDefault(); keys.e = false; }, { passive: false });
        actionBtn.addEventListener('mousedown', () => { eJustPressed = true; keys.e = true; });
        actionBtn.addEventListener('mouseup', () => { keys.e = false; });

        // ========================================
        // SVG DRAWING HELPERS
        // ========================================
        const svg = document.getElementById('gameCanvas');
        svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

        function svgEl(tag, attrs = {}) {
            const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
            return el;
        }

        function isDarkWorldTheme() {
            return document.documentElement.getAttribute('data-theme') === 'dark';
        }

        function getScenePalette() {
            if (isDarkWorldTheme()) {
                return {
                    waterTop: '#244a78',
                    waterBottom: '#0f2746',
                    skyTop: '#070d1f',
                    skyBottom: '#15294a',
                    grassTop: '#2f5a3a',
                    grassBottom: '#1d3a26',
                    hill: '#5f7c67',
                    hillOpacity: '0.35',
                    bank: '#6d5a44',
                    path: '#6f5a46',
                    pathTop: '#816752',
                    cloud: '#9fb5cf',
                    cloudOpacity: '0.28',
                    sunGlow: '#d7e3ff',
                    treeTrunk: '#5e4a35',
                    treeLeafA: '#2f6a43',
                    treeLeafB: '#3b7a4d',
                    treeLeafC: '#4b8a58',
                    treeLeafD: '#5a9863',
                    flowerStem: '#3b7248',
                    flowerCenter: '#d8cf95',
                    bushA: '#2a6b39',
                    bushB: '#337844',
                    bushC: '#3f8650',
                    rockA: '#7f7e87',
                    rockB: '#6d6c76',
                    ripple: '#d6e4ff',
                    rippleOpacity: '0.42',
                };
            }

            return {
                waterTop: '#5bb8f5',
                waterBottom: '#2a7abf',
                skyTop: '#87CEEB',
                skyBottom: '#b8e4f9',
                grassTop: '#6abf69',
                grassBottom: '#4a8f4a',
                hill: '#8FBF8F',
                hillOpacity: '0.5',
                bank: '#c4a265',
                path: '#b28658',
                pathTop: '#c89a68',
                cloud: '#ffffff',
                cloudOpacity: '0.85',
                sunGlow: '#FFD93D',
                treeTrunk: '#8B6939',
                treeLeafA: '#4CAF50',
                treeLeafB: '#5ABF5E',
                treeLeafC: '#66CC6A',
                treeLeafD: '#72D176',
                flowerStem: '#4a8f4a',
                flowerCenter: '#FFD93D',
                bushA: '#3d9142',
                bushB: '#4ba34f',
                bushC: '#45a349',
                rockA: '#a89070',
                rockB: '#9a8264',
                ripple: '#ffffff',
                rippleOpacity: '0.5',
            };
        }

        // ========================================
        // DRAW SCENERY (background, never changes)
        // ========================================
        function drawScenery() {
            const SCENE_EXT = Math.max(W, H) * 4;
            const scene = getScenePalette();
            const darkMode = isDarkWorldTheme();
            const defs = svgEl('defs');

            // Water gradient
            const wg = svgEl('linearGradient', { id: 'waterGrad', x1: '0', y1: '0', x2: '0', y2: '1' });
            wg.appendChild(svgEl('stop', { offset: '0%', 'stop-color': scene.waterTop, 'stop-opacity': darkMode ? '0.92' : '0.9' }));
            wg.appendChild(svgEl('stop', { offset: '100%', 'stop-color': scene.waterBottom, 'stop-opacity': darkMode ? '0.98' : '0.95' }));
            defs.appendChild(wg);

            // Sky gradient
            const sg = svgEl('linearGradient', { id: 'skyGrad', x1: '0', y1: '0', x2: '0', y2: '1' });
            sg.appendChild(svgEl('stop', { offset: '0%', 'stop-color': scene.skyTop }));
            sg.appendChild(svgEl('stop', { offset: '100%', 'stop-color': scene.skyBottom }));
            defs.appendChild(sg);

            // Grass gradient left
            const gl = svgEl('linearGradient', { id: 'grassLeft', x1: '0', y1: '0', x2: '0', y2: '1' });
            gl.appendChild(svgEl('stop', { offset: '0%', 'stop-color': scene.grassTop }));
            gl.appendChild(svgEl('stop', { offset: '100%', 'stop-color': scene.grassBottom }));
            defs.appendChild(gl);

            // Grass gradient right
            const gr = svgEl('linearGradient', { id: 'grassRight', x1: '0', y1: '0', x2: '0', y2: '1' });
            gr.appendChild(svgEl('stop', { offset: '0%', 'stop-color': scene.grassTop }));
            gr.appendChild(svgEl('stop', { offset: '100%', 'stop-color': scene.grassBottom }));
            defs.appendChild(gr);

            svg.appendChild(defs);

            // Sky
            svg.appendChild(svgEl('rect', {
                x: -SCENE_EXT,
                y: -SCENE_EXT,
                width: W + SCENE_EXT * 2,
                height: GROUND_Y + SCENE_EXT,
                fill: 'url(#skyGrad)'
            }));

            if (darkMode) {
                const cloudZones = [
                    { x: W * 0.18, y: H * 0.2, sx: 35 * 0.9, sy: 18 * 0.9 },
                    { x: W * 0.45, y: H * 0.13, sx: 35 * 0.7, sy: 18 * 0.7 },
                    { x: W * 0.72, y: H * 0.22, sx: 35 * 0.95, sy: 18 * 0.95 },
                ];

                const isInsideCloudZone = (x, y) => {
                    for (const zone of cloudZones) {
                        const dx = (x - zone.x) / (zone.sx + 18);
                        const dy = (y - zone.y) / (zone.sy + 10);
                        if ((dx * dx + dy * dy) <= 1) return true;
                    }
                    return false;
                };

                // Stars
                for (let i = 0; i < 36; i++) {
                    const sx = 10 + ((i * 37) % (W - 20));
                    const sy = 8 + ((i * 23) % Math.max(20, GROUND_Y - 14));
                    if (isInsideCloudZone(sx, sy)) continue;
                    const sr = (i % 3 === 0) ? 1.5 : ((i % 2 === 0) ? 1.2 : 0.9);
                    const so = (i % 4 === 0) ? '0.85' : '0.62';
                    svg.appendChild(svgEl('circle', { cx: sx, cy: sy, r: sr, fill: '#e9efff', opacity: so }));
                }

                // Moon (with subtle crescent mask effect)
                const moonX = W * 0.82;
                const moonY = H * 0.14;
                const moonMask = svgEl('mask', { id: 'moonCrescentMask' });
                moonMask.appendChild(svgEl('rect', {
                    x: moonX - 30,
                    y: moonY - 30,
                    width: 60,
                    height: 60,
                    fill: '#fff'
                }));
                moonMask.appendChild(svgEl('circle', { cx: moonX + 8, cy: moonY - 3, r: 20, fill: '#000' }));
                defs.appendChild(moonMask);

                svg.appendChild(svgEl('circle', {
                    cx: moonX,
                    cy: moonY,
                    r: 22,
                    fill: scene.sunGlow,
                    opacity: '0.92',
                    mask: 'url(#moonCrescentMask)'
                }));
            } else {
                // Sun
                const sun = svgEl('circle', { cx: W * 0.82, cy: H * 0.14, r: 26, fill: scene.sunGlow, opacity: '0.9' });
                svg.appendChild(sun);
                // Sun rays
                for (let i = 0; i < 8; i++) {
                    const angle = (i * 45) * Math.PI / 180;
                    const x1 = W * 0.82 + Math.cos(angle) * 34;
                    const y1 = H * 0.14 + Math.sin(angle) * 34;
                    const x2 = W * 0.82 + Math.cos(angle) * 48;
                    const y2 = H * 0.14 + Math.sin(angle) * 48;
                    svg.appendChild(svgEl('line', { x1, y1, x2, y2, stroke: scene.sunGlow, 'stroke-width': '3', 'stroke-linecap': 'round', opacity: '0.7' }));
                }
            }

            // Clouds
            drawCloud(W * 0.18, H * 0.2, 0.9, scene);
            drawCloud(W * 0.45, H * 0.13, 0.7, scene);
            drawCloud(W * 0.72, H * 0.22, 0.95, scene);

            // Background hills (centered over visible grass areas)
            const hillLeftCx = RIVER_LEFT / 2;
            const hillRightCx = RIVER_RIGHT + (W - RIVER_RIGHT) / 2;
            const hillRy = 18;
            const hillCy = GROUND_Y; // vertical center aligned to horizon level
            svg.appendChild(svgEl('ellipse', {
                cx: hillLeftCx,
                cy: hillCy,
                rx: RIVER_LEFT * 0.48,
                ry: hillRy,
                fill: scene.hill,
                opacity: scene.hillOpacity
            }));
            svg.appendChild(svgEl('ellipse', {
                cx: hillRightCx,
                cy: hillCy,
                rx: (W - RIVER_RIGHT) * 0.48,
                ry: hillRy,
                fill: scene.hill,
                opacity: scene.hillOpacity
            }));

            // Water
            const waterRect = svgEl('rect', {
                x: RIVER_LEFT,
                y: WATER_Y,
                width: RIVER_RIGHT - RIVER_LEFT,
                height: H - WATER_Y + SCENE_EXT,
                fill: 'url(#waterGrad)'
            });
            svg.appendChild(waterRect);

            // Left shore
            svg.appendChild(svgEl('rect', {
                x: -SCENE_EXT,
                y: GROUND_Y,
                width: RIVER_LEFT + SCENE_EXT,
                height: H - GROUND_Y + SCENE_EXT,
                fill: 'url(#grassLeft)',
                rx: 0
            }));
            // Right shore
            svg.appendChild(svgEl('rect', {
                x: RIVER_RIGHT,
                y: GROUND_Y,
                width: W - RIVER_RIGHT + SCENE_EXT,
                height: H - GROUND_Y + SCENE_EXT,
                fill: 'url(#grassRight)',
                rx: 0
            }));

            // Water ripple lines (animated later)
            const rippleGroup = svgEl('g', { id: 'waterRipples', opacity: '0.4' });
            svg.appendChild(rippleGroup);

            // Dirt edge on left
            svg.appendChild(svgEl('rect', { x: RIVER_LEFT - 15, y: GROUND_Y, width: 18, height: H - GROUND_Y + SCENE_EXT, fill: scene.bank, rx: 0 }));
            // Dirt edge on right
            svg.appendChild(svgEl('rect', { x: RIVER_RIGHT - 3, y: GROUND_Y, width: 18, height: H - GROUND_Y + SCENE_EXT, fill: scene.bank, rx: 0 }));

            // Path (with margins above and below)
            svg.appendChild(svgEl('rect', {
                x: -SCENE_EXT,
                y: PATH_TOP,
                width: RIVER_LEFT + SCENE_EXT - 6,
                height: PATH_HEIGHT,
                fill: scene.path,
                rx: 4
            }));
            svg.appendChild(svgEl('rect', {
                x: RIVER_RIGHT + 6,
                y: PATH_TOP,
                width: W - RIVER_RIGHT + SCENE_EXT,
                height: PATH_HEIGHT,
                fill: scene.path,
                rx: 4
            }));
            svg.appendChild(svgEl('line', {
                x1: -SCENE_EXT,
                y1: PATH_TOP + 1,
                x2: RIVER_LEFT - 6,
                y2: PATH_TOP + 1,
                stroke: scene.pathTop,
                'stroke-width': '1'
            }));
            svg.appendChild(svgEl('line', {
                x1: RIVER_RIGHT + 6,
                y1: PATH_TOP + 1,
                x2: W + SCENE_EXT,
                y2: PATH_TOP + 1,
                stroke: scene.pathTop,
                'stroke-width': '1'
            }));

            const leftTreeXs = [0.2, 0.5, 0.8].map((p) => RIVER_LEFT * p);
            const rightTreeXs = [0.2, 0.5, 0.8].map((p) => RIVER_RIGHT + (W - RIVER_RIGHT) * p);
            const treeScales = [0.74, 0.84, 0.78];

            // Trees just below horizon, evenly distributed
            leftTreeXs.forEach((x, i) => drawTree(x, TREE_LINE_Y + (i % 2 === 0 ? -2 : 2), treeScales[i % treeScales.length], scene));
            rightTreeXs.forEach((x, i) => drawTree(x, TREE_LINE_Y + (i % 2 === 1 ? -2 : 2), treeScales[(i + 1) % treeScales.length], scene));

            const leftBushXs = [0.17, 0.39, 0.61, 0.83].map((p) => RIVER_LEFT * p);
            const rightBushXs = [0.17, 0.39, 0.61, 0.83].map((p) => RIVER_RIGHT + (W - RIVER_RIGHT) * p);
            const leftFlowerXs = [0.1, 0.28, 0.46, 0.64, 0.82].map((p) => RIVER_LEFT * p);
            const rightFlowerXs = [0.1, 0.28, 0.46, 0.64, 0.82].map((p) => RIVER_RIGHT + (W - RIVER_RIGHT) * p);

            // Bushes below path
            leftBushXs.forEach((x, i) => drawBush(x, BUSH_LINE_Y + (i % 2 === 0 ? 2 : -1), scene));
            rightBushXs.forEach((x, i) => drawBush(x, BUSH_LINE_Y + (i % 2 === 1 ? 2 : -1), scene));

            // Flowers further below bushes
            const flowerPalette = darkMode
                ? ['#8ca7e8', '#b2b8d9', '#8f98c8', '#8ca7e8', '#b2b8d9']
                : ['#ff6b9d', '#ffb347', '#c792ea', '#ff6b9d', '#ffb347'];
            leftFlowerXs.forEach((x, i) => drawFlower(x, FLOWER_LINE_Y + (i % 2 === 0 ? 2 : -2), flowerPalette[i % flowerPalette.length], scene));
            rightFlowerXs.forEach((x, i) => drawFlower(x, FLOWER_LINE_Y + (i % 2 === 1 ? 2 : -2), flowerPalette[(i + 2) % flowerPalette.length], scene));

            // Pebbles on sandbanks near the river edges (not in bush area)
            svg.appendChild(svgEl('ellipse', { cx: RIVER_LEFT - 9, cy: GROUND_Y + 10, rx: 6.5, ry: 3.8, fill: scene.rockA }));
            svg.appendChild(svgEl('ellipse', { cx: RIVER_LEFT - 20, cy: GROUND_Y + 14, rx: 5.5, ry: 3.2, fill: scene.rockB }));
            svg.appendChild(svgEl('ellipse', { cx: RIVER_RIGHT + 9, cy: GROUND_Y + 10, rx: 6.5, ry: 3.8, fill: scene.rockA }));
            svg.appendChild(svgEl('ellipse', { cx: RIVER_RIGHT + 20, cy: GROUND_Y + 14, rx: 5.5, ry: 3.2, fill: scene.rockB }));

        }

        function drawCloud(x, y, scale, scene) {
            const g = svgEl('g', { transform: `translate(${x},${y}) scale(${scale})`, opacity: scene.cloudOpacity });
            g.appendChild(svgEl('ellipse', { cx: 0, cy: 0, rx: 35, ry: 18, fill: scene.cloud }));
            g.appendChild(svgEl('ellipse', { cx: -20, cy: 5, rx: 22, ry: 13, fill: scene.cloud }));
            g.appendChild(svgEl('ellipse', { cx: 22, cy: 5, rx: 25, ry: 14, fill: scene.cloud }));
            g.appendChild(svgEl('ellipse', { cx: 5, cy: -8, rx: 20, ry: 12, fill: scene.cloud }));
            svg.appendChild(g);
        }

        function drawTree(x, y, scale, scene) {
            const g = svgEl('g', { transform: `translate(${x},${y}) scale(${scale})` });
            // Trunk
            g.appendChild(svgEl('rect', { x: -5, y: -45, width: 10, height: 50, fill: scene.treeTrunk, rx: 3 }));
            // Foliage layers
            g.appendChild(svgEl('ellipse', { cx: 0, cy: -55, rx: 28, ry: 22, fill: scene.treeLeafA }));
            g.appendChild(svgEl('ellipse', { cx: -10, cy: -50, rx: 20, ry: 18, fill: scene.treeLeafB }));
            g.appendChild(svgEl('ellipse', { cx: 10, cy: -48, rx: 18, ry: 16, fill: scene.treeLeafC }));
            g.appendChild(svgEl('ellipse', { cx: 0, cy: -65, rx: 15, ry: 12, fill: scene.treeLeafD }));
            svg.appendChild(g);
        }

        function drawFlower(x, y, color, scene) {
            const g = svgEl('g', { transform: `translate(${x},${y})` });
            // Stem
            g.appendChild(svgEl('line', { x1: 0, y1: 0, x2: 0, y2: -14, stroke: scene.flowerStem, 'stroke-width': '2', 'stroke-linecap': 'round' }));
            // Petals
            for (let i = 0; i < 5; i++) {
                const a = (i * 72) * Math.PI / 180;
                g.appendChild(svgEl('circle', { cx: Math.cos(a) * 4, cy: -14 + Math.sin(a) * 4, r: 3, fill: color, opacity: '0.9' }));
            }
            // Centre
            g.appendChild(svgEl('circle', { cx: 0, cy: -14, r: 2.5, fill: scene.flowerCenter }));
            svg.appendChild(g);
        }

        function drawBush(x, y, scene) {
            const g = svgEl('g', { transform: `translate(${x},${y})` });
            g.appendChild(svgEl('ellipse', { cx: 0, cy: 0, rx: 18, ry: 12, fill: scene.bushA }));
            g.appendChild(svgEl('ellipse', { cx: -8, cy: -3, rx: 12, ry: 9, fill: scene.bushB }));
            g.appendChild(svgEl('ellipse', { cx: 8, cy: -2, rx: 14, ry: 10, fill: scene.bushC }));
            svg.appendChild(g);
        }

        // ========================================
        // DRAW DYNAMIC ENTITIES
        // ========================================
        let dynamicGroup = null;

        function clearDynamic() {
            if (dynamicGroup) dynamicGroup.remove();
            dynamicGroup = svgEl('g', { id: 'dynamic' });
            svg.appendChild(dynamicGroup);
        }

        function boatHelmOffset() {
            return -18 * state.boat.facing;
        }

        function boatCargoOffset() {
            return 18 * state.boat.facing;
        }

        function boatHelmX() {
            return state.boat.x + boatHelmOffset();
        }

        function boatCargoX() {
            return state.boat.x + boatCargoOffset();
        }

        // ---- BOAT ----
        function drawBoat(x, y, bobOffset, facing) {
            const by = y + bobOffset;
            const g = svgEl('g', { transform: `translate(${x},${by}) scale(${facing},1)` });

            // Ferry hull (flat-ish, shallow, open)
            const hull = svgEl('path', {
                d: 'M-34,0 L-30,-8 L30,-8 L34,0 L26,8 L-26,8 Z',
                fill: '#8b6a45', stroke: '#5e4025', 'stroke-width': '1.5'
            });
            g.appendChild(hull);

            // Deck surface
            g.appendChild(svgEl('rect', { x: -26, y: -8, width: 52, height: 13, fill: '#9d7b54', rx: 2 }));

            // Hull rim
            g.appendChild(svgEl('line', { x1: -30, y1: -8, x2: 30, y2: -8, stroke: '#5e4025', 'stroke-width': '1.2' }));

            // Mast and mainsail
            g.appendChild(svgEl('line', { x1: -2, y1: -8, x2: -2, y2: -36, stroke: '#6b4728', 'stroke-width': '2.2', 'stroke-linecap': 'round' }));
            g.appendChild(svgEl('path', {
                d: 'M-1,-34 L16,-24 L-1,-14 Z',
                fill: '#fff7dd',
                stroke: '#d9caa0',
                'stroke-width': '1'
            }));
            g.appendChild(svgEl('line', { x1: -1, y1: -34, x2: -1, y2: -14, stroke: '#d9caa0', 'stroke-width': '0.8' }));

            // Helm marker (shore-side end)
            g.appendChild(svgEl('rect', { x: -26, y: -7, width: 10, height: 10, fill: 'none', stroke: '#f4d690', 'stroke-width': '1.4', rx: 1.6 }));
            g.appendChild(svgEl('line', { x1: -21, y1: -7, x2: -21, y2: -15, stroke: '#f4d690', 'stroke-width': '1' }));
            g.appendChild(svgEl('circle', { cx: -21, cy: -16.5, r: 2.1, fill: 'none', stroke: '#f4d690', 'stroke-width': '1' }));

            // Inventory slot marker (river-side end)
            g.appendChild(svgEl('rect', { x: 16, y: -7, width: 10, height: 10, fill: 'none', stroke: '#c4a265', 'stroke-width': '1.2', rx: 1.5 }));
            g.appendChild(svgEl('line', { x1: 18, y1: -2, x2: 24, y2: -2, stroke: '#c4a265', 'stroke-width': '1' }));
            g.appendChild(svgEl('line', { x1: 21, y1: -5, x2: 21, y2: 1, stroke: '#c4a265', 'stroke-width': '1' }));

            dynamicGroup.appendChild(g);
        }

        // ---- FARMER ----
        function drawFarmer(x, y, facing, walkFrame, carrying) {
            const g = svgEl('g', { transform: `translate(${x},${y}) scale(${facing},1)` });

            // Body bounce
            const bounce = Math.abs(Math.sin(walkFrame * 0.3)) * 2;

            // Legs
            const legSwing = Math.sin(walkFrame * 0.35) * 8;
            g.appendChild(svgEl('line', { x1: -3, y1: -bounce, x2: -3 - legSwing, y2: 16, stroke: '#4a6fa5', 'stroke-width': '4', 'stroke-linecap': 'round' }));
            g.appendChild(svgEl('line', { x1: 3, y1: -bounce, x2: 3 + legSwing, y2: 16, stroke: '#4a6fa5', 'stroke-width': '4', 'stroke-linecap': 'round' }));

            // Boots
            g.appendChild(svgEl('circle', { cx: -3 - legSwing, cy: 17, r: 3, fill: '#5c3b1e' }));
            g.appendChild(svgEl('circle', { cx: 3 + legSwing, cy: 17, r: 3, fill: '#5c3b1e' }));

            // Torso
            g.appendChild(svgEl('rect', { x: -7, y: -20 - bounce, width: 14, height: 22, fill: '#e8785e', rx: 4 }));

            // Overall straps
            g.appendChild(svgEl('line', { x1: -4, y1: -18 - bounce, x2: -4, y2: -6 - bounce, stroke: '#c4a265', 'stroke-width': '1.5' }));
            g.appendChild(svgEl('line', { x1: 4, y1: -18 - bounce, x2: 4, y2: -6 - bounce, stroke: '#c4a265', 'stroke-width': '1.5' }));

            // Arms
            const armSwing = Math.sin(walkFrame * 0.35) * 6;
            if (carrying) {
                // Carrying arm holding up
                g.appendChild(svgEl('line', { x1: 7, y1: -14 - bounce, x2: 14, y2: -22 - bounce, stroke: '#f0a890', 'stroke-width': '3', 'stroke-linecap': 'round' }));
                g.appendChild(svgEl('line', { x1: -7, y1: -14 - bounce, x2: -12, y2: -8 - bounce + armSwing, stroke: '#f0a890', 'stroke-width': '3', 'stroke-linecap': 'round' }));
            } else {
                g.appendChild(svgEl('line', { x1: 7, y1: -14 - bounce, x2: 12, y2: -6 - bounce - armSwing, stroke: '#f0a890', 'stroke-width': '3', 'stroke-linecap': 'round' }));
                g.appendChild(svgEl('line', { x1: -7, y1: -14 - bounce, x2: -12, y2: -6 - bounce + armSwing, stroke: '#f0a890', 'stroke-width': '3', 'stroke-linecap': 'round' }));
            }

            // Head
            g.appendChild(svgEl('circle', { cx: 0, cy: -27 - bounce, r: 9, fill: '#f0a890' }));

            // Eyes
            g.appendChild(svgEl('circle', { cx: 3, cy: -28 - bounce, r: 1.8, fill: '#333' }));
            // Eye shine
            g.appendChild(svgEl('circle', { cx: 3.8, cy: -28.8 - bounce, r: 0.6, fill: '#fff' }));

            // Happy mouth
            g.appendChild(svgEl('path', { d: `M1,${-24 - bounce} Q4,${-21.5 - bounce} 7,${-24 - bounce}`, fill: 'none', stroke: '#c0705a', 'stroke-width': '1.2', 'stroke-linecap': 'round' }));

            // Cute blush
            g.appendChild(svgEl('ellipse', { cx: 6, cy: -25 - bounce, rx: 2.5, ry: 1.5, fill: '#ff9999', opacity: '0.4' }));

            // Straw hat
            g.appendChild(svgEl('ellipse', { cx: 0, cy: -34 - bounce, rx: 14, ry: 4, fill: '#F4D35E' }));
            g.appendChild(svgEl('rect', { x: -7, y: -40 - bounce, width: 14, height: 7, fill: '#F4D35E', rx: 3 }));
            g.appendChild(svgEl('rect', { x: -7, y: -36 - bounce, width: 14, height: 2, fill: '#e8785e', rx: 1 }));

            // If carrying, draw item above head
            if (carrying) {
                drawCarriedItem(g, carrying, 10, -44 - bounce);
            }

            dynamicGroup.appendChild(g);
        }

        function drawCarriedItem(parent, type, x, y) {
            const g = svgEl('g', { transform: `translate(${x},${y}) scale(0.6)` });
            if (type === 'wolf') drawWolfShape(g, 0, 0);
            else if (type === 'goat') drawGoatShape(g, 0, 0);
            else if (type === 'cabbage') drawCabbageShape(g, 0, 0);
            parent.appendChild(g);
        }

        // ---- WOLF ----
        function drawWolf(x, y, bobFrame) {
            const g = svgEl('g', { transform: `translate(${x},${y})` });
            const bob = Math.sin(bobFrame * 0.05) * 1.5;
            const tailWag = Math.sin(bobFrame * 0.15) * 12;

            // Tail
            g.appendChild(svgEl('path', {
                d: `M-10,${-8 + bob} Q${-22},${-18 + bob + tailWag} ${-16},${-25 + bob}`,
                fill: 'none', stroke: '#7a7a8a', 'stroke-width': '3', 'stroke-linecap': 'round'
            }));

            drawWolfShape(g, 0, bob);
            dynamicGroup.appendChild(g);
        }

        function drawWolfShape(g, ox, oy) {
            // Body
            g.appendChild(svgEl('ellipse', { cx: ox, cy: oy - 5, rx: 16, ry: 10, fill: '#8a8a9a' }));
            // Belly
            g.appendChild(svgEl('ellipse', { cx: ox, cy: oy - 2, rx: 12, ry: 6, fill: '#b0b0c0' }));

            // Legs
            g.appendChild(svgEl('rect', { x: ox - 10, y: oy + 2, width: 5, height: 10, fill: '#7a7a8a', rx: 2 }));
            g.appendChild(svgEl('rect', { x: ox + 5, y: oy + 2, width: 5, height: 10, fill: '#7a7a8a', rx: 2 }));

            // Head
            g.appendChild(svgEl('circle', { cx: ox + 14, cy: oy - 10, r: 8, fill: '#8a8a9a' }));
            // Snout
            g.appendChild(svgEl('ellipse', { cx: ox + 20, cy: oy - 8, rx: 5, ry: 3.5, fill: '#b0b0c0' }));
            // Nose
            g.appendChild(svgEl('circle', { cx: ox + 23, cy: oy - 8, r: 2, fill: '#333' }));

            // Eyes
            g.appendChild(svgEl('circle', { cx: ox + 16, cy: oy - 12, r: 2, fill: '#FFD93D' }));
            g.appendChild(svgEl('circle', { cx: ox + 16, cy: oy - 12, r: 1, fill: '#333' }));

            // Ears
            g.appendChild(svgEl('polygon', { points: `${ox + 10},${oy - 16} ${ox + 12},${oy - 24} ${ox + 16},${oy - 16}`, fill: '#7a7a8a' }));
            g.appendChild(svgEl('polygon', { points: `${ox + 14},${oy - 16} ${ox + 17},${oy - 23} ${ox + 20},${oy - 16}`, fill: '#7a7a8a' }));

            // Inner ears
            g.appendChild(svgEl('polygon', { points: `${ox + 11},${oy - 17} ${ox + 12.5},${oy - 22} ${ox + 15},${oy - 17}`, fill: '#c0a0a0', opacity: '0.6' }));
        }

        // ---- GOAT ----
        function drawGoat(x, y, bobFrame) {
            const g = svgEl('g', { transform: `translate(${x},${y})` });
            const bob = Math.sin(bobFrame * 0.06 + 1) * 1.5;

            drawGoatShape(g, 0, bob);
            dynamicGroup.appendChild(g);
        }

        function drawGoatShape(g, ox, oy) {
            // Body
            g.appendChild(svgEl('ellipse', { cx: ox, cy: oy - 4, rx: 14, ry: 9, fill: '#f5f0e8' }));

            // Legs
            g.appendChild(svgEl('rect', { x: ox - 8, y: oy + 3, width: 4, height: 10, fill: '#e8e0d4', rx: 2 }));
            g.appendChild(svgEl('rect', { x: ox + 4, y: oy + 3, width: 4, height: 10, fill: '#e8e0d4', rx: 2 }));
            // Hooves
            g.appendChild(svgEl('rect', { x: ox - 9, y: oy + 11, width: 6, height: 3, fill: '#6B3E1C', rx: 1 }));
            g.appendChild(svgEl('rect', { x: ox + 3, y: oy + 11, width: 6, height: 3, fill: '#6B3E1C', rx: 1 }));

            // Head
            g.appendChild(svgEl('circle', { cx: ox + 12, cy: oy - 8, r: 7, fill: '#f5f0e8' }));

            // Horns
            g.appendChild(svgEl('path', { d: `M${ox + 10},${oy - 14} Q${ox + 6},${oy - 23} ${ox + 8},${oy - 18}`, fill: 'none', stroke: '#c4a265', 'stroke-width': '2', 'stroke-linecap': 'round' }));
            g.appendChild(svgEl('path', { d: `M${ox + 14},${oy - 14} Q${ox + 18},${oy - 23} ${ox + 16},${oy - 18}`, fill: 'none', stroke: '#c4a265', 'stroke-width': '2', 'stroke-linecap': 'round' }));

            // Eye
            g.appendChild(svgEl('circle', { cx: ox + 15, cy: oy - 9, r: 1.8, fill: '#333' }));
            g.appendChild(svgEl('circle', { cx: ox + 15.5, cy: oy - 9.5, r: 0.5, fill: '#fff' }));

            // Nose
            g.appendChild(svgEl('ellipse', { cx: ox + 18, cy: oy - 6, rx: 2, ry: 1.5, fill: '#ddb8a0' }));

            // Cute smile
            g.appendChild(svgEl('path', { d: `M${ox + 15},${oy - 5} Q${ox + 17},${oy - 3.5} ${ox + 19},${oy - 5}`, fill: 'none', stroke: '#c0a080', 'stroke-width': '0.8', 'stroke-linecap': 'round' }));

            // Bell
            g.appendChild(svgEl('circle', { cx: ox + 4, cy: oy + 2, r: 3, fill: '#FFD93D', stroke: '#e0b820', 'stroke-width': '0.8' }));
            g.appendChild(svgEl('circle', { cx: ox + 4, cy: oy + 3, r: 1, fill: '#e0b820' }));

            // Blush
            g.appendChild(svgEl('ellipse', { cx: ox + 17, cy: oy - 6, rx: 2, ry: 1.2, fill: '#ffaaaa', opacity: '0.35' }));
        }

        // ---- CABBAGE ----
        function drawCabbage(x, y, bobFrame) {
            const g = svgEl('g', { transform: `translate(${x},${y})` });
            const bob = Math.sin(bobFrame * 0.04 + 2) * 1;
            drawCabbageShape(g, 0, bob);
            dynamicGroup.appendChild(g);
        }

        function drawCabbageShape(g, ox, oy) {
            // Outer leaves
            g.appendChild(svgEl('ellipse', { cx: ox - 5, cy: oy - 2, rx: 10, ry: 9, fill: '#7bc47b' }));
            g.appendChild(svgEl('ellipse', { cx: ox + 5, cy: oy - 2, rx: 10, ry: 9, fill: '#7bc47b' }));
            g.appendChild(svgEl('ellipse', { cx: ox, cy: oy - 6, rx: 9, ry: 10, fill: '#8fd48f' }));

            // Inner layers
            g.appendChild(svgEl('ellipse', { cx: ox, cy: oy - 4, rx: 7, ry: 7, fill: '#a3e4a3' }));
            g.appendChild(svgEl('ellipse', { cx: ox, cy: oy - 3, rx: 5, ry: 5, fill: '#c8f0c8' }));

            // Centre heart
            g.appendChild(svgEl('circle', { cx: ox, cy: oy - 4, r: 2.5, fill: '#e8ffe8' }));

            // Leaf veins
            g.appendChild(svgEl('path', { d: `M${ox},${oy - 4} Q${ox - 4},${oy + 2} ${ox - 7},${oy + 5}`, fill: 'none', stroke: '#5ba05b', 'stroke-width': '0.6', opacity: '0.5' }));
            g.appendChild(svgEl('path', { d: `M${ox},${oy - 4} Q${ox + 4},${oy + 2} ${ox + 7},${oy + 5}`, fill: 'none', stroke: '#5ba05b', 'stroke-width': '0.6', opacity: '0.5' }));

            // Cute face on cabbage
            g.appendChild(svgEl('circle', { cx: ox - 2, cy: oy - 5, r: 1, fill: '#2a6a2a' }));
            g.appendChild(svgEl('circle', { cx: ox + 2, cy: oy - 5, r: 1, fill: '#2a6a2a' }));
            g.appendChild(svgEl('path', { d: `M${ox - 1.5},${oy - 3} Q${ox},${oy - 1.5} ${ox + 1.5},${oy - 3}`, fill: 'none', stroke: '#2a6a2a', 'stroke-width': '0.7', 'stroke-linecap': 'round' }));
        }

        // ---- WATER RIPPLES ----
        function drawRipples(frame) {
            const rg = document.getElementById('waterRipples');
            if (!rg) return;
            rg.innerHTML = '';
            const scene = getScenePalette();
            for (let i = 0; i < 6; i++) {
                const xOff = (frame * 0.4 + i * 40) % (RIVER_RIGHT - RIVER_LEFT);
                const rx = RIVER_LEFT + xOff;
                const ry = WATER_Y + 20 + i * 15 + Math.sin(frame * 0.02 + i) * 5;
                rg.appendChild(svgEl('path', {
                    d: `M${rx - 12},${ry} Q${rx - 6},${ry - 3} ${rx},${ry} Q${rx + 6},${ry + 3} ${rx + 12},${ry}`,
                    fill: 'none', stroke: scene.ripple, 'stroke-width': '1.2', 'stroke-linecap': 'round', opacity: scene.rippleOpacity
                }));
            }
        }

        // ---- LEASH / ROPE ----
        function drawLeash(x1, y1, x2, y2) {
            const mx = (x1 + x2) / 2;
            const my = Math.max(y1, y2) + 8;
            dynamicGroup.appendChild(svgEl('path', {
                d: `M${x1},${y1} Q${mx},${my} ${x2},${y2}`,
                fill: 'none', stroke: '#c4a265', 'stroke-width': '2', 'stroke-linecap': 'round', 'stroke-dasharray': '4,3'
            }));
        }

        // ========================================
        // GAME LOGIC
        // ========================================
        function getItemObj(name) {
            return state[name];
        }

        function itemsOnSide(side) {
            const items = [];
            for (const name of ['wolf', 'goat', 'cabbage']) {
                if (state[name].side === side && state.farmer.carrying !== name && !state[name].onBoat) {
                    items.push(name);
                }
            }
            return items;
        }

        function checkFail() {
            if (state.gameOver) return;
            // Check each shore: if farmer is not there, check conflicts
            for (const side of ['left', 'right']) {
                const farmerHere = state.farmer.side === side && !state.farmer.onBoat;
                if (farmerHere) continue; // farmer present, no danger

                const items = itemsOnSide(side);
                if (items.includes('wolf') && items.includes('goat')) {
                    triggerFail('wolf', 'goat', 'The wolf ate the goat! üê∫üí®üêê');
                    return;
                }
                if (items.includes('goat') && items.includes('cabbage')) {
                    triggerFail('goat', 'cabbage', 'The goat ate the cabbage! üêêüí®ü•¨');
                    return;
                }
            }
        }

        function checkWin() {
            if (state.gameOver) return;
            for (const name of ['wolf', 'goat', 'cabbage']) {
                if (state[name].side !== 'right' || state[name].onBoat) return;
            }
            if (state.farmer.side !== 'right') return;
            state.gameOver = true;
            state.won = true;
            stopTimer();
            showWinModal();
        }

        function triggerFail(eater, eaten, msg) {
            state.gameOver = true;
            state.won = false;
            stopTimer();
            showFailModal(msg);
        }

        function centerDistanceSq(x1, y1, x2, y2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            return dx * dx + dy * dy;
        }

        function farmerNearBoat() {
            return Math.abs(state.farmer.x - state.boat.x) < 65 && state.farmer.y > WATER_Y - 60;
        }

        function farmerNearHelm() {
            return Math.abs(state.farmer.x - boatHelmX()) < 14;
        }

        function farmerNearCargo() {
            return Math.abs(state.farmer.x - boatCargoX()) < 14;
        }

        function handleHelmDirectionCommand(dir) {
            const boat = state.boat;

            if (boat.motionDir === -dir) {
                boat.motionDir = 0;
                showHud('Boat stopped');
                return;
            }

            if (boat.motionDir === 0) {
                if (boat.facing !== dir) {
                    boat.facing = dir;
                    showHud(dir === 1 ? 'Turned right' : 'Turned left');
                    return;
                }

                boat.motionDir = dir;
                boat.justArrived = false;
                startTimerIfNeeded();
                showHud(dir === 1 ? 'Boat moving right' : 'Boat moving left');
            }
        }

        function handleInteract() {
            if (state.gameOver) return;
            const f = state.farmer;

            // On-boat interactions are position-based: helm vs cargo end.
            if (f.onBoat) {
                if (f.helmAttached) {
                    f.helmAttached = false;
                    showHud('Detached from helm');
                    return;
                }

                if (farmerNearHelm()) {
                    if (f.carrying) {
                        showHud('You must place your passenger at cargo before steering');
                        return;
                    }
                    f.helmAttached = true;
                    f.x = boatHelmX();
                    f.y = state.boat.y - 20;
                    showHud('Attached to helm. Use A/D to control the boat');
                    return;
                }

                if (f.carrying && farmerNearCargo()) {
                    if (state.boatCargoItem) {
                        showHud('Cargo slot is full. Pick up current cargo first');
                        return;
                    }
                    const itemName = f.carrying;
                    const item = getItemObj(itemName);
                    item.onBoat = true;
                    item.side = state.boat.side;
                    item.x = boatCargoX();
                    item.y = state.boat.y - 10;
                    state.boatCargoItem = itemName;
                    f.carrying = null;
                    showHud(`Placed ${itemName} at the cargo end`);
                    return;
                }

                if (!f.carrying && state.boatCargoItem && farmerNearCargo()) {
                    const itemName = state.boatCargoItem;
                    f.carrying = itemName;
                    state[itemName].onBoat = false;
                    state.boatCargoItem = null;
                    showHud(`Picked up the ${itemName}`);
                    return;
                }

                if (f.carrying) {
                    showHud('Move to the cargo end to place your passenger');
                } else if (state.boatCargoItem) {
                    showHud('Move to cargo end to pick up, or helm to attach');
                } else {
                    showHud('Move to the helm end and press E to attach');
                }
                return;
            }

            // If carrying, drop
            if (f.carrying) {
                const droppedItemName = f.carrying;
                const item = getItemObj(droppedItemName);
                item.x = f.x;
                item.y = f.onBoat ? f.y + 5 : PATH_CENTER_Y - (f.carrying === 'cabbage' ? CABBAGE_FEET_OFFSET : f.carrying === 'goat' ? GOAT_FEET_OFFSET : WOLF_FEET_OFFSET);
                item.side = f.onBoat ? state.boat.side : f.side;
                item.onBoat = false;
                showHud(`Dropped the ${f.carrying}`);
                f.carrying = null;
                state.moves++;
                updateStats();
                // Check after dropping
                setTimeout(() => {
                    checkFail();
                    checkWin();
                }, 100);
                return;
            }

            // Try to pick up the nearest item center within range
            const pickupRadius = 35;
            const pickupRadiusSq = pickupRadius * pickupRadius;
            let nearestItem = null;
            let nearestDistSq = Infinity;
            for (const name of ['wolf', 'goat', 'cabbage']) {
                const item = state[name];
                if (item.onBoat) continue;
                const distSq = centerDistanceSq(f.x, f.y, item.x, item.y);
                if (distSq <= pickupRadiusSq && distSq < nearestDistSq) {
                    nearestDistSq = distSq;
                    nearestItem = name;
                }
            }

            if (nearestItem) {
                f.carrying = nearestItem;
                showHud(`Picked up the ${nearestItem}!`);
                state.moves++;
                updateStats();
                return;
            }

            showHud('Nothing nearby to interact with');
        }

        function updateBoat(dt) {
            const speedScale = dt * BASE_FPS;
            const boatStep = BOAT_SPEED * speedScale;
            const wasDockedSide = state.boat.side;

            if (state.boat.motionDir !== 0) {
                const previousHelmX = boatHelmX();
                const helmShift = state.farmer.x - previousHelmX;

                state.boat.facing = state.boat.motionDir;
                state.boat.x += state.boat.motionDir * boatStep;

                if (state.boat.x <= BOAT_LEFT_X) {
                    state.boat.x = BOAT_LEFT_X;
                    if (state.boat.motionDir < 0) state.boat.motionDir = 0;
                }
                if (state.boat.x >= BOAT_RIGHT_X) {
                    state.boat.x = BOAT_RIGHT_X;
                    if (state.boat.motionDir > 0) state.boat.motionDir = 0;
                }

                if (state.farmer.onBoat) {
                    if (state.farmer.helmAttached) {
                        state.farmer.x = boatHelmX();
                        state.farmer.y = state.boat.y - 20;
                    } else {
                        state.farmer.x = boatHelmX() + helmShift;
                    }
                }
            }

            if (state.boat.x <= BOAT_LEFT_X + 0.01) {
                state.boat.side = 'left';
            } else if (state.boat.x >= BOAT_RIGHT_X - 0.01) {
                state.boat.side = 'right';
            } else {
                state.boat.side = null;
            }

            if (state.farmer.onBoat && state.boat.side) {
                state.farmer.side = state.boat.side;
            }

            for (const name of ['wolf', 'goat', 'cabbage']) {
                if (state[name].onBoat) {
                    if (state.boat.side) state[name].side = state.boat.side;
                    state[name].x = boatCargoX();
                }
            }

            if (state.farmer.carrying && state.boat.side) {
                state[state.farmer.carrying].side = state.boat.side;
            }

            if (state.boat.side && state.boat.side !== wasDockedSide) {
                state.crossings++;
                updateStats();
                state.boat.justArrived = true;
                showHud('Docked. Press E at helm to attach/detach, A/D to steer');
                checkFail();
            }
        }

        function updateFarmer(dt) {
            if (state.gameOver) return;
            const f = state.farmer;
            const speedScale = dt * BASE_FPS;
            let dx = 0, dy = 0;

            if (keys.a) { dx -= 1; f.facing = -1; }
            if (keys.d) { dx += 1; f.facing = 1; }
            if (keys.w) dy -= 1;
            if (keys.s) dy += 1;

            if (f.onBoat) {
                if (f.helmAttached) {
                    f.x = boatHelmX();
                    f.y = state.boat.y - 20;
                    return;
                }

                if (state.boat.motionDir !== 0 && dx === 0 && dy === 0) return;

                if (dx === 0 && dy === 0) return;

                state.walkCycle += speedScale;

                // Move freely within boat deck bounds (both axes)
                const newX = f.x + dx * FARMER_SPEED * speedScale;
                const newY = f.y + dy * FARMER_SPEED * 0.6 * speedScale;
                const minDeckX = Math.min(boatHelmX(), boatCargoX()) - 14;
                const maxDeckX = Math.max(boatHelmX(), boatCargoX()) + 14;
                const minDeckY = state.boat.y - 34;
                const maxDeckY = state.boat.y - 8;
                f.x = Math.max(minDeckX, Math.min(maxDeckX, newX));
                f.y = Math.max(minDeckY, Math.min(maxDeckY, newY));

                // Disembark only at the explicit shore-side edge while pushing outward
                const wantsLeft = dx < 0;
                const wantsRight = dx > 0;
                if (state.boat.side === 'left' && wantsLeft && f.x <= minDeckX + 1) {
                    f.onBoat = false;
                    f.helmAttached = false;
                    f.side = 'left';
                    // Strictly preserve horizontal continuity; only re-align feet vertically.
                    f.y = PATH_CENTER_Y - FARMER_FEET_OFFSET;
                    showHud('Stepped ashore');
                    checkFail();
                }
                if (state.boat.side === 'right' && wantsRight && f.x >= maxDeckX - 1) {
                    f.onBoat = false;
                    f.helmAttached = false;
                    f.side = 'right';
                    // Strictly preserve horizontal continuity; only re-align feet vertically.
                    f.y = PATH_CENTER_Y - FARMER_FEET_OFFSET;
                    showHud('Stepped ashore');
                    checkFail();
                }
                return;
            }

            if (dx === 0 && dy === 0) return;

            state.walkCycle += speedScale;

            let newX = f.x + dx * FARMER_SPEED * speedScale;
            let newY = f.y + dy * FARMER_SPEED * 0.5 * speedScale;
            const viewBox = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : null;
            const walkMinX = viewBox ? viewBox.x + 20 : 20;
            const walkMaxX = viewBox ? (viewBox.x + viewBox.width - 20) : (W - 20);

            // Boundaries ‚Äî allow walking right up to the dock/river edge
            if (f.side === 'left') {
                const edgeLimit = state.boat.motionDir === 0 && state.boat.side === 'left' ? state.boat.x : RIVER_LEFT;
                newX = Math.max(walkMinX, Math.min(edgeLimit, newX));
            } else {
                const edgeLimit = state.boat.motionDir === 0 && state.boat.side === 'right' ? state.boat.x : RIVER_RIGHT;
                newX = Math.max(edgeLimit, Math.min(walkMaxX, newX));
            }
            const minFeetY = PATH_CENTER_Y;
            const maxFeetY = PATH_CENTER_Y;
            newY = Math.max(minFeetY - FARMER_FEET_OFFSET, Math.min(maxFeetY - FARMER_FEET_OFFSET, newY));

            f.x = newX;
            f.y = newY;

            // Auto-board when crossing onto the docked deck edge (no horizontal snap)
            const movingTowardBoat = (f.side === 'left' && dx > 0) || (f.side === 'right' && dx < 0);
            const minDeckX = Math.min(boatHelmX(), boatCargoX()) - 14;
            const maxDeckX = Math.max(boatHelmX(), boatCargoX()) + 14;
            const crossedDeckEdge = (f.side === 'left' && f.x >= minDeckX) || (f.side === 'right' && f.x <= maxDeckX);
            if (!f.onBoat && state.boat.motionDir === 0 && state.boat.side === f.side && movingTowardBoat && crossedDeckEdge) {
                f.onBoat = true;
                f.helmAttached = false;
                // Preserve x for a seamless transition; only align vertically to boat deck center.
                f.y = state.boat.y - 18;
                showHud('Boarded the boat! Move to helm and press E to attach');
                startTimerIfNeeded();
                state.moves++;
                updateStats();
                return;
            }
        }

        // ========================================
        // RENDERING
        // ========================================
        function render() {
            clearDynamic();

            const bobOff = Math.sin(state.bobPhase + state.animFrame * 0.04) * 3;

            drawRipples(state.animFrame);

            // Draw boat
            drawBoat(state.boat.x, state.boat.y, bobOff, state.boat.facing);

            // Draw items (not carried, not on boat separately shown near boat)
            for (const name of ['wolf', 'goat', 'cabbage']) {
                const item = state[name];
                if (state.farmer.carrying === name) continue; // drawn with farmer

                let ix = item.x;
                let iy = item.y;

                if (item.onBoat) {
                    ix = boatCargoX();
                    iy = state.boat.y - 10 + bobOff;
                }

                if (name === 'wolf') drawWolf(ix, iy, state.animFrame);
                else if (name === 'goat') drawGoat(ix, iy, state.animFrame);
                else drawCabbage(ix, iy, state.animFrame);

                // Draw leash if farmer is nearby and carrying this
                if (state.farmer.carrying === name) {
                    drawLeash(state.farmer.x, state.farmer.y - 10, ix, iy);
                }
            }

            // Draw farmer
            drawFarmer(
                state.farmer.x,
                state.farmer.onBoat ? state.boat.y - 18 + bobOff : state.farmer.y,
                state.farmer.facing,
                state.walkCycle,
                state.farmer.carrying
            );
        }

        // ========================================
        // GAME LOOP
        // ========================================
        let timerInterval = null;
        let lastFrameTime = 0;
        let accumulator = 0;

        function stepSimulation(dt) {
            if (!state.gameOver) {
                if (state.farmer.onBoat && state.farmer.helmAttached) {
                    if (aJustPressed) handleHelmDirectionCommand(-1);
                    if (dJustPressed) handleHelmDirectionCommand(1);
                }

                updateFarmer(dt);
                updateBoat(dt);

                if (eJustPressed) {
                    handleInteract();
                }

                eJustPressed = false;
                aJustPressed = false;
                dJustPressed = false;
            }

            state.animFrame += dt * BASE_FPS;
        }

        function startTimerIfNeeded() {
            if (state.timerRunning) return;
            state.startTime = Date.now();
            state.timerRunning = true;
        }

        function stopTimer() {
            state.timerRunning = false;
        }

        function updateStats() {
            document.getElementById('movesCount').textContent = state.moves;
            document.getElementById('crossingsCount').textContent = state.crossings;
            if (state.timerRunning) {
                state.elapsed = Math.floor((Date.now() - state.startTime) / 1000);
            }
            document.getElementById('timeCount').textContent = state.elapsed + 's';
        }

        function gameLoop(timestamp) {
            if (!lastFrameTime) lastFrameTime = timestamp;
            let frameDt = (timestamp - lastFrameTime) / 1000;
            lastFrameTime = timestamp;
            frameDt = Math.min(frameDt, 0.25);
            accumulator += frameDt;

            while (accumulator >= FIXED_DT) {
                stepSimulation(FIXED_DT);
                accumulator -= FIXED_DT;
            }

            render();
            updateStats();
            requestAnimationFrame(gameLoop);
        }

        // ========================================
        // HUD
        // ========================================
        let hudTimeout = null;
        function showHud(msg) {
            const hud = document.getElementById('hud');
            hud.textContent = msg;
            hud.classList.remove('hidden');
            clearTimeout(hudTimeout);
            hudTimeout = setTimeout(() => hud.classList.add('hidden'), 3000);
        }

        // ========================================
        // MODALS
        // ========================================
        let resultViewMode = null;

        function showWinModal() {
            const score = calculateScore();
            document.getElementById('finalScore').textContent = `Score: ${score}`;
            document.getElementById('finalStats').innerHTML = `<strong>${state.moves} moves, ${state.crossings} crossings in ${state.elapsed}s</strong>`;
            resultViewMode = null;
            document.getElementById('winModal').classList.add('open');
        }

        function showFailModal(msg) {
            document.getElementById('failMessage').textContent = msg;
            document.getElementById('failDetails').textContent = `After ${state.moves} moves and ${state.crossings} crossings`;
            resultViewMode = null;
            document.getElementById('failModal').classList.add('open');
        }

        function reopenResultModalIfViewing() {
            if (!state.gameOver || !resultViewMode) return;
            if (resultViewMode === 'win') {
                document.getElementById('winModal').classList.add('open');
            } else if (resultViewMode === 'fail') {
                document.getElementById('failModal').classList.add('open');
            }
            resultViewMode = null;
        }

        function calculateScore() {
            const base = 1000;
            const movePenalty = state.moves * 15;
            const timePenalty = Math.floor(state.elapsed / 2);
            return Math.max(0, base - movePenalty - timePenalty);
        }

        function buildShareText() {
            const emojis = ['üê∫', 'üêê', 'ü•¨'];
            const result = state.won ? '‚úÖ' : '‚ùå';
            const score = state.won ? calculateScore() : 0;
            return `üö£ River Crossing ${result}\nScore: ${score}\nMoves: ${state.moves} | Crossings: ${state.crossings} | Time: ${state.elapsed}s\n${emojis.join(' ')} ‚Üí üèûÔ∏è`;
        }

        // ---- Event listeners ----
        document.getElementById('newGameBtn').addEventListener('click', startNewGame);
        document.getElementById('helpBtn').addEventListener('click', () => {
            document.getElementById('helpModal').classList.add('open');
        });
        document.getElementById('closeHelpBtn').addEventListener('click', () => {
            document.getElementById('helpModal').classList.remove('open');
        });
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            document.getElementById('winModal').classList.remove('open');
            resultViewMode = null;
            startNewGame();
        });
        document.getElementById('tryAgainBtn').addEventListener('click', () => {
            document.getElementById('failModal').classList.remove('open');
            resultViewMode = null;
            startNewGame();
        });

        document.getElementById('viewResultBtn').addEventListener('click', () => {
            document.getElementById('winModal').classList.remove('open');
            resultViewMode = 'win';
        });

        document.getElementById('viewFailResultBtn').addEventListener('click', () => {
            document.getElementById('failModal').classList.remove('open');
            resultViewMode = 'fail';
        });

        document.getElementById('gameViewport').addEventListener('click', () => {
            reopenResultModalIfViewing();
        });
        document.getElementById('touchControls').addEventListener('click', () => {
            reopenResultModalIfViewing();
        });

        document.getElementById('shareScoreBtn').addEventListener('click', async () => {
            const text = `${buildShareText()}\n${window.location.href}`;
            const shareStatus = document.getElementById('shareStatus');
            let copied = false;
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'River Crossing', text });
                } catch {
                    try { await navigator.clipboard.writeText(text); copied = true; } catch {}
                }
            } else {
                try { await navigator.clipboard.writeText(text); copied = true; } catch {}
            }
            if (copied) {
                shareStatus.textContent = 'Copied to clipboard!';
                setTimeout(() => { shareStatus.textContent = ''; }, 2500);
            }
        });

        // Close modals on backdrop click
        for (const id of ['helpModal', 'winModal', 'failModal']) {
            document.getElementById(id).addEventListener('click', (e) => {
                if (e.target.id === id) e.target.classList.remove('open');
            });
        }

        // Escape to close modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                for (const id of ['helpModal', 'winModal', 'failModal']) {
                    document.getElementById(id).classList.remove('open');
                }
            }
        });

        // ---- Theme toggle ----
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = document.getElementById('themeIcon');
        const systemThemeQuery = window.matchMedia('(prefers-color-scheme: dark)');
        const THEME_MODE_KEY = 'idlegames-rivercrossing-theme-mode';
        let themeMode = localStorage.getItem(THEME_MODE_KEY);
        if (!themeMode) {
            const legacyTheme = localStorage.getItem('idlegames-rivercrossing-theme');
            themeMode = (legacyTheme === 'light' || legacyTheme === 'dark') ? legacyTheme : 'system';
        }

        function repaintWorldForTheme() {
            svg.innerHTML = '';
            drawScenery();
            render();
            fitCanvas();
        }

        function applyTheme(mode) {
            const resolvedTheme = mode === 'system'
                ? (systemThemeQuery.matches ? 'dark' : 'light')
                : mode;

            document.documentElement.setAttribute('data-theme', resolvedTheme);
            const moon = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
            const sun = '<circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>';
            const system = '<rect x="3" y="4" width="18" height="12" rx="2"/><line x1="8" y1="20" x2="16" y2="20"/><line x1="12" y1="16" x2="12" y2="20"/>';
            themeIcon.innerHTML = mode === 'system' ? system : (resolvedTheme === 'dark' ? moon : sun);
            themeToggle.title = `Theme: ${mode[0].toUpperCase()}${mode.slice(1)}`;
            themeToggle.setAttribute('aria-label', `Theme mode: ${mode}`);
        }

        applyTheme(themeMode);
        repaintWorldForTheme();

        const themeModes = ['system', 'light', 'dark'];

        themeToggle.addEventListener('click', () => {
            const nextIndex = (themeModes.indexOf(themeMode) + 1) % themeModes.length;
            themeMode = themeModes[nextIndex];
            localStorage.setItem(THEME_MODE_KEY, themeMode);
            applyTheme(themeMode);
            repaintWorldForTheme();
        });

        const handleSystemThemeChange = () => {
            if (themeMode !== 'system') return;
            applyTheme(themeMode);
            repaintWorldForTheme();
        };
        if (typeof systemThemeQuery.addEventListener === 'function') {
            systemThemeQuery.addEventListener('change', handleSystemThemeChange);
        } else if (typeof systemThemeQuery.addListener === 'function') {
            systemThemeQuery.addListener(handleSystemThemeChange);
        }

        // ---- Resize ----
        function fitCanvas() {
            const vp = document.getElementById('gameViewport');
            const rect = vp.getBoundingClientRect();
            const stage = document.getElementById('gameStage');
            stage.style.width = '100%';
            stage.style.height = '100%';

            const viewportAspect = rect.width / Math.max(1, rect.height);
            const worldAspect = W / H;

            let viewX = 0;
            let viewY = 0;
            let viewW = W;
            let viewH = H;

            if (viewportAspect > worldAspect) {
                viewW = H * viewportAspect;
                viewX = -(viewW - W) / 2;
            } else if (viewportAspect < worldAspect) {
                viewH = W / viewportAspect;
                const skyRatio = GROUND_Y / H;
                const topExtra = (viewH - H) * skyRatio;
                viewY = -topExtra;
            }

            svg.setAttribute('viewBox', `${viewX} ${viewY} ${viewW} ${viewH}`);
        }

        window.addEventListener('resize', fitCanvas);

        // ---- Start ----
        function startNewGame() {
            // Close modals
            for (const id of ['helpModal', 'winModal', 'failModal']) {
                document.getElementById(id).classList.remove('open');
            }
            resultViewMode = null;

            // Reset input latches so no previous interaction carries into new game
            keys.w = false;
            keys.a = false;
            keys.s = false;
            keys.d = false;
            keys.e = false;
            eJustPressed = false;
            aJustPressed = false;
            dJustPressed = false;

            state = freshState();
            state.farmer.carrying = null;
            updateStats();

            // Clear and redraw scenery
            svg.innerHTML = '';
            drawScenery();
            render();

            showHud('Use WASD to move, E to interact');
            fitCanvas();
        }

        function init() {
            startNewGame();
            requestAnimationFrame(gameLoop);

            // Show help on first visit
            if (!localStorage.getItem('idlegames-rivercrossing-played')) {
                document.getElementById('helpModal').classList.add('open');
                localStorage.setItem('idlegames-rivercrossing-played', '1');
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            setTimeout(init, 0);
        }
    </script>
    <script src="parental.js" defer></script>
</body>
</html>
