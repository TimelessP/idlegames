<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b1e40">
  <meta name="application-name" content="IdleGames">
  <script src="assets/js/pwa.js" defer></script>
  <title>Voxel Paint Studio</title>
  <style>
    :root {
      color-scheme: dark light;
      --bg-top: #0f172a;
      --bg-bottom: #1e293b;
      --toolbar-bg: rgba(15, 23, 42, 0.88);
      --toolbar-border: rgba(148, 163, 184, 0.2);
      --accent: #38bdf8;
      --danger: #f87171;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      background: linear-gradient(var(--bg-top), var(--bg-bottom));
      color: #e2e8f0;
      overscroll-behavior: none;
    }

    .app {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    .viewport {
      width: 100%;
      height: 100%;
      touch-action: none;
      position: relative;
    }

    .viewport canvas {
      display: block;
    }

    .toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px;
      background: var(--toolbar-bg);
      border: 1px solid var(--toolbar-border);
      border-radius: 10px;
      backdrop-filter: blur(10px);
      z-index: 10;
      max-width: min(320px, 92vw);
    }

    .tool-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .tool-btn {
      border: 1px solid transparent;
      background: rgba(15, 23, 42, 0.6);
      color: #e2e8f0;
      border-radius: 8px;
      width: 38px;
      height: 38px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }

    .tool-btn svg {
      width: 22px;
      height: 22px;
      fill: currentColor;
    }

    .tool-btn.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.2);
    }

    .tool-btn.danger {
      color: var(--danger);
    }

    .tool-btn:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .palette {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .swatch {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 2px solid rgba(255, 255, 255, 0.15);
      cursor: pointer;
      padding: 0;
      background: transparent;
    }

    .swatch.active {
      border-color: var(--accent);
    }

    .color-picker,
    .gradient-controls,
    .ambient-control {
      display: flex;
      gap: 6px;
      margin-top: 6px;
    }

    .color-picker input,
    .gradient-controls input,
    .ambient-control input,
    .sun-control input[type="color"] {
      width: 38px;
      height: 38px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 8px;
      background: transparent;
      padding: 0;
    }

    .sun-control {
      display: flex;
      gap: 6px;
      margin-top: 6px;
      align-items: center;
    }

    .sun-control input[type="range"] {
      width: 110px;
      accent-color: var(--accent);
    }

    .floor-controls {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 9;
    }

    .floor-controls button {
      pointer-events: auto;
      position: absolute;
      background: var(--toolbar-bg);
      border: 1px solid var(--toolbar-border);
      color: #e2e8f0;
      border-radius: 999px;
      width: 32px;
      height: 32px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: background 0.2s;
    }

    .floor-controls .plus-x { right: 50%; top: 12px; transform: translateX(60px); }
    .floor-controls .minus-x { right: 50%; top: 12px; transform: translateX(18px); }
    .floor-controls .plus-z { top: 50%; right: 12px; transform: translateY(18px); }
    .floor-controls .minus-z { top: 50%; right: 12px; transform: translateY(60px); }

    .floor-label {
      position: absolute;
      right: 12px;
      bottom: 12px;
      background: var(--toolbar-bg);
      border: 1px solid var(--toolbar-border);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      color: #e2e8f0;
    }

    .nav-cube {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 220px;
      height: 220px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.55);
      border: 1px solid var(--toolbar-border);
      backdrop-filter: blur(6px);
      z-index: 10;
      touch-action: none;
    }

    .nav-cube canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    @media (max-width: 600px) {
      .toolbar {
        top: 8px;
        left: 8px;
        gap: 4px;
        padding: 6px;
        border-radius: 12px;
        max-width: calc(100vw - 120px);
      }

      .tool-btn,
      .color-picker input,
      .gradient-controls input {
        width: 34px;
        height: 34px;
      }

      .nav-cube {
        width: 184px;
        height: 184px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="toolbar" aria-label="Voxel Paint toolbar">
      <div class="tool-group">
        <button class="tool-btn active" data-tool="paint" aria-pressed="true" title="Paint voxel">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 15.5A3.5 3.5 0 0 1 7.5 12h2.086l9.414-9.414a2 2 0 0 1 2.828 2.828L12.414 14.828A2 2 0 0 1 11 15.5h-1a2.5 2.5 0 0 0-5 0H4Z"/><path d="M5 19h7a2 2 0 0 0 1.414-.586l8-8-2.828-2.828-8 8A2 2 0 0 1 9.172 17H5a2 2 0 0 1 0-4" opacity="0.5"/></svg>
          <span class="sr-only">Paint voxel</span>
        </button>
        <button class="tool-btn" data-tool="dropper" title="Pick colour">
          <svg viewBox="0 0 24 24"><path d="m21.12 4.88-2-2a3 3 0 0 0-4.24 0l-1.17 1.17-1.41-1.41-1.42 1.41 1.41 1.42-7.79 7.78a3 3 0 0 0-.78 2.95l.27.81L2 20l2.12 2.12 2.3-2.3.77.28a3 3 0 0 0 2.95-.78l7.78-7.79 1.42 1.41 1.41-1.42-1.41-1.41 1.17-1.17a3 3 0 0 0 0-4.24Zm-4.24 6.24-1.41-1.41L7.7 17.47a1 1 0 0 1-.98.26l-.9-.33-.26-.9a1 1 0 0 1 .26-.98l7.76-7.78 2.83 2.83Z"/></svg>
          <span class="sr-only">Colour picker</span>
        </button>
        <button class="tool-btn" data-tool="erase" title="Delete voxel">
          <svg viewBox="0 0 24 24"><path d="M3.707 17.707 11.414 10l-4-4L2 11.414a2 2 0 0 0 0 2.828l2.879 2.879a2 2 0 0 0 2.828 0l8.486-8.485-2.828-2.829-1.415 1.415"/><path d="M15 3h6v6"/></svg>
          <span class="sr-only">Remove voxel</span>
        </button>
        <button class="tool-btn" data-tool="wall-xy" title="Draw wall on X/Y plane">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="4" y="4" width="12" height="12" rx="1.8"/>
            <path d="M10 8v8"/>
            <path d="M6 12h8"/>
          </svg>
          <span class="sr-only">Draw wall on X/Y plane</span>
        </button>
        <button class="tool-btn" data-tool="wall-xz" title="Draw wall on X/Z plane">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M5 6h14v12H5z"/>
            <path d="M5 12h14"/>
            <path d="M12 6v12"/>
          </svg>
          <span class="sr-only">Draw wall on X/Z plane</span>
        </button>
        <button class="tool-btn" data-tool="wall-yz" title="Draw wall on Y/Z plane">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <rect x="8" y="4" width="12" height="12" rx="1.8"/>
            <path d="M14 8v8"/>
            <path d="M10 10h8"/>
          </svg>
          <span class="sr-only">Draw wall on Y/Z plane</span>
        </button>
        <button class="tool-btn" data-action="clear" title="Clear all" aria-label="Clear all voxels">
          <svg viewBox="0 0 24 24"><path d="M5 5h14"/><path d="m6 9 1 10a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2l1-10"/><path d="M10 13v6"/><path d="M14 13v6"/><path d="M9 5l.5-2h5l.5 2"/></svg>
        </button>
        <button class="tool-btn" data-toggle="light" title="Toggle light source">
          <svg viewBox="0 0 24 24"><path d="M12 2v3"/><path d="M5.22 5.22 7.34 7.34"/><path d="M2 12h3"/><path d="M16.66 7.34l2.12-2.12"/><path d="M19 12h3"/><path d="M12 19v3"/><path d="m6 16-2.24 2.24"/><path d="M18 16l2.24 2.24"/><path d="M8 12a4 4 0 1 1 8 0c0 1.612-.74 3.038-1.87 3.97A4.983 4.983 0 0 0 14 18H10a4.983 4.983 0 0 0-.13-2.03A4.993 4.993 0 0 1 8 12Z"/></svg>
          <span class="sr-only">Toggle light source</span>
        </button>
        <button class="tool-btn" data-toggle="grid" title="Toggle grid">
          <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 9h18"/>
            <path d="M3 15h18"/>
            <path d="M9 21V3"/>
            <path d="M15 21V3"/>
          </svg>
          <span class="sr-only">Toggle floor grid</span>
        </button>
      </div>
      <div class="tool-group">
        <button class="tool-btn" data-action="export-png" title="Export PNG">
          <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><path d="M7 10l5 5 5-5"/><path d="M12 15V3"/></svg>
        </button>
        <button class="tool-btn" data-action="export-json" title="Export JSON">
          <svg viewBox="0 0 24 24"><path d="M6 20h12"/><path d="M9 4h6"/><path d="M12 4v16"/><path d="m5 8 4-4-4-4"/><path d="m19 8-4-4 4-4"/></svg>
        </button>
        <button class="tool-btn" data-action="import-json" title="Import JSON">
          <svg viewBox="0 0 24 24"><path d="M12 21V3"/><path d="m5 10 7-7 7 7"/><path d="M5 17h14"/></svg>
        </button>
        <button class="tool-btn" data-action="screenshot" title="Capture screenshot">
          <svg viewBox="0 0 24 24"><path d="m3 7 1.5-3A2 2 0 0 1 6.386 3h11.228a2 2 0 0 1 1.886 1l1.5 3"/><path d="M21 7v11a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3V7"/><path d="M7 7h.01"/><path d="M12 13a4 4 0 1 0 0-8 4 4 0 0 0 0 8Z"/></svg>
        </button>
      </div>
      <div class="palette" aria-label="Colour palette">
        <button class="swatch active" style="background:#f87171" data-color="#f87171" title="Salmon"></button>
        <button class="swatch" style="background:#fb923c" data-color="#fb923c" title="Orange"></button>
        <button class="swatch" style="background:#facc15" data-color="#facc15" title="Gold"></button>
        <button class="swatch" style="background:#4ade80" data-color="#4ade80" title="Green"></button>
        <button class="swatch" style="background:#38bdf8" data-color="#38bdf8" title="Sky"></button>
        <button class="swatch" style="background:#a855f7" data-color="#a855f7" title="Purple"></button>
        <button class="swatch" style="background:#f472b6" data-color="#f472b6" title="Pink"></button>
        <button class="swatch" style="background:#94a3b8" data-color="#94a3b8" title="Slate"></button>
      </div>
      <div class="color-picker" aria-label="Custom colour">
        <input type="color" value="#f87171" aria-label="Custom colour picker">
      </div>
      <div class="gradient-controls" aria-label="Background gradient">
        <input type="color" value="#0f172a" data-gradient="top" aria-label="Top background colour">
        <input type="color" value="#1e293b" data-gradient="bottom" aria-label="Bottom background colour">
      </div>
      <div class="ambient-control" aria-label="Ambient light colour">
        <input type="color" value="#96a3b7" aria-label="Ambient light colour">
      </div>
      <div class="sun-control" aria-label="Sunlight controls">
        <input type="color" value="#ffffff" data-sun="color" aria-label="Sunlight colour">
        <input type="range" min="10" max="200" value="100" step="5" data-sun="intensity" aria-label="Sunlight intensity">
      </div>
    </div>
    <div class="viewport" id="viewport"></div>
    <div class="floor-controls" aria-hidden="true">
  <button class="minus-x" data-dimension="width" data-delta="-2">−</button>
  <button class="plus-x" data-dimension="width" data-delta="2">+</button>
  <button class="minus-z" data-dimension="depth" data-delta="-2">−</button>
  <button class="plus-z" data-dimension="depth" data-delta="2">+</button>
      <div class="floor-label" id="floorLabel">Grid: 16 × 16</div>
    </div>
    <div class="nav-cube" id="navCube" title="Camera orientation cube" aria-label="Camera orientation cube"></div>
    <input type="file" id="importInput" accept="application/json" class="sr-only">
  </div>
  <script type="module">
    import * as THREE from './assets/vendor/three/three.module.js';
    import { EffectComposer } from './assets/vendor/three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from './assets/vendor/three/examples/jsm/postprocessing/RenderPass.js';
    import { SSAOPass } from './assets/vendor/three/examples/jsm/postprocessing/SSAOPass.js';

    const viewport = document.getElementById('viewport');
    const navCubeContainer = document.getElementById('navCube');
    const floorLabel = document.getElementById('floorLabel');
    const importInput = document.getElementById('importInput');

    const defaultCameraTarget = new THREE.Vector3(0, 0.5, 0);
    const defaultCameraPosition = new THREE.Vector3(32, 26, 32);
    const defaultCameraOffset = defaultCameraPosition.clone().sub(defaultCameraTarget);
    const defaultCameraDistance = defaultCameraOffset.length();
    const defaultCameraDirection = defaultCameraOffset.clone().normalize();

  const DEFAULT_TOOL = 'paint';
  const DEFAULT_COLOR = '#f87171';
  const DEFAULT_BG_TOP = '#0f172a';
  const DEFAULT_BG_BOTTOM = '#1e293b';
  const DEFAULT_AMBIENT_COLOR = '#96a3b7';
  const DEFAULT_SUN_COLOR = '#ffffff';
  const DEFAULT_SUN_INTENSITY = 1.0;
  const DEFAULT_FLOOR_SIZE = 16;
  const MAX_DYNAMIC_LIGHTS = 12;
  const LIGHT_DISTANCE = 18;
  const LIGHT_INTENSITY = 1.35;
  const LIGHT_DECAY = 1.25;
  const LIGHT_EMISSIVE_INTENSITY = 1.15;
  const STORAGE_KEY = 'voxel-paint-session-v1';
  const PERSIST_DEBOUNCE_MS = 120;
  const WALL_TOOLS = new Set(['wall-xy', 'wall-xz', 'wall-yz']);
  const WALL_PLANES = {
    'wall-xy': { axes: ['x', 'y'], fixed: 'z', normal: new THREE.Vector3(0, 0, 1) },
    'wall-xz': { axes: ['x', 'z'], fixed: 'y', normal: new THREE.Vector3(0, 1, 0) },
    'wall-yz': { axes: ['y', 'z'], fixed: 'x', normal: new THREE.Vector3(1, 0, 0) }
  };
  const WALL_GHOST_COLOR = 0x38bdf8;

    const state = {
      tool: DEFAULT_TOOL,
      color: DEFAULT_COLOR,
      isLightVoxel: false,
      gridVisible: true,
      floor: { width: DEFAULT_FLOOR_SIZE, depth: DEFAULT_FLOOR_SIZE },
      voxels: new Map(),
      cameraDistance: defaultCameraDistance,
      cameraTarget: defaultCameraTarget.clone(),
      pointerInfo: null,
      touchMap: new Map(),
      pinchDistance: null,
      bgGradient: { top: DEFAULT_BG_TOP, bottom: DEFAULT_BG_BOTTOM },
      ambientColor: DEFAULT_AMBIENT_COLOR,
      sunlightColor: DEFAULT_SUN_COLOR,
      sunlightIntensity: DEFAULT_SUN_INTENSITY,
      wallDrag: null
    };

    const scene = new THREE.Scene();
    scene.background = null;

    const camera = new THREE.PerspectiveCamera(55, viewport.clientWidth / viewport.clientHeight, 0.1, 500);
  camera.position.copy(defaultCameraPosition);
    camera.lookAt(state.cameraTarget);

    function getViewportSize(element) {
      const width = Math.max(1, element?.clientWidth || element?.offsetWidth || window.innerWidth || 1);
      const height = Math.max(1, element?.clientHeight || element?.offsetHeight || window.innerHeight || 1);
      return { width, height };
    }

    function quantizeToHalf(value) {
      const snapped = Math.round(value * 2) / 2;
      return Object.is(snapped, -0) ? 0 : snapped;
    }

    function snapToFloorCoordinate(value, dimension) {
      const half = dimension / 2;
      const clamped = THREE.MathUtils.clamp(value, -half, half - 1e-4);
      const index = Math.floor(clamped + half);
      return quantizeToHalf((index + 0.5) - half);
    }

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    const initialViewport = getViewportSize(viewport);
    renderer.setSize(initialViewport.width, initialViewport.height); 
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  renderer.autoClear = false;
    viewport.appendChild(renderer.domElement);

  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  const ssaoInitialSize = getViewportSize(viewport);
  const ssaoPass = new SSAOPass(scene, camera, ssaoInitialSize.width, ssaoInitialSize.height);
  ssaoPass.kernelRadius = 18;
  ssaoPass.minDistance = 0.005;
  ssaoPass.maxDistance = 0.24;
  ssaoPass.renderToScreen = true;
  composer.addPass(ssaoPass);

    const hemiLight = new THREE.HemisphereLight(0xdbeafe, 0x0f172a, 0.45);
    scene.add(hemiLight);

  const sunLight = new THREE.DirectionalLight(0xffffff, state.sunlightIntensity);
    sunLight.color.set(state.sunlightColor);
    sunLight.position.set(-15, 24, -12);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.set(2048, 2048);
    sunLight.shadow.camera.near = 1;
    sunLight.shadow.camera.far = 120;
    sunLight.shadow.radius = 3;
    scene.add(sunLight);
  scene.add(sunLight.target);

  const ambient = new THREE.AmbientLight(state.ambientColor, computeAmbientIntensity(state.ambientColor));
    scene.add(ambient);
    function updateSunShadowBounds() {
      const halfSize = Math.max(state.floor.width, state.floor.depth) / 2 + 4;
      sunLight.shadow.camera.left = -halfSize;
      sunLight.shadow.camera.right = halfSize;
      sunLight.shadow.camera.top = halfSize;
      sunLight.shadow.camera.bottom = -halfSize;
      sunLight.target.position.set(0, 0, 0);
      sunLight.shadow.camera.updateProjectionMatrix();
    }


    const voxelGroup = new THREE.Group();
    voxelGroup.castShadow = true;
    voxelGroup.receiveShadow = true;
    scene.add(voxelGroup);

    const lightGroup = new THREE.Group();
    scene.add(lightGroup);

    const lightPool = Array.from({ length: MAX_DYNAMIC_LIGHTS }, () => {
      const light = new THREE.PointLight(0xffffff, LIGHT_INTENSITY, LIGHT_DISTANCE, LIGHT_DECAY);
      light.castShadow = false;
      light.visible = false;
      lightGroup.add(light);
      return light;
    });
    const lightVoxels = new Set();

  const wallGhostGeometry = new THREE.BoxGeometry(1, 1, 1);
  const wallGhostMaterial = new THREE.MeshBasicMaterial({ color: WALL_GHOST_COLOR, opacity: 0.28, transparent: true, depthWrite: false });
  const wallGhostMesh = new THREE.Mesh(wallGhostGeometry, wallGhostMaterial);
  wallGhostMesh.visible = false;
  wallGhostMesh.raycast = () => {};
  scene.add(wallGhostMesh);

    function createGridLines(width, depth) {
      const vertices = [];
      const halfW = width / 2;
      const halfD = depth / 2;
      for (let i = 0; i <= width; i++) {
        const x = i - halfW;
        vertices.push(x, 0.02, -halfD, x, 0.02, halfD);
      }
      for (let k = 0; k <= depth; k++) {
        const z = k - halfD;
        vertices.push(-halfW, 0.02, z, halfW, 0.02, z);
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      const material = new THREE.LineBasicMaterial({ color: 0x38bdf8, transparent: true, opacity: 0.35 });
      const lines = new THREE.LineSegments(geometry, material);
      lines.renderOrder = -1;
      lines.raycast = () => {};
      return lines;
    }

    let gridLines = createGridLines(state.floor.width, state.floor.depth);
    gridLines.visible = state.gridVisible;
    scene.add(gridLines);

    const floorGeo = new THREE.PlaneGeometry(state.floor.width, state.floor.depth);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.95, metalness: 0.0, transparent: true, opacity: 1 });
    const floorMesh = new THREE.Mesh(floorGeo, floorMat);
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const navOffset = new THREE.Vector3();

    const navScene = new THREE.Scene();
    const navCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 10);
    navCamera.position.set(2, 2, 2);
    navCamera.lookAt(0, 0, 0);

    const navRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    navRenderer.setSize(navCubeContainer.clientWidth, navCubeContainer.clientHeight);
    navCubeContainer.appendChild(navRenderer.domElement);

  const navCubeGeometry = new THREE.BoxGeometry(1, 1, 1);
    const navCubeMaterial = new THREE.MeshStandardMaterial({ color: 0x1d4ed8, metalness: 0.2, roughness: 0.3, transparent: true, opacity: 0.85 });
    const navCubeMesh = new THREE.Mesh(navCubeGeometry, navCubeMaterial);
    navCubeMesh.castShadow = false;
    navCubeMesh.receiveShadow = false;
    navScene.add(navCubeMesh);
    const navLight = new THREE.DirectionalLight(0xffffff, 0.8);
    navLight.position.set(2, 3, 1);
    navScene.add(navLight);
    navScene.add(new THREE.AmbientLight(0xffffff, 0.4));

    const navTargets = new THREE.Group();

    const axes = [-1, 0, 1];
    axes.forEach(x => {
      axes.forEach(y => {
        axes.forEach(z => {
          if (x === 0 && y === 0 && z === 0) return;
          const vec = new THREE.Vector3(x, y, z).normalize();
          const sphereGeo = new THREE.SphereGeometry(0.18, 20, 20);
          const sphereMat = new THREE.MeshBasicMaterial({ color: 0xfacc15, transparent: true, opacity: 0.4 });
          const clickable = new THREE.Mesh(sphereGeo, sphereMat);
          clickable.position.copy(vec.multiplyScalar(0.72));
          clickable.userData.direction = vec.clone();
          navTargets.add(clickable);
        });
      });
    });
    navCubeMesh.add(navTargets);

    function resizeRenderer() {
      const { width, height } = getViewportSize(viewport);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      composer.setSize(width, height);
      ssaoPass.setSize(width, height);
    }

    function resizeNavCube() {
      const { width, height } = getViewportSize(navCubeContainer);
      navRenderer.setSize(width, height);
      navCamera.aspect = width / height;
      navCamera.updateProjectionMatrix();
    }

    function syncViewportSizing() {
      resizeRenderer();
      resizeNavCube();
    }

    function scheduleViewportResize() {
      requestAnimationFrame(syncViewportSizing);
      setTimeout(syncViewportSizing, 160);
    }

    window.addEventListener('resize', syncViewportSizing);

    requestAnimationFrame(syncViewportSizing);

    const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
    fullscreenEvents.forEach(eventName => {
      document.addEventListener(eventName, scheduleViewportResize);
    });

    if (window.screen?.orientation?.addEventListener) {
      window.screen.orientation.addEventListener('change', scheduleViewportResize);
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'F11') {
        scheduleViewportResize();
      }
    });

    function updateFloor() {
      const { width, depth } = state.floor;
      floorMesh.geometry.dispose();
      floorMesh.geometry = new THREE.PlaneGeometry(width, depth);
      scene.remove(gridLines);
      gridLines.geometry.dispose();
      gridLines.material.dispose();
      gridLines = createGridLines(width, depth);
      gridLines.visible = state.gridVisible;
      scene.add(gridLines);
      floorLabel.textContent = `Grid: ${width} × ${depth}`;
      updateSunShadowBounds();
    }

    function setGradient(top, bottom) {
      document.body.style.background = `linear-gradient(${top}, ${bottom})`;
    }

    function computeAmbientIntensity(hexColor) {
      // Map selected ambient colour luminance into an extended intensity range.
      const color = new THREE.Color(hexColor);
      const luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
      return THREE.MathUtils.lerp(0.25, 1.4, luminance);
    }

    let suppressPersistence = false;
    let pendingSaveHandle = null;

    function schedulePersistence() {
      if (suppressPersistence) return;
      if (typeof window === 'undefined' || !('localStorage' in window)) return;
      if (pendingSaveHandle !== null) return;
      pendingSaveHandle = window.setTimeout(() => {
        pendingSaveHandle = null;
        persistSession();
      }, PERSIST_DEBOUNCE_MS);
    }

    function persistSession() {
      try {
        if (typeof window === 'undefined' || !('localStorage' in window)) return;
        const voxels = [];
        state.voxels.forEach((mesh) => {
          voxels.push({
            position: [mesh.userData.position.x, mesh.userData.position.y, mesh.userData.position.z],
            color: mesh.userData.color,
            light: mesh.userData.isLight
          });
        });
        const payload = {
          version: 1,
          voxels,
          tool: state.tool,
          color: state.color,
          isLightVoxel: state.isLightVoxel,
          gridVisible: state.gridVisible,
          floor: { ...state.floor },
          bgGradient: { ...state.bgGradient },
          ambientColor: state.ambientColor,
          sunlightColor: state.sunlightColor,
          sunlightIntensity: state.sunlightIntensity,
          camera: {
            position: camera.position.toArray(),
            target: state.cameraTarget.toArray(),
            up: camera.up.toArray(),
            distance: state.cameraDistance
          }
        };
        window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('Voxel Paint: failed to persist session', err);
      }
    }

    function clearPersistedSession() {
      try {
        if (typeof window === 'undefined' || !('localStorage' in window)) return;
        window.localStorage.removeItem(STORAGE_KEY);
      } catch (err) {
        console.warn('Voxel Paint: failed to clear persisted session', err);
      }
    }

    function formatTimestampedFileName(prefix, extension) {
      const ts = new Date();
      const pad = (value) => String(value).padStart(2, '0');
      return `${prefix}-${ts.getFullYear()}${pad(ts.getMonth() + 1)}${pad(ts.getDate())}-${pad(ts.getHours())}${pad(ts.getMinutes())}.${extension}`;
    }

    function downloadDataUrl(dataUrl, fileName) {
      const link = document.createElement('a');
      link.href = dataUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function restorePersistedSession() {
      if (typeof window === 'undefined' || !('localStorage' in window)) return;
      let raw;
      try {
        raw = window.localStorage.getItem(STORAGE_KEY);
      } catch (err) {
        console.warn('Voxel Paint: failed to read persisted session', err);
        return;
      }
      if (!raw) return;
      let parsed;
      try {
        parsed = JSON.parse(raw);
      } catch (err) {
        console.warn('Voxel Paint: invalid persisted session payload', err);
        return;
      }
      if (!parsed || parsed.version !== 1) return;

      suppressPersistence = true;
      try {
        clearVoxels({ skipStorage: true });

        if (parsed.floor) {
          if (typeof parsed.floor.width === 'number') {
            state.floor.width = THREE.MathUtils.clamp(parsed.floor.width, 6, 64);
          }
          if (typeof parsed.floor.depth === 'number') {
            state.floor.depth = THREE.MathUtils.clamp(parsed.floor.depth, 6, 64);
          }
          updateFloor();
        }

        if (typeof parsed.gridVisible === 'boolean') {
          state.gridVisible = parsed.gridVisible;
          updateGridToggle();
        }

        if (parsed.bgGradient) {
          if (typeof parsed.bgGradient.top === 'string') {
            state.bgGradient.top = parsed.bgGradient.top;
          }
          if (typeof parsed.bgGradient.bottom === 'string') {
            state.bgGradient.bottom = parsed.bgGradient.bottom;
          }
          setGradient(state.bgGradient.top, state.bgGradient.bottom);
        }

        if (typeof parsed.ambientColor === 'string') {
          state.ambientColor = parsed.ambientColor;
          ambient.color.set(state.ambientColor);
          ambient.intensity = computeAmbientIntensity(state.ambientColor);
        }

        if (parsed.sunlightColor) {
          state.sunlightColor = parsed.sunlightColor;
          sunLight.color.set(state.sunlightColor);
        }
        if (typeof parsed.sunlightIntensity === 'number') {
          state.sunlightIntensity = parsed.sunlightIntensity;
          sunLight.intensity = state.sunlightIntensity;
        }

        if (Array.isArray(parsed.voxels)) {
          parsed.voxels.forEach((voxel) => {
            if (!voxel || !Array.isArray(voxel.position) || voxel.position.length !== 3) return;
            const [x, y, z] = voxel.position.map((value) => quantizeToHalf(Number(value)));
            if ([x, y, z].some((value) => Number.isNaN(value))) return;
            const color = typeof voxel.color === 'string' ? voxel.color : '#ffffff';
            const light = Boolean(voxel.light);
            addVoxel(new THREE.Vector3(x, y, z), color, light);
          });
        }

        if (typeof parsed.tool === 'string') {
          updateToolSelection(parsed.tool);
        }
        if (typeof parsed.color === 'string') {
          state.color = parsed.color;
          updatePaletteSelection(state.color);
        }
        if (typeof parsed.isLightVoxel === 'boolean') {
          state.isLightVoxel = parsed.isLightVoxel;
          updateLightToggle();
        }

        if (parsed.camera) {
          if (Array.isArray(parsed.camera.position) && parsed.camera.position.length === 3) {
            camera.position.fromArray(parsed.camera.position);
          }
          if (Array.isArray(parsed.camera.target) && parsed.camera.target.length === 3) {
            state.cameraTarget.fromArray(parsed.camera.target);
          }
          if (Array.isArray(parsed.camera.up) && parsed.camera.up.length === 3) {
            camera.up.fromArray(parsed.camera.up);
          }
          if (typeof parsed.camera.distance === 'number') {
            state.cameraDistance = THREE.MathUtils.clamp(parsed.camera.distance, 6, 140);
          } else {
            state.cameraDistance = camera.position.clone().sub(state.cameraTarget).length();
          }
          camera.lookAt(state.cameraTarget);
          updateNavCamera();
        }

        const ambientInput = document.querySelector('.ambient-control input');
        if (ambientInput) {
          ambientInput.value = state.ambientColor;
        }
        const sunColorInput = document.querySelector('.sun-control input[data-sun="color"]');
        if (sunColorInput) {
          sunColorInput.value = state.sunlightColor;
        }
        const sunIntensityInput = document.querySelector('.sun-control input[data-sun="intensity"]');
        if (sunIntensityInput) {
          sunIntensityInput.value = Math.round(state.sunlightIntensity * 100);
        }
        const gradientInputs = document.querySelectorAll('.gradient-controls input');
        gradientInputs.forEach((input) => {
          const key = input.dataset.gradient;
          if (key && state.bgGradient[key]) {
            input.value = state.bgGradient[key];
          }
        });
      } finally {
        suppressPersistence = false;
      }
      schedulePersistence();
    }

    function voxelKey(x, y, z) {
      return `${x}|${y}|${z}`;
    }

    function computeCenter() {
      if (state.voxels.size === 0) {
        state.cameraTarget.copy(defaultCameraTarget);
        return;
      }
      const box = new THREE.Box3();
      voxelGroup.children.forEach(mesh => {
        box.expandByPoint(mesh.position);
      });
      const center = box.getCenter(new THREE.Vector3());
      state.cameraTarget.copy(center);
    }

    function updateNavCamera() {
      navOffset.copy(camera.position).sub(state.cameraTarget);
      if (navOffset.lengthSq() < 1e-6) {
        navCamera.position.set(0, 0, 3);
      } else {
        navCamera.position.copy(navOffset.normalize().multiplyScalar(3));
      }
      navCamera.up.copy(camera.up).normalize();
      navCamera.lookAt(0, 0, 0);
    }

    function resetCameraView() {
      state.cameraDistance = defaultCameraDistance;
      state.cameraTarget.copy(defaultCameraTarget);
      camera.up.set(0, 1, 0);
      updateCameraPosition(defaultCameraDirection);
    }

    function updateCameraPosition(direction = null) {
      if (direction) {
        const dir = direction.clone().normalize();
        if (Math.abs(dir.y) > 0.98) {
          camera.up.set(0, dir.y > 0 ? 0 : 0, dir.y > 0 ? -1 : 1);
        } else {
          camera.up.set(0, 1, 0);
        }
        camera.position.copy(dir.multiplyScalar(state.cameraDistance).add(state.cameraTarget));
        camera.lookAt(state.cameraTarget);
        updateNavCamera();
        return;
      }
      const currentDir = camera.position.clone().sub(state.cameraTarget).normalize();
      camera.position.copy(currentDir.multiplyScalar(state.cameraDistance).add(state.cameraTarget));
      camera.lookAt(state.cameraTarget);
      updateNavCamera();
    }

    function addVoxel(position, color, isLight) {
      const key = voxelKey(position.x, position.y, position.z);
      if (state.voxels.has(key)) {
        removeVoxel(position);
      }
      const size = 1;
      const geometry = new THREE.BoxGeometry(size, size, size);
      const materialOptions = {
        color,
        roughness: 0.92,
        metalness: 0.0,
        flatShading: true
      };
      if (isLight) {
        materialOptions.emissive = color;
        materialOptions.emissiveIntensity = LIGHT_EMISSIVE_INTENSITY;
      }
      const material = new THREE.MeshStandardMaterial(materialOptions);
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.castShadow = !isLight;
      mesh.receiveShadow = !isLight;
      mesh.userData = { color, isLight, position: position.clone() };
      voxelGroup.add(mesh);

      if (isLight) {
        lightVoxels.add(mesh);
      }

      state.voxels.set(key, mesh);
      schedulePersistence();
    }

    function removeVoxel(position) {
      const key = voxelKey(position.x, position.y, position.z);
      const mesh = state.voxels.get(key);
      if (!mesh) return;
      if (mesh.userData.isLight) {
        lightVoxels.delete(mesh);
      }
      mesh.geometry.dispose();
      mesh.material.dispose();
      voxelGroup.remove(mesh);
      state.voxels.delete(key);
      schedulePersistence();
    }

    function updateDynamicLights() {
      if (lightVoxels.size === 0) {
        lightPool.forEach((light) => {
          light.visible = false;
        });
        return;
      }

      const activeMeshes = Array.from(lightVoxels);
      activeMeshes.sort((a, b) => (
        a.position.distanceToSquared(camera.position) - b.position.distanceToSquared(camera.position)
      ));

      for (let i = 0; i < lightPool.length; i += 1) {
        const light = lightPool[i];
        const mesh = activeMeshes[i];
        if (mesh) {
          light.position.copy(mesh.position);
          light.color.set(mesh.userData.color);
          light.intensity = LIGHT_INTENSITY;
          light.distance = LIGHT_DISTANCE;
          light.decay = LIGHT_DECAY;
          light.visible = true;
        } else {
          light.visible = false;
        }
      }
    }

    function clearVoxels({ skipStorage = false } = {}) {
      [...voxelGroup.children].forEach(mesh => {
        mesh.geometry.dispose();
        mesh.material.dispose();
        voxelGroup.remove(mesh);
      });
      lightVoxels.clear();
      lightPool.forEach(light => {
        light.visible = false;
      });
      state.voxels.clear();
      clearWallPreview();
      state.floor.width = DEFAULT_FLOOR_SIZE;
      state.floor.depth = DEFAULT_FLOOR_SIZE;
      updateFloor();
      resetCameraView();
      if (skipStorage) {
        schedulePersistence();
      } else {
        clearPersistedSession();
      }
    }

    function getPointerIntersection(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const voxelHits = raycaster.intersectObjects(voxelGroup.children, false);
      if (voxelHits.length > 0) {
        return { type: 'voxel', intersection: voxelHits[0] };
      }
      const floorHit = raycaster.intersectObject(floorMesh, false);
      if (floorHit.length > 0) {
        return { type: 'floor', intersection: floorHit[0] };
      }
      return null;
    }

    function isWallTool(tool) {
      return WALL_TOOLS.has(tool);
    }

    function clearWallPreview() {
      state.wallDrag = null;
      wallGhostMesh.visible = false;
    }

    function computeWallAnchor(intersection) {
      if (!intersection) return null;
      if (intersection.type === 'floor') {
        const { width, depth } = state.floor;
        const x = snapToFloorCoordinate(intersection.intersection.point.x, width);
        const z = snapToFloorCoordinate(intersection.intersection.point.z, depth);
        return new THREE.Vector3(x, 0.5, z);
      }
      if (intersection.type === 'voxel') {
        const { object, face } = intersection.intersection;
        const base = object.userData.position.clone();
        if (face?.normal) {
          base.add(face.normal);
        }
        base.set(
          quantizeToHalf(base.x),
          quantizeToHalf(base.y),
          quantizeToHalf(base.z)
        );
        return base;
      }
      return null;
    }

    function refreshWallGhost() {
      const drag = state.wallDrag;
      if (!drag) {
        wallGhostMesh.visible = false;
        return;
      }
      const minX = Math.min(drag.start.x, drag.current.x);
      const minY = Math.min(drag.start.y, drag.current.y);
      const minZ = Math.min(drag.start.z, drag.current.z);
      const maxX = Math.max(drag.start.x, drag.current.x);
      const maxY = Math.max(drag.start.y, drag.current.y);
      const maxZ = Math.max(drag.start.z, drag.current.z);
      const width = (maxX - minX) + 1;
      const height = (maxY - minY) + 1;
      const depth = (maxZ - minZ) + 1;
      wallGhostMesh.visible = true;
      wallGhostMesh.position.set(
        (minX + maxX) / 2,
        (minY + maxY) / 2,
        (minZ + maxZ) / 2
      );
      wallGhostMesh.scale.set(width, height, depth);
    }

    function startWallDrag(intersection, event) {
  const planeInfo = WALL_PLANES[state.tool];
      if (!planeInfo) return false;
  const anchor = computeWallAnchor(intersection);
      if (!anchor) return false;
      clearWallPreview();
      const plane = new THREE.Plane();
      plane.setFromNormalAndCoplanarPoint(planeInfo.normal.clone(), anchor);
      state.wallDrag = {
        planeKey: state.tool,
        info: planeInfo,
        start: anchor.clone(),
        current: anchor.clone(),
        plane
      };
      wallGhostMesh.visible = true;
      wallGhostMesh.position.copy(anchor);
      wallGhostMesh.scale.set(1, 1, 1);
      refreshWallGhost();
      return true;
    }

    function projectPointerToWall(event) {
      if (!state.wallDrag) return null;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const pointOnPlane = new THREE.Vector3();
      if (!raycaster.ray.intersectPlane(state.wallDrag.plane, pointOnPlane)) {
        return null;
      }
      const { start, info } = state.wallDrag;
      const snapAxis = (value, anchor) => anchor + Math.round(value - anchor);
      pointOnPlane.x = snapAxis(pointOnPlane.x, start.x);
      pointOnPlane.y = snapAxis(pointOnPlane.y, start.y);
      pointOnPlane.z = snapAxis(pointOnPlane.z, start.z);
      pointOnPlane[info.fixed] = start[info.fixed];
      return pointOnPlane;
    }

    function updateWallPreview(event) {
      const drag = state.wallDrag;
      if (!drag) return;
      const projected = projectPointerToWall(event);
      if (!projected) return;
      let changed = false;
      drag.info.axes.forEach(axis => {
        if (drag.current[axis] !== projected[axis]) {
          drag.current[axis] = projected[axis];
          changed = true;
        }
      });
      drag.current[drag.info.fixed] = drag.start[drag.info.fixed];
      if (changed) {
        refreshWallGhost();
        if (state.pointerInfo) {
          state.pointerInfo.moved = true;
        }
      }
    }

    function commitWallDrag() {
      const drag = state.wallDrag;
      if (!drag) {
        clearWallPreview();
        return;
      }
      const minX = Math.min(drag.start.x, drag.current.x);
      const minY = Math.min(drag.start.y, drag.current.y);
      const minZ = Math.min(drag.start.z, drag.current.z);
      const maxX = Math.max(drag.start.x, drag.current.x);
      const maxY = Math.max(drag.start.y, drag.current.y);
      const maxZ = Math.max(drag.start.z, drag.current.z);
      const epsilon = 1e-4;
      for (let x = minX; x <= maxX + epsilon; x += 1) {
        for (let y = minY; y <= maxY + epsilon; y += 1) {
          for (let z = minZ; z <= maxZ + epsilon; z += 1) {
            addVoxel(new THREE.Vector3(x, y, z), state.color, state.isLightVoxel);
          }
        }
      }
      clearWallPreview();
    }

    function placeVoxel(intersection) {
      if (!intersection) return;
      if (intersection.type === 'floor') {
        const { width, depth } = state.floor;
        const x = snapToFloorCoordinate(intersection.intersection.point.x, width);
        const z = snapToFloorCoordinate(intersection.intersection.point.z, depth);
        const y = 0.5;
        addVoxel(new THREE.Vector3(x, y, z), state.color, state.isLightVoxel);
        return;
      }
      const { point, face, object } = intersection.intersection;
      const normal = face?.normal?.clone() ?? new THREE.Vector3(0, 1, 0);
      const voxelPos = object.userData.position.clone().add(normal);
      voxelPos.set(
        quantizeToHalf(voxelPos.x),
        quantizeToHalf(voxelPos.y),
        quantizeToHalf(voxelPos.z)
      );
      addVoxel(voxelPos, state.color, state.isLightVoxel);
    }

    function eraseVoxel(intersection) {
      if (!intersection || intersection.type !== 'voxel') return;
      removeVoxel(intersection.intersection.object.userData.position);
    }

    function pickColor(intersection) {
      if (!intersection || intersection.type !== 'voxel') return;
      const mesh = intersection.intersection.object;
      const { color, isLight } = mesh.userData;
      state.color = color;
      state.isLightVoxel = isLight;
      updatePaletteSelection(color);
      updateLightToggle();
      schedulePersistence();
    }

    function updatePaletteSelection(color) {
      document.querySelectorAll('.palette .swatch').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === color);
      });
      const colorInput = document.querySelector('.color-picker input');
      if (colorInput) {
        colorInput.value = color;
      }
      schedulePersistence();
    }

    function updateToolSelection(tool) {
      if (state.wallDrag) {
        clearWallPreview();
      }
      document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
        const isActive = btn.dataset.tool === tool;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', isActive);
      });
      state.tool = tool;
      schedulePersistence();
    }

    function updateLightToggle() {
      const btn = document.querySelector('.tool-btn[data-toggle="light"]');
      if (btn) {
        btn.classList.toggle('active', state.isLightVoxel);
        btn.setAttribute('aria-pressed', state.isLightVoxel);
      }
      schedulePersistence();
    }

    function updateGridToggle() {
      const btn = document.querySelector('.tool-btn[data-toggle="grid"]');
      if (btn) {
        btn.classList.toggle('active', state.gridVisible);
        btn.setAttribute('aria-pressed', state.gridVisible);
      }
      if (gridLines) {
        gridLines.visible = state.gridVisible;
      }
      floorMesh.material.opacity = state.gridVisible ? 1 : 0;
      floorMesh.material.needsUpdate = true;
      schedulePersistence();
    }

    function toggleGrid() {
      state.gridVisible = !state.gridVisible;
      updateGridToggle();
    }

    function exportPNG() {
      composer.render();
      const dataUrl = renderer.domElement.toDataURL('image/png');
      downloadDataUrl(dataUrl, formatTimestampedFileName('voxel-paint', 'png'));
    }

    function exportJSON() {
      const voxels = [];
      state.voxels.forEach(mesh => {
        voxels.push({
          position: [mesh.userData.position.x, mesh.userData.position.y, mesh.userData.position.z],
          color: mesh.userData.color,
          light: mesh.userData.isLight
        });
      });
      const payload = JSON.stringify({ voxels }, null, 2);
      const fileName = formatTimestampedFileName('voxel-obj', 'json');
      const blob = new Blob([payload], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = fileName;
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function captureScreenshotWithBackground() {
      composer.render();
      const sourceCanvas = renderer.domElement;
      const width = sourceCanvas.width;
      const height = sourceCanvas.height;
      const composite = document.createElement('canvas');
      composite.width = width;
      composite.height = height;
      const ctx = composite.getContext('2d');
      if (!ctx) {
        exportPNG();
        return;
      }
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, state.bgGradient.top);
      gradient.addColorStop(1, state.bgGradient.bottom);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      ctx.drawImage(sourceCanvas, 0, 0, width, height);
      const dataUrl = composite.toDataURL('image/png');
      downloadDataUrl(dataUrl, formatTimestampedFileName('voxel-screenshot', 'png'));
    }

    function importJSON(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const parsed = JSON.parse(reader.result);
          if (!parsed || !Array.isArray(parsed.voxels)) return;
          const previous = suppressPersistence;
          suppressPersistence = true;
          clearVoxels({ skipStorage: true });
          parsed.voxels.forEach(item => {
            if (!Array.isArray(item.position) || item.position.length !== 3) return;
            const rawPosition = item.position.map(n => Number(n));
            if (rawPosition.some(n => Number.isNaN(n))) return;
            const [x, y, z] = rawPosition.map(value => quantizeToHalf(value));
            const color = item.color || '#ffffff';
            const light = Boolean(item.light);
            addVoxel(new THREE.Vector3(x, y, z), color, light);
          });
          suppressPersistence = previous;
          schedulePersistence();
        } catch (err) {
          console.error('Failed to import voxel JSON', err);
        }
      };
      reader.readAsText(file);
    }

    function handleToolAction(action) {
      switch (action) {
        case 'clear':
          {
            const previous = suppressPersistence;
            suppressPersistence = true;
            clearVoxels();
            resetToolDefaults();
            suppressPersistence = previous;
          }
          break;
        case 'export-png':
          exportPNG();
          break;
        case 'export-json':
          exportJSON();
          break;
        case 'import-json':
          importInput.click();
          break;
        case 'screenshot':
          captureScreenshotWithBackground();
          break;
        default:
          break;
      }
    }

    function onPointerDown(event) {
      if (event.pointerType === 'touch') {
        state.touchMap.set(event.pointerId, { x: event.clientX, y: event.clientY });
        if (state.touchMap.size === 2) {
          event.preventDefault();
        }
      }
      if (event.pointerType === 'mouse') {
        renderer.domElement.setPointerCapture(event.pointerId);
      }
      let mode = 'pan';
      let startedWall = false;
      if (isWallTool(state.tool)) {
        const isPrimaryButton = event.pointerType === 'mouse' ? (event.buttons & 1) === 1 : true;
        if (isPrimaryButton) {
          const interaction = getPointerIntersection(event);
          if (interaction && (interaction.type === 'floor' || interaction.type === 'voxel')) {
            startedWall = startWallDrag(interaction, event);
            if (startedWall) {
              mode = 'wall';
              event.preventDefault();
            }
          }
        }
      }
      if (!startedWall) {
        if (event.pointerType === 'mouse') {
          const isLeftButton = event.buttons === 1;
          const isRightButton = event.buttons === 2;
          if (isLeftButton) {
            mode = 'orbit';
          } else if (isRightButton) {
            mode = 'pan';
          }
        } else if (event.pointerType === 'touch') {
          mode = 'pan';
        }
      }
      state.pointerInfo = {
        id: event.pointerId,
        startX: event.clientX,
        startY: event.clientY,
        moved: false,
        lastX: event.clientX,
        lastY: event.clientY,
        mode,
        button: event.button
      };
    }

    function handlePan(dx, dy) {
      const panSpeed = 0.0025 * state.cameraDistance;
      const right = new THREE.Vector3().subVectors(camera.position, state.cameraTarget).normalize().cross(camera.up).normalize();
      const up = new THREE.Vector3().copy(camera.up).normalize();
      const panOffset = new THREE.Vector3();
      panOffset.addScaledVector(right, dx * panSpeed);
      panOffset.addScaledVector(up, dy * panSpeed);
      camera.position.add(panOffset);
      state.cameraTarget.add(panOffset);
      updateCameraPosition();
    }

    function handleOrbit(dx, dy) {
      const offset = camera.position.clone().sub(state.cameraTarget);
      const spherical = new THREE.Spherical().setFromVector3(offset);
      const orbitSpeed = 0.005;
      spherical.theta -= dx * orbitSpeed;
      spherical.phi -= dy * orbitSpeed;
      const epsilon = 0.05;
      spherical.phi = THREE.MathUtils.clamp(spherical.phi, epsilon, Math.PI - epsilon);
      offset.setFromSpherical(spherical);
      camera.position.copy(state.cameraTarget).add(offset);
      camera.lookAt(state.cameraTarget);
      updateNavCamera();
    }

    function handleZoom(delta) {
      state.cameraDistance *= delta > 0 ? 1.06 : 0.94;
      state.cameraDistance = THREE.MathUtils.clamp(state.cameraDistance, 6, 140);
      updateCameraPosition();
    }

    function onPointerMove(event) {
      if (!state.pointerInfo || state.pointerInfo.id !== event.pointerId) return;
      if (state.pointerInfo.mode === 'wall') {
        updateWallPreview(event);
        return;
      }
      const dx = event.clientX - state.pointerInfo.startX;
      const dy = event.clientY - state.pointerInfo.startY;
      const threshold = 6;
      if (Math.abs(dx) > threshold || Math.abs(dy) > threshold) {
        state.pointerInfo.moved = true;
        const deltaX = event.clientX - state.pointerInfo.lastX;
        const deltaY = event.clientY - state.pointerInfo.lastY;
        if (state.pointerInfo.mode === 'orbit') {
          handleOrbit(deltaX, deltaY);
        } else {
          handlePan(deltaX, deltaY);
        }
        state.pointerInfo.lastX = event.clientX;
        state.pointerInfo.lastY = event.clientY;
      }
      if (event.pointerType === 'touch') {
        state.touchMap.set(event.pointerId, { x: event.clientX, y: event.clientY });
        if (state.touchMap.size === 2) {
          const touches = Array.from(state.touchMap.values());
          const dist = Math.hypot(touches[0].x - touches[1].x, touches[0].y - touches[1].y);
          if (state.pinchDistance !== null) {
            if (Math.abs(dist - state.pinchDistance) > 2) {
              handleZoom(dist > state.pinchDistance ? -1 : 1);
              state.pinchDistance = dist;
            }
          } else {
            state.pinchDistance = dist;
          }
        }
      }
    }

    function onPointerUp(event) {
      if (!state.pointerInfo || state.pointerInfo.id !== event.pointerId) {
        state.touchMap.delete(event.pointerId);
        return;
      }
      const pointerSnapshot = state.pointerInfo;
      const { moved, mode, button } = pointerSnapshot;
      if (mode === 'wall') {
        commitWallDrag();
      } else {
        const interaction = moved && mode !== 'orbit' ? null : getPointerIntersection(event);
        const isPrimaryButton = event.pointerType !== 'mouse' || button === 0;
        if (!moved && isPrimaryButton) {
          if (state.tool === 'paint') {
            placeVoxel(interaction);
          } else if (state.tool === 'erase') {
            eraseVoxel(interaction);
          } else if (state.tool === 'dropper') {
            pickColor(interaction);
          }
        }
      }
      if (event.pointerType === 'mouse') {
        renderer.domElement.releasePointerCapture(event.pointerId);
      }
      state.pointerInfo = null;
      state.touchMap.delete(event.pointerId);
      if (event.pointerType === 'touch' && state.touchMap.size < 2) {
        state.pinchDistance = null;
      }
      if (pointerSnapshot?.moved && (pointerSnapshot.mode === 'pan' || pointerSnapshot.mode === 'orbit')) {
        schedulePersistence();
      }
    }

    function onPointerCancel(event) {
      if (event.pointerType === 'mouse') {
        renderer.domElement.releasePointerCapture(event.pointerId);
      }
      if (state.pointerInfo && state.pointerInfo.id === event.pointerId) {
        if (state.pointerInfo.mode === 'wall') {
          clearWallPreview();
        }
        state.pointerInfo = null;
      }
      state.touchMap.delete(event.pointerId);
      if (event.pointerType === 'touch' && state.touchMap.size < 2) {
        state.pinchDistance = null;
      }
    }

    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('pointercancel', onPointerCancel);
    renderer.domElement.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
    renderer.domElement.addEventListener('wheel', (event) => {
      event.preventDefault();
      handleZoom(event.deltaY);
      schedulePersistence();
    }, { passive: false });

    navRenderer.domElement.addEventListener('pointerdown', (event) => {
      const rect = navRenderer.domElement.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      pointer.set(x, y);
      raycaster.setFromCamera(pointer, navCamera);
      const hits = raycaster.intersectObjects(navTargets.children, true);
      if (hits.length > 0) {
        const dir = hits[0].object.userData.direction.clone();
        computeCenter();
        updateCameraPosition(dir);
        schedulePersistence();
      }
    });

    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
      btn.addEventListener('click', () => {
        updateToolSelection(btn.dataset.tool);
      });
    });

    document.querySelectorAll('.tool-btn[data-action]').forEach(btn => {
      btn.addEventListener('click', () => handleToolAction(btn.dataset.action));
    });

    document.querySelector('.tool-btn[data-toggle="light"]').addEventListener('click', () => {
      state.isLightVoxel = !state.isLightVoxel;
      updateLightToggle();
    });

    document.querySelector('.tool-btn[data-toggle="grid"]').addEventListener('click', () => {
      toggleGrid();
    });

    document.querySelectorAll('.palette .swatch').forEach(btn => {
      btn.addEventListener('click', () => {
        state.color = btn.dataset.color;
        state.isLightVoxel = false;
        updatePaletteSelection(state.color);
        updateLightToggle();
        schedulePersistence();
      });
    });

    document.querySelector('.color-picker input').addEventListener('input', (event) => {
      state.color = event.target.value;
      state.isLightVoxel = false;
      updatePaletteSelection(state.color);
      updateLightToggle();
      schedulePersistence();
    });

    const gradientInputs = document.querySelectorAll('.gradient-controls input');
    gradientInputs.forEach(input => {
      input.addEventListener('input', () => {
        state.bgGradient[input.dataset.gradient] = input.value;
        setGradient(state.bgGradient.top, state.bgGradient.bottom);
        schedulePersistence();
      });
    });

    const ambientInput = document.querySelector('.ambient-control input');
    ambientInput.addEventListener('input', (event) => {
      state.ambientColor = event.target.value;
      ambient.color.set(state.ambientColor);
      ambient.intensity = computeAmbientIntensity(state.ambientColor);
      schedulePersistence();
    });

    const sunColorInput = document.querySelector('.sun-control input[data-sun="color"]');
    const sunIntensityInput = document.querySelector('.sun-control input[data-sun="intensity"]');
    sunColorInput.addEventListener('input', (event) => {
      state.sunlightColor = event.target.value;
      sunLight.color.set(state.sunlightColor);
      schedulePersistence();
    });

    sunIntensityInput.addEventListener('input', (event) => {
      const normalized = Number(event.target.value) / 100;
      state.sunlightIntensity = normalized;
      sunLight.intensity = normalized;
      schedulePersistence();
    });

    function resetToolDefaults() {
      updateToolSelection(DEFAULT_TOOL);
      state.color = DEFAULT_COLOR;
      state.isLightVoxel = false;
      updatePaletteSelection(state.color);
      updateLightToggle();

      state.bgGradient.top = DEFAULT_BG_TOP;
      state.bgGradient.bottom = DEFAULT_BG_BOTTOM;
      gradientInputs.forEach(input => {
        const key = input.dataset.gradient;
        if (key) {
          input.value = state.bgGradient[key];
        }
      });
      setGradient(state.bgGradient.top, state.bgGradient.bottom);

  state.ambientColor = DEFAULT_AMBIENT_COLOR;
  ambient.color.set(state.ambientColor);
  ambient.intensity = computeAmbientIntensity(state.ambientColor);
  ambientInput.value = state.ambientColor;

      state.sunlightColor = DEFAULT_SUN_COLOR;
      sunLight.color.set(state.sunlightColor);
      sunColorInput.value = state.sunlightColor;

    state.sunlightIntensity = DEFAULT_SUN_INTENSITY;
    sunLight.intensity = state.sunlightIntensity;
    sunIntensityInput.value = Math.round(state.sunlightIntensity * 100);

    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;

      state.gridVisible = true;
      updateGridToggle();
    }

    document.querySelectorAll('.floor-controls button').forEach(btn => {
      btn.addEventListener('click', () => {
        const dimension = btn.dataset.dimension;
        const delta = Number(btn.dataset.delta);
        const newValue = THREE.MathUtils.clamp(state.floor[dimension] + delta, 6, 64);
        state.floor[dimension] = newValue;
        updateFloor();
        schedulePersistence();
      });
    });

    importInput.addEventListener('change', (event) => {
      const file = event.target.files?.[0];
      if (file) {
        importJSON(file);
      }
      importInput.value = '';
    });

    function animate() {
      requestAnimationFrame(animate);
      updateDynamicLights();
      composer.render();
      navRenderer.render(navScene, navCamera);
    }

  restorePersistedSession();
  updateNavCamera();
    animate();
    setGradient(state.bgGradient.top, state.bgGradient.bottom);
    updateFloor();
    updateGridToggle();
    updateLightToggle();
    ambientInput.value = state.ambientColor;
    sunColorInput.value = state.sunlightColor;
    sunIntensityInput.value = Math.round(state.sunlightIntensity * 100);
    gradientInputs.forEach(input => {
      const key = input.dataset.gradient;
      if (key) {
        input.value = state.bgGradient[key];
      }
    });
    updateSunShadowBounds();
  </script>
</body>
</html>
