<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lumen Drift</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at top, #11172f 0%, #05060c 55%, #020309 100%);
      color: #f4f7ff;
      overflow: hidden;
    }
    main {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: rgba(4, 9, 18, 0.7);
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
      touch-action: none;
    }
    .fullscreen-toggle {
      position: absolute;
      top: clamp(12px, 2vw, 24px);
      left: 50%;
      transform: translate(-50%, 0);
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(7, 14, 28, 0.75);
      color: #f4f7ff;
      font: inherit;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
      z-index: 10;
    }
    .fullscreen-toggle:hover {
      background: rgba(18, 28, 48, 0.85);
      transform: translate(-50%, 0);
    }
    .fullscreen-toggle:active { transform: translate(-50%, 0) scale(0.98); }
    .hud {
      position: absolute;
      inset: clamp(12px, 2.8vw, 32px);
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-size: clamp(12px, 2vw, 14px);
      letter-spacing: 0.08em;
    }
    .hud section {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      text-transform: uppercase;
    }
    .hud strong { font-size: 24px; letter-spacing: 0.12em; }
    .energy-bar {
      width: 160px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.1);
      overflow: hidden;
    }
    .energy-bar span {
      display: block;
      height: 100%;
      width: var(--fill, 0%);
      background: linear-gradient(90deg, rgba(60, 204, 255, 0.85), rgba(237, 161, 255, 0.9));
      transition: width 0.2s linear;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(6, 12, 24, 0.78);
      display: grid;
      place-items: center;
      text-align: center;
      padding: clamp(20px, 4vw, 48px);
      gap: 16px;
    }
    .card {
      width: min(440px, 90vw);
      display: grid;
      gap: 18px;
      padding: clamp(20px, 3.6vw, 32px);
      background: rgba(10, 18, 32, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 18px;
      box-shadow: 0 24px 48px rgba(3, 8, 20, 0.6);
    }
    h1 {
      margin: 0;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      font-size: 22px;
    }
    p {
      margin: 0;
      color: rgba(218, 224, 255, 0.78);
      line-height: 1.6;
      font-size: 14px;
    }
    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 12px 26px;
      font: inherit;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      background: linear-gradient(90deg, rgba(64, 204, 255, 0.9), rgba(238, 156, 255, 0.95));
      color: #051021;
      transition: transform 0.12s ease, box-shadow 0.2s ease;
      box-shadow: 0 18px 32px rgba(38, 102, 184, 0.45);
    }
  button:not(.fullscreen-toggle):hover { transform: translateY(-2px); box-shadow: 0 24px 40px rgba(38, 102, 184, 0.5); }
  button:not(.fullscreen-toggle):active { transform: translateY(1px) scale(0.98); box-shadow: 0 16px 24px rgba(38, 102, 184, 0.4); }
    .hidden { display: none; }
    @media (max-width: 740px) {
      .hud strong { font-size: 18px; }
      h1 { font-size: 18px; }
    }
  </style>
</head>
<body>
  <main>
    <canvas id="field" width="960" height="600"></canvas>
    <button type="button" id="fullscreen-btn" class="fullscreen-toggle" aria-pressed="false" title="Enter fullscreen">Fullscreen</button>
    <div class="hud">
      <section>
        <div>Glints <strong id="score">0</strong></div>
        <div class="energy-bar"><span id="energy-fill"></span></div>
      </section>
      <section>
        <div>Longest Drift <strong id="longest">0.0s</strong></div>
        <div>Whispers <strong id="notes">0</strong></div>
      </section>
    </div>
    <div class="overlay" id="overlay">
      <div class="card">
        <h1>Lumen Drift</h1>
        <p>Guide a wandering lantern through a current of gentle light. Collect glints, dodge the dusk, and stretch each drift a little longer than the last. Move your pointer (or touch) to beckon the lantern.</p>
        <p id="summary">Hold still for a moment to let the currents nudge you. Each glint refreshes your glow. Shaded eddies will siphon it away.</p>
        <button id="start-btn">Begin Drift</button>
      </div>
    </div>
  </main>
  <script>
  const canvas = document.getElementById('field');
  const ctx = canvas.getContext('2d');
  const frame = document.querySelector('main');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('start-btn');
  const scoreEl = document.getElementById('score');
  const longestEl = document.getElementById('longest');
  const notesEl = document.getElementById('notes');
  const energyFill = document.getElementById('energy-fill');
  const summaryEl = document.getElementById('summary');
  const fullscreenBtn = document.getElementById('fullscreen-btn');

  const pointer = { x: 0, y: 0, active: false };
  const player = { x: 0, y: 0, radius: 18, jitter: 0, trail: [] };

  let viewWidth = canvas.width;
  let viewHeight = canvas.height;

    let glows = [];
    let shadows = [];
    let whispers = [];
    let running = false;
    let score = 0;
    let longest = 0;
    let whisperCount = 0;
    let driftTimer = 0;
    let energy = 100;
    let glowTimer = 0;
    let shadowTimer = 0;
    let whisperTimer = 0;
    let lastTick = 0;

    function resize() {
      const rect = canvas.getBoundingClientRect();
      const prevWidth = viewWidth || rect.width;
      const prevHeight = viewHeight || rect.height;
  const scale = window.devicePixelRatio || 1;
      viewWidth = rect.width || 1;
      viewHeight = rect.height || 1;
      canvas.width = Math.round(viewWidth * scale);
      canvas.height = Math.round(viewHeight * scale);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(scale, scale);

      const playerRatioX = prevWidth ? player.x / prevWidth : 0.5;
      const playerRatioY = prevHeight ? player.y / prevHeight : 0.5;
      const pointerRatioX = prevWidth ? pointer.x / prevWidth : 0.5;
      const pointerRatioY = prevHeight ? pointer.y / prevHeight : 0.5;

      player.x = clamp(playerRatioX * viewWidth, player.radius, viewWidth - player.radius);
      player.y = clamp(playerRatioY * viewHeight, player.radius, viewHeight - player.radius);
      pointer.x = clamp(pointerRatioX * viewWidth, 0, viewWidth);
      pointer.y = clamp(pointerRatioY * viewHeight, 0, viewHeight);

      if (!running && player.trail.length === 0) {
        player.x = viewWidth / 2;
        player.y = viewHeight / 2;
      }
      if (!running && !pointer.active && pointer.x === 0 && pointer.y === 0) {
        pointer.x = viewWidth / 2;
        pointer.y = viewHeight / 2;
      }

      if (prevWidth && prevHeight) {
        const scaleX = viewWidth / prevWidth;
        const scaleY = viewHeight / prevHeight;
        player.trail.forEach((node) => {
          node.x *= scaleX;
          node.y *= scaleY;
        });
        glows.forEach((g) => {
          g.x *= scaleX;
          g.y *= scaleY;
        });
        shadows.forEach((s) => {
          s.x *= scaleX;
          s.y *= scaleY;
        });
        whispers.forEach((w) => {
          w.x *= scaleX;
          w.y *= scaleY;
        });
      }
    }

    function updateFullscreenState() {
      if (!fullscreenBtn) return;
      const active = Boolean(document.fullscreenElement);
      fullscreenBtn.textContent = active ? 'Exit Fullscreen' : 'Fullscreen';
      fullscreenBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
      fullscreenBtn.title = active ? 'Exit fullscreen' : 'Enter fullscreen';
    }

    async function toggleFullscreen() {
      if (!fullscreenBtn) return;
      try {
        if (document.fullscreenElement) {
          await document.exitFullscreen();
        } else if (document.fullscreenEnabled && typeof frame.requestFullscreen === 'function') {
          try {
            await frame.requestFullscreen({ navigationUI: 'hide' });
          } catch (err) {
            await frame.requestFullscreen();
          }
        } else if (frame && frame.webkitRequestFullscreen) {
          frame.webkitRequestFullscreen();
        }
      } catch (err) {
        console.warn('Fullscreen toggle failed', err);
      } finally {
        updateFullscreenState();
      }
    }

    function setPointer(e) {
      const rect = canvas.getBoundingClientRect();
  pointer.x = clamp(e.clientX - rect.left, 0, viewWidth);
  pointer.y = clamp(e.clientY - rect.top, 0, viewHeight);
      pointer.active = true;
    }

    canvas.addEventListener('pointerdown', (e) => {
      setPointer(e);
    });
    canvas.addEventListener('pointermove', (e) => {
      if (e.pressure === 0 && !pointer.active) return;
      setPointer(e);
    });
    window.addEventListener('pointerup', () => {
      pointer.active = false;
    });
    window.addEventListener('blur', () => {
      pointer.active = false;
    });

    function spawnGlow() {
      const edge = Math.random();
      let x;
      let y;
      if (edge < 0.5) {
        x = Math.random() * viewWidth;
        y = Math.random() < 0.5 ? -40 : viewHeight + 40;
      } else {
        x = Math.random() < 0.5 ? -40 : viewWidth + 40;
        y = Math.random() * viewHeight;
      }
      const speed = 20 + Math.random() * 50;
      const angle = Math.atan2(player.y - y, player.x - x) + (Math.random() - 0.5) * 0.6;
      glows.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 16 + Math.random() * 10, radius: 14 + Math.random() * 8 });
    }

    function spawnShadow() {
  const x = Math.random() * viewWidth;
  const y = Math.random() * viewHeight;
      const drift = (Math.random() - 0.5) * 18;
      shadows.push({ x, y, vx: drift, vy: -Math.abs(drift) * 0.4, radius: 26 + Math.random() * 18, pulse: Math.random() * Math.PI * 2 });
    }

    function spawnWhisper() {
      if (!glows.length) return;
      const source = glows[Math.floor(Math.random() * glows.length)];
      whispers.push({ x: source.x, y: source.y, text: pickWhisper(), alpha: 1, life: 2.5 });
      whisperCount += 1;
      notesEl.textContent = whisperCount;
    }

    const whispersPool = [
      'soft current',
      'echo bloom',
      'glacial hum',
      'lilac hush',
      'tidal hymn',
      'ember hush'
    ];
    function pickWhisper() {
      return whispersPool[Math.floor(Math.random() * whispersPool.length)];
    }

    function resetGame() {
      score = 0;
      driftTimer = 0;
      energy = 100;
      glows = [];
      shadows = [];
      whispers = [];
      glowTimer = 0;
      shadowTimer = 1.4;
      whisperTimer = 5;
  player.x = viewWidth / 2;
  player.y = viewHeight / 2;
      player.trail.length = 0;
  pointer.x = viewWidth / 2;
  pointer.y = viewHeight / 2;
      pointer.active = false;
      running = true;
      updateHud();
      summaryEl.textContent = 'Hold still for a moment to let the currents nudge you. Each glint refreshes your glow. Shaded eddies will siphon it away.';
      overlay.classList.add('hidden');
    }

    function endGame() {
      running = false;
      summaryEl.textContent = `You gathered ${score} glints and drifted for ${driftTimer.toFixed(1)} seconds. Longest drift so far: ${longest.toFixed(1)} seconds.`;
      startBtn.textContent = 'Drift Again';
      overlay.classList.remove('hidden');
    }

    startBtn.addEventListener('click', () => {
      resetGame();
    });

    if (fullscreenBtn) {
      if (!document.fullscreenEnabled || typeof frame.requestFullscreen !== 'function') {
        fullscreenBtn.style.display = 'none';
      } else {
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        document.addEventListener('fullscreenchange', updateFullscreenState);
        document.addEventListener('fullscreenerror', updateFullscreenState);
        updateFullscreenState();
      }
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function updateHud() {
      scoreEl.textContent = score;
      longestEl.textContent = `${longest.toFixed(1)}s`;
      energyFill.style.setProperty('--fill', `${(energy / 120) * 100}%`);
    }

    function update(dt) {
      const inertia = pointer.active ? 0.18 : 0.05;
      const sway = pointer.active ? 0 : Math.sin(performance.now() / 1200) * 0.5;
  const targetX = pointer.active ? pointer.x : viewWidth / 2 + Math.cos(performance.now() / 1600) * 60;
  const targetY = pointer.active ? pointer.y : viewHeight / 2 + Math.sin(performance.now() / 1800) * 48;
      player.x += (targetX - player.x) * (inertia + sway * dt);
      player.y += (targetY - player.y) * (inertia + sway * dt);
  player.x = clamp(player.x, 20, viewWidth - 20);
  player.y = clamp(player.y, 20, viewHeight - 20);

      player.trail.push({ x: player.x, y: player.y, life: 0.7 });
      if (player.trail.length > 64) player.trail.shift();
      for (const t of player.trail) t.life -= dt;

      glowTimer -= dt;
      if (glowTimer <= 0) {
        spawnGlow();
        glowTimer = 0.6 + Math.random() * 0.7;
      }

      shadowTimer -= dt;
      if (shadowTimer <= 0) {
        spawnShadow();
        shadowTimer = 5 + Math.random() * 4;
      }

      whisperTimer -= dt;
      if (whisperTimer <= 0) {
        spawnWhisper();
        whisperTimer = 7 + Math.random() * 6;
      }

      for (const g of glows) {
        g.x += g.vx * dt;
        g.y += g.vy * dt;
        g.life -= dt;
      }
  glows = glows.filter((g) => g.life > 0 && g.x > -80 && g.x < viewWidth + 80 && g.y > -80 && g.y < viewHeight + 80);

      for (const s of shadows) {
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        s.pulse += dt * 2;
  if (s.x < -60 || s.x > viewWidth + 60) s.vx *= -1;
  if (s.y < 60 || s.y > viewHeight - 60) s.vy *= -1;
      }

      for (const w of whispers) {
        w.y -= 12 * dt;
        w.life -= dt;
        w.alpha = w.life / 2.5;
      }
      whispers = whispers.filter((w) => w.life > 0);

      driftTimer += dt;
      energy = clamp(energy - dt * 6, 0, 120);

      let collected = false;
      for (let i = glows.length - 1; i >= 0; i -= 1) {
        const g = glows[i];
        const dx = g.x - player.x;
        const dy = g.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < g.radius + player.radius) {
          glows.splice(i, 1);
          score += 1;
          energy = clamp(energy + 18, 0, 120);
          collected = true;
          break;
        }
      }

      if (collected) {
        if (driftTimer > longest) longest = driftTimer;
        driftTimer = 0;
        updateHud();
      }

      for (const s of shadows) {
        const dx = s.x - player.x;
        const dy = s.y - player.y;
        if (Math.hypot(dx, dy) < s.radius + player.radius * 0.6) {
          energy = clamp(energy - dt * 45, 0, 120);
        }
      }

      if (energy <= 0) {
        endGame();
      } else {
        updateHud();
      }
    }

    function draw() {
      ctx.save();
  ctx.clearRect(0, 0, viewWidth, viewHeight);

  const gradient = ctx.createLinearGradient(0, 0, viewWidth, viewHeight);
      gradient.addColorStop(0, '#081227');
      gradient.addColorStop(0.5, '#051426');
      gradient.addColorStop(1, '#0b1124');
      ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, viewWidth, viewHeight);

      ctx.globalCompositeOperation = 'lighter';
      for (const g of glows) {
        const rad = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.radius * 1.6);
        rad.addColorStop(0, 'rgba(116, 216, 255, 0.9)');
        rad.addColorStop(0.6, 'rgba(94, 170, 255, 0.5)');
        rad.addColorStop(1, 'rgba(40, 90, 180, 0)');
        ctx.fillStyle = rad;
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.radius * 1.6, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.globalCompositeOperation = 'source-over';
      for (const s of shadows) {
        const pulse = (Math.sin(s.pulse) + 1) * 0.25;
        const rad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius * 1.3);
        rad.addColorStop(0, `rgba(12, 15, 24, ${0.8 + pulse})`);
        rad.addColorStop(1, 'rgba(6, 8, 16, 0)');
        ctx.fillStyle = rad;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius * 1.3, 0, Math.PI * 2);
        ctx.fill();
      }

      for (const t of player.trail) {
        const alpha = clamp(t.life / 0.7, 0, 1);
        ctx.fillStyle = `rgba(184, 216, 255, ${alpha * 0.35})`;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 12 * alpha, 0, Math.PI * 2);
        ctx.fill();
      }

      const lanternGlow = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.radius * 2.4);
      lanternGlow.addColorStop(0, 'rgba(225, 244, 255, 0.9)');
      lanternGlow.addColorStop(0.4, 'rgba(180, 224, 255, 0.65)');
      lanternGlow.addColorStop(1, 'rgba(90, 160, 255, 0)');
      ctx.fillStyle = lanternGlow;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius * 2.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#f4fbff';
      ctx.beginPath();
      ctx.ellipse(player.x, player.y, player.radius * 0.6, player.radius * 0.9, Math.sin(performance.now() / 900) * 0.3, 0, Math.PI * 2);
      ctx.fill();

      for (const w of whispers) {
        ctx.globalAlpha = clamp(w.alpha, 0, 1);
        ctx.font = '12px "Inter", system-ui, sans-serif';
        ctx.fillStyle = 'rgba(188, 208, 255, 0.85)';
        ctx.fillText(w.text, w.x - 20, w.y);
      }
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function loop(timestamp) {
      if (!lastTick) lastTick = timestamp;
      const dt = Math.min((timestamp - lastTick) / 1000, 0.05);
      lastTick = timestamp;
      if (running) {
        update(dt);
        draw();
      } else {
        draw();
      }
      requestAnimationFrame(loop);
    }

    window.addEventListener('resize', resize);
    resize();
    draw();
    requestAnimationFrame(loop);
  </script>
</body>
<script src="parental.js"></script>
</html>
