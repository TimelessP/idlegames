<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lumen Drift</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at top, #11172f 0%, #05060c 55%, #020309 100%);
      color: #f4f7ff;
      overflow: hidden;
    }
    main {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: rgba(4, 9, 18, 0.7);
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
      touch-action: none;
    }
    .fullscreen-toggle {
      position: absolute;
      top: clamp(12px, 2vw, 24px);
      left: 50%;
      transform: translate(-50%, 0);
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(7, 14, 28, 0.75);
      color: #f4f7ff;
      font: inherit;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.1s ease;
      z-index: 10;
    }
    .fullscreen-toggle:hover {
      background: rgba(18, 28, 48, 0.85);
      transform: translate(-50%, 0);
    }
    .fullscreen-toggle:active { transform: translate(-50%, 0) scale(0.98); }
    .hud {
      position: absolute;
      inset: clamp(12px, 2.8vw, 32px);
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-size: clamp(12px, 2vw, 14px);
      letter-spacing: 0.08em;
    }
    .hud section {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      text-transform: uppercase;
    }
    .hud strong { font-size: 24px; letter-spacing: 0.12em; }
    .energy-bar {
      width: 160px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.1);
      overflow: hidden;
    }
    .energy-bar span {
      display: block;
      height: 100%;
      width: var(--fill, 0%);
      background: linear-gradient(90deg, rgba(60, 204, 255, 0.85), rgba(237, 161, 255, 0.9));
      transition: width 0.2s linear;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(6, 12, 24, 0.78);
      display: grid;
      place-items: center;
      text-align: center;
      padding: clamp(20px, 4vw, 48px);
      gap: 16px;
    }
    .card {
      width: min(440px, 90vw);
      display: grid;
      gap: 18px;
      padding: clamp(20px, 3.6vw, 32px);
      background: rgba(10, 18, 32, 0.82);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 18px;
      box-shadow: 0 24px 48px rgba(3, 8, 20, 0.6);
    }
    h1 {
      margin: 0;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      font-size: 22px;
    }
    p {
      margin: 0;
      color: rgba(218, 224, 255, 0.78);
      line-height: 1.6;
      font-size: 14px;
    }
    button {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 12px 26px;
      font: inherit;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      cursor: pointer;
      background: linear-gradient(90deg, rgba(64, 204, 255, 0.9), rgba(238, 156, 255, 0.95));
      color: #051021;
      transition: transform 0.12s ease, box-shadow 0.2s ease;
      box-shadow: 0 18px 32px rgba(38, 102, 184, 0.45);
    }
  button:not(.fullscreen-toggle):hover { transform: translateY(-2px); box-shadow: 0 24px 40px rgba(38, 102, 184, 0.5); }
  button:not(.fullscreen-toggle):active { transform: translateY(1px) scale(0.98); box-shadow: 0 16px 24px rgba(38, 102, 184, 0.4); }
    .hidden { display: none; }
    @media (max-width: 740px) {
      .hud strong { font-size: 18px; }
      h1 { font-size: 18px; }
    }
  </style>
</head>
<body>
  <main>
    <canvas id="field" width="960" height="600"></canvas>
    <button type="button" id="fullscreen-btn" class="fullscreen-toggle" aria-pressed="false" title="Enter fullscreen">Fullscreen</button>
    <div class="hud">
      <section>
        <div>Glints <strong id="score">0</strong></div>
        <div class="energy-bar"><span id="energy-fill"></span></div>
      </section>
      <section>
        <div>Longest Drift <strong id="longest">0.0s</strong></div>
        <div>Whispers <strong id="notes">0</strong></div>
      </section>
    </div>
    <div class="overlay" id="overlay">
      <div class="card">
        <h1>Lumen Drift</h1>
        <p>Guide a wandering lantern through a current of gentle light. Collect glints, dodge the dusk, and stretch each drift a little longer than the last. Move your pointer (or touch) to beckon the lantern.</p>
  <p id="summary">Hold still for a moment to let the currents nudge you. Each glint refreshes your glow. Violet whispers gift a 10-second shield against the dusk.</p>
        <button id="start-btn">Begin Drift</button>
      </div>
    </div>
  </main>
  <script>
  const canvas = document.getElementById('field');
  const ctx = canvas.getContext('2d');
  const frame = document.querySelector('main');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('start-btn');
  const scoreEl = document.getElementById('score');
  const longestEl = document.getElementById('longest');
  const notesEl = document.getElementById('notes');
  const energyFill = document.getElementById('energy-fill');
  const summaryEl = document.getElementById('summary');
  const fullscreenBtn = document.getElementById('fullscreen-btn');

  const pointer = { x: 0, y: 0, active: false };
  const player = { x: 0, y: 0, radius: 18, jitter: 0, trail: [] };

  let viewWidth = canvas.width;
  let viewHeight = canvas.height;

    let glows = [];
      let shadows = [];
      let whispers = [];
      let shieldParticles = [];
      let running = false;
      let score = 0;
      let longest = 0;
      let whisperCount = 0;
      let driftTimer = 0;
      let energy = 100;
      let glowTimer = 0;
      let shadowTimer = 0;
      let whisperTimer = 0;
      let shieldTimer = 0;
  let shieldParticleTimer = 0;
  let lastTick = 0;

    function resize() {
      const rect = canvas.getBoundingClientRect();
      const prevWidth = viewWidth || rect.width;
      const prevHeight = viewHeight || rect.height;
  const scale = window.devicePixelRatio || 1;
      viewWidth = rect.width || 1;
      viewHeight = rect.height || 1;
      canvas.width = Math.round(viewWidth * scale);
      canvas.height = Math.round(viewHeight * scale);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(scale, scale);

      const playerRatioX = prevWidth ? player.x / prevWidth : 0.5;
      const playerRatioY = prevHeight ? player.y / prevHeight : 0.5;
      const pointerRatioX = prevWidth ? pointer.x / prevWidth : 0.5;
      const pointerRatioY = prevHeight ? pointer.y / prevHeight : 0.5;

      player.x = clamp(playerRatioX * viewWidth, player.radius, viewWidth - player.radius);
      player.y = clamp(playerRatioY * viewHeight, player.radius, viewHeight - player.radius);
      pointer.x = clamp(pointerRatioX * viewWidth, 0, viewWidth);
      pointer.y = clamp(pointerRatioY * viewHeight, 0, viewHeight);

      if (!running && player.trail.length === 0) {
        player.x = viewWidth / 2;
        player.y = viewHeight / 2;
      }
      if (!running && !pointer.active && pointer.x === 0 && pointer.y === 0) {
        pointer.x = viewWidth / 2;
        pointer.y = viewHeight / 2;
      }

      if (prevWidth && prevHeight) {
        const scaleX = viewWidth / prevWidth;
        const scaleY = viewHeight / prevHeight;
        player.trail.forEach((node) => {
          node.x *= scaleX;
          node.y *= scaleY;
        });
        glows.forEach((g) => {
          g.x *= scaleX;
          g.y *= scaleY;
        });
        shadows.forEach((s) => {
          s.x *= scaleX;
          s.y *= scaleY;
        });
        whispers.forEach((w) => {
          w.x *= scaleX;
          w.y *= scaleY;
        });
      }
    }

    function updateFullscreenState() {
      if (!fullscreenBtn) return;
      const active = Boolean(document.fullscreenElement);
      fullscreenBtn.textContent = active ? 'Exit Fullscreen' : 'Fullscreen';
      fullscreenBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
      fullscreenBtn.title = active ? 'Exit fullscreen' : 'Enter fullscreen';
    }

    async function toggleFullscreen() {
      if (!fullscreenBtn) return;
      try {
        if (document.fullscreenElement) {
          await document.exitFullscreen();
        } else if (document.fullscreenEnabled && typeof frame.requestFullscreen === 'function') {
          try {
            await frame.requestFullscreen({ navigationUI: 'hide' });
          } catch (err) {
            await frame.requestFullscreen();
          }
        } else if (frame && frame.webkitRequestFullscreen) {
          frame.webkitRequestFullscreen();
        }
      } catch (err) {
        console.warn('Fullscreen toggle failed', err);
      } finally {
        updateFullscreenState();
      }
    }

    function setPointer(e) {
      const rect = canvas.getBoundingClientRect();
  pointer.x = clamp(e.clientX - rect.left, 0, viewWidth);
  pointer.y = clamp(e.clientY - rect.top, 0, viewHeight);
      pointer.active = true;
    }

    canvas.addEventListener('pointerdown', (e) => {
      setPointer(e);
    });
    canvas.addEventListener('pointermove', (e) => {
      if (e.pressure === 0 && !pointer.active) return;
      setPointer(e);
    });
    window.addEventListener('pointerup', () => {
      pointer.active = false;
    });
    window.addEventListener('blur', () => {
      pointer.active = false;
    });

    function spawnGlow() {
      const edge = Math.random();
      let x;
      let y;
      if (edge < 0.5) {
        x = Math.random() * viewWidth;
        y = Math.random() < 0.5 ? -40 : viewHeight + 40;
      } else {
        x = Math.random() < 0.5 ? -40 : viewWidth + 40;
        y = Math.random() * viewHeight;
      }
      const speed = 20 + Math.random() * 50;
      const angle = Math.atan2(player.y - y, player.x - x) + (Math.random() - 0.5) * 0.6;
      glows.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 16 + Math.random() * 10, radius: 14 + Math.random() * 8 });
    }

    function spawnShadow() {
  const x = Math.random() * viewWidth;
  const y = Math.random() * viewHeight;
      const drift = (Math.random() - 0.5) * 18;
      shadows.push({ x, y, vx: drift, vy: -Math.abs(drift) * 0.4, radius: 26 + Math.random() * 18, pulse: Math.random() * Math.PI * 2 });
    }

    function spawnWhisper() {
      if (!glows.length) return;
      const source = glows[Math.floor(Math.random() * glows.length)];
      const offsetAngle = Math.random() * Math.PI * 2;
      const offsetMag = 40 + Math.random() * 40;
      const spawnX = clamp(source.x + Math.cos(offsetAngle) * offsetMag, 48, viewWidth - 48);
      const spawnY = clamp(source.y + Math.sin(offsetAngle) * offsetMag, 48, viewHeight - 48);
      whispers.push({
        x: spawnX,
        y: spawnY,
        vx: (Math.random() - 0.5) * 12,
        vy: -6 - Math.random() * 6,
        radius: 24 + Math.random() * 6,
        text: pickWhisper(),
        alpha: 1,
        life: 8,
        pulse: Math.random() * Math.PI * 2
      });
    }

    function spawnShieldParticle() {
      const angle = Math.random() * Math.PI * 2;
      const baseDistance = player.radius * 0.6 + Math.random() * 10;
      const speed = 28 + Math.random() * 26;
      const maxLife = 1.6 + Math.random() * 0.6;
      const amplitude = 4 + Math.random() * 6;
      const frequency = 2 + Math.random() * 1.8;
      const normal = angle + Math.PI / 2;
      const baseX = player.x + Math.cos(angle) * baseDistance;
      const baseY = player.y + Math.sin(angle) * baseDistance;
      const sway = Math.sin(0) * amplitude;
      shieldParticles.push({
        angle,
        distance: baseDistance,
        speed,
        time: 0,
        amplitude,
        frequency,
        maxLife,
        life: maxLife,
        x: baseX + Math.cos(normal) * sway,
        y: baseY + Math.sin(normal) * sway
      });
      if (shieldParticles.length > 140) {
        shieldParticles.splice(0, shieldParticles.length - 140);
      }
    }

    function activateShield() {
      shieldTimer = 10;
    }

    const whispersPool = [
      'soft current',
      'echo bloom',
      'glacial hum',
      'lilac hush',
      'tidal hymn',
      'ember hush',
      'silver drift',
      'quiet lagoon',
      'mist lullaby',
      'harmony float',
      'violet murmur',
      'aurora sigh',
      'gossamer hush',
      'twilight hymn',
      'lucid tide',
      'moonlit hush',
      'soft phosphor',
      'glow chorus',
      'serene glint',
      'calm horizon',
      'starlit lull',
      'gentle ripple',
      'warm halo',
      'velvet hush',
      'whisper bloom',
      'dream drift',
      'tidal lull',
      'satin hush',
      'auric lull',
      'deep lullaby',
      'distant bell',
      'celestial hush',
      'calm cadence',
      'quiet glimmer',
      'teal lull',
      'gentle pulse',
      'soothing hush',
      'soft prism',
      'horizon hum',
      'echo shimmer',
      'tranquil hum',
      'nebula lull',
      'gleam hush',
      'soft lumen',
      'opalescent hush',
      'lavender hymn',
      'serenity murmur',
      'mariner hymn',
      'moonglow hum',
      'light lullaby',
      'silken hum',
      'gentle echo',
      'satin tide',
      'evening hymn',
      'cosmic whisper',
      'aurora hum',
      'luminal hush',
      'silver lull',
      'quiet aurora',
      'calm shimmer',
      'gentle orbit',
      'soft eclipse',
      'hushed ember',
      'dawn hum',
      'skyline hush',
      'mellow tide',
      'silk hymn',
      'deep hush',
      'ether hush',
      'zenith hum',
      'still tide',
      'calm halo',
      'soft galena',
      'evening hush',
      'night whisper',
      'violet echo',
      'gentle prism',
      'glacial lull',
      'moon hush',
      'tide lullaby',
      'soft resonance',
      'quiet shimmer',
      'gentle halo',
      'distant hush',
      'serene lumen',
      'dream hush'
    ];
    function pickWhisper() {
      return whispersPool[Math.floor(Math.random() * whispersPool.length)];
    }

    function resetGame() {
      score = 0;
      driftTimer = 0;
      energy = 100;
      glows = [];
      shadows = [];
      whispers = [];
    shieldParticles = [];
      glowTimer = 0;
      shadowTimer = 1.4;
      whisperTimer = 5;
    shieldTimer = 0;
    whisperCount = 0;
  shieldParticleTimer = 0;
  player.x = viewWidth / 2;
  player.y = viewHeight / 2;
      player.trail.length = 0;
  pointer.x = viewWidth / 2;
  pointer.y = viewHeight / 2;
      pointer.active = false;
      running = true;
      updateHud();
  summaryEl.textContent = 'Hold still for a moment to let the currents nudge you. Each glint refreshes your glow. Violet whispers gift a 10-second shield against the dusk.';
      overlay.classList.add('hidden');
    }

    function endGame() {
      running = false;
      summaryEl.textContent = `You gathered ${score} glints and drifted for ${driftTimer.toFixed(1)} seconds. Longest drift so far: ${longest.toFixed(1)} seconds.`;
      startBtn.textContent = 'Drift Again';
      overlay.classList.remove('hidden');
    }

    startBtn.addEventListener('click', () => {
      resetGame();
    });

    if (fullscreenBtn) {
      if (!document.fullscreenEnabled || typeof frame.requestFullscreen !== 'function') {
        fullscreenBtn.style.display = 'none';
      } else {
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        document.addEventListener('fullscreenchange', updateFullscreenState);
        document.addEventListener('fullscreenerror', updateFullscreenState);
        updateFullscreenState();
      }
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function updateHud() {
      scoreEl.textContent = score;
      longestEl.textContent = `${longest.toFixed(1)}s`;
      notesEl.textContent = whisperCount;
      energyFill.style.setProperty('--fill', `${(energy / 120) * 100}%`);
    }

    function update(dt) {
      if (shieldTimer > 0) {
        shieldTimer = Math.max(0, shieldTimer - dt);
      }
      let shieldActive = shieldTimer > 0;
      if (shieldActive) {
        shieldParticleTimer -= dt;
        const interval = 0.08;
        while (shieldParticleTimer <= 0) {
          spawnShieldParticle();
          shieldParticleTimer += interval;
        }
      } else if (shieldParticles.length === 0) {
        shieldParticleTimer = 0;
      }
      const inertia = pointer.active ? 0.18 : 0.05;
      const sway = pointer.active ? 0 : Math.sin(performance.now() / 1200) * 0.5;
  const targetX = pointer.active ? pointer.x : viewWidth / 2 + Math.cos(performance.now() / 1600) * 60;
  const targetY = pointer.active ? pointer.y : viewHeight / 2 + Math.sin(performance.now() / 1800) * 48;
      player.x += (targetX - player.x) * (inertia + sway * dt);
      player.y += (targetY - player.y) * (inertia + sway * dt);
  player.x = clamp(player.x, 20, viewWidth - 20);
  player.y = clamp(player.y, 20, viewHeight - 20);

      player.trail.push({ x: player.x, y: player.y, life: 0.7 });
      if (player.trail.length > 64) player.trail.shift();
      for (const t of player.trail) t.life -= dt;

      glowTimer -= dt;
      if (glowTimer <= 0) {
        spawnGlow();
        glowTimer = 0.6 + Math.random() * 0.7;
      }

      shadowTimer -= dt;
      if (shadowTimer <= 0) {
        spawnShadow();
        shadowTimer = 5 + Math.random() * 4;
      }

      whisperTimer -= dt;
      if (whisperTimer <= 0) {
        spawnWhisper();
        whisperTimer = 7 + Math.random() * 6;
      }

      for (const g of glows) {
        g.x += g.vx * dt;
        g.y += g.vy * dt;
        g.life -= dt;
      }
  glows = glows.filter((g) => g.life > 0 && g.x > -80 && g.x < viewWidth + 80 && g.y > -80 && g.y < viewHeight + 80);

      for (const s of shadows) {
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        s.pulse += dt * 2;
  if (s.x < -60 || s.x > viewWidth + 60) s.vx *= -1;
  if (s.y < 60 || s.y > viewHeight - 60) s.vy *= -1;
      }

      for (const w of whispers) {
        w.x += w.vx * dt;
        w.y += w.vy * dt;
        w.vx *= 0.98;
        w.vy *= 0.98;
        w.pulse += dt * 1.5;
        w.life -= dt;
        w.alpha = clamp(w.life / 8, 0, 1);
      }
      whispers = whispers.filter((w) => w.life > 0);

      for (const p of shieldParticles) {
        p.time += dt;
        p.life -= dt;
        p.distance += p.speed * dt;
        const baseX = player.x + Math.cos(p.angle) * p.distance;
        const baseY = player.y + Math.sin(p.angle) * p.distance;
        const normal = p.angle + Math.PI / 2;
        const sway = Math.sin(p.time * p.frequency) * p.amplitude;
        p.x = baseX + Math.cos(normal) * sway;
        p.y = baseY + Math.sin(normal) * sway;
      }
      shieldParticles = shieldParticles.filter((p) => p.life > 0);

      driftTimer += dt;
      energy = clamp(energy - dt * 6, 0, 120);

      let collected = false;
      for (let i = glows.length - 1; i >= 0; i -= 1) {
        const g = glows[i];
        const dx = g.x - player.x;
        const dy = g.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < g.radius + player.radius) {
          glows.splice(i, 1);
          score += 1;
          energy = clamp(energy + 18, 0, 120);
          collected = true;
          break;
        }
      }

      let shieldCollected = false;
      for (let i = whispers.length - 1; i >= 0; i -= 1) {
        const w = whispers[i];
        const dx = w.x - player.x;
        const dy = w.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < w.radius + player.radius) {
          whispers.splice(i, 1);
          whisperCount += 1;
          activateShield();
          shieldCollected = true;
          shieldActive = true;
        }
      }

      if (collected) {
        if (driftTimer > longest) longest = driftTimer;
        driftTimer = 0;
        updateHud();
      }

      if (shieldCollected) {
        updateHud();
      }

      for (const s of shadows) {
        const dx = s.x - player.x;
        const dy = s.y - player.y;
        if (Math.hypot(dx, dy) < s.radius + player.radius * 0.6) {
          if (!shieldActive) {
            energy = clamp(energy - dt * 45, 0, 120);
          }
        }
      }

      if (energy <= 0) {
        endGame();
      } else {
        updateHud();
      }
    }

    function draw() {
      ctx.save();
  ctx.clearRect(0, 0, viewWidth, viewHeight);

  const gradient = ctx.createLinearGradient(0, 0, viewWidth, viewHeight);
      gradient.addColorStop(0, '#081227');
      gradient.addColorStop(0.5, '#051426');
      gradient.addColorStop(1, '#0b1124');
      ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, viewWidth, viewHeight);

      const shieldActive = shieldTimer > 0;

      ctx.globalCompositeOperation = 'lighter';
      for (const g of glows) {
        const rad = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.radius * 1.6);
        rad.addColorStop(0, 'rgba(116, 216, 255, 0.9)');
        rad.addColorStop(0.6, 'rgba(94, 170, 255, 0.5)');
        rad.addColorStop(1, 'rgba(40, 90, 180, 0)');
        ctx.fillStyle = rad;
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.radius * 1.6, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.globalCompositeOperation = 'source-over';
      for (const s of shadows) {
        const pulse = (Math.sin(s.pulse) + 1) * 0.25;
        const rad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius * 1.3);
        rad.addColorStop(0, `rgba(12, 15, 24, ${0.8 + pulse})`);
        rad.addColorStop(1, 'rgba(6, 8, 16, 0)');
        ctx.fillStyle = rad;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius * 1.3, 0, Math.PI * 2);
        ctx.fill();
      }

      for (const t of player.trail) {
        const alpha = clamp(t.life / 0.7, 0, 1);
        ctx.fillStyle = `rgba(184, 216, 255, ${alpha * 0.35})`;
        ctx.beginPath();
        ctx.arc(t.x, t.y, 12 * alpha, 0, Math.PI * 2);
        ctx.fill();
      }

      if (shieldParticles.length) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (const p of shieldParticles) {
          const alpha = clamp(p.life / p.maxLife, 0, 1);
          const radius = 2 + alpha * 3.5;
          ctx.fillStyle = `rgba(206, 176, 255, ${0.4 * alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      if (shieldActive) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const shieldAura = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.radius * 3.4);
        shieldAura.addColorStop(0, 'rgba(255, 255, 255, 0.24)');
        shieldAura.addColorStop(0.35, 'rgba(216, 186, 255, 0.28)');
        shieldAura.addColorStop(1, 'rgba(120, 70, 220, 0)');
        ctx.fillStyle = shieldAura;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius * 3.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowColor = 'rgba(10, 0, 30, 0.7)';
        ctx.shadowBlur = 6;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;
        ctx.restore();
      }

      const lanternGlow = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, player.radius * 2.4);
      if (shieldActive) {
        lanternGlow.addColorStop(0, 'rgba(255, 255, 255, 0.96)');
        lanternGlow.addColorStop(0.45, 'rgba(226, 204, 255, 0.8)');
        lanternGlow.addColorStop(1, 'rgba(150, 120, 255, 0)');
      } else {
        lanternGlow.addColorStop(0, 'rgba(225, 244, 255, 0.9)');
        lanternGlow.addColorStop(0.4, 'rgba(180, 224, 255, 0.65)');
        lanternGlow.addColorStop(1, 'rgba(90, 160, 255, 0)');
      }
      ctx.fillStyle = lanternGlow;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius * 2.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = shieldActive ? '#ffffff' : '#f4fbff';
      ctx.beginPath();
      ctx.ellipse(player.x, player.y, player.radius * 0.6, player.radius * 0.9, Math.sin(performance.now() / 900) * 0.3, 0, Math.PI * 2);
      ctx.fill();

      for (const w of whispers) {
        const alpha = clamp(w.alpha, 0, 1);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = 'rgba(230, 214, 255, 0.95)';
        ctx.font = '16px "Inter", system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(10, 0, 30, 0.7)';
        ctx.shadowBlur = 6;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;
        ctx.fillText(w.text, w.x, w.y);
        ctx.restore();
      }

      ctx.restore();
    }

    function loop(timestamp) {
      if (!lastTick) lastTick = timestamp;
      const dt = Math.min((timestamp - lastTick) / 1000, 0.05);
      lastTick = timestamp;
      if (running) {
        update(dt);
        draw();
      } else {
        draw();
      }
      requestAnimationFrame(loop);
    }

    window.addEventListener('resize', resize);
    resize();
    draw();
    requestAnimationFrame(loop);
  </script>
</body>
<script src="parental.js"></script>
</html>
