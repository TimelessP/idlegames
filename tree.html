<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tree Decorator</title>
    <meta name="description" content="A cozy, fractal-based Christmas tree decorating game. Draw glowing lights, place ornaments, and enjoy the festive atmosphere.">
    <meta name="theme-color" content="#1a1a2e">
    <link rel="manifest" href="manifest.webmanifest">
    <script type="module" src="assets/js/pwa.js" defer></script>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --ui-bg: rgba(255, 255, 255, 0.1);
            --ui-text: #fff;
            --accent: #ffeb3b;
        }
        body {
            margin: 0;
            padding: 0;
            background: var(--bg-color);
            color: var(--ui-text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none; /* Prevent default touch actions like scrolling */
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to SVG where not on UI elements */
        }
        .ui-panel {
            pointer-events: auto;
            background: rgba(20, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 10px;
            margin: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 60px;
            align-items: center;
        }
        #decorations-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row;
            overflow-x: auto;
            max-width: 90%;
            padding: 10px 20px;
            gap: 15px;
            scrollbar-width: none; /* Firefox */
        }
        #decorations-box::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .control-btn.active {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 10px var(--accent);
        }
        .deco-item {
            font-size: 32px;
            cursor: grab;
            user-select: none;
            transition: transform 0.2s;
            cursor: pointer;
        }
        .deco-item:hover {
            transform: scale(1.2);
        }
        .deco-item:active {
            cursor: grabbing;
        }
        
        /* SVG Styles */
        svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        .tree-poly {
            stroke: none;
        }
        .wire {
            fill: none;
            stroke: #222;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }
        .light-bulb {
            transition: fill 0.2s, filter 0.2s;
        }
        .light-glow {
            mix-blend-mode: screen;
            pointer-events: none;
        }
        
        /* Animations */
        @keyframes twinkle {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #back-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0,0,0,0.3);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            pointer-events: auto;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #back-btn:hover {
            background: rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <a id="back-btn" href="index.html">‚Üê Back</a>

    <div id="ui-layer">
        <div id="controls" class="ui-panel">
            <button class="control-btn" id="btn-power" title="Toggle Lights">üí°</button>
            <button class="control-btn" id="btn-mode" title="Cycle Mode">üîÑ</button>
            <button class="control-btn" id="btn-clear-lights" title="Clear Lights">‚úÇÔ∏è</button>
            <button class="control-btn" id="btn-clear-decos" title="Clear Decorations">üóëÔ∏è</button>
        </div>
        
        <div id="decorations-box" class="ui-panel">
            <!-- Emojis will be injected here -->
        </div>
        
        <div id="wastebasket" class="ui-panel" style="position: absolute; bottom: 20px; right: 20px; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 30px; border-radius: 50%; cursor: drop;">
            üóëÔ∏è
        </div>
    </div>

    <div id="game-container">
        <svg id="main-svg" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMax slice">
            <defs>
                <radialGradient id="wall-glow" cx="0.5" cy="0.5" r="0.8">
                    <stop offset="0%" stop-color="#2a2a4a" />
                    <stop offset="100%" stop-color="#111" />
                </radialGradient>
                <filter id="glow-filter" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
                <filter id="soft-shadow" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                    <feOffset dx="2" dy="2" result="offsetblur"/>
                    <feComponentTransfer>
                        <feFuncA type="linear" slope="0.3"/>
                    </feComponentTransfer>
                    <feMerge>
                        <feMergeNode/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
            
            <!-- Background -->
            <rect x="-5000" y="-5000" width="10000" height="10000" fill="url(#wall-glow)" />
            
            <!-- Skirting Board -->
            <rect x="-5000" y="850" width="10000" height="150" fill="#3e2723" />
            <rect x="-5000" y="850" width="10000" height="10" fill="#5d4037" />
            
            <!-- Carpet -->
            <rect x="-5000" y="860" width="10000" height="140" fill="#5c1a1a" />
            <!-- Carpet texture (noise) could be added here -->
            
            <!-- Tree Layer -->
            <g id="tree-layer" filter="url(#soft-shadow)"></g>
            
            <!-- Presents Layer -->
            <g id="presents-layer"></g>
            
            <!-- Wires Layer -->
            <g id="wires-layer"></g>
            
            <!-- Lights Layer -->
            <g id="lights-layer"></g>
            
            <!-- Decorations Layer -->
            <g id="decorations-layer"></g>
            
            <!-- Drag Layer (for moving items) -->
            <g id="drag-layer"></g>
        </svg>
    </div>

    <script>
        // --- Configuration ---
        const CONFIG = {
            treeBaseX: 500,
            treeBaseY: 920,
            treeHeight: 700,
            wireThreshold: 20, // Distance to drag before adding a new node
            colors: {
                treeLight: '#2e7d32',
                treeDark: '#1b5e20',
                wire: '#111'
            },
            lightColors: ['#ff5252', '#ffeb3b', '#40c4ff', '#69f0ae', '#e040fb'],
            decorations: ['üî¥', 'üîµ', 'üü°', '‚≠ê', 'üéÄ', 'üîî', 'üïØÔ∏è', 'üç™', 'üç≠', '‚ùÑÔ∏è', 'ü¶å', 'üéÖ']
        };

        // --- State ---
        const state = {
            lightsOn: true,
            lightMode: 0, // 0: Steady, 1: Blink, 2: Chase, 3: Random
            wireNodes: [], // Array of arrays of points [[{x,y}, {x,y}...], ...] (multiple strands)
            currentStrand: null,
            decorations: [], // {id, emoji, x, y, scale}
            isDraggingWire: false,
            isDraggingDeco: false,
            draggedDeco: null,
            treePolygons: [], // For collision detection
            time: 0,
            viewBox: { x: 0, y: 0, w: 1000, h: 1000 },
            isPanning: false,
            lastPanPoint: { x: 0, y: 0 },
            lastPinchDist: 0,
            lastPinchCenter: { x: 0, y: 0 }
        };

        // --- Elements ---
        const svg = document.getElementById('main-svg');
        const treeLayer = document.getElementById('tree-layer');
        const wiresLayer = document.getElementById('wires-layer');
        const lightsLayer = document.getElementById('lights-layer');
        const decosLayer = document.getElementById('decorations-layer');
        const dragLayer = document.getElementById('drag-layer');
        const presentsLayer = document.getElementById('presents-layer');
        const decoBox = document.getElementById('decorations-box');

        // --- Initialization ---
        function init() {
            handleResize();
            generateTree();
            generatePresents();
            initUI();
            setupInteraction();
            requestAnimationFrame(gameLoop);
        }
        
        function handleResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const aspect = w / h;
            
            // We want to see at least this box:
            const minW = 700;
            const minH = 950; // From y=50 to y=1000
            
            let vw, vh;
            
            if (aspect > minW / minH) {
                // Screen is wider. Fit height.
                vh = minH;
                vw = vh * aspect;
            } else {
                // Screen is taller. Fit width.
                vw = minW;
                vh = vw / aspect;
            }
            
            const vx = 500 - vw / 2;
            const vy = 1000 - vh;
            
            state.viewBox = { x: vx, y: vy, w: vw, h: vh };
            updateViewBox();
        }
        
        function updateViewBox() {
            svg.setAttribute('viewBox', `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.w} ${state.viewBox.h}`);
        }

        // --- Tree Generation (Fractal-ish) ---
        function generateTree() {
            // Clear existing
            treeLayer.innerHTML = '';
            state.treePolygons = [];

            // Simple recursive function to draw branches
            // We'll draw from bottom up
            
            // Trunk
            drawTrunk(CONFIG.treeBaseX, CONFIG.treeBaseY, 60, 100);

            // Recursive branches
            // startX, startY, length, angle (degrees, 0 is up), width, depth
            growBranch(CONFIG.treeBaseX, CONFIG.treeBaseY - 80, 180, 0, 140, 6);
        }
        
        function createStarElement(cx, cy, scale = 1, rotation = 0) {
            const spikes = 5;
            const outerRadius = 30 * scale;
            const innerRadius = 15 * scale;
            let rot = (Math.PI / 2 * 3) + (rotation * Math.PI / 180);
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;

            let points = [];
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                points.push([x, y]);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                points.push([x, y]);
                rot += step;
            }
            
            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            poly.setAttribute('points', points.map(p => p.join(',')).join(' '));
            poly.setAttribute('fill', '#ffd700');
            poly.setAttribute('filter', 'url(#glow-filter)');
            // Add a class for interaction if needed, though decosLayer handles it via parent usually
            return poly;
        }

        function drawTrunk(x, y, width, height) {
            const halfW = width / 2;
            const points = [
                [x - halfW, y],
                [x + halfW, y],
                [x + halfW * 0.8, y - height],
                [x - halfW * 0.8, y - height]
            ];
            drawPoly(points, '#5d4037', '#3e2723');
        }

        function growBranch(x, y, len, angle, width, depth) {
            if (depth <= 0) return;

            const rad = (angle - 90) * Math.PI / 180;
            const endX = x + Math.cos(rad) * len;
            const endY = y + Math.sin(rad) * len;

            // Draw this segment as a triangle/trapezoid
            // We want a "pine" look, so maybe just a triangle pointing along the angle
            
            // Calculate perpendicular vectors for width
            const perpAngle = rad + Math.PI / 2;
            const w2 = width * 0.6; // Taper
            
            const p1x = x + Math.cos(perpAngle) * (width / 2);
            const p1y = y + Math.sin(perpAngle) * (width / 2);
            const p2x = x - Math.cos(perpAngle) * (width / 2);
            const p2y = y - Math.sin(perpAngle) * (width / 2);
            
            // End points (tapered)
            const p3x = endX - Math.cos(perpAngle) * (w2 / 2);
            const p3y = endY - Math.sin(perpAngle) * (w2 / 2);
            const p4x = endX + Math.cos(perpAngle) * (w2 / 2);
            const p4y = endY + Math.sin(perpAngle) * (w2 / 2);

            // Draw the main body of this branch segment
            // Actually, for a pine tree, we want "foliage" shapes.
            // Let's draw a jagged triangle.
            
            const polyPoints = [
                [p1x, p1y],
                [p2x, p2y],
                [endX, endY] // Triangle tip
            ];
            
            // Add some noise/jaggedness to the sides
            // ... (simplified for now: just split triangle)
            
            drawPoly(polyPoints, CONFIG.colors.treeLight, CONFIG.colors.treeDark);
            
            // Store polygon for collision
            state.treePolygons.push(polyPoints);

            // Recursion
            const nextLen = len * 0.75;
            const nextWidth = width * 0.7;
            
            // Continue straight
            growBranch(endX, endY, nextLen, angle, nextWidth, depth - 1);
            
            // Side branches
            // Only branch if depth is high enough or randomly
            if (depth > 1) {
                growBranch(x + (endX-x)*0.3, y + (endY-y)*0.3, nextLen * 0.8, angle - 45, nextWidth * 0.8, depth - 1);
                growBranch(x + (endX-x)*0.3, y + (endY-y)*0.3, nextLen * 0.8, angle + 45, nextWidth * 0.8, depth - 1);
                
                // Maybe another pair higher up
                growBranch(x + (endX-x)*0.6, y + (endY-y)*0.6, nextLen * 0.6, angle - 30, nextWidth * 0.6, depth - 1);
                growBranch(x + (endX-x)*0.6, y + (endY-y)*0.6, nextLen * 0.6, angle + 30, nextWidth * 0.6, depth - 1);
            }
        }

        function drawPoly(points, colorLight, colorDark) {
            // Create SVG polygon
            // We split it into two halves for shading
            
            // Simple approach: Draw full polygon in Dark, then draw left half in Light.
            
            const pointsStr = points.map(p => p.join(',')).join(' ');
            
            const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            poly.setAttribute('points', pointsStr);
            poly.setAttribute('fill', colorDark);
            treeLayer.appendChild(poly);
            
            // Shaded half (Light)
            // Let's just overlay a lighter polygon on the "lit" side.
            // For a triangle A(Right), B(Left), C(Tip), the lit side is Left (B).
            if (points.length === 3) {
                const [A, B, C] = points;
                const midBase = [(A[0] + B[0])/2, (A[1] + B[1])/2];
                // Light from left -> Light up Left side (B)
                const litPoints = [B, midBase, C];
                const litPoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                litPoly.setAttribute('points', litPoints.map(p => p.join(',')).join(' '));
                litPoly.setAttribute('fill', colorLight);
                treeLayer.appendChild(litPoly);
            } else if (points.length === 4) {
                // Trapezoid (Trunk)
                // Just fill with light and shadow right side
                poly.setAttribute('fill', colorLight);
                
                const w = Math.abs(points[1][0] - points[0][0]);
                const h = Math.abs(points[2][1] - points[0][1]);
                const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                shadow.setAttribute('x', points[0][0] + w/2);
                shadow.setAttribute('y', points[2][1]);
                shadow.setAttribute('width', w/2);
                shadow.setAttribute('height', h);
                shadow.setAttribute('fill', 'rgba(0,0,0,0.3)');
                treeLayer.appendChild(shadow);
            }
        }

        function generatePresents() {
            const colors = ['#e53935', '#1e88e5', '#43a047', '#fdd835', '#8e24aa'];
            for (let i = 0; i < 8; i++) {
                const w = 40 + Math.random() * 60;
                const h = 30 + Math.random() * 50;
                const x = CONFIG.treeBaseX - 200 + Math.random() * 400;
                const y = CONFIG.treeBaseY - h + 10; // Slightly buried in carpet
                
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Box
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', w);
                rect.setAttribute('height', h);
                rect.setAttribute('fill', color);
                rect.setAttribute('stroke', '#000');
                rect.setAttribute('stroke-width', '1');
                g.appendChild(rect);
                
                // Ribbon (vertical)
                const ribV = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                ribV.setAttribute('x', x + w/2 - 5);
                ribV.setAttribute('y', y);
                ribV.setAttribute('width', 10);
                ribV.setAttribute('height', h);
                ribV.setAttribute('fill', '#fff');
                g.appendChild(ribV);
                
                // Ribbon (horizontal)
                const ribH = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                ribH.setAttribute('x', x);
                ribH.setAttribute('y', y + h/2 - 5);
                ribH.setAttribute('width', w);
                ribH.setAttribute('height', 10);
                ribH.setAttribute('fill', '#fff');
                g.appendChild(ribH);
                
                presentsLayer.appendChild(g);
            }
        }

        // --- UI & Interaction ---
        function initUI() {
            // Populate decorations
            CONFIG.decorations.forEach(emoji => {
                const span = document.createElement('span');
                span.className = 'deco-item';
                span.textContent = emoji;
                span.onmousedown = (e) => startDragDeco(e, emoji);
                span.ontouchstart = (e) => startDragDeco(e, emoji);
                decoBox.appendChild(span);
            });

            document.getElementById('btn-power').onclick = () => {
                state.lightsOn = !state.lightsOn;
                renderLights();
            };
            
            document.getElementById('btn-mode').onclick = () => {
                state.lightMode = (state.lightMode + 1) % 4;
            };
            
            document.getElementById('btn-clear-lights').onclick = () => {
                if(confirm('Remove all lights?')) {
                    state.wireNodes = [];
                    renderWires();
                    renderLights();
                }
            };
            
            document.getElementById('btn-clear-decos').onclick = () => {
                if(confirm('Remove all decorations?')) {
                    state.decorations = [];
                    renderDecos();
                }
            };
        }

        function setupInteraction() {
            // SVG interaction for wires
            svg.addEventListener('pointerdown', handlePointerDown);
            
            // Global interaction for dragging (wires or decos)
            window.addEventListener('pointermove', handlePointerMove);
            window.addEventListener('pointerup', handlePointerUp);
            
            // Zoom
            window.addEventListener('wheel', handleWheel, { passive: false });
            
            // Touch gestures (Pinch/Pan)
            // We use touch events directly for multi-touch support
            window.addEventListener('touchstart', handleTouchStart, { passive: false });
            window.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd);
            
            // Prevent context menu on right click
            window.addEventListener('contextmenu', e => e.preventDefault());
        }

        function getSVGPoint(e) {
            const pt = svg.createSVGPoint();
            // Handle touch or mouse
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
            pt.x = clientX;
            pt.y = clientY;
            return pt.matrixTransform(svg.getScreenCTM().inverse());
        }
        
        function handleWheel(e) {
            if (e.target.closest('.ui-panel')) return;
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
            
            // Zoom towards mouse pointer
            const pt = getSVGPoint(e);
            
            const oldW = state.viewBox.w;
            const oldH = state.viewBox.h;
            const newW = oldW * zoomFactor;
            const newH = oldH * zoomFactor;
            
            // Calculate new X/Y to keep pt at same screen position
            // P_screen = (P_svg - VB_x) / VB_w * Screen_w
            // We want P_screen to be constant.
            // (P_svg - NewVB_x) / NewVB_w = (P_svg - OldVB_x) / OldVB_w
            // P_svg - NewVB_x = (P_svg - OldVB_x) * (NewVB_w / OldVB_w)
            // NewVB_x = P_svg - (P_svg - OldVB_x) * zoomFactor
            
            state.viewBox.x = pt.x - (pt.x - state.viewBox.x) * zoomFactor;
            state.viewBox.y = pt.y - (pt.y - state.viewBox.y) * zoomFactor;
            state.viewBox.w = newW;
            state.viewBox.h = newH;
            
            updateViewBox();
        }

        function handlePointerDown(e) {
            if (e.target.closest('.ui-panel') || e.target.closest('#back-btn')) return;
            
            // Right click pan
            if (e.button === 2) {
                state.isPanning = true;
                state.lastPanPoint = { x: e.clientX, y: e.clientY };
                return;
            }
            
            // If touch, wait for touchstart to handle multi-touch
            if (e.pointerType === 'touch') return;
            
            const pt = getSVGPoint(e);
            
            // Check if clicking an existing decoration to move/remove it
            for (let i = state.decorations.length - 1; i >= 0; i--) {
                const d = state.decorations[i];
                // Simple distance check - adjust for star size?
                const dist = Math.hypot(d.x - pt.x, d.y - pt.y);
                if (dist < 30) {
                    // Pick up existing
                    state.decorations.splice(i, 1);
                    renderDecos();
                    startDragDeco(e, d.emoji);
                    return;
                }
            }

            // Start drawing wire
            state.isDraggingWire = true;
            state.currentStrand = [{x: pt.x, y: pt.y}];
            state.wireNodes.push(state.currentStrand);
            renderWires();
        }

        function handlePointerMove(e) {
            if (state.isPanning && e.pointerType !== 'touch') {
                const dx = e.clientX - state.lastPanPoint.x;
                const dy = e.clientY - state.lastPanPoint.y;
                
                // Convert screen delta to SVG delta
                // Scale = VB_w / Screen_w
                // Actually we can just use getScreenCTM logic or simple ratio
                const screenW = svg.clientWidth;
                const scale = state.viewBox.w / screenW;
                
                state.viewBox.x -= dx * scale;
                state.viewBox.y -= dy * scale;
                updateViewBox();
                
                state.lastPanPoint = { x: e.clientX, y: e.clientY };
                return;
            }

            if (!state.isDraggingWire && !state.isDraggingDeco) return;
            
            const pt = getSVGPoint(e);

            if (state.isDraggingWire) {
                const strand = state.currentStrand;
                const lastNode = strand[strand.length - 1];
                const dist = Math.hypot(pt.x - lastNode.x, pt.y - lastNode.y);
                
                if (dist > CONFIG.wireThreshold) {
                    strand.push({x: pt.x, y: pt.y});
                    renderWires();
                    renderLights(); // Add new light
                }
            } else if (state.isDraggingDeco) {
                // Update drag layer
                dragLayer.innerHTML = '';
                
                if (state.draggedDeco === '‚≠ê') {
                    const star = createStarElement(pt.x, pt.y, 1.5, 0);
                    star.setAttribute('pointer-events', 'none');
                    dragLayer.appendChild(star);
                } else {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.textContent = state.draggedDeco;
                    text.setAttribute('x', pt.x);
                    text.setAttribute('y', pt.y);
                    text.setAttribute('font-size', '40');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('pointer-events', 'none');
                    dragLayer.appendChild(text);
                }
            }
        }

        function handlePointerUp(e) {
            if (state.isPanning) {
                state.isPanning = false;
            }
            
            if (state.isDraggingWire) {
                state.isDraggingWire = false;
                state.currentStrand = null;
            } else if (state.isDraggingDeco) {
                const pt = getSVGPoint(e);
                
                // Check wastebasket
                const wb = document.getElementById('wastebasket');
                const wbRect = wb.getBoundingClientRect();
                const clientX = e.clientX || (e.changedTouches ? e.changedTouches[0].clientX : 0);
                const clientY = e.clientY || (e.changedTouches ? e.changedTouches[0].clientY : 0);
                
                if (clientX >= wbRect.left && clientX <= wbRect.right &&
                    clientY >= wbRect.top && clientY <= wbRect.bottom) {
                    // Discarded
                    state.isDraggingDeco = false;
                    state.draggedDeco = null;
                    dragLayer.innerHTML = '';
                    return;
                }
                
                // Check if dropped on tree
                const onTree = isPointInTree(pt.x, pt.y);
                
                state.decorations.push({
                    emoji: state.draggedDeco,
                    x: pt.x,
                    y: pt.y,
                    rotation: (Math.random() - 0.5) * 30,
                    vy: 0,
                    isFalling: !onTree
                });
                
                renderDecos();
                
                state.isDraggingDeco = false;
                state.draggedDeco = null;
                dragLayer.innerHTML = '';
            }
        }
        
        // Touch Handlers for Multi-touch
        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                state.isPanning = true; // Reuse flag for 2-finger pan
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                const cx = (t1.clientX + t2.clientX) / 2;
                const cy = (t1.clientY + t2.clientY) / 2;
                
                state.lastPinchDist = dist;
                state.lastPinchCenter = { x: cx, y: cy };
            } else if (e.touches.length === 1) {
                // Delegate to pointerdown logic manually if needed, 
                // but pointerdown usually fires for touch too.
                // However, we returned early in pointerdown for touch to avoid conflict.
                // Let's handle single touch start here for game logic.
                
                if (e.target.closest('.ui-panel') || e.target.closest('#back-btn')) return;
                
                const t = e.touches[0];
                const pt = getSVGPoint(t);
                
                // Check existing deco
                for (let i = state.decorations.length - 1; i >= 0; i--) {
                    const d = state.decorations[i];
                    const dist = Math.hypot(d.x - pt.x, d.y - pt.y);
                    if (dist < 30) {
                        state.decorations.splice(i, 1);
                        renderDecos();
                        startDragDeco(e, d.emoji);
                        return;
                    }
                }
                
                // Start wire
                state.isDraggingWire = true;
                state.currentStrand = [{x: pt.x, y: pt.y}];
                state.wireNodes.push(state.currentStrand);
                renderWires();
            }
        }
        
        function handleTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                
                const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                const cx = (t1.clientX + t2.clientX) / 2;
                const cy = (t1.clientY + t2.clientY) / 2;
                
                // Pan
                const dx = cx - state.lastPinchCenter.x;
                const dy = cy - state.lastPinchCenter.y;
                
                const screenW = svg.clientWidth;
                const scale = state.viewBox.w / screenW;
                
                state.viewBox.x -= dx * scale;
                state.viewBox.y -= dy * scale;
                
                // Zoom
                if (state.lastPinchDist > 0) {
                    const zoomFactor = state.lastPinchDist / dist;
                    
                    // Zoom towards center point (cx, cy)
                    // Convert cx, cy to SVG coords
                    const pt = svg.createSVGPoint();
                    pt.x = cx; pt.y = cy;
                    const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
                    
                    const oldW = state.viewBox.w;
                    const newW = oldW * zoomFactor;
                    const newH = state.viewBox.h * zoomFactor;
                    
                    state.viewBox.x = svgPt.x - (svgPt.x - state.viewBox.x) * zoomFactor;
                    state.viewBox.y = svgPt.y - (svgPt.y - state.viewBox.y) * zoomFactor;
                    state.viewBox.w = newW;
                    state.viewBox.h = newH;
                }
                
                updateViewBox();
                
                state.lastPinchDist = dist;
                state.lastPinchCenter = { x: cx, y: cy };
            }
        }
        
        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                state.isPanning = false;
                state.lastPinchDist = 0;
            }
        }

        function animateReturnToBox(emoji, startX, startY) {
            // Create element
            let el;
            if (emoji === '‚≠ê') {
                el = createStarElement(startX, startY, 1.5, 0);
            } else {
                el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                el.textContent = emoji;
                el.setAttribute('x', startX);
                el.setAttribute('y', startY);
                el.setAttribute('font-size', '40');
                el.setAttribute('text-anchor', 'middle');
                el.setAttribute('dominant-baseline', 'middle');
            }
            dragLayer.appendChild(el);
            
            // Target: Center of decorations box
            const boxRect = decoBox.getBoundingClientRect();
            const targetScreenX = boxRect.left + boxRect.width / 2;
            const targetScreenY = boxRect.top + boxRect.height / 2;
            
            // We need to animate in SVG coords, but the target is fixed on screen.
            // So we must update the target SVG coord every frame if the view moves (though view shouldn't move during this animation ideally)
            // Or just calculate it once.
            
            const startTime = performance.now();
            const duration = 500;
            
            function step(now) {
                const progress = Math.min((now - startTime) / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 3); // Cubic ease out
                
                // Recalculate target SVG coord in case of zoom/pan during animation? 
                // Maybe overkill, but safer.
                const pt = svg.createSVGPoint();
                pt.x = targetScreenX;
                pt.y = targetScreenY;
                const targetSVG = pt.matrixTransform(svg.getScreenCTM().inverse());
                
                const curX = startX + (targetSVG.x - startX) * ease;
                const curY = startY + (targetSVG.y - startY) * ease;
                
                if (emoji === '‚≠ê') {
                    // Re-create star at new pos? Or transform?
                    // Transform is easier
                    // But createStarElement returns a polygon with fixed points.
                    // Let's just translate it.
                    // Actually, createStarElement creates points based on cx, cy.
                    // We can't easily move it without re-calculating points or using transform.
                    // Let's use transform.
                    const dx = curX - startX;
                    const dy = curY - startY;
                    el.setAttribute('transform', `translate(${dx}, ${dy})`);
                } else {
                    el.setAttribute('x', curX);
                    el.setAttribute('y', curY);
                }
                
                // Fade out near end
                if (progress > 0.7) {
                    el.style.opacity = 1 - (progress - 0.7) / 0.3;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    el.remove();
                }
            }
            requestAnimationFrame(step);
        }

        function animateFall(emoji, startX, startY) {
            // Deprecated in favor of animateReturnToBox
            animateReturnToBox(emoji, startX, startY);
        }

        function startDragDeco(e, emoji) {
            e.preventDefault(); // Prevent text selection
            state.isDraggingDeco = true;
            state.draggedDeco = emoji;
            
            // Initial render in drag layer
            // We need to handle both MouseEvent and TouchEvent
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const pt = svg.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            // Manually trigger first move to show item
            dragLayer.innerHTML = '';
            
            if (emoji === '‚≠ê') {
                const star = createStarElement(svgPt.x, svgPt.y, 1.5, 0);
                star.setAttribute('pointer-events', 'none');
                dragLayer.appendChild(star);
            } else {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.textContent = state.draggedDeco;
                text.setAttribute('x', svgPt.x);
                text.setAttribute('y', svgPt.y);
                text.setAttribute('font-size', '40');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('pointer-events', 'none');
                dragLayer.appendChild(text);
            }
        }

        function isPointInTree(x, y) {
            // Check against all tree polygons
            // Ray casting algorithm
            for (const poly of state.treePolygons) {
                if (pointInPolygon([x, y], poly)) return true;
            }
            return false;
        }

        function pointInPolygon(point, vs) {
            // ray-casting algorithm based on
            // https://github.com/substack/point-in-polygon
            var x = point[0], y = point[1];
            var inside = false;
            for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                var xi = vs[i][0], yi = vs[i][1];
                var xj = vs[j][0], yj = vs[j][1];
                var intersect = ((yi > y) != (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // --- Rendering ---
        function renderWires() {
            wiresLayer.innerHTML = '';
            state.wireNodes.forEach(strand => {
                if (strand.length < 2) return;
                const pathData = strand.map((p, i) => (i === 0 ? 'M' : 'L') + `${p.x},${p.y}`).join(' ');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('class', 'wire');
                wiresLayer.appendChild(path);
            });
        }

        function renderLights() {
            lightsLayer.innerHTML = '';
            // if (!state.lightsOn && state.wireNodes.length > 0) return; // Removed to show unlit bulbs
            
            let lightIndex = 0;
            state.wireNodes.forEach(strand => {
                strand.forEach(p => {
                    const color = CONFIG.lightColors[lightIndex % CONFIG.lightColors.length];
                    lightIndex++;
                    
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'light-bulb-group');
                    g.dataset.index = lightIndex;
                    g.dataset.color = color;
                    
                    // Bulb
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', p.x);
                    circle.setAttribute('cy', p.y + 5); // Dangling a bit
                    circle.setAttribute('r', 4);
                    circle.setAttribute('fill', state.lightsOn ? color : '#444');
                    circle.setAttribute('class', 'light-bulb');
                    
                    // Glow
                    if (state.lightsOn) {
                        circle.setAttribute('filter', 'url(#glow-filter)');
                    }
                    
                    // Socket
                    const socket = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    socket.setAttribute('x', p.x - 2);
                    socket.setAttribute('y', p.y);
                    socket.setAttribute('width', 4);
                    socket.setAttribute('height', 5);
                    socket.setAttribute('fill', '#222');
                    
                    g.appendChild(socket);
                    g.appendChild(circle);
                    lightsLayer.appendChild(g);
                });
            });
        }

        function renderDecos() {
            decosLayer.innerHTML = '';
            state.decorations.forEach(d => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.style.cursor = 'grab';
                g.setAttribute('transform', `translate(${d.x}, ${d.y})`);
                
                if (d.emoji === '‚≠ê') {
                    // Render vector star at 0,0 relative to group
                    const star = createStarElement(0, 0, 1.5, d.rotation); 
                    g.appendChild(star);
                } else {
                    // Render emoji at 0,0 relative to group
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.textContent = d.emoji;
                    text.setAttribute('x', 0);
                    text.setAttribute('y', 0);
                    text.setAttribute('font-size', '30');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('transform', `rotate(${d.rotation})`);
                    g.appendChild(text);
                }
                
                d.element = g; // Store reference for animation
                decosLayer.appendChild(g);
            });
        }

        // --- Game Loop (Animation) ---
        function gameLoop(timestamp) {
            state.time = timestamp;
            
            // Handle falling decorations
            const floorY = 950; 
            const gravity = 0.8;
            
            state.decorations.forEach(d => {
                if (d.isFalling) {
                    d.vy += gravity;
                    d.y += d.vy;
                    
                    // Floor collision
                    if (d.y >= floorY) {
                        d.y = floorY;
                        d.vy = -d.vy * 0.4; // Bounce with damping
                        
                        // Stop if slow enough
                        if (Math.abs(d.vy) < 1) {
                            d.isFalling = false;
                            d.vy = 0;
                        }
                    }
                    
                    // Update DOM
                    if (d.element) {
                        d.element.setAttribute('transform', `translate(${d.x}, ${d.y})`);
                    }
                }
            });
            
            if (state.lightsOn) {
                const bulbs = document.querySelectorAll('.light-bulb');
                bulbs.forEach((bulb, i) => {
                    const group = bulb.parentElement;
                    const idx = parseInt(group.dataset.index);
                    const baseColor = group.dataset.color;
                    
                    let opacity = 1;
                    
                    switch (state.lightMode) {
                        case 0: // Steady
                            opacity = 1;
                            break;
                        case 1: // Blink
                            opacity = (Math.floor(timestamp / 500) % 2 === 0) ? 1 : 0.3;
                            break;
                        case 2: // Chase
                            const phase = Math.floor(timestamp / 100) % 5;
                            opacity = (idx % 5 === phase) ? 1 : 0.3;
                            break;
                        case 3: // Random / Twinkle
                            // Use a pseudo-random based on time and index
                            const noise = Math.sin(idx * 13 + timestamp / 200);
                            opacity = 0.5 + 0.5 * noise;
                            break;
                    }
                    
                    bulb.style.opacity = opacity;
                });
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Start
        init();
        
        // Handle resize
        window.addEventListener('resize', handleResize);

    </script>
    <script src="parental.js" defer></script>
</body>
</html>
