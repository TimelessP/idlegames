import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');
const distDir = path.join(projectRoot, 'dist');
const args = new Set(process.argv.slice(2));

async function fileExists(target) {
  try {
    await fs.access(target);
    return true;
  } catch {
    return false;
  }
}

async function cleanDist() {
  await fs.rm(distDir, { recursive: true, force: true });
  console.log('Removed dist/ directory');
}

if (args.has('--clean')) {
  await cleanDist();
  process.exit(0);
}

const packageJson = JSON.parse(await fs.readFile(path.join(projectRoot, 'package.json'), 'utf8'));
const appVersion = packageJson.version;

const versionModulePath = path.join(projectRoot, 'assets', 'js', 'version.js');
const versionModuleContent = `// Generated by scripts/build-sw.mjs. Do not edit manually.\nexport const APP_VERSION = '${appVersion}';\n`;
await fs.writeFile(versionModulePath, versionModuleContent, 'utf8');

await cleanDist();
await fs.mkdir(distDir, { recursive: true });

const EXCLUDED_DIRS = new Set(['node_modules', 'dist', '.git', '.github', '.vscode', 'scripts']);
const EXCLUDED_FILES = new Set(['package.json', 'package-lock.json', 'pnpm-lock.yaml', 'pnpm-lock.yml', 'yarn.lock']);

async function copyTree(from, to) {
  await fs.mkdir(to, { recursive: true });
  const entries = await fs.readdir(from, { withFileTypes: true });
  for (const entry of entries) {
    if (EXCLUDED_DIRS.has(entry.name)) continue;
    const srcPath = path.join(from, entry.name);
    const destPath = path.join(to, entry.name);
    if (entry.isDirectory()) {
      await copyTree(srcPath, destPath);
    } else {
      if (EXCLUDED_FILES.has(entry.name)) continue;
      await fs.copyFile(srcPath, destPath);
    }
  }
}

await copyTree(projectRoot, distDir);

async function copyModuleFile(moduleSegments, destinationSegments) {
  const src = path.join(projectRoot, 'node_modules', ...moduleSegments);
  const dest = path.join(distDir, ...destinationSegments);
  await fs.mkdir(path.dirname(dest), { recursive: true });
  await fs.copyFile(src, dest);
}

async function rewriteBareThreeImports(filePath) {
  const content = await fs.readFile(filePath, 'utf8');
  if (!content.includes("from 'three'") && !content.includes('from "three"')) {
    return;
  }
  const threeModulePath = path.join(distDir, 'assets', 'vendor', 'three', 'three.module.js');
  const relativePath = path.relative(path.dirname(filePath), threeModulePath).split(path.sep).join('/');
  const normalizedPath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`;
  const updated = content.replace(/from\s+['"]three['"]/g, `from '${normalizedPath}'`);
  if (updated !== content) {
    await fs.writeFile(filePath, updated, 'utf8');
  }
}

async function ensureVendorAssets() {
  await copyModuleFile(['qrious', 'dist', 'qrious.min.js'], ['assets', 'vendor', 'qrious', 'qrious.min.js']);
  await copyModuleFile(['jsqr', 'dist', 'jsQR.js'], ['assets', 'vendor', 'jsqr', 'jsQR.js']);
  await copyModuleFile(['three', 'build', 'three.module.js'], ['assets', 'vendor', 'three', 'three.module.js']);

  const exampleFiles = [
    ['postprocessing', 'EffectComposer.js'],
    ['postprocessing', 'Pass.js'],
    ['postprocessing', 'RenderPass.js'],
    ['postprocessing', 'SSAOPass.js'],
    ['postprocessing', 'ShaderPass.js'],
    ['postprocessing', 'MaskPass.js'],
    ['shaders', 'CopyShader.js'],
    ['shaders', 'SSAOShader.js'],
    ['math', 'SimplexNoise.js']
  ];

  for (const segments of exampleFiles) {
    const destination = ['assets', 'vendor', 'three', 'examples', 'jsm', ...segments];
    await copyModuleFile(['three', 'examples', 'jsm', ...segments], destination);
    await rewriteBareThreeImports(path.join(distDir, ...destination));
  }

  const transformersSrc = path.join(projectRoot, 'node_modules', '@xenova', 'transformers', 'dist');
  const transformersDest = path.join(distDir, 'assets', 'vendor', 'transformers');
  await fs.rm(transformersDest, { recursive: true, force: true });
  await fs.cp(transformersSrc, transformersDest, { recursive: true });
}

async function ensureFonts() {
  const weights = [400, 500, 600, 700, 900];
  const sourceDir = path.join(projectRoot, 'node_modules', '@fontsource', 'inter', 'files');
  const fontsDir = path.join(distDir, 'assets', 'fonts', 'inter');
  const cssDir = path.join(distDir, 'assets', 'fonts');
  await fs.mkdir(fontsDir, { recursive: true });
  await fs.mkdir(cssDir, { recursive: true });
  let css = '/* Generated by scripts/build-sw.mjs */\n';
  for (const weight of weights) {
    const fileName = `inter-latin-${weight}-normal.woff2`;
    const src = path.join(sourceDir, fileName);
    const dest = path.join(fontsDir, fileName);
    await fs.copyFile(src, dest);
    css += `@font-face {\n`;
    css += `  font-family: 'Inter';\n`;
    css += `  font-style: normal;\n`;
    css += `  font-weight: ${weight};\n`;
    css += `  font-display: swap;\n`;
    css += `  src: url('./inter/${fileName}') format('woff2');\n`;
    css += `}\n\n`;
  }
  css += `/* End Inter font declarations */\n`;
  await fs.writeFile(path.join(cssDir, 'inter.css'), css, 'utf8');
}

await ensureVendorAssets();
await ensureFonts();

const gitignoreInDist = path.join(distDir, '.gitignore');
if (await fileExists(gitignoreInDist)) {
  await fs.rm(gitignoreInDist);
}

const PRECACHE_EXTENSIONS = new Set(['.html', '.css', '.js', '.json', '.webmanifest', '.png', '.svg', '.ico', '.txt', '.woff2']);
const precacheSet = new Set();

async function collectPrecache(currentDir) {
  const entries = await fs.readdir(currentDir, { withFileTypes: true });
  for (const entry of entries) {
    const absPath = path.join(currentDir, entry.name);
    const relPath = path.relative(distDir, absPath).split(path.sep).join('/');
    if (entry.isDirectory()) {
      await collectPrecache(absPath);
    } else {
      const ext = path.extname(entry.name).toLowerCase();
      if (PRECACHE_EXTENSIONS.has(ext)) {
        precacheSet.add(`./${relPath}`);
      }
    }
  }
}

await collectPrecache(distDir);

if (await fileExists(path.join(distDir, 'index.html'))) {
  precacheSet.add('./index.html');
}
if (await fileExists(path.join(distDir, 'manifest.webmanifest'))) {
  precacheSet.add('./manifest.webmanifest');
}

const precacheList = Array.from(precacheSet).sort();

const swTemplate = await fs.readFile(path.join(projectRoot, 'scripts', 'sw.template.js'), 'utf8');
const swContent = swTemplate
  .replaceAll('__APP_VERSION__', appVersion)
  .replace('__PRECACHE_LIST__', JSON.stringify(precacheList, null, 2));

await fs.writeFile(path.join(distDir, 'sw.js'), swContent, 'utf8');

console.log(`Built IdleGames v${appVersion}`);
console.log(`- dist/: ${precacheList.length} files precached`);
