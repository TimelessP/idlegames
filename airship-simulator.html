<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Airship Flight Simulator</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      background: #87ceeb;
      color: #fff;
      overflow: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    canvas {
      display: block;
    }
    .hud {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    .hud div {
      margin-bottom: 5px;
    }
    .controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-size: 14px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <div class="hud">
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Fuel: <span id="fuel">100</span>%</div>
    <div>Score: <span id="score">0</span></div>
  </div>
  <div class="controls">
    WASD: Move<br>
    Mouse: Look<br>
    Space: Thrust<br>
    Shift: Brake<br>
    R: Reset
  </div>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x87ceeb, 100, 1000);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x87ceeb);
    document.body.appendChild(renderer.domElement);

    // Airship
    const airshipGroup = new THREE.Group();
    const balloonGeometry = new THREE.SphereGeometry(3, 16, 16);
    const balloonMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
    const balloon = new THREE.Mesh(balloonGeometry, balloonMaterial);
    balloon.position.y = 2;
    airshipGroup.add(balloon);

    const gondolaGeometry = new THREE.BoxGeometry(2, 1, 4);
    const gondolaMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const gondola = new THREE.Mesh(gondolaGeometry, gondolaMaterial);
    gondola.position.y = -1;
    airshipGroup.add(gondola);

    const propellerGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2);
    const propellerMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
    const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
    propeller.position.set(0, 0, -3);
    propeller.rotation.z = Math.PI / 2;
    airshipGroup.add(propeller);

    scene.add(airshipGroup);

    // Ground
    const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -50;
    scene.add(ground);

    // Sky
    const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87ceeb, side: THREE.BackSide });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Clouds
    for (let i = 0; i < 20; i++) {
      const cloudGeometry = new THREE.SphereGeometry(Math.random() * 5 + 2, 8, 8);
      const cloudMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      cloud.position.set(
        (Math.random() - 0.5) * 1000,
        Math.random() * 100 + 50,
        (Math.random() - 0.5) * 1000
      );
      scene.add(cloud);
    }

    // Rings (objectives)
    const rings = [];
    for (let i = 0; i < 10; i++) {
      const ringGeometry = new THREE.TorusGeometry(5, 0.5, 8, 16);
      const ringMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.position.set(
        (Math.random() - 0.5) * 500,
        Math.random() * 100 + 20,
        (Math.random() - 0.5) * 500
      );
      scene.add(ring);
      rings.push(ring);
    }

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    // Physics variables
    let velocity = new THREE.Vector3(0, 0, 0);
    let rotation = new THREE.Euler(0, 0, 0);
    let thrust = 0;
    let fuel = 100;
    let score = 0;

    // Controls
    const keys = {};
    document.addEventListener('keydown', (e) => { keys[e.code] = true; });
    document.addEventListener('keyup', (e) => { keys[e.code] = false; });

    let mouseX = 0, mouseY = 0;
    document.addEventListener('mousemove', (e) => {
      mouseX = (e.clientX / window.innerWidth) * 2 - 1;
      mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    // Pointer lock for better mouse control
    document.addEventListener('click', () => {
      document.body.requestPointerLock();
    });

    // Update function
    function update(deltaTime) {
      // Controls
      if (keys['KeyW']) velocity.z -= 0.1;
      if (keys['KeyS']) velocity.z += 0.1;
      if (keys['KeyA']) velocity.x -= 0.1;
      if (keys['KeyD']) velocity.x += 0.1;
      if (keys['Space']) {
        thrust = 0.2;
        fuel = Math.max(0, fuel - 0.1);
      } else {
        thrust = 0;
      }
      if (keys['ShiftLeft']) {
        velocity.multiplyScalar(0.95);
      }
      if (keys['KeyR']) {
        airshipGroup.position.set(0, 0, 0);
        velocity.set(0, 0, 0);
        rotation.set(0, 0, 0);
        fuel = 100;
        score = 0;
      }

      // Mouse look
      rotation.y -= mouseX * 0.01;
      rotation.x -= mouseY * 0.01;
      rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));

      // Physics
      velocity.y += thrust - 0.01; // Gravity and thrust
      velocity.multiplyScalar(0.98); // Air resistance
      airshipGroup.position.add(velocity);
      airshipGroup.rotation.copy(rotation);

      // Keep airship above ground
      if (airshipGroup.position.y < 0) {
        airshipGroup.position.y = 0;
        velocity.y = 0;
      }

      // Animate propeller
      propeller.rotation.x += 0.5;

      // Check ring collisions
      rings.forEach((ring, index) => {
        if (airshipGroup.position.distanceTo(ring.position) < 8) {
          scene.remove(ring);
          rings.splice(index, 1);
          score += 100;
        }
      });

      // Camera follow
      camera.position.copy(airshipGroup.position);
      camera.position.add(new THREE.Vector3(0, 5, 10));
      camera.lookAt(airshipGroup.position);

      // Update HUD
      document.getElementById('altitude').textContent = Math.round(airshipGroup.position.y);
      document.getElementById('speed').textContent = Math.round(velocity.length() * 10);
      document.getElementById('fuel').textContent = Math.round(fuel);
      document.getElementById('score').textContent = score;
    }

    // Render loop
    let lastTime = 0;
    function animate(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      update(deltaTime);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate(0);

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
