<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ballistic Warfare</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: "Courier New", monospace;
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      user-select: none;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      grid-template-rows: minmax(0, 1fr) minmax(min-content, clamp(220px, 45vh, 420px));
      overflow: hidden;
    }

    #hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.6);
      z-index: 10;
      font-size: 18px;
      font-weight: bold;
    }

    .player-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .player-info.active {
      color: #ffeb3b;
      text-shadow: 0 0 10px rgba(255, 235, 59, 0.6);
    }

    .player-a { text-align: left; }
    .player-b { text-align: right; }

    #controls {
      position: relative;
      background: rgba(0, 0, 0, 0.85);
      padding: 16px 20px;
      z-index: 5;
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex-shrink: 0;
    box-shadow: 0 -6px 20px rgba(0, 0, 0, 0.6);
    overflow-y: auto;
    touch-action: auto;
    max-height: clamp(220px, 45vh, 420px);
    }

    .control-row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    label {
      font-size: 14px;
      min-width: 80px;
    }

    input[type="range"] {
      width: 150px;
      height: 6px;
      background: #333;
      outline: none;
      border-radius: 3px;
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      background: #ffeb3b;
      cursor: pointer;
      border-radius: 50%;
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #ffeb3b;
      cursor: pointer;
      border-radius: 50%;
      border: none;
    }

    .value-display {
      display: inline-block;
      min-width: 40px;
      text-align: right;
      color: #ffeb3b;
    }

    button {
      padding: 10px 18px;
      background: #1e88e5;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-family: inherit;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover:not(:disabled) {
      background: #1976d2;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(30, 136, 229, 0.4);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }

    button.primary {
      background: #f44336;
    }

    button.primary:hover:not(:disabled) {
      background: #e53935;
      box-shadow: 0 4px 8px rgba(244, 67, 54, 0.4);
    }

    .weapon-select {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .weapon-btn {
      padding: 8px 14px;
      background: #424242;
      font-size: 13px;
      position: relative;
    }

    .weapon-btn.selected {
      background: #1e88e5;
      box-shadow: 0 0 12px rgba(30, 136, 229, 0.6);
    }

    .weapon-btn.depleted {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .weapon-count {
      position: absolute;
      top: -4px;
      right: -4px;
      background: #f44336;
      color: #fff;
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 10px;
      font-weight: bold;
    }

    .weapon-btn.infinite .weapon-count {
      background: #4caf50;
    }

    #new-game-btn {
      background: #4caf50;
    }

    #new-game-btn:hover {
      background: #43a047;
      box-shadow: 0 4px 8px rgba(76, 175, 80, 0.4);
    }

    #shield-btn {
      background: #9c27b0;
    }

    #shield-btn:hover:not(:disabled) {
      background: #8e24aa;
      box-shadow: 0 4px 8px rgba(156, 39, 176, 0.4);
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      min-width: 0;
      min-height: 0;
      image-rendering: crisp-edges;
    }

    #round-modal {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.75);
      z-index: 20;
      padding: 20px;
    }

    #round-modal.visible {
      display: flex;
    }

    #round-modal .modal-content {
      background: rgba(20, 20, 20, 0.95);
      border: 2px solid #ffeb3b;
      padding: 24px 32px;
      text-align: center;
      max-width: 340px;
      width: 100%;
      box-shadow: 0 0 25px rgba(255, 235, 59, 0.3);
    }

    #round-modal .modal-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 12px;
      text-transform: uppercase;
      color: #ffeb3b;
    }

    #round-modal .modal-message {
      font-size: 16px;
      margin-bottom: 20px;
      color: #fff;
    }

    #next-round-btn {
      padding: 12px 24px;
      font-size: 15px;
    }

    @media (max-width: 768px) {
      #hud {
        font-size: 14px;
        padding: 8px 12px;
      }

      #controls {
        padding: 10px 12px;
        gap: 8px;
      }

      label {
        font-size: 12px;
        min-width: 60px;
      }

      input[type="range"] {
        width: 100px;
      }

      button {
        padding: 8px 12px;
        font-size: 12px;
      }
    }

    @media (max-width: 540px) {
      #controls {
        padding: 12px 14px;
        gap: 10px;
      }

      .control-row {
        flex-direction: column;
        align-items: stretch;
      }

      .control-group {
        width: 100%;
        justify-content: space-between;
        gap: 6px;
      }

      .control-group label {
        min-width: 0;
      }

      .control-group input[type="range"] {
        width: 100%;
      }

      .control-row button,
      #shield-btn,
      #fire-btn,
      #new-game-btn,
      #move-left-btn,
      #move-right-btn {
        width: 100%;
      }

      .weapon-select {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
        gap: 8px;
      }

      .weapon-btn {
        width: 100%;
        justify-self: stretch;
      }
    }

    @media (orientation: landscape) {
      #game-container {
        grid-template-rows: minmax(0, 1fr) auto;
      }

      #controls {
        max-height: clamp(160px, 40vh, 320px);
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="hud">
      <div class="player-info player-a">
        <div>PLAYER A: <span id="score-a">0</span></div>
        <div>HP: <span id="hp-a">100</span></div>
        <div id="shield-a" style="display: none; color: #9c27b0;">üõ°Ô∏è SHIELD</div>
      </div>
      <div class="player-info player-b">
        <div>PLAYER B: <span id="score-b">0</span></div>
        <div>HP: <span id="hp-b">100</span></div>
        <div id="shield-b" style="display: none; color: #9c27b0;">üõ°Ô∏è SHIELD</div>
      </div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="controls">
      <div class="control-row">
        <div class="control-group">
          <label>Angle:</label>
          <input type="range" id="angle" min="0" max="180" value="45">
          <span class="value-display"><span id="angle-val">45</span>¬∞</span>
        </div>
        <div class="control-group">
          <label>Power:</label>
          <input type="range" id="power" min="10" max="100" value="50">
          <span class="value-display"><span id="power-val">50</span>%</span>
        </div>
        <button id="shield-btn">SHIELD (1x)</button>
      </div>

      <div class="control-row weapon-select" id="weapons">
        <!-- Weapons will be dynamically added -->
      </div>

      <div class="control-row">
        <button id="fire-btn" class="primary">FIRE!</button>
        <button id="move-left-btn">MOVE ‚óÄ</button>
        <button id="move-right-btn">MOVE ‚ñ∂</button>
        <button id="new-game-btn">NEW GAME</button>
      </div>
    </div>

      <div id="round-modal">
        <div class="modal-content">
          <div id="round-modal-heading" class="modal-title">Round Over</div>
          <div id="round-modal-message" class="modal-message">Prepare for the next volley.</div>
          <button id="next-round-btn">NEXT ROUND</button>
        </div>
      </div>
  </div>

  <script>
    (() => {
      'use strict';

      // Constants
      const FPS = 20;
      const FRAME_TIME = 1000 / FPS;
      const GRAVITY = 400;
      const MAX_HP = 100;
      const TURRET_SIZE = 20;
    const BARREL_LENGTH = 30;
    const GRENADE_RADIUS = 6;
  const TURRET_MOVE_DISTANCE = TURRET_SIZE * 5;
      
      const WEAPONS = {
        shell: { 
          name: 'Shell', 
          damage: 20, 
          radius: 30, 
          count: Infinity, 
          speed: 1.0,
          type: 'ballistic'
        },
        grenade: { 
          name: 'Grenade', 
          damage: 25, 
          radius: 35, 
          count: 8, 
          speed: 0.9,
          type: 'grenade',
          fuseTime: 1000
        },
        spread: { 
          name: 'Spread', 
          damage: 15, 
          radius: 25, 
          count: 5, 
          speed: 1.0,
          type: 'spread',
          shots: 4,
          spreadAngle: 2
        },
        nuke: { 
          name: 'Nuke', 
          damage: 60, 
          radius: 80, 
          count: 1, 
          speed: 0.8,
          type: 'ballistic'
        },
        homing: { 
          name: 'Homing', 
          damage: 18, 
          radius: 28, 
          count: 3, 
          speed: 1.1,
          type: 'homing',
          lockTime: 1000,
          homingCruiseSpeed: 180,
          homingTurnRate: 2.2
        }
      };

      // Utility functions
      const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
      const lerp = (a, b, t) => a + (b - a) * t;
      const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
      const shortestAngleDiff = (target, current) => Math.atan2(Math.sin(target - current), Math.cos(target - current));

      // Seeded random for terrain generation
      class Random {
        constructor(seed) {
          this.seed = seed;
        }
        next() {
          this.seed = (this.seed * 9301 + 49297) % 233280;
          return this.seed / 233280;
        }
        range(min, max) {
          return min + this.next() * (max - min);
        }
      }

      // Game state
      class Game {
        constructor() {
          this.canvas = document.getElementById('canvas');
          this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
          
          // Off-screen canvases
          this.skyCanvas = document.createElement('canvas');
          this.terrainCanvas = document.createElement('canvas');
          this.terrainCtx = this.terrainCanvas.getContext('2d', { willReadFrequently: true });
          this.maskCanvas = document.createElement('canvas');
          this.maskCtx = this.maskCanvas.getContext('2d', { willReadFrequently: true });
          this.bufferCanvas = document.createElement('canvas');
          this.bufferCtx = this.bufferCanvas.getContext('2d');
          
          this.width = 0;
          this.height = 0;
          this.terrainHeights = null;
          
          this.players = {
            a: {
              name: 'A',
              score: 0,
              hp: MAX_HP,
              x: 0,
              y: 0,
              angle: 45,
              power: 50,
              weapons: {},
              shieldAvailable: true,
              shieldActive: false
            },
            b: {
              name: 'B',
              score: 0,
              hp: MAX_HP,
              x: 0,
              y: 0,
              angle: 135,
              power: 50,
              weapons: {},
              shieldAvailable: true,
              shieldActive: false
            }
          };
          
          this.currentPlayer = null;
          this.selectedWeapon = 'shell';
          this.projectiles = [];
          this.explosions = [];
          this.lastTime = 0;
          this.accumulator = 0;
          this.animating = false;
          this.roundOver = false;
          this.roundModal = null;
          this.roundModalHeading = null;
          this.roundModalMessage = null;
          this.nextRoundBtn = null;
          
          this.init();
        }

        init() {
          this.resize();
          window.addEventListener('resize', () => this.resize());
          
          this.setupControls();
          this.setupModal();
          this.newGame();
          this.lastTime = performance.now();
          this.loop(this.lastTime);
        }

        resize() {
          const dpr = window.devicePixelRatio || 1;
          const rect = this.canvas.getBoundingClientRect();
          
          this.width = rect.width;
          this.height = rect.height;
          
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          this.canvas.width = this.width * dpr;
          this.canvas.height = this.height * dpr;
          this.ctx.scale(dpr, dpr);
          
          [this.skyCanvas, this.terrainCanvas, this.maskCanvas, this.bufferCanvas].forEach(canvas => {
            canvas.width = this.width;
            canvas.height = this.height;
          });
          
          if (this.players.a.x > 0) {
            this.generateTerrain();
            this.render();
          }
        }

        setupControls() {
          const angleInput = document.getElementById('angle');
          const powerInput = document.getElementById('power');
          const angleVal = document.getElementById('angle-val');
          const powerVal = document.getElementById('power-val');
          const fireBtn = document.getElementById('fire-btn');
          const moveLeftBtn = document.getElementById('move-left-btn');
          const moveRightBtn = document.getElementById('move-right-btn');
          const newGameBtn = document.getElementById('new-game-btn');
          const shieldBtn = document.getElementById('shield-btn');
          const weaponsDiv = document.getElementById('weapons');

          angleInput.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            angleVal.textContent = val;
            if (this.currentPlayer) {
              this.players[this.currentPlayer].angle = val;
              this.render();
            }
          });

          powerInput.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            powerVal.textContent = val;
            if (this.currentPlayer) {
              this.players[this.currentPlayer].power = val;
            }
          });

          fireBtn.addEventListener('click', () => this.fire());
          moveLeftBtn.addEventListener('click', () => this.moveTurret(-1));
          moveRightBtn.addEventListener('click', () => this.moveTurret(1));
          newGameBtn.addEventListener('click', () => this.resetScores());
          shieldBtn.addEventListener('click', () => this.toggleShield());

          // Create weapon buttons
          Object.keys(WEAPONS).forEach(key => {
            const weapon = WEAPONS[key];
            const btn = document.createElement('button');
            btn.className = 'weapon-btn';
            btn.dataset.weapon = key;
            btn.innerHTML = `
              ${weapon.name}
              <span class="weapon-count ${weapon.count === Infinity ? 'infinite' : ''}">
                ${weapon.count === Infinity ? '‚àû' : weapon.count}
              </span>
            `;
            btn.addEventListener('click', () => this.selectWeapon(key));
            weaponsDiv.appendChild(btn);
          });

          this.selectWeapon('shell');
        }

        setupModal() {
          this.roundModal = document.getElementById('round-modal');
          this.roundModalHeading = document.getElementById('round-modal-heading');
          this.roundModalMessage = document.getElementById('round-modal-message');
          this.nextRoundBtn = document.getElementById('next-round-btn');
          if (this.nextRoundBtn) {
            this.nextRoundBtn.addEventListener('click', () => this.handleNextRound());
          }
        }

        newGame() {
          this.hideRoundModal();
          this.roundOver = false;
          // Reset HP and weapons
          ['a', 'b'].forEach(key => {
            const player = this.players[key];
            player.hp = MAX_HP;
            player.weapons = {};
            player.shieldAvailable = true;
            player.shieldActive = false;
            
            Object.keys(WEAPONS).forEach(wKey => {
              player.weapons[wKey] = WEAPONS[wKey].count;
            });
          });
          
          this.generateTerrain();
          this.projectiles = [];
          this.explosions = [];
          this.animating = false;
          
          // Random first player
          this.currentPlayer = Math.random() < 0.5 ? 'a' : 'b';
          this.updateUI();
          this.render();
        }

        resetScores() {
          this.players.a.score = 0;
          this.players.b.score = 0;
          this.roundOver = false;
          this.hideRoundModal();
          this.newGame();
        }

        handleNextRound() {
          if (!this.roundOver) return;
          this.newGame();
        }

        showRoundModal(heading, message) {
          if (this.roundModalHeading) {
            this.roundModalHeading.textContent = heading;
          }
          if (this.roundModalMessage) {
            this.roundModalMessage.textContent = message;
          }
          if (this.roundModal) {
            this.roundModal.classList.add('visible');
          }
        }

        hideRoundModal() {
          if (this.roundModal) {
            this.roundModal.classList.remove('visible');
          }
        }

        generateTerrain() {
          const w = this.width;
          const h = this.height;
          
          // Generate sky with smoky war-zone effect
          const skyCtx = this.skyCanvas.getContext('2d');
          const skyGrad = skyCtx.createLinearGradient(0, 0, 0, h);
          skyGrad.addColorStop(0, '#8c6f4f');
          skyGrad.addColorStop(0.5, '#b38a5c');
          skyGrad.addColorStop(1, '#d8ad73');
          skyCtx.fillStyle = skyGrad;
          skyCtx.fillRect(0, 0, w, h);
          
          // Add smoky blotches
          const rng = new Random(Math.random() * 999999);
          for (let i = 0; i < 30; i++) {
            const x = rng.range(0, w);
            const y = rng.range(0, h * 0.6);
            const size = rng.range(40, 120);
            const grd = skyCtx.createRadialGradient(x, y, 0, x, y, size);
            grd.addColorStop(0, `rgba(120, 90, 60, ${rng.range(0.15, 0.3)})`);
            grd.addColorStop(1, 'rgba(120, 90, 60, 0)');
            skyCtx.fillStyle = grd;
            skyCtx.fillRect(x - size, y - size, size * 2, size * 2);
          }
          
          // Generate terrain with mountains
          const terrainCtx = this.terrainCtx;
          terrainCtx.fillStyle = '#3d2f1f';
          terrainCtx.fillRect(0, 0, w, h);
          
          // Create mask for terrain shape
          const maskCtx = this.maskCtx;
          maskCtx.clearRect(0, 0, w, h);
          
          // Generate mountain profile using midpoint displacement
          const bottomMargin = Math.max(40, h * 0.12); // Keep terrain away from bottom
          const minTerrainHeight = h * 0.18;
          
          // Start with three initial points
          const heightMap = [
            { x: 0, y: rng.range(minTerrainHeight, h * 0.5) },
            { x: w / 2, y: rng.range(minTerrainHeight, h * 0.5) },
            { x: w, y: rng.range(minTerrainHeight, h * 0.5) }
          ];
          
          // Midpoint displacement - subdivide multiple times
          const subdivisions = 6; // Number of times to subdivide
          let variance = h * 0.25; // Initial variance
          const roughness = 0.5; // How much variance decreases each iteration
          
          for (let iteration = 0; iteration < subdivisions; iteration++) {
            const newPoints = [];
            
            for (let i = 0; i < heightMap.length - 1; i++) {
              const left = heightMap[i];
              const right = heightMap[i + 1];
              
              // Keep the left point
              newPoints.push(left);
              
              // Create midpoint with random displacement
              const midX = (left.x + right.x) / 2;
              const midY = (left.y + right.y) / 2;
              const displacement = rng.range(-variance, variance);
              
              let newY = midY + displacement;
              // Clamp to valid range
              newY = Math.max(minTerrainHeight, Math.min(h - bottomMargin, newY));
              
              newPoints.push({ x: midX, y: newY });
            }
            
            // Add the last point
            newPoints.push(heightMap[heightMap.length - 1]);
            
            heightMap.length = 0;
            heightMap.push(...newPoints);
            
            // Reduce variance for next iteration
            variance *= roughness;
          }
          
          // Shift terrain downward so the lowest point hugs the bottom margin
          let minY = Infinity;
          let maxY = -Infinity;
          heightMap.forEach(p => {
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
          });
          const targetMin = h * 0.35;
          const targetMax = h - bottomMargin;
          const sourceRange = Math.max(1, maxY - minY);
          const targetRange = targetMax - targetMin;
          heightMap.forEach(p => {
            const normalized = (p.y - minY) / sourceRange;
            p.y = targetMin + normalized * targetRange;
          });

          const points = heightMap;
          
          // Draw terrain mask
          maskCtx.fillStyle = '#fff';
          maskCtx.beginPath();
          maskCtx.moveTo(0, h);
          points.forEach(p => maskCtx.lineTo(p.x, p.y));
          maskCtx.lineTo(w, h);
          maskCtx.closePath();
          maskCtx.fill();
          
          // Apply grunge to terrain
          for (let i = 0; i < 50; i++) {
            const x = rng.range(0, w);
            const y = rng.range(h * 0.1, h);
            const size = rng.range(20, 60);
            const grd = terrainCtx.createRadialGradient(x, y, 0, x, y, size);
            const darkness = rng.range(0.1, 0.3);
            grd.addColorStop(0, `rgba(0, 0, 0, ${darkness})`);
            grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
            terrainCtx.fillStyle = grd;
            terrainCtx.fillRect(x - size, y - size, size * 2, size * 2);
          }

          this.rebuildTerrainHeights();
          
          // Place turrets at ground level
          const margin = 100;
          this.players.a.x = margin;
          this.players.b.x = w - margin;
          
          ['a', 'b'].forEach(key => {
            const player = this.players[key];
            player.y = this.getTerrainHeight(player.x);
          });
        }

        rebuildTerrainHeights() {
          const width = Math.floor(this.maskCanvas.width);
          const height = Math.floor(this.maskCanvas.height);
          if (!width || !height) {
            this.terrainHeights = null;
            return;
          }

          const imageData = this.maskCtx.getImageData(0, 0, width, height).data;
          this.terrainHeights = new Float32Array(width);

          for (let x = 0; x < width; x++) {
            let y = 0;
            for (; y < height; y++) {
              const idx = (y * width + x) * 4;
              if (imageData[idx] > 128) {
                this.terrainHeights[x] = y;
                break;
              }
            }
            if (y === height) {
              this.terrainHeights[x] = height;
            }
          }
        }

        sampleTerrainHeightFromMask(x) {
          const width = Math.floor(this.maskCanvas.width);
          const height = Math.floor(this.maskCanvas.height);
          if (x < 0 || x >= width) {
            return this.height;
          }

          const data = this.maskCtx.getImageData(x, 0, 1, height).data;
          for (let y = 0; y < height; y++) {
            if (data[y * 4] > 128) {
              return y;
            }
          }
          return height;
        }

        refreshTerrainHeights(startX, endX) {
          if (!this.terrainHeights) return;
          const width = this.terrainHeights.length;
          const start = Math.max(0, Math.floor(startX));
          const end = Math.min(width - 1, Math.ceil(endX));
          if (start > end) return;
          for (let x = start; x <= end; x++) {
            this.terrainHeights[x] = this.sampleTerrainHeightFromMask(x);
          }
        }

        getTerrainSlope(x) {
          if (!this.terrainHeights || this.terrainHeights.length < 3) return 0;
          const width = this.terrainHeights.length;
          const xi = Math.max(1, Math.min(width - 2, Math.floor(x)));
          const prev = this.terrainHeights[xi - 1];
          const next = this.terrainHeights[xi + 1];
          return (next - prev) * 0.5;
        }

        getSurfaceTangent(slope) {
          const length = Math.hypot(1, slope);
          if (length === 0) {
            return { x: 1, y: 0 };
          }
          return { x: 1 / length, y: slope / length };
        }

        getTerrainHeight(x) {
          if (!this.terrainHeights || !this.terrainHeights.length) {
            return this.height;
          }
          const width = this.terrainHeights.length;
          const xi = Math.max(0, Math.min(width - 1, Math.floor(x)));
          return this.terrainHeights[xi];
        }

        isTerrainAt(x, y) {
          if (x < 0 || x >= this.width || y < 0 || y >= this.height) return false;
          const terrainY = this.getTerrainHeight(x);
          return terrainY < this.height && y >= terrainY;
        }

        selectWeapon(weaponKey) {
          if (!this.currentPlayer) return;
          
          const player = this.players[this.currentPlayer];
          if (player.weapons[weaponKey] === 0) return;
          
          this.selectedWeapon = weaponKey;
          
          document.querySelectorAll('.weapon-btn').forEach(btn => {
            btn.classList.remove('selected');
            if (btn.dataset.weapon === weaponKey) {
              btn.classList.add('selected');
            }
          });
        }

        toggleShield() {
          if (!this.currentPlayer || this.animating || this.roundOver) return;
          
          const player = this.players[this.currentPlayer];
          if (!player.shieldAvailable) return;
          
          player.shieldActive = !player.shieldActive;
          this.updateUI();
        }

        fire() {
          if (!this.currentPlayer || this.animating || this.roundOver) return;
          
          const player = this.players[this.currentPlayer];
          const weapon = WEAPONS[this.selectedWeapon];
          
          if (player.weapons[this.selectedWeapon] === 0) return;
          
          if (player.weapons[this.selectedWeapon] !== Infinity) {
            player.weapons[this.selectedWeapon]--;
          }
          
          this.animating = true;
          const angleRad = (player.angle * Math.PI) / 180;
          const power = (player.power / 100) * 1200 * weapon.speed;
          
          if (weapon.type === 'spread') {
            const centerAngle = player.angle;
            const spread = weapon.spreadAngle;
            const shots = weapon.shots;
            
            for (let i = 0; i < shots; i++) {
              const offset = (i - (shots - 1) / 2) * spread;
              const shotAngleRad = ((centerAngle + offset) * Math.PI) / 180;
              const spawnX = player.x + Math.cos(shotAngleRad) * BARREL_LENGTH;
              const spawnY = player.y - Math.sin(shotAngleRad) * BARREL_LENGTH;
              
              this.projectiles.push({
                x: spawnX,
                y: spawnY,
                vx: Math.cos(shotAngleRad) * power,
                vy: -Math.sin(shotAngleRad) * power,
                weapon: this.selectedWeapon,
                owner: this.currentPlayer,
                time: 0,
                state: 'flight',
                rollTimer: 0,
                hasRolled: false,
                tangentSpeed: 0,
                radius: 6,
                initialSpeed: power
              });
            }
          } else {
            const radius = weapon.type === 'grenade' ? GRENADE_RADIUS : 6;
            const spawnX = player.x + Math.cos(angleRad) * BARREL_LENGTH;
            const spawnY = player.y - Math.sin(angleRad) * BARREL_LENGTH;
            const projectile = {
              x: spawnX,
              y: spawnY,
              vx: Math.cos(angleRad) * power,
              vy: -Math.sin(angleRad) * power,
              weapon: this.selectedWeapon,
              owner: this.currentPlayer,
              time: 0,
              state: 'flight',
              rollTimer: 0,
              hasRolled: false,
              tangentSpeed: 0,
              radius,
              initialSpeed: power
            };
            if (weapon.type === 'homing') {
              projectile.homingActive = false;
              projectile.homingSpeed = weapon.homingCruiseSpeed || Math.max(power, 0);
            }
            this.projectiles.push(projectile);
          }
          
          this.updateUI();
        }

        moveTurret(direction) {
          if (!this.currentPlayer || this.animating || this.roundOver) return;

          const player = this.players[this.currentPlayer];
          const targetX = clamp(
            player.x + direction * TURRET_MOVE_DISTANCE,
            TURRET_SIZE,
            this.width - TURRET_SIZE
          );

          if (Math.abs(targetX - player.x) < 1) {
            return;
          }

          const targetY = this.getTerrainHeight(targetX);
          if (targetY >= this.height) {
            return;
          }

          const otherKey = this.currentPlayer === 'a' ? 'b' : 'a';
          const other = this.players[otherKey];
          const minSeparation = TURRET_SIZE * 2;
          if (Math.abs(other.x - targetX) < minSeparation) {
            return;
          }

          player.x = targetX;
          player.y = targetY;

          this.render();
          this.endTurn();
        }

        update(dt) {
          // Update projectiles
          for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            const weapon = WEAPONS[proj.weapon];
            
            proj.time += dt;

            if (weapon.type === 'grenade') {
              if (this.updateGrenade(proj, weapon, dt)) {
                this.projectiles.splice(i, 1);
              }
              continue;
            }
            
            // Homing behavior
            if (weapon.type === 'homing') {
              const lockSeconds = weapon.lockTime / 1000;
              if (proj.time > lockSeconds) {
                if (!proj.homingActive) {
                  proj.homingActive = true;
                  if (!proj.homingSpeed) {
                    const currentSpeed = Math.hypot(proj.vx, proj.vy);
                    proj.homingSpeed = weapon.homingCruiseSpeed || currentSpeed;
                  }
                }

                const target = proj.owner === 'a' ? this.players.b : this.players.a;
                const dx = target.x - proj.x;
                const dy = target.y - proj.y;
                const angle = Math.atan2(dy, dx);
                const currentAngle = Math.atan2(proj.vy, proj.vx);

                const angleDiff = shortestAngleDiff(angle, currentAngle);
                const maxTurn = (weapon.homingTurnRate || 2) * dt;
                const clampedDiff = clamp(angleDiff, -maxTurn, maxTurn);
                const newAngle = currentAngle + clampedDiff;

                const currentSpeed = Math.hypot(proj.vx, proj.vy);
                const targetSpeed = proj.homingSpeed || currentSpeed;
                const blend = clamp(dt * 6, 0, 1);
                const speed = currentSpeed + (targetSpeed - currentSpeed) * blend;

                proj.vx = Math.cos(newAngle) * speed;
                proj.vy = Math.sin(newAngle) * speed;
              } else {
                proj.vy += GRAVITY * dt;
              }
            } else {
              proj.vy += GRAVITY * dt;
            }
            
            const oldX = proj.x;
            const oldY = proj.y;
            proj.x += proj.vx * dt;
            proj.y += proj.vy * dt;
            
            // Check collision
            let hit = false;
            
            // Check terrain
            if (this.isTerrainAt(proj.x, proj.y)) {
              hit = true;
            }
            
            // Check player collision
            ['a', 'b'].forEach(key => {
              if (key === proj.owner) return;
              const target = this.players[key];
              const d = dist(proj.x, proj.y, target.x, target.y);
              if (d < TURRET_SIZE) {
                hit = true;
              }
            });
            
            // Out of bounds
            if (proj.x < 0 || proj.x > this.width || proj.y > this.height) {
              this.projectiles.splice(i, 1);
              continue;
            }
            
            if (hit) {
              this.explode(proj.x, proj.y, weapon, proj.owner);
              this.projectiles.splice(i, 1);
            }
          }
          
          // Update explosions
          for (let i = this.explosions.length - 1; i >= 0; i--) {
            const exp = this.explosions[i];
            exp.time += dt;
            exp.currentRadius = lerp(0, exp.radius, Math.min(1, exp.time / exp.duration));
            
            if (exp.time >= exp.duration) {
              this.explosions.splice(i, 1);
            }
          }
          
          // Check if animation done
          if (this.projectiles.length === 0 && this.explosions.length === 0 && this.animating) {
            this.animating = false;
            this.endTurn();
          }
        }

        explode(x, y, weapon, owner) {
          this.explosions.push({
            x,
            y,
            radius: weapon.radius,
            currentRadius: 0,
            time: 0,
            duration: 0.4,
            weapon,
            owner
          });
          
          // Damage terrain
          setTimeout(() => {
            this.damageTerrain(x, y, weapon.radius);
            this.applyExplosionDamage(x, y, weapon);
          }, 400);
        }

        applyExplosionDamage(x, y, weapon) {
          if (this.roundOver) return;
          let roundShouldEnd = false;

          ['a', 'b'].forEach(key => {
            const player = this.players[key];
            const distanceToBlast = dist(player.x, player.y, x, y);
            if (distanceToBlast > weapon.radius + TURRET_SIZE) {
              return;
            }

            if (player.shieldActive) {
              player.shieldActive = false;
              player.shieldAvailable = false;
              return;
            }

            player.hp = Math.max(0, player.hp - weapon.damage);
            if (player.hp <= 0) {
              roundShouldEnd = true;
            }
          });

          this.updateUI();

          if (roundShouldEnd) {
            this.endRound();
          }
        }

        damageTerrain(x, y, radius) {
          const maskCtx = this.maskCtx;
          maskCtx.globalCompositeOperation = 'destination-out';
          maskCtx.fillStyle = '#fff';
          maskCtx.beginPath();
          maskCtx.arc(x, y, radius, 0, Math.PI * 2);
          maskCtx.fill();
          maskCtx.globalCompositeOperation = 'source-over';

          this.refreshTerrainHeights(x - radius - 2, x + radius + 2);
          
          // Update player positions if terrain changed
          ['a', 'b'].forEach(key => {
            const player = this.players[key];
            const newY = this.getTerrainHeight(player.x);
            if (newY > player.y + 5) {
              player.y = newY;
            }
          });
        }

    // Handle grenade physics including rolling and timed detonation
    updateGrenade(proj, weapon, dt) {
          const radius = proj.radius || GRENADE_RADIUS;

          if (proj.state === 'rolling') {
            let terrainY = this.getTerrainHeight(proj.x);
            if (terrainY >= this.height) {
              proj.state = 'flight';
              return false;
            }

            const slope = this.getTerrainSlope(proj.x);
            const tangent = this.getSurfaceTangent(slope);
            let tangential = Number.isFinite(proj.tangentSpeed)
              ? proj.tangentSpeed
              : (proj.vx * tangent.x + proj.vy * tangent.y);

            tangential += GRAVITY * dt * tangent.y;

            const friction = 3.2;
            if (tangential > 0) {
              tangential = Math.max(0, tangential - friction * dt);
            } else {
              tangential = Math.min(0, tangential + friction * dt);
            }

            proj.vx = tangent.x * tangential;
            proj.vy = tangent.y * tangential;
            proj.x += proj.vx * dt;
            proj.y += proj.vy * dt;

            terrainY = this.getTerrainHeight(proj.x);
            if (terrainY >= this.height) {
              proj.state = 'flight';
              return false;
            }

            const targetY = terrainY - radius;
            if (proj.y > targetY + 1) {
              proj.state = 'flight';
              return false;
            }
            proj.y = targetY;

            if (this.handleGrenadeTurretCollision(proj, radius)) {
              const postSlope = this.getTerrainSlope(proj.x);
              const postTangent = this.getSurfaceTangent(postSlope);
              const adjusted = proj.vx * postTangent.x + proj.vy * postTangent.y;
              proj.vx = postTangent.x * adjusted;
              proj.vy = postTangent.y * adjusted;
              const adjustedHeight = this.getTerrainHeight(proj.x);
              if (adjustedHeight < this.height) {
                proj.y = adjustedHeight - radius;
              }
              tangential = adjusted;
            }

            proj.tangentSpeed = tangential;
            proj.rollTimer += dt;

            if (proj.rollTimer >= weapon.fuseTime / 1000) {
              this.explode(proj.x, proj.y, weapon, proj.owner);
              return true;
            }

            return false;
          }

          proj.vy += GRAVITY * dt;
          const oldX = proj.x;
          const oldY = proj.y;
          proj.x += proj.vx * dt;
          proj.y += proj.vy * dt;

          if (this.handleGrenadeTurretCollision(proj, radius)) {
            return false;
          }

          const terrainY = this.getTerrainHeight(proj.x);
          if (terrainY < this.height && proj.y + radius >= terrainY) {
            const slope = this.getTerrainSlope(proj.x);
            const tangent = this.getSurfaceTangent(slope);
            const normal = { x: -tangent.y, y: tangent.x };
            const velNormal = proj.vx * normal.x + proj.vy * normal.y;
            const velTang = proj.vx * tangent.x + proj.vy * tangent.y;

            if (velNormal < -120) {
              const restitution = 0.4;
              const bouncedNormal = -velNormal * restitution;
              proj.vx = tangent.x * velTang + normal.x * bouncedNormal;
              proj.vy = tangent.y * velTang + normal.y * bouncedNormal;
              proj.x = oldX;
              proj.y = terrainY - radius - 0.5;
            } else {
              if (!proj.hasRolled) {
                proj.rollTimer = 0;
                proj.hasRolled = true;
              }
              proj.state = 'rolling';
              proj.tangentSpeed = velTang + velNormal * 0.2;
              proj.x = clamp(proj.x, radius, this.width - radius);
              proj.y = terrainY - radius;
              proj.vx = tangent.x * proj.tangentSpeed;
              proj.vy = tangent.y * proj.tangentSpeed;
            }
          }

          if (proj.x < -radius || proj.x > this.width + radius || proj.y > this.height + radius) {
            return true;
          }

          return false;
        }

        handleGrenadeTurretCollision(proj, radius) {
          let collided = false;
          ['a', 'b'].forEach(key => {
            if (key === proj.owner) {
              return;
            }
            const turret = this.players[key];
            const dx = proj.x - turret.x;
            const dy = proj.y - turret.y;
            const minDist = TURRET_SIZE + radius;
            const distSq = dx * dx + dy * dy;
            if (distSq < minDist * minDist) {
              const dist = Math.sqrt(distSq) || 0.0001;
              const nx = dx / dist;
              const ny = dy / dist;
              const overlap = minDist - dist;
              proj.x += nx * overlap;
              proj.y += ny * overlap;
              proj.x = clamp(proj.x, radius, this.width - radius);
              proj.y = Math.min(proj.y, this.height - radius);
              const velAlong = proj.vx * nx + proj.vy * ny;
              proj.vx -= velAlong * nx;
              proj.vy -= velAlong * ny;
              proj.vx *= 0.8;
              proj.vy *= 0.8;
              collided = true;
            }
          });
          return collided;
        }

        endTurn() {
          if (this.roundOver) return;
          this.currentPlayer = this.currentPlayer === 'a' ? 'b' : 'a';
          const player = this.players[this.currentPlayer];
          
          document.getElementById('angle').value = player.angle;
          document.getElementById('angle-val').textContent = player.angle;
          document.getElementById('power').value = player.power;
          document.getElementById('power-val').textContent = player.power;
          
          this.updateUI();
        }

        endRound() {
          if (this.roundOver) return;
          this.roundOver = true;

          const aDead = this.players.a.hp <= 0;
          const bDead = this.players.b.hp <= 0;

          let heading = 'Round Over';
          let message = 'Prepare for the next volley.';

          if (aDead && bDead) {
            heading = 'Stalemate';
            message = 'Both turrets were obliterated in the blast.';
          } else if (bDead) {
            heading = 'Player A Wins';
            message = 'Player A stands victorious this round.';
            this.players.a.score++;
          } else if (aDead) {
            heading = 'Player B Wins';
            message = 'Player B claims the round.';
            this.players.b.score++;
          }

          this.animating = false;
          this.projectiles.length = 0;
          this.explosions.length = 0;
          this.updateUI();
          this.showRoundModal(heading, message);
        }

        updateUI() {
          document.getElementById('score-a').textContent = this.players.a.score;
          document.getElementById('score-b').textContent = this.players.b.score;
          document.getElementById('hp-a').textContent = this.players.a.hp;
          document.getElementById('hp-b').textContent = this.players.b.hp;
          
          // Shield indicators
          document.getElementById('shield-a').style.display = this.players.a.shieldActive ? 'block' : 'none';
          document.getElementById('shield-b').style.display = this.players.b.shieldActive ? 'block' : 'none';
          
          // Active player
          document.querySelector('.player-a').classList.toggle('active', this.currentPlayer === 'a');
          document.querySelector('.player-b').classList.toggle('active', this.currentPlayer === 'b');
          
          // Update weapon counts
          if (this.currentPlayer) {
            const player = this.players[this.currentPlayer];
            document.querySelectorAll('.weapon-btn').forEach(btn => {
              const key = btn.dataset.weapon;
              const count = player.weapons[key];
              const countSpan = btn.querySelector('.weapon-count');
              
              if (count === Infinity) {
                countSpan.textContent = '‚àû';
                btn.classList.remove('depleted');
              } else {
                countSpan.textContent = count;
                btn.classList.toggle('depleted', count === 0);
              }
            });
          }
          
          // Shield button
          const shieldBtn = document.getElementById('shield-btn');
          if (this.currentPlayer) {
            const player = this.players[this.currentPlayer];
            shieldBtn.disabled = !player.shieldAvailable || this.animating || this.roundOver;
            shieldBtn.style.opacity = player.shieldActive ? '1' : '0.8';
            shieldBtn.textContent = player.shieldActive ? 'SHIELD ON' : 'SHIELD (1x)';
          } else {
            shieldBtn.disabled = true;
            shieldBtn.style.opacity = '0.5';
            shieldBtn.textContent = 'SHIELD (1x)';
          }
          
          // Fire button
          const fireBtn = document.getElementById('fire-btn');
          if (fireBtn) {
            fireBtn.disabled = this.animating || this.roundOver || !this.currentPlayer;
          }
          const moveLeftBtn = document.getElementById('move-left-btn');
          const moveRightBtn = document.getElementById('move-right-btn');
          if (moveLeftBtn && moveRightBtn) {
            const disableMovement = this.animating || this.roundOver || !this.currentPlayer;
            moveLeftBtn.disabled = disableMovement;
            moveRightBtn.disabled = disableMovement;
          }
        }

        render() {
          const ctx = this.ctx;
          const w = this.width;
          const h = this.height;
          
          // Clear canvas
          ctx.clearRect(0, 0, w, h);
          
          // Draw sky first (full background)
          ctx.drawImage(this.skyCanvas, 0, 0);
          
          // Draw terrain clipped by mask via off-screen buffer
          const bufferCtx = this.bufferCtx;
          bufferCtx.clearRect(0, 0, w, h);
          bufferCtx.drawImage(this.terrainCanvas, 0, 0);
          bufferCtx.globalCompositeOperation = 'destination-in';
          bufferCtx.drawImage(this.maskCanvas, 0, 0);
          bufferCtx.globalCompositeOperation = 'source-over';
          ctx.drawImage(this.bufferCanvas, 0, 0);
          
          // Draw turrets
          ['a', 'b'].forEach(key => {
            const player = this.players[key];
            
            // Shield
            if (player.shieldActive) {
              ctx.strokeStyle = 'rgba(156, 39, 176, 0.6)';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(player.x, player.y, TURRET_SIZE + 10, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Turret base
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(player.x, player.y, TURRET_SIZE, 0, Math.PI * 2);
            ctx.fill();
            
            // Barrel
            const angleRad = (player.angle * Math.PI) / 180;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(
              player.x + Math.cos(angleRad) * BARREL_LENGTH,
              player.y - Math.sin(angleRad) * BARREL_LENGTH
            );
            ctx.stroke();
          });
          
          // Draw projectiles
          this.projectiles.forEach(proj => {
            const phase = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
            const radius = proj.radius || 6;
            
            ctx.save();
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(255, 150, 50, 0.8)';
            
            const grd = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, radius);
            grd.addColorStop(0, `rgba(255, 255, 150, ${phase})`);
            grd.addColorStop(0.5, `rgba(255, 150, 50, ${phase})`);
            grd.addColorStop(1, `rgba(255, 100, 0, ${phase * 0.5})`);
            
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          });
          
          // Draw explosions
          this.explosions.forEach(exp => {
            const progress = exp.currentRadius / exp.radius;
            const alpha = 1 - progress;
            
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'rgba(255, 150, 0, 0.6)';
            
            const grd = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, exp.currentRadius);
            grd.addColorStop(0, `rgba(255, 255, 100, ${alpha})`);
            grd.addColorStop(0.4, `rgba(255, 150, 50, ${alpha * 0.8})`);
            grd.addColorStop(1, `rgba(255, 50, 0, 0)`);
            
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, exp.currentRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          });
        }

        loop(currentTime) {
          requestAnimationFrame((time) => this.loop(time));
          
          const deltaTime = currentTime - this.lastTime;
          this.lastTime = currentTime;
          
          this.accumulator += deltaTime;
          
          while (this.accumulator >= FRAME_TIME) {
            this.update(FRAME_TIME / 1000);
            this.accumulator -= FRAME_TIME;
          }
          
          this.render();
        }
      }

      // Start game when DOM loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => new Game());
      } else {
        new Game();
      }
    })();
  </script>
</body>
<script src="parental.js"></script>
</html>
