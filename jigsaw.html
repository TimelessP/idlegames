<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <!-- Navigation/status bar color on Android; updated dynamically by JS -->
    <meta name="theme-color" content="#0f1320" id="theme-color" />
    <title>Jigsaw Puzzle</title>
    <style>
        :root {
            --bg: #0f1320;
            --panel: #151a2b;
            --text: #e6f0ff;
            --muted: #9bb3d1;
            --accent: #4fc3f7;
            --accent-2: #7c4dff;
            --shadow: rgba(0, 0, 0, 0.35);
            /* Start color for page background gradient */
            --bg-start: #1a2240;
            /* Let UA components adapt; overridden by explicit theme below */
            color-scheme: dark light;
        }
        :root[data-theme="dark"] { color-scheme: dark; }

        /* Light theme overrides */
        :root[data-theme="light"] {
            --bg: #b9b9b9;
            --panel: #ffffff;
            --text: #0c1630;
            --muted: #51627a;
            --accent: #1ea0e6;
            --accent-2: #6a4cff;
            --shadow: rgba(0, 0, 0, 0.18);
            /* Brighter, fresh start for light-mode gradient */
            --bg-start: #ebebeb;
            /* ~#3f3 */
            color-scheme: light;
        }

        /* System preference when no explicit theme set */
        @media (prefers-color-scheme: light) {
            :root:not([data-theme]) {
                --bg: #b9b9b9;
                --panel: #ffffff;
                --text: #0c1630;
                --muted: #51627a;
                --accent: #1ea0e6;
                --accent-2: #6a4cff;
                --shadow: rgba(0, 0, 0, 0.18);
                --bg-start: #ebebeb;
                color-scheme: light;
            }
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }
        html { background-color: var(--bg); }

        body {
            margin: 0;
            background: radial-gradient(1200px 800px at 10% 10%, var(--bg-start) 0%, var(--bg) 60%);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
            overflow: hidden;
            /* we manage panning/zoom inside */
            touch-action: none;
            /* we provide custom pan/zoom/drag */
            /* Prevent long-press text selection/callout */
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            /* Extend under system UI (notches/gesture areas) */
            padding-top: env(safe-area-inset-top);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
        }

        /* Floating action buttons */
        .fab-stack {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 12;
        }

        .hud {
            position: fixed; /* anchor to visual viewport */
            bottom: 12px;
            left: 12px;
            right: 12px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        @supports (bottom: calc(12px + env(safe-area-inset-bottom))) {
            .hud { bottom: calc(12px + env(safe-area-inset-bottom)); }
            .hud { left: calc(12px + env(safe-area-inset-left)); right: calc(12px + env(safe-area-inset-right)); }
        }

        .fab {
            width: 46px;
            height: 46px;
            border-radius: 50%;
            background: color-mix(in oklab, var(--panel) 88%, black 0%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 8px 24px var(--shadow);
            display: grid;
            place-items: center;
            color: var(--text);
            cursor: pointer;
            outline: none;
            -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
        }

        .fab:hover {
            filter: brightness(1.05);
        }

        .fab:active {
            transform: translateY(1px);
        }

        .fab svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }

        .stage {
            position: absolute;
            left: 0; right: 0; top: 0; bottom: 0;
            /* also honor safe area so content isn't obscured */
            padding-top: env(safe-area-inset-top);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        #bg {
            fill: transparent;
            pointer-events: all;
        }

        .piece {
            cursor: grab;
        }

        .piece:active {
            cursor: grabbing;
        }

        .outline {
            fill: none;
            stroke: rgba(255, 255, 255, 0.14);
            stroke-width: 1;
        }

        .highlight {
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.35));
        }

        /* .hud absolute version removed; using fixed-position .hud defined above */

        .badge {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 999px;
            font-size: 12px;
            color: var(--muted);
            -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
        }

        /* Edge shading visuals */
        .edge-shade {
            fill: none;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .edge-highlight {
            stroke: rgba(255, 255, 255, 0.7);
            stroke-width: 2.2;
        }

        .edge-shadow {
            stroke: rgba(0, 0, 0, 0.45);
            stroke-width: 2.2;
        }

        .win {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            background: rgba(10, 14, 25, 0.35);
            z-index: 20;
            -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
        }

        .win .panel {
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 18px 22px;
            border-radius: 14px;
            box-shadow: 0 12px 30px var(--shadow);
            text-align: center;
        }

        .win .panel h2 {
            margin: 0 0 8px 0;
        }

        /* Import modal */
        .modal {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            background: rgba(10, 14, 25, 0.45);
            z-index: 20;
            -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
        }

        .modal .panel {
            background: var(--panel);
            border: 1px solid rgba(255, 255, 255, 0.12);
            padding: 20px 22px;
            border-radius: 14px;
            box-shadow: 0 12px 30px var(--shadow);
            width: min(92vw, 560px);
            color: var(--text);
        }

        .modal .panel h3 {
            margin: 0 0 12px 0;
        }

        .modal .grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-top: 12px;
        }

        .modal label {
            display: block;
            font-size: 13px;
            color: var(--muted);
            margin: 6px 0;
        }

        .modal input[type="number"],
        .modal input[type="file"] {
            width: 100%;
            background: #0f152a;
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 18px;
            /* Re-enable selection and callouts for inputs */
            -webkit-user-select: text; user-select: text; -webkit-touch-callout: default;
        }

        [data-theme="light"] .modal input[type="number"],
        [data-theme="light"] .modal input[type="file"] {
            background: #f5f7fb;
            border-color: rgba(0, 0, 0, 0.12);
        }

        .modal .actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 16px;
        }

        .btn {
            background: #0f152a;
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            padding: 10px 14px;
            font-size: 14px;
            cursor: pointer;
        }

        .btn.primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
            border: none;
            font-weight: 700;
            letter-spacing: 0.2px;
            box-shadow: 0 6px 16px rgba(79, 195, 247, 0.35);
        }
    </style>
</head>

<body>
    <div class="fab-stack">
        <button id="btnImport" class="fab" title="Import image" aria-label="Import image">
            <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                    d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2Zm0 2v9.59l-3.3-3.3a1 1 0 0 0-1.4 0L9 16l-2.3-2.3a1 1 0 0 0-1.4 0L5 14.99V5h14ZM7.5 8.5A1.5 1.5 0 1 0 9 7a1.5 1.5 0 0 0-1.5 1.5Z" />
            </svg>
        </button>
        <button id="btnFit" class="fab" title="Fit view" aria-label="Fit view">
            <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                    d="M7 3H3v4h2V5h2V3Zm14 0h-4v2h2v2h2V3ZM3 17v4h4v-2H5v-2H3Zm16 2h-2v2h4v-4h-2v2ZM7 11h2v2H7v-2Zm4 0h2v2h-2v-2Zm4 0h2v2h-2v-2Z" />
            </svg>
        </button>
        <button id="btnFull" class="fab" title="Enter fullscreen" aria-label="Toggle fullscreen">
            <svg id="iconFull" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M8 3H3v5h2V5h3V3Zm13 0h-5v2h3v3h2V3ZM3 21h5v-2H5v-3H3v5Zm18-5h-2v3h-3v2h5v-5Z" />
            </svg>
        </button>
        <button id="btnTheme" class="fab" title="Theme: System" aria-label="Cycle theme">
            <svg id="iconTheme" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 3a9 9 0 1 0 9 9c0-.34-.02-.68-.06-1.01A7 7 0 0 1 12 3Z" />
            </svg>
        </button>
    </div>
    <div class="stage">
        <svg id="svg" xmlns="http://www.w3.org/2000/svg">
            <defs id="defs"></defs>
            <g id="world">
                <rect id="bg" x="-5000" y="-5000" width="10000" height="10000"></rect>
                <g id="pieces"></g>
            </g>
        </svg>
        <div class="hud">
            <div class="badge" id="status">0 / 0 joined</div>
            <div class="badge" id="zoomLabel">100%</div>
        </div>
        <div class="win" id="win">
            <div class="panel">
                <h2>ðŸŽ‰ Puzzle Complete!</h2>
                <div style="margin-bottom:10px;color:var(--muted)">Pinch or scroll to view your masterpiece.</div>
                <button id="closeWin" class="btn primary">Close</button>
            </div>
        </div>
        <!-- Import modal -->
        <div class="modal" id="importModal" role="dialog" aria-modal="true" aria-labelledby="importTitle">
            <div class="panel">
                <h3 id="importTitle">Import Image</h3>
                <div class="form">
                    <label>Image file
                        <input id="impFile" type="file" accept="image/*" />
                    </label>
                    <div class="grid">
                        <div>
                            <label>Rows</label>
                            <input id="impRows" type="number" inputmode="numeric" min="2" max="50" step="1" value="4" />
                        </div>
                        <div>
                            <label>Cols</label>
                            <input id="impCols" type="number" inputmode="numeric" min="2" max="50" step="1" value="6" />
                        </div>
                        <div>
                            <label>Snap</label>
                            <input id="impSnap" type="number" inputmode="numeric" min="2" max="100" step="1"
                                value="12" />
                        </div>
                    </div>
                    <div class="actions">
                        <button id="impCancel" class="btn">Cancel</button>
                        <button id="impBegin" class="btn primary">Begin</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function () {
            'use strict';

            // --- State ---
            const svg = document.getElementById('svg');
            const world = document.getElementById('world');
            const defs = document.getElementById('defs');
            const piecesLayer = document.getElementById('pieces');
            const statusEl = document.getElementById('status');
            const zoomLabel = document.getElementById('zoomLabel');
            const winEl = document.getElementById('win');
            const closeWin = document.getElementById('closeWin');
            const importModal = document.getElementById('importModal');
            const impFile = document.getElementById('impFile');
            const impRows = document.getElementById('impRows');
            const impCols = document.getElementById('impCols');
            const impSnap = document.getElementById('impSnap');
            const impBegin = document.getElementById('impBegin');
            const impCancel = document.getElementById('impCancel');
            const btnImport = document.getElementById('btnImport');
            const btnFit = document.getElementById('btnFit');
            const btnFull = document.getElementById('btnFull');
            const iconFull = document.getElementById('iconFull');
            const btnTheme = document.getElementById('btnTheme');
            const iconTheme = document.getElementById('iconTheme');

            let imgHref = null;
            let imgW = 0, imgH = 0;
            let rows = 4, cols = 6;
            let snapTol = 12;

            let scale = 1, tx = 0, ty = 0; // world transform
            const minScale = 0.05, maxScale = 4;
            const TOUCH_DRAG_OFFSET_PX = 56; // keep piece above finger by ~56px in screen space

            // current puzzle metrics
            let cellW = 0, cellH = 0, edgeTabRMax = 0;
            // Flattened final image (after completion)
            let flattened = null; // { x, y }

            const rng = (seed) => () => (seed = (seed * 1664525 + 1013904223) >>> 0) / 4294967296;

            // Edge params shared between neighboring pieces
            let hEdges = []; // horizontal edges [r][c] r:0..rows, c:0..cols-1
            let vEdges = []; // vertical edges [r][c] r:0..rows-1, c:0..cols

            // Pieces and groups
            let pieces = []; // {id, r,c, pathD, clipId, g, groupId, anchor:[x,y]}
            let groups = new Map(); // groupId -> {id, members:Set<pieceId>, g, x,y}
            let nextGroupId = 1;

            // Active interactions
            const pointers = new Map(); // id -> {x,y, sx,sy}
            let dragging = null; // {groupId, dx, dy}
            let pinching = null; // {startDist, startScale, startTx, startTy, startCenter}
            let panning = null; // background pan via right mouse or space?
            let dragAnimId = 0; // rAF id for drag
            let dragNext = null; // {gid, x, y}

            // --- UI wiring ---
            closeWin.addEventListener('click', () => { winEl.style.display = 'none'; });

            // Import modal controls
            btnImport.addEventListener('click', () => {
                impRows.value = rows; impCols.value = cols; impSnap.value = snapTol;
                impFile.value = '';
                importModal.style.display = 'flex';
                // Autofocus file input for quick action
                setTimeout(() => impFile && impFile.focus && impFile.focus(), 0);
            });
            impCancel.addEventListener('click', () => { importModal.style.display = 'none'; });
            impBegin.addEventListener('click', async () => {
                // Read values
                rows = clamp(int(impRows.value, rows), 2, 50);
                cols = clamp(int(impCols.value, cols), 2, 50);
                snapTol = clamp(int(impSnap.value, snapTol), 2, 100);
                const f = impFile.files && impFile.files[0];
                if (f) {
                    try {
                        const href = await readFileAsDataURL(f);
                        const dim = await getImageSize(href);
                        imgHref = href; imgW = dim.w; imgH = dim.h;
                    } catch (err) { console.error('Failed to load image', err); }
                }
                if (!imgHref) { // ensure there's an image
                    const placeholder = createGradientImage(1024, 768);
                    imgHref = placeholder.href; imgW = placeholder.w; imgH = placeholder.h;
                }
                importModal.style.display = 'none';
                initPuzzle();
            });

            // Fullscreen toggle
            function updateFullIcon() {
                if (document.fullscreenElement) {
                    iconFull.innerHTML = '<path d="M9 7H7v2H5v2h4V7Zm10 2h-2V7h-2v4h4V9ZM7 15H5v2h2v2h2v-4H7Zm12 0h-4v4h2v-2h2v-2Z"/>'; // exit-ish
                    btnFull.title = 'Exit fullscreen';
                } else {
                    iconFull.innerHTML = '<path d="M8 3H3v5h2V5h3V3Zm13 0h-5v2h3v3h2V3ZM3 21h5v-2H5v-3H3v5Zm18-5h-2v3h-3v2h5v-5Z"/>';
                    btnFull.title = 'Enter fullscreen';
                }
            }
            updateFullIcon();
            btnFull.addEventListener('click', async () => {
                try {
                    if (!document.fullscreenElement) {
                        const el = document.documentElement;
                        if (el.requestFullscreen) {
                            // Some browsers support an option to hide system UI
                            const opts = { navigationUI: 'hide' };
                            try { await el.requestFullscreen(opts); }
                            catch { await el.requestFullscreen(); }
                        }
                    }
                    else { await document.exitFullscreen(); }
                } catch (err) { console.warn('Fullscreen error', err); }
            });
            document.addEventListener('fullscreenchange', updateFullIcon);

            // Theme cycle: system -> light -> dark -> system
            const THEME_KEY = 'puzzle-theme-mode';
            let themeMode = (localStorage.getItem(THEME_KEY) || 'system');
            function applyTheme(mode) {
                themeMode = mode;
                if (mode === 'light') document.documentElement.setAttribute('data-theme', 'light');
                else if (mode === 'dark') document.documentElement.setAttribute('data-theme', 'dark');
                else document.documentElement.removeAttribute('data-theme');
                localStorage.setItem(THEME_KEY, themeMode);
                // Update Android nav bar color to match theme
                try {
                    const meta = document.querySelector('meta[name="theme-color"]');
                    if (meta) {
                        let color;
                        if (mode === 'light') color = '#ffffff';
                        else if (mode === 'dark') color = '#0f1320';
                        else {
                            // system: pick by media query
                            const dark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                            color = dark ? '#0f1320' : '#ffffff';
                        }
                        meta.setAttribute('content', color);
                    }
                } catch (_) { }
                // Update icon
                if (mode === 'system') {
                    iconTheme.innerHTML = '<path d="M12 3a9 9 0 1 0 9 9c0-.34-.02-.68-.06-1.01A7 7 0 0 1 12 3Z"/>';
                    btnTheme.title = 'Theme: System';
                } else if (mode === 'light') {
                    iconTheme.innerHTML = '<path d="M6.76 4.84 5.34 3.42 3.92 4.84 5.34 6.26 6.76 4.84Zm10.48 0 1.42-1.42 1.42 1.42-1.42 1.42-1.42-1.42ZM12 5a7 7 0 1 1 0 14 7 7 0 0 1 0-14Zm0-4h1v3h-1V1ZM1 11h3v1H1v-1Zm19 0h3v1h-3v-1ZM12 20h1v3h-1v-3Zm-6.66-.24L3.92 21.18 5.34 22.6l1.42-1.42-1.42-1.42Zm13.32 0 1.42 1.42-1.42 1.42-1.42-1.42 1.42-1.42Z"/>';
                    btnTheme.title = 'Theme: Light';
                } else {
                    iconTheme.innerHTML = '<path d="M9.37 5.51A7 7 0 1 0 18.5 14.63 8 8 0 1 1 9.37 5.5Z"/>';
                    btnTheme.title = 'Theme: Dark';
                }
            }
            applyTheme(themeMode);
            btnTheme.addEventListener('click', () => {
                const next = themeMode === 'system' ? 'light' : (themeMode === 'light' ? 'dark' : 'system');
                applyTheme(next);
            });
            // If in system mode, react to live system theme changes to keep nav bar in sync
            if (window.matchMedia) {
                const mq = window.matchMedia('(prefers-color-scheme: dark)');
                mq.addEventListener && mq.addEventListener('change', () => { if (themeMode === 'system') applyTheme('system'); });
            }

            // Fit View button
            btnFit.addEventListener('click', () => {
                fitView(getContentBounds());
            });

            // Modal UX: backdrop click and Escape to cancel
            importModal.addEventListener('click', (e) => { if (e.target === importModal) importModal.style.display = 'none'; });
            window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && importModal.style.display === 'flex') importModal.style.display = 'none'; });

            // --- Helpers ---
            function int(v, d = 0) { const n = parseInt(v, 10); return Number.isFinite(n) ? n : d; }
            function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
            function lerp(a, b, t) { return a + (b - a) * t; }
            function readFileAsDataURL(file) {
                return new Promise((resolve, reject) => {
                    const fr = new FileReader();
                    fr.onerror = reject; fr.onload = () => resolve(fr.result);
                    fr.readAsDataURL(file);
                });
            }
            function getImageSize(href) {
                return new Promise((resolve, reject) => {
                    const im = new Image();
                    im.onload = () => resolve({ w: im.naturalWidth, h: im.naturalHeight });
                    im.onerror = reject; im.src = href;
                });
            }

            function setWorldTransform(ns, ntx, nty) {
                scale = clamp(ns, minScale, maxScale);
                tx = ntx; ty = nty;
                world.setAttribute('transform', `translate(${tx},${ty}) scale(${scale})`);
                zoomLabel.textContent = Math.round(scale * 100) + '%';
            }

            function screenToWorld(pt) {
                const rect = svg.getBoundingClientRect();
                const x = (pt.x - rect.left - tx) / scale;
                const y = (pt.y - rect.top - ty) / scale;
                return { x, y };
            }

            function worldToScreen(pt) {
                const rect = svg.getBoundingClientRect();
                return { x: pt.x * scale + tx + rect.left, y: pt.y * scale + ty + rect.top };
            }

            // --- Puzzle generation ---
            function initPuzzle() {
                // Reset layers/state
                piecesLayer.innerHTML = '';
                defs.innerHTML = '';
                pieces = []; groups.clear(); nextGroupId = 1; winEl.style.display = 'none'; flattened = null;

                // Prepare edges
                hEdges = Array.from({ length: rows + 1 }, () => Array(cols).fill(null));
                vEdges = Array.from({ length: rows }, () => Array(cols + 1).fill(null));

                const rnd = rng((rows * 73856093) ^ (cols * 19349663) ^ (Math.floor(imgW + imgH) >>> 0));
                cellW = imgW / cols;
                cellH = imgH / rows;
                const base = Math.min(cellW, cellH);
                // Reasonable tab sizes
                const tabRMin = base * 0.10, tabRMax = base * 0.18;
                edgeTabRMax = tabRMax;
                const tabWMin = base * 0.20, tabWMax = base * 0.32;

                for (let r = 0; r <= rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (r === 0 || r === rows) {
                            hEdges[r][c] = { border: true, p0: { x: c * cellW, y: r * cellH }, p1: { x: (c + 1) * cellW, y: r * cellH } };
                        } else {
                            const dir = (rnd() < 0.5) ? 1 : -1; // +1 = bulge downward
                            const R = lerp(tabRMin, tabRMax, rnd());
                            const W = lerp(tabWMin, tabWMax, rnd());
                            const neck = 0.6 + rnd() * 0.3; // 0..1 softness
                            const p0 = { x: c * cellW, y: r * cellH };
                            const p1 = { x: (c + 1) * cellW, y: r * cellH };
                            const nodes = computeEdgeNodes(p0, p1, { dir, R, W, neck }, 'h');
                            hEdges[r][c] = { border: false, dir, R, W, neck, p0, p1, nodes };
                        }
                    }
                }
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c <= cols; c++) {
                        if (c === 0 || c === cols) {
                            vEdges[r][c] = { border: true, p0: { x: c * cellW, y: r * cellH }, p1: { x: c * cellW, y: (r + 1) * cellH } };
                        } else {
                            const dir = (rnd() < 0.5) ? 1 : -1; // +1 = bulge right
                            const R = lerp(tabRMin, tabRMax, rnd());
                            const W = lerp(tabWMin, tabWMax, rnd());
                            const neck = 0.6 + rnd() * 0.3;
                            const p0 = { x: c * cellW, y: r * cellH };
                            const p1 = { x: c * cellW, y: (r + 1) * cellH };
                            const nodes = computeEdgeNodes(p0, p1, { dir, R, W, neck }, 'v');
                            vEdges[r][c] = { border: false, dir, R, W, neck, p0, p1, nodes };
                        }
                    }
                }

                // Define drop shadow filter once
                const filterId = 'pieceShadow';
                defs.insertAdjacentHTML('beforeend', `
        <filter id="${filterId}" x="-30%" y="-30%" width="160%" height="160%">
          <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="rgba(0,0,0,0.35)" />
        </filter>`);

                // Build pieces
                const imgId = 'puzzleImage';
                defs.insertAdjacentHTML('beforeend', `<image id="${imgId}" href="${imgHref}" x="0" y="0" width="${imgW}" height="${imgH}" preserveAspectRatio="none" />`);

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const id = r * cols + c;
                        const d = buildPiecePath(r, c, cellW, cellH);
                        const clipId = `clip_${id}`;
                        defs.insertAdjacentHTML('beforeend', `<clipPath id="${clipId}"><path d="${d}"/></clipPath>`);

                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.classList.add('piece');
                        g.setAttribute('data-id', id);
                        g.setAttribute('filter', `url(#${filterId})`);

                        // Image clipped to the piece path
                        const img = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                        img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#${imgId}`);
                        img.setAttribute('clip-path', `url(#${clipId})`);
                        img.classList.add('highlight');
                        g.appendChild(img);

                        // Outline path for crisp edges and pointer hit
                        const outline = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        outline.setAttribute('d', d);
                        outline.setAttribute('class', 'outline');
                        outline.setAttribute('pointer-events', 'stroke');
                        g.appendChild(outline);

                        // Edge shading group clipped to piece
                        const shadeG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        shadeG.setAttribute('clip-path', `url(#${clipId})`);
                        const shadePaths = {};
                        const sides = ['top', 'right', 'bottom', 'left'];
                        for (const side of sides) {
                            const sp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            sp.setAttribute('class', `edge-shade ${(side === 'top' || side === 'left') ? 'edge-highlight' : 'edge-shadow'}`);
                            sp.setAttribute('data-side', side);
                            sp.setAttribute('d', buildSidePathD(r, c, side));
                            shadeG.appendChild(sp);
                            shadePaths[side] = sp;
                        }
                        g.appendChild(shadeG);

                        piecesLayer.appendChild(g);

                        const anchor = { x: c * cellW, y: r * cellH };
                        pieces.push({ id, r, c, pathD: d, clipId, g, groupId: null, anchor, shades: shadePaths });
                    }
                }

                // Create individual groups, shuffle positions
                pieces.forEach(p => {
                    const gid = newGroup();
                    joinPieceToGroup(p, gid);
                });

                // Shuffle in a donut around the puzzle
                const pad = Math.min(imgW, imgH) * 0.15;
                const leftArea = { x: -imgW - pad, y: -pad, w: imgW * 0.9, h: imgH + 2 * pad };
                const rightArea = { x: imgW + pad * 0.1, y: -pad, w: imgW * 0.9, h: imgH + 2 * pad };
                const topArea = { x: -pad, y: -imgH - pad, w: imgW + 2 * pad, h: imgH * 0.9 };
                const botArea = { x: -pad, y: imgH + pad * 0.1, w: imgW + 2 * pad, h: imgH * 0.9 };
                const areas = [leftArea, rightArea, topArea, botArea];
                const rgen = rng(0xC0FFEE ^ (rows << 8) ^ cols);
                pieces.forEach(p => {
                    const ar = areas[Math.floor(rgen() * areas.length)];
                    const gx = ar.x + rgen() * ar.w;
                    const gy = ar.y + rgen() * ar.h;
                    setGroupTransform(p.groupId, gx, gy);
                });

                // Fit view to the entire scattered content
                fitView(getContentBounds());
                updateJoinedStatus();
                updateAllEdgeShading();

                // Bind interactions
                bindInteractions();
            }

            function fitView(bounds) {
                const rect = svg.getBoundingClientRect();
                const pad = 40; // screen-space padding
                let minX = 0, minY = 0, maxX = imgW, maxY = imgH;
                if (bounds) {
                    ({ minX, minY, maxX, maxY } = bounds);
                }
                const width = Math.max(1, maxX - minX);
                const height = Math.max(1, maxY - minY);
                const sx = (rect.width - pad * 2) / width;
                const sy = (rect.height - pad * 2) / height;
                const s = Math.min(maxScale, Math.max(minScale, Math.min(sx, sy)));
                const nx = pad + (rect.width - pad * 2 - width * s) / 2 - minX * s;
                const ny = pad + (rect.height - pad * 2 - height * s) / 2 - minY * s;
                setWorldTransform(s, nx, ny);
            }

            function getContentBounds() {
                // Compute world-space bounds of all piece rectangles with a margin for tabs
                if (flattened) {
                    return { minX: flattened.x, minY: flattened.y, maxX: flattened.x + imgW, maxY: flattened.y + imgH };
                }
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                const tabMargin = edgeTabRMax + Math.min(cellW, cellH) * 0.05;
                groups.forEach(gr => {
                    gr.members.forEach(pid => {
                        const p = pieces[pid];
                        const x = p.anchor.x + gr.x;
                        const y = p.anchor.y + gr.y;
                        minX = Math.min(minX, x - tabMargin);
                        minY = Math.min(minY, y - tabMargin);
                        maxX = Math.max(maxX, x + cellW + tabMargin);
                        maxY = Math.max(maxY, y + cellH + tabMargin);
                    });
                });
                if (!Number.isFinite(minX)) {
                    // Fallback to puzzle rectangle
                    minX = 0; minY = 0; maxX = imgW; maxY = imgH;
                }
                return { minX, minY, maxX, maxY };
            }

            function newGroup() {
                const gid = nextGroupId++;
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('data-group', gid);
                piecesLayer.appendChild(g);
                groups.set(gid, { id: gid, members: new Set(), g, x: 0, y: 0 });
                return gid;
            }
            function setGroupTransform(gid, x, y) {
                const grp = groups.get(gid); if (!grp) return;
                grp.x = x; grp.y = y; grp.g.setAttribute('transform', `translate(${x},${y})`);
            }
            function joinPieceToGroup(piece, gid) {
                const grp = groups.get(gid);
                if (piece.groupId && piece.groupId !== gid) {
                    // remove from old group
                    const old = groups.get(piece.groupId);
                    old.members.delete(piece.id);
                }
                piece.groupId = gid;
                grp.members.add(piece.id);
                grp.g.appendChild(piece.g);
            }
            function mergeGroups(targetGid, sourceGid) {
                if (targetGid === sourceGid) return targetGid;
                const A = groups.get(targetGid); const B = groups.get(sourceGid);
                // Move B's children under A, keeping world position by adjusting their local positions (groups are translate-only)
                const dx = B.x - A.x, dy = B.y - A.y;
                // Move pieces from B to A
                B.members.forEach(id => {
                    const p = pieces[id];
                    joinPieceToGroup(p, A.id);
                });
                // After reparent, A's translate stays; remove B group
                piecesLayer.removeChild(B.g);
                groups.delete(B.id);
                // Update edge shading at the seam
                updateEdgeShadingForGroup(A.id);
                updateJoinedStatus();
                if (groups.size === 1) { showWin(); }
                return A.id;
            }

            function showWin() {
                winEl.style.display = 'flex';
                // Hide all shading so the finished image looks flat
                document.querySelectorAll('.edge-shade').forEach(el => el.style.display = 'none');
                // Flatten solved puzzle to a single image for performance
                try {
                    // Use any remaining group's translate as the solved offset
                    let gx = 0, gy = 0;
                    if (groups && groups.size) {
                        for (const gr of groups.values()) { gx = gr.x || 0; gy = gr.y || 0; break; }
                    }
                    // Clear heavy defs and per-piece DOM
                    defs.innerHTML = '';
                    piecesLayer.innerHTML = '';
                    const flatG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    flatG.setAttribute('id', 'flat');
                    flatG.setAttribute('transform', `translate(${gx},${gy})`);
                    const flatImg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    flatImg.setAttribute('href', imgHref);
                    flatImg.setAttribute('x', '0');
                    flatImg.setAttribute('y', '0');
                    flatImg.setAttribute('width', imgW);
                    flatImg.setAttribute('height', imgH);
                    flatImg.setAttribute('preserveAspectRatio', 'none');
                    flatG.appendChild(flatImg);
                    piecesLayer.appendChild(flatG);
                    flattened = { x: gx, y: gy };
                    // Free groups/pieces memory
                    groups.clear();
                    pieces = [];
                } catch (_) { }
            }

            function updateJoinedStatus() {
                let maxSize = 0; groups.forEach(gr => maxSize = Math.max(maxSize, gr.members.size));
                statusEl.textContent = `${maxSize} / ${pieces.length} joined`;
            }

            function buildSidePathD(r, c, side) {
                let p0, p1, edge;
                if (side === 'top') {
                    p0 = { x: c * cellW, y: r * cellH }; p1 = { x: (c + 1) * cellW, y: r * cellH }; edge = hEdges[r][c];
                } else if (side === 'right') {
                    p0 = { x: (c + 1) * cellW, y: r * cellH }; p1 = { x: (c + 1) * cellW, y: (r + 1) * cellH }; edge = vEdges[r][c + 1];
                } else if (side === 'bottom') {
                    p0 = { x: (c + 1) * cellW, y: (r + 1) * cellH }; p1 = { x: c * cellW, y: (r + 1) * cellH }; edge = hEdges[r + 1][c];
                } else { // left
                    p0 = { x: c * cellW, y: (r + 1) * cellH }; p1 = { x: c * cellW, y: r * cellH }; edge = vEdges[r][c];
                }
                const segs = sideBezier(p0, p1, side, edge);
                return `M ${p0.x.toFixed(2)} ${p0.y.toFixed(2)} ${segs.join(' ')}`;
            }

            function buildPiecePath(r, c, cellW, cellH) {
                const x0 = c * cellW, y0 = r * cellH;
                const x1 = (c + 1) * cellW, y1 = (r + 1) * cellH;
                const cmds = [];
                const moveTo = (x, y) => cmds.push(`M ${x.toFixed(2)} ${y.toFixed(2)}`);
                const lineTo = (x, y) => cmds.push(`L ${x.toFixed(2)} ${y.toFixed(2)}`);

                moveTo(x0, y0);

                // Top side
                cmds.push(...sideBezier({ x: x0, y: y0 }, { x: x1, y: y0 }, 'top', hEdges[r][c]));
                // Right side
                cmds.push(...sideBezier({ x: x1, y: y0 }, { x: x1, y: y1 }, 'right', vEdges[r][c + 1]));
                // Bottom side
                cmds.push(...sideBezier({ x: x1, y: y1 }, { x: x0, y: y1 }, 'bottom', hEdges[r + 1][c]));
                // Left side
                cmds.push(...sideBezier({ x: x0, y: y1 }, { x: x0, y: y0 }, 'left', vEdges[r][c]));

                cmds.push('Z');
                return cmds.join(' ');
            }

            function sideBezier(p0, p1, side, edge) {
                // Returns array of path commands strings for this side using shared edge nodes
                const cmds = [];
                const pushC = (a, b, c) => cmds.push(`C ${a.x.toFixed(2)} ${a.y.toFixed(2)} ${b.x.toFixed(2)} ${b.y.toFixed(2)} ${c.x.toFixed(2)} ${c.y.toFixed(2)}`);
                const pushL = (p) => cmds.push(`L ${p.x.toFixed(2)} ${p.y.toFixed(2)}`);

                if (edge.border) { pushL(p1); return cmds; }

                // Choose nodes forward or reversed depending on direction
                const nodes = edge.nodes;
                const forward = (Math.abs(nodes[0].x - p0.x) + Math.abs(nodes[0].y - p0.y)) < 0.1;
                const seq = forward ? nodes : nodes.slice().reverse();
                // Convert Catmull-Rom nodes to Bezier segments
                const s = 1.0; // smoothing strength
                for (let i = 0; i < seq.length - 1; i++) {
                    const P0 = i > 0 ? seq[i - 1] : mirror(seq[i], seq[i + 1]);
                    const P1 = seq[i];
                    const P2 = seq[i + 1];
                    const P3 = (i + 2 < seq.length) ? seq[i + 2] : mirror(seq[i + 1], seq[i]);
                    const c1 = { x: P1.x + (P2.x - P0.x) * (s / 6), y: P1.y + (P2.y - P0.y) * (s / 6) };
                    const c2 = { x: P2.x - (P3.x - P1.x) * (s / 6), y: P2.y - (P3.y - P1.y) * (s / 6) };
                    pushC(c1, c2, P2);
                }
                return cmds;
            }

            function mirror(a, b) {
                // mirror of point a across b? We want pseudo previous/next: P(-1) = P0 + (P0-P1)
                return { x: a.x + (a.x - b.x), y: a.y + (a.y - b.y) };
            }

            function computeEdgeNodes(p0, p1, params, type) {
                const dx = p1.x - p0.x, dy = p1.y - p0.y;
                const L = Math.hypot(dx, dy) || 1;
                const tx = dx / L, ty = dy / L; // tangent
                // Consistent normal per edge type: horizontal normal down (+y), vertical normal right (+x)
                const nx = (type === 'h') ? 0 : 1;
                const ny = (type === 'h') ? 1 : 0;
                const sign = params.dir; // +1 bulge along +normal
                const R = params.R;
                const W = Math.min(params.W, L * 0.8);
                const neckS = 0.25 + 0.5 * params.neck; // 0.25..0.75

                // Node parameters along baseline (0..1)
                const span = (W / L);
                const t1 = Math.max(0.15, 0.5 - span * 0.5);
                const t2 = 0.5;
                const t3 = Math.min(0.85, 0.5 + span * 0.5);

                const small = R * 0.25 * neckS;
                const mid = R;

                const nodesT = [0, t1, t2, t3, 1];
                const offs = [0, sign * small, sign * mid, sign * small, 0];

                const nodes = nodesT.map((t, i) => ({
                    x: p0.x + tx * (t * L) + nx * offs[i],
                    y: p0.y + ty * (t * L) + ny * offs[i]
                }));
                return nodes;
            }

            // --- Interaction handling ---
            let listenersBound = false;
            function bindInteractions() {
                if (listenersBound) return;
                svg.addEventListener('pointerdown', onPointerDown);
                svg.addEventListener('pointermove', onPointerMove);
                window.addEventListener('pointerup', onPointerUp);
                window.addEventListener('pointercancel', onPointerCancel);
                svg.addEventListener('wheel', onWheel, { passive: false });
                svg.addEventListener('contextmenu', e => e.preventDefault());
                listenersBound = true;
            }

            function pieceFromEventTarget(t) {
                // Find parent g with data-id
                let el = t;
                while (el && el !== svg) {
                    if (el.classList && el.classList.contains('piece')) {
                        const pid = parseInt(el.getAttribute('data-id'), 10);
                        return pieces[pid];
                    }
                    el = el.parentNode;
                }
                return null;
            }

            function getGroup(gid) { return groups.get(gid); }

            function onPointerDown(e) {
                const pt = { x: e.clientX, y: e.clientY };
                const wpt = screenToWorld(pt);
                pointers.set(e.pointerId, { x: pt.x, y: pt.y, sx: wpt.x, sy: wpt.y, button: e.button, type: e.pointerType || 'mouse', t: (typeof performance!=='undefined'&&performance.now)?performance.now():Date.now() });
                // Capture pointer to the SVG for consistent move/up stream
                if (svg.setPointerCapture) { try { svg.setPointerCapture(e.pointerId); } catch (_) { } }

                const piece = pieceFromEventTarget(e.target);

                // Start pinch only when we have at least two active touch pointers
                const touches = Array.from(pointers.values()).filter(p => p.type === 'touch');
                if (touches.length >= 2) {
                    // Use the two most recent touches for stable pinch pairing
                    touches.sort((a, b) => a.t - b.t);
                    const a = touches[touches.length - 1];
                    const b = touches[touches.length - 2];
                    const c0 = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
                    const w0 = screenToWorld(c0);
                    const d = Math.hypot(a.x - b.x, a.y - b.y);
                    pinching = { startDist: d, startScale: scale, startTx: tx, startTy: ty, startCenter: w0 };
                    dragging = null; panning = null;
                    e.preventDefault();
                    return;
                }

                if (piece && e.button === 0) {
                    // Bring group's g to front by re-append
                    const grp = groups.get(piece.groupId);
                    if (piecesLayer.lastElementChild !== grp.g) {
                        piecesLayer.appendChild(grp.g);
                    }
                    // start drag group
                    const wgrp = { x: grp.x, y: grp.y };
                    const isTouch = e.pointerType === 'touch';
                    dragging = { groupId: grp.id, dx: wpt.x - wgrp.x, dy: wpt.y - wgrp.y, touch: !!isTouch };
                    e.preventDefault();
                    return;
                }

                // Background pan (right button or no piece)
                panning = { dx: pt.x - tx, dy: pt.y - ty };
                e.preventDefault();
            }

            function onPointerMove(e) {
                const p = pointers.get(e.pointerId);
                if (!p) return;
                p.x = e.clientX; p.y = e.clientY; p.t = (typeof performance!=='undefined'&&performance.now)?performance.now():Date.now();

                if (pinching) {
                    const touches = Array.from(pointers.values()).filter(q => q.type === 'touch');
                    if (touches.length < 2) {
                        pinching = null; // not enough touches to continue pinch
                    } else {
                        touches.sort((a, b) => a.t - b.t);
                        const a = touches[touches.length - 1];
                        const b = touches[touches.length - 2];
                        const c = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
                        const d = Math.hypot(a.x - b.x, a.y - b.y);
                        const pivotWorld = screenToWorld(c);
                        const s = clamp(pinching.startScale * (d / pinching.startDist), minScale, maxScale);
                        // Keep pivot fixed: adjust tx,ty so that pivotWorld maps to current screen c
                        const rect = svg.getBoundingClientRect();
                        const ntx = c.x - rect.left - pivotWorld.x * s;
                        const nty = c.y - rect.top - pivotWorld.y * s;
                        setWorldTransform(s, ntx, nty);
                        e.preventDefault();
                        return;
                    }
                }

                if (dragging) {
                    const grp = groups.get(dragging.groupId);
                    const wpt = screenToWorld({ x: e.clientX, y: e.clientY });
                    const oy = dragging.touch ? -(TOUCH_DRAG_OFFSET_PX / scale) : 0;
                    // Queue transform to next animation frame
                    dragNext = { gid: grp.id, x: wpt.x - dragging.dx, y: wpt.y - dragging.dy + oy };
                    if (!dragAnimId) {
                        dragAnimId = requestAnimationFrame(() => {
                            dragAnimId = 0;
                            if (dragNext) {
                                setGroupTransform(dragNext.gid, dragNext.x, dragNext.y);
                                dragNext = null;
                            }
                        });
                    }
                    e.preventDefault();
                    return;
                }

                if (panning) {
                    setWorldTransform(scale, e.clientX - panning.dx, e.clientY - panning.dy);
                    e.preventDefault();
                    return;
                }
            }

            function onPointerUp(e) {
                pointers.delete(e.pointerId);
                // end pinch when fewer than 2 touch pointers remain
                const touchesLeft = Array.from(pointers.values()).filter(p => p.type === 'touch').length;
                if (pinching && touchesLeft < 2) { pinching = null; }
                if (dragging) {
                    const gid = dragging.groupId;
                    dragging = null;
                    // Flush any pending drag update
                    if (dragAnimId) { cancelAnimationFrame(dragAnimId); dragAnimId = 0; }
                    if (dragNext) { setGroupTransform(dragNext.gid, dragNext.x, dragNext.y); dragNext = null; }
                    // Avoid snapping if puzzle is already flattened or group no longer exists
                    if (!flattened && groups && groups.has(gid)) {
                        trySnapGroup(gid);
                    }
                }
                if (panning) { panning = null; }
                if (svg.releasePointerCapture) { try { svg.releasePointerCapture(e.pointerId); } catch (_) { } }
            }

            // Clear interactions on pointercancel (common during UA gestures) to avoid stuck states
            function onPointerCancel(e) {
                pointers.delete(e.pointerId);
                pinching = null; dragging = null; panning = null;
                if (dragAnimId) { cancelAnimationFrame(dragAnimId); dragAnimId = 0; }
                dragNext = null;
                if (svg.releasePointerCapture) { try { svg.releasePointerCapture(e.pointerId); } catch (_) { } }
            }

            function onWheel(e) {
                e.preventDefault();
                const delta = e.deltaY;
                const factor = Math.pow(1.0015, -delta);
                const rect = svg.getBoundingClientRect();
                const mouse = { x: e.clientX, y: e.clientY };
                const pivot = screenToWorld(mouse);
                const ns = clamp(scale * factor, minScale, maxScale);
                const ntx = mouse.x - rect.left - pivot.x * ns;
                const nty = mouse.y - rect.top - pivot.y * ns;
                setWorldTransform(ns, ntx, nty);
            }

            // --- Snapping ---
            function trySnapGroup(gid) {
                // Do nothing if the puzzle has been flattened (completed)
                if (flattened) return;
                let grp = groups.get(gid); if (!grp) return;
                // For any piece in this group, check neighbors outside group for proximity
                const tol = snapTol / scale; // adjust for zoom
                let snapped = false;
                // Snapshot member ids to avoid mutation issues during merges
                const memberIds = Array.from(grp.members);
                for (const pid of memberIds) {
                    if (flattened || !groups || groups.size === 0 || !pieces || pieces.length === 0) return;
                    const p = pieces[pid];
                    if (!p) continue;
                    const nbrs = neighbors(p.r, p.c);
                    for (const nb of nbrs) {
                        const qid = nb.r * cols + nb.c;
                        if (flattened || !groups || groups.size === 0 || !pieces || pieces.length === 0) return;
                        const q = pieces[qid];
                        if (!q) continue;
                        if (!groups.has(grp.id) || !groups.has(q.groupId)) continue;
                        if (q.groupId === grp.id) continue; // same group
                        // Compute expected delta between anchors in solved state
                        const expected = { x: (q.c - p.c) * (imgW / cols), y: (q.r - p.r) * (imgH / rows) };
                        // Current world positions of anchors
                        const pGrp = groups.get(p.groupId);
                        const qGrp = groups.get(q.groupId);
                        if (!pGrp || !qGrp) continue;
                        const pw = { x: p.anchor.x + pGrp.x, y: p.anchor.y + pGrp.y };
                        const qw = { x: q.anchor.x + qGrp.x, y: q.anchor.y + qGrp.y };
                        const dx = (qw.x - pw.x) - expected.x;
                        const dy = (qw.y - pw.y) - expected.y;
                        if (Math.hypot(dx, dy) <= tol) {
                            // Snap by moving dragged group by (dx,dy)
                            setGroupTransform(grp.id, grp.x + dx, grp.y + dy);
                            // Merge with q's group
                            const newId = mergeGroups(grp.id, q.groupId);
                            snapped = true;
                            // Update reference to possibly new group id
                            if (flattened || !groups || groups.size === 0) return;
                            grp = groups.get(newId);
                            if (!grp) return;
                            // After merge, continue to check for cascading joins
                        }
                    }
                }
                if (snapped) {
                    // Try a quick flood to snap any other immediate neighbors
                    if (!flattened && groups && groups.has(grp.id)) {
                        trySnapGroup(grp.id);
                    }
                }
            }

            function neighbors(r, c) {
                const arr = [];
                if (r > 0) arr.push({ r: r - 1, c });
                if (r < rows - 1) arr.push({ r: r + 1, c });
                if (c > 0) arr.push({ r, c: c - 1 });
                if (c < cols - 1) arr.push({ r, c: c + 1 });
                return arr;
            }

            function updateAllEdgeShading() {
                groups.forEach(gr => updateEdgeShadingForGroup(gr.id));
            }

            function updateEdgeShadingForGroup(gid) {
                const gr = groups.get(gid); if (!gr) return;
                const sideOpp = { top: 'bottom', bottom: 'top', left: 'right', right: 'left' };
                gr.members.forEach(pid => {
                    const p = pieces[pid];
                    const rc = { r: p.r, c: p.c };
                    const checks = [
                        { side: 'top', nr: rc.r - 1, nc: rc.c },
                        { side: 'right', nr: rc.r, nc: rc.c + 1 },
                        { side: 'bottom', nr: rc.r + 1, nc: rc.c },
                        { side: 'left', nr: rc.r, nc: rc.c - 1 },
                    ];
                    for (const ch of checks) {
                        const inBounds = ch.nr >= 0 && ch.nr < rows && ch.nc >= 0 && ch.nc < cols;
                        if (!p.shades || !p.shades[ch.side]) continue;
                        if (!inBounds) {
                            p.shades[ch.side].style.display = '';
                            continue;
                        }
                        const nid = ch.nr * cols + ch.nc;
                        const q = pieces[nid];
                        if (q && q.groupId === p.groupId && q.groupId === gid) {
                            p.shades[ch.side].style.display = 'none';
                            if (q.shades && q.shades[sideOpp[ch.side]]) q.shades[sideOpp[ch.side]].style.display = 'none';
                        } else {
                            p.shades[ch.side].style.display = '';
                        }
                    }
                });
            }

            // --- Kickoff ---
            // Provide a default image if none chosen by user using a small data URI gradient
            (function bootstrapDefault() {
                const placeholder = createGradientImage(1024, 768);
                imgHref = placeholder.href;
                imgW = placeholder.w; imgH = placeholder.h;
                initPuzzle();
            })();

            function createGradientImage(w, h) {
                const c = document.createElement('canvas'); c.width = w; c.height = h;
                const ctx = c.getContext('2d');
                const g = ctx.createLinearGradient(0, 0, w, h);
                g.addColorStop(0, '#2b5876'); g.addColorStop(1, '#4e4376');
                ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
                ctx.globalAlpha = 0.18; ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 80; i++) {
                    const x = Math.random() * w, y = Math.random() * h, r = 6 + Math.random() * 28;
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
                }
                return { href: c.toDataURL('image/png'), w, h };
            }
        })();
    </script>
</body>

</html>