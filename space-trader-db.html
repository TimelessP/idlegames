<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="application-name" content="IdleGames">
  <script src="assets/js/pwa.js" defer></script>
  <meta name="theme-color" content="#102545">
  <title>Space Trader Starmap</title>
  <link rel="icon" href="favicon.ico">
  <style>
    :root {
      color-scheme: light;
      --bg: #f3f5fb;
      --panel: rgba(255, 255, 255, 0.88);
      --panel-border: rgba(12, 36, 68, 0.16);
      --text: #0f1d33;
      --muted: rgba(15, 29, 51, 0.6);
      --button-bg: rgba(255, 255, 255, 0.92);
      --button-border: rgba(12, 36, 68, 0.16);
      --button-text: #0f1d33;
      --button-hover: rgba(16, 45, 84, 0.06);
      --accent: #1d4b82;
      --accent-soft: rgba(29, 75, 130, 0.12);
      --grid: rgba(15, 29, 51, 0.12);
      --grid-strong: rgba(15, 29, 51, 0.24);
      --origin-line: rgba(29, 75, 130, 0.38);
      --orbit: rgba(29, 75, 130, 0.18);
      --orbit-highlight: rgba(255, 182, 80, 0.55);
      --star-core: #fffaf0;
      --star-glow: rgba(255, 204, 132, 0.55);
      --overlay: rgba(9, 16, 28, 0.72);
      --modal-bg: rgba(255, 255, 255, 0.98);
      --input-bg: rgba(245, 246, 250, 0.95);
      --input-border: rgba(12, 36, 68, 0.16);
      --scroll-thumb: rgba(29, 75, 130, 0.25);
    }

    html[data-theme="dark"] {
      color-scheme: dark;
      --bg: #05070f;
      --panel: rgba(12, 16, 26, 0.9);
      --panel-border: rgba(127, 198, 255, 0.28);
      --text: #d8ebff;
      --muted: rgba(216, 235, 255, 0.66);
      --button-bg: rgba(18, 28, 46, 0.88);
      --button-border: rgba(127, 198, 255, 0.25);
      --button-text: #d8ebff;
      --button-hover: rgba(127, 198, 255, 0.15);
      --accent: #7fc6ff;
      --accent-soft: rgba(127, 198, 255, 0.12);
      --grid: rgba(127, 198, 255, 0.14);
      --grid-strong: rgba(127, 198, 255, 0.28);
      --origin-line: rgba(127, 198, 255, 0.55);
      --orbit: rgba(127, 198, 255, 0.18);
      --orbit-highlight: rgba(255, 210, 120, 0.65);
      --star-core: #fff7e8;
      --star-glow: rgba(130, 236, 255, 0.55);
      --overlay: rgba(2, 4, 8, 0.72);
      --modal-bg: rgba(10, 16, 26, 0.96);
      --input-bg: rgba(12, 18, 28, 0.92);
      --input-border: rgba(127, 198, 255, 0.24);
      --scroll-thumb: rgba(127, 198, 255, 0.32);
    }

    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; min-height: 100%; }

    body {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    header {
      position: sticky;
      top: 0;
      z-index: 20;
      background: var(--panel);
      border-bottom: 1px solid var(--panel-border);
      backdrop-filter: blur(12px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 18px clamp(16px, 4vw, 32px);
    }

    .branding {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .branding h1 {
      font-size: clamp(1.05rem, 2.4vw, 1.35rem);
      margin: 0;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .branding span {
      font-size: clamp(0.7rem, 1.6vw, 0.85rem);
      color: var(--muted);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      color: var(--button-text);
      border-radius: 12px;
      height: 40px;
      padding: 0 16px;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover { background: var(--button-hover); }

    button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    main {
      position: relative;
      flex: 1;
      display: flex;
      min-height: 0;
    }

    .map-shell {
      position: relative;
      flex: 1;
      min-height: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      cursor: grab;
    }

    canvas:active { cursor: grabbing; }

    .info-panel {
      position: absolute;
      right: clamp(12px, 3vw, 32px);
      top: clamp(12px, 4vw, 42px);
      width: min(340px, 80vw);
      max-height: calc(100% - 96px);
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      padding: 20px 20px 24px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 16px;
      backdrop-filter: blur(12px);
    }

    .info-panel h2 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .info-meta {
      display: grid;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .planet-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
      overflow-y: auto;
      max-height: 260px;
      padding-right: 4px;
    }

    .planet-list::-webkit-scrollbar { width: 8px; }
    .planet-list::-webkit-scrollbar-thumb {
      background: var(--scroll-thumb);
      border-radius: 999px;
    }

    .planet {
      padding: 10px 12px;
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      background: var(--accent-soft);
      display: grid;
      gap: 4px;
    }

    .planet.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(29, 75, 130, 0.12);
    }

    .planet-name {
      font-weight: 600;
      letter-spacing: 0.04em;
    }

    .planet-details {
      font-size: 0.8rem;
      color: var(--muted);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .status {
      position: absolute;
      left: clamp(12px, 3vw, 32px);
      bottom: clamp(12px, 4vw, 32px);
      background: var(--panel);
      border: 1px solid var(--panel-border);
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 0.85rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      display: flex;
      flex-direction: column;
      gap: 6px;
      backdrop-filter: blur(10px);
    }

    .search-modal {
      position: fixed;
      inset: 0;
      background: var(--overlay);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
      padding: 24px;
    }

    .search-modal.open { display: flex; }

    .search-dialog {
      width: min(540px, 100%);
      background: var(--modal-bg);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: clamp(18px, 4vw, 28px);
      display: flex;
      flex-direction: column;
      gap: 16px;
      max-height: calc(100vh - 64px);
    }

    .search-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .search-header h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .search-close {
      height: 36px;
      width: 36px;
      padding: 0;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-size: 1.2rem;
      line-height: 1;
    }

    .search-input {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--text);
      font-size: 1rem;
      padding: 12px 14px;
    }

    .search-input:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .search-hint {
      margin: 0;
      font-size: 0.8rem;
      color: var(--muted);
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .search-results {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
      overflow-y: auto;
      max-height: 320px;
    }

    .search-results::-webkit-scrollbar { width: 8px; }
    .search-results::-webkit-scrollbar-thumb {
      background: var(--scroll-thumb);
      border-radius: 999px;
    }

    .result-item {
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 12px 14px;
      background: var(--accent-soft);
      display: grid;
      gap: 6px;
      cursor: pointer;
    }

    .result-item strong {
      letter-spacing: 0.05em;
    }

    .result-meta {
      font-size: 0.78rem;
      color: var(--muted);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    @media (max-width: 900px) {
      .info-panel {
        position: static;
        width: auto;
        max-height: none;
        margin: clamp(12px, 4vw, 24px);
      }
      main { flex-direction: column-reverse; }
      .status {
        position: static;
        margin: 0 clamp(12px, 4vw, 24px) clamp(12px, 4vw, 24px);
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="branding">
      <h1>Space Trader Starmap</h1>
      <span>Procedural Sector Atlas</span>
    </div>
    <div class="actions">
      <button type="button" id="home-button">Home</button>
      <button type="button" id="search-button">Search</button>
      <button type="button" id="theme-button">Theme: System</button>
    </div>
  </header>
  <main>
    <div class="map-shell">
      <canvas id="starmap" aria-label="Procedural star map"></canvas>
      <aside class="info-panel" id="info-panel"></aside>
      <div class="status" id="status">
        <span id="status-position">Center: (0, 0)</span>
        <span id="status-zoom">Zoom ×1.0</span>
      </div>
    </div>
  </main>

  <div class="search-modal" id="search-modal" aria-hidden="true">
    <div class="search-dialog" role="dialog" aria-modal="true" aria-labelledby="search-title">
      <div class="search-header">
        <h2 id="search-title">Search Visible Space</h2>
        <button type="button" class="search-close" id="search-close" aria-label="Close search">×</button>
      </div>
      <input type="text" id="search-input" class="search-input" placeholder="Search system or planet name" autocomplete="off">
      <p class="search-hint" id="search-hint">Search runs only across the map currently in view.</p>
      <ul class="search-results" id="search-results"></ul>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('starmap');
    const ctx = canvas.getContext('2d');
    const infoPanel = document.getElementById('info-panel');
    const statusPosition = document.getElementById('status-position');
    const statusZoom = document.getElementById('status-zoom');
    const searchModal = document.getElementById('search-modal');
    const searchInput = document.getElementById('search-input');
    const searchResultsEl = document.getElementById('search-results');
    const searchHint = document.getElementById('search-hint');
    const homeButton = document.getElementById('home-button');
    const searchButton = document.getElementById('search-button');
    const searchClose = document.getElementById('search-close');
    const themeButton = document.getElementById('theme-button');

    const BASE_SCALE = 72;
    const MIN_ZOOM = 0.55;
    const MAX_ZOOM = 18;
  const PLANET_REVEAL_ZOOM = 6; // delay orbit/planet rendering until we are zoomed far enough in to avoid system overlap
    const SEARCH_RESULT_LIMIT = 48;
    const EVEN_GRID_STEP = 2;

    const state = {
      centerX: 0,
      centerY: 0,
      zoom: 1.4,
      selectedSystem: null,
      selectedPlanet: null,
      themeMode: 'system'
    };

    const planetProfileCache = new Map();
    const starInfoCache = new Map();
    const systemDetailsCache = new Map();
    const planetBitmapCache = new Map();
    let visibleSystems = [];
    let searchQuery = '';

    const dpr = window.devicePixelRatio || 1;

    function scheduleRender() {
      if (scheduleRender.pending) return;
      scheduleRender.pending = true;
      requestAnimationFrame(() => {
        scheduleRender.pending = false;
        render();
      });
    }
    scheduleRender.pending = false;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const width = Math.max(1, Math.round(rect.width * dpr));
      const height = Math.max(1, Math.round(rect.height * dpr));
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
        scheduleRender();
      }
    }

    function pointerToCanvas(event) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (event.clientX - rect.left) * dpr,
        y: (event.clientY - rect.top) * dpr
      };
    }

    function worldToScreen(wx, wy) {
      const scale = state.zoom * BASE_SCALE;
      return {
        x: canvas.width / 2 + (wx - state.centerX) * scale,
        y: canvas.height / 2 + (wy - state.centerY) * scale
      };
    }

    function screenToWorld(sx, sy) {
      const scale = state.zoom * BASE_SCALE;
      return {
        x: state.centerX + (sx - canvas.width / 2) / scale,
        y: state.centerY + (sy - canvas.height / 2) / scale
      };
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function applyZoom(newZoom, anchor) {
      const zoom = clamp(newZoom, MIN_ZOOM, MAX_ZOOM);
      const before = screenToWorld(anchor.x, anchor.y);
      state.zoom = zoom;
      const after = screenToWorld(anchor.x, anchor.y);
      state.centerX += before.x - after.x;
      state.centerY += before.y - after.y;
      scheduleRender();
    }

    function openSearchModal() {
      searchModal.classList.add('open');
      searchModal.setAttribute('aria-hidden', 'false');
      searchInput.value = searchQuery;
      searchInput.focus({ preventScroll: true });
      updateSearchResults();
    }

    function closeSearchModal() {
      searchModal.classList.remove('open');
      searchModal.setAttribute('aria-hidden', 'true');
      searchInput.blur();
      searchQuery = searchInput.value.trim();
    }

    function cycleThemeMode() {
      const order = ['system', 'light', 'dark'];
      const idx = order.indexOf(state.themeMode);
      state.themeMode = order[(idx + 1) % order.length];
      applyThemeMode();
    }

    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');

    function applyThemeMode() {
      const effective = state.themeMode === 'system'
        ? (prefersDark.matches ? 'dark' : 'light')
        : state.themeMode;
      document.documentElement.setAttribute('data-theme', effective);
      themeButton.textContent = `Theme: ${state.themeMode.charAt(0).toUpperCase()}${state.themeMode.slice(1)}`;
      localStorage.setItem('space-trader-db-theme', state.themeMode);
      scheduleRender();
    }

    function loadThemePreference() {
      const stored = localStorage.getItem('space-trader-db-theme');
      if (stored === 'light' || stored === 'dark' || stored === 'system') {
        state.themeMode = stored;
      }
      applyThemeMode();
    }

    prefersDark.addEventListener('change', () => {
      if (state.themeMode === 'system') {
        applyThemeMode();
      }
    });

    function readColor(varName, fallback) {
      const value = getComputedStyle(document.documentElement).getPropertyValue(varName);
      return value ? value.trim() : fallback;
    }

    function getThemePalette() {
      return {
        background: readColor('--bg', '#0c101a'),
        grid: readColor('--grid', 'rgba(255,255,255,0.08)'),
        gridStrong: readColor('--grid-strong', 'rgba(255,255,255,0.15)'),
        origin: readColor('--origin-line', 'rgba(127,198,255,0.4)'),
        orbit: readColor('--orbit', 'rgba(120,160,255,0.2)'),
        orbitHighlight: readColor('--orbit-highlight', 'rgba(255, 210, 120, 0.6)'),
        starCore: readColor('--star-core', '#fff8ef'),
        starGlow: readColor('--star-glow', 'rgba(255, 204, 132, 0.5)'),
        accent: readColor('--accent', '#7fc6ff')
      };
    }

    function getStarInfo(x, y) {
      const key = `${x},${y}`;
      if (starInfoCache.has(key)) return starInfoCache.get(key);
      const rng = seededRandom(hash32('STAR', x | 0, y | 0));
      const classes = [
        { label: 'O', color: '#9bbcff', mass: 1.35 },
        { label: 'B', color: '#a9c7ff', mass: 1.25 },
        { label: 'A', color: '#c8d6ff', mass: 1.15 },
        { label: 'F', color: '#f7f2d8', mass: 1.05 },
        { label: 'G', color: '#ffe5a1', mass: 1.0 },
        { label: 'K', color: '#ffcc8a', mass: 0.9 },
        { label: 'M', color: '#ffb47a', mass: 0.8 }
      ];
      const typeIndex = Math.floor(rng() * classes.length);
      const jitter = 0.85 + rng() * 0.3;
      const info = {
        label: classes[typeIndex].label,
        color: classes[typeIndex].color,
        radiusFactor: classes[typeIndex].mass * jitter,
        temperatureBias: rng(),
        brightness: 0.7 + rng() * 0.6
      };
      starInfoCache.set(key, info);
      return info;
    }

    function getSystemDetails(x, y) {
      const key = `${x},${y}`;
      if (systemDetailsCache.has(key)) return systemDetailsCache.get(key);
      const name = generateSolarSystemName(x, y);
      const planetCount = getPlanetCount(x, y);
      const planetNames = generatePlanetNames(x, y, planetCount);
      const details = {
        name,
        planetCount,
        planetNames,
        star: getStarInfo(x, y)
      };
      systemDetailsCache.set(key, details);
      return details;
    }

    function getCachedPlanetProfile(x, y, planetIndex, typeOverride) {
      const key = `${x},${y},${planetIndex},${typeOverride || ''}`;
      if (planetProfileCache.has(key)) return planetProfileCache.get(key);
      const profile = getPlanetProfile(x, y, planetIndex, typeOverride);
      planetProfileCache.set(key, profile);
      return profile;
    }

  function getPlanetSpriteImage(x, y, planetIndex, size = PLANET_TEXTURE_SIZE, typeOverride, baseColorOverride, lightOverride) {
      const lightKey = lightOverride
        ? `|L:${lightOverride.map((v) => v.toFixed(4)).join(',')}`
        : '|L:seed';
      const key = `${x}|${y}|${planetIndex}|${size}|${typeOverride || ''}|${baseColorOverride || ''}${lightKey}`;
      let entry = planetBitmapCache.get(key);
      if (entry) return entry;
      const url = getPlanetSprite(x, y, planetIndex, size, typeOverride, baseColorOverride, lightOverride);
      const img = new Image();
      entry = { img, ready: false };
      img.onload = () => {
        entry.ready = true;
        scheduleRender();
      };
      img.onerror = () => {
        planetBitmapCache.delete(key);
      };
      img.src = url;
      planetBitmapCache.set(key, entry);
      return entry;
    }

    function focusSystem(x, y, { planetIndex = null, ensureZoom = null } = {}) {
      state.centerX = x;
      state.centerY = y;
      if (ensureZoom != null) {
        state.zoom = clamp(ensureZoom, MIN_ZOOM, MAX_ZOOM);
      }
      state.selectedSystem = { x, y };
      state.selectedPlanet = planetIndex;
      updateInfoPanel();
      scheduleRender();
    }

    function updateInfoPanel() {
      if (!state.selectedSystem) {
        infoPanel.innerHTML = `
          <h2>Select a Star System</h2>
          <div class="info-meta">
            <span>Tap or click any star to inspect its worlds.</span>
            <span>Zoom in to reveal orbital details.</span>
          </div>`;
        return;
      }
      const { x, y } = state.selectedSystem;
      const details = getSystemDetails(x, y);
      const star = details.star;
      const planetItems = [];
      for (let i = 0; i < details.planetCount; i++) {
        const name = details.planetNames[i];
        const info = getPlanetColor(x, y, i);
        const profile = getCachedPlanetProfile(x, y, i, info.profileKey || info.type);
        const active = state.selectedPlanet === i;
        const detailParts = [`Orbit ${i + 1}`, info.type];
        if (profile.key && profile.key !== info.type) detailParts.push(profile.key);
        if (profile.hasOceans) detailParts.push('Oceans');
        if (profile.atmosphere) detailParts.push('Atmosphere');
        if (profile.hasCraters && !profile.hasOceans) detailParts.push('Craters');
        planetItems.push(`
          <li class="planet${active ? ' active' : ''}">
            <div class="planet-name">${name}</div>
            <div class="planet-details">${detailParts.map((part) => `<span>${part}</span>`).join('')}</div>
          </li>`);
      }
      infoPanel.innerHTML = `
        <h2>${details.name}</h2>
        <div class="info-meta">
          <span>Coordinates: (${x}, ${y})</span>
          <span>Star Class ${star.label}</span>
          <span>Planets: ${details.planetCount}</span>
        </div>
        <ul class="planet-list">${planetItems.join('')}</ul>`;
    }

    function updateStatusOverlay() {
      statusPosition.textContent = `Center: (${state.centerX.toFixed(1)}, ${state.centerY.toFixed(1)})`;
      statusZoom.textContent = `Zoom ×${state.zoom.toFixed(2)}`;
    }

    function updateSearchResults() {
      if (!searchModal.classList.contains('open')) return;
      const query = searchInput.value.trim().toLowerCase();
      searchQuery = query;
      if (!visibleSystems.length) {
        searchHint.textContent = 'Render in progress…';
        searchResultsEl.innerHTML = '';
        return;
      }
      const matches = [];
      for (const system of visibleSystems) {
        const { x, y, details } = system;
        if (!details) continue;
        if (!query) continue;
        if (details.name.toLowerCase().includes(query)) {
          matches.push({
            type: 'system',
            label: details.name,
            coords: { x, y }
          });
        }
        for (let i = 0; i < details.planetCount; i++) {
          const name = details.planetNames[i];
          if (name.toLowerCase().includes(query)) {
            matches.push({
              type: 'planet',
              label: `${name} — ${details.name}`,
              coords: { x, y },
              planetIndex: i
            });
          }
        }
        if (matches.length >= SEARCH_RESULT_LIMIT) break;
      }

      if (!query) {
        searchHint.textContent = 'Enter a name fragment (visible map only).';
        searchResultsEl.innerHTML = '';
        return;
      }

      if (!matches.length) {
        searchHint.textContent = 'No matches in the current view. Pan or zoom, then try again.';
        searchResultsEl.innerHTML = '';
        return;
      }

      if (matches.length >= SEARCH_RESULT_LIMIT) {
        searchHint.textContent = 'Results trimmed — refine search or zoom in.';
      } else {
        searchHint.textContent = 'Search runs only across the map currently in view.';
      }

      searchResultsEl.innerHTML = matches.map((match) => {
        const meta = match.type === 'system'
          ? `System • (${match.coords.x}, ${match.coords.y})`
          : `Planet • Orbit ${match.planetIndex + 1} • (${match.coords.x}, ${match.coords.y})`;
        return `<li class="result-item" data-x="${match.coords.x}" data-y="${match.coords.y}" data-type="${match.type}" data-planet="${match.planetIndex ?? ''}">
          <strong>${match.label}</strong>
          <span class="result-meta">${meta}</span>
        </li>`;
      }).join('');
    }

    searchResultsEl.addEventListener('click', (event) => {
      const target = event.target.closest('.result-item');
      if (!target) return;
      const x = Number(target.dataset.x);
      const y = Number(target.dataset.y);
      const type = target.dataset.type;
      const planetIndex = target.dataset.planet ? Number(target.dataset.planet) : null;
      const ensureZoom = type === 'planet' ? Math.max(state.zoom, PLANET_REVEAL_ZOOM + 0.6) : state.zoom;
      focusSystem(x, y, { planetIndex: type === 'planet' ? planetIndex : null, ensureZoom });
      closeSearchModal();
    });

    searchInput.addEventListener('input', updateSearchResults);

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && searchModal.classList.contains('open')) {
        closeSearchModal();
      }
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
        const delta = event.key === 'ArrowUp' ? { x: 0, y: -1 }
          : event.key === 'ArrowDown' ? { x: 0, y: 1 }
          : event.key === 'ArrowLeft' ? { x: -1, y: 0 }
          : { x: 1, y: 0 };
        const factor = 0.9 / state.zoom;
        state.centerX += delta.x * factor * 4;
        state.centerY += delta.y * factor * 4;
        scheduleRender();
      }
      if (event.key === '+' || event.key === '=') {
        applyZoom(state.zoom * 1.1, { x: canvas.width / 2, y: canvas.height / 2 });
      }
      if (event.key === '-' || event.key === '_') {
        applyZoom(state.zoom / 1.1, { x: canvas.width / 2, y: canvas.height / 2 });
      }
    });

    homeButton.addEventListener('click', () => {
      state.centerX = 0;
      state.centerY = 0;
      state.zoom = 1.4;
      state.selectedSystem = null;
      state.selectedPlanet = null;
      updateInfoPanel();
      scheduleRender();
    });

    searchButton.addEventListener('click', openSearchModal);
    searchClose.addEventListener('click', closeSearchModal);
    themeButton.addEventListener('click', () => {
      cycleThemeMode();
    });

    searchModal.addEventListener('click', (event) => {
      if (event.target === searchModal) {
        closeSearchModal();
      }
    });

    let primaryPointerId = null;
    const pointers = new Map();
    let panOrigin = null;
    let panCenterStart = null;
    let pinchDistanceStart = null;
    let pinchZoomStart = null;
    let pointerMoved = false;

    canvas.addEventListener('pointerdown', (event) => {
      canvas.setPointerCapture(event.pointerId);
      const point = pointerToCanvas(event);
      pointers.set(event.pointerId, point);
      if (pointers.size === 1) {
        primaryPointerId = event.pointerId;
        panOrigin = point;
        panCenterStart = { x: state.centerX, y: state.centerY };
        pointerMoved = false;
      } else if (pointers.size === 2) {
        const pts = Array.from(pointers.values());
        pinchDistanceStart = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        pinchZoomStart = state.zoom;
      }
    });

    canvas.addEventListener('pointermove', (event) => {
      if (!pointers.has(event.pointerId)) return;
      const point = pointerToCanvas(event);
      pointers.set(event.pointerId, point);
      if (pointers.size === 1 && primaryPointerId === event.pointerId) {
        const dx = point.x - panOrigin.x;
        const dy = point.y - panOrigin.y;
        if (!pointerMoved && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) pointerMoved = true;
        const scale = state.zoom * BASE_SCALE;
        state.centerX = panCenterStart.x - dx / scale;
        state.centerY = panCenterStart.y - dy / scale;
        scheduleRender();
      } else if (pointers.size === 2 && pinchDistanceStart) {
        const pts = Array.from(pointers.values());
        const distance = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
        if (distance <= 0) return;
        const midpoint = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 };
        const factor = distance / pinchDistanceStart;
        applyZoom(pinchZoomStart * factor, midpoint);
      }
    });

    function handleTap(point) {
      let selectedPlanet = null;
      let selectedSystem = null;
      let minPlanetDistance = Infinity;
      const starPickRadius = 24 * dpr;
      const planetPickRadius = 26 * dpr;

      for (const system of visibleSystems) {
        const dx = point.x - system.screenX;
        const dy = point.y - system.screenY;
        const dist = Math.hypot(dx, dy);
        if (system.planets) {
          for (const planet of system.planets) {
            const pdx = point.x - planet.screenX;
            const pdy = point.y - planet.screenY;
            const planetDist = Math.hypot(pdx, pdy);
            if (planetDist < Math.max(planet.radius, planetPickRadius) && planetDist < minPlanetDistance) {
              selectedPlanet = { system, index: planet.index };
              minPlanetDistance = planetDist;
            }
          }
        }
        if (!selectedPlanet && dist < Math.max(system.starRadius + 6, starPickRadius)) {
          selectedSystem = system;
        }
      }

      if (selectedPlanet) {
        state.selectedSystem = { x: selectedPlanet.system.x, y: selectedPlanet.system.y };
        state.selectedPlanet = selectedPlanet.index;
        updateInfoPanel();
        scheduleRender();
        return;
      }
      if (selectedSystem) {
        state.selectedSystem = { x: selectedSystem.x, y: selectedSystem.y };
        state.selectedPlanet = null;
        updateInfoPanel();
        scheduleRender();
        return;
      }
    }

    canvas.addEventListener('pointerup', (event) => {
      if (pointers.has(event.pointerId)) {
        pointers.delete(event.pointerId);
      }
      if (event.pointerId === primaryPointerId) {
        primaryPointerId = null;
        if (!pointerMoved) {
          const point = pointerToCanvas(event);
          handleTap(point);
        }
      }
      if (pointers.size < 2) {
        pinchDistanceStart = null;
        pinchZoomStart = null;
      }
    });

    canvas.addEventListener('pointercancel', (event) => {
      pointers.delete(event.pointerId);
      if (event.pointerId === primaryPointerId) {
        primaryPointerId = null;
      }
    });

    canvas.addEventListener('wheel', (event) => {
      event.preventDefault();
      const point = pointerToCanvas(event);
      const delta = Math.sign(event.deltaY);
      const factor = delta > 0 ? 1 / 1.12 : 1.12;
      applyZoom(state.zoom * factor, point);
    }, { passive: false });

    function drawGrid(palette, scale) {
      ctx.save();
      ctx.lineWidth = Math.max(1, dpr * 0.6);
      ctx.strokeStyle = palette.grid;
      ctx.beginPath();
      const worldWidth = canvas.width / scale;
      const worldHeight = canvas.height / scale;
      let startX = Math.floor(state.centerX - worldWidth / 2) - 2;
      let endX = Math.ceil(state.centerX + worldWidth / 2) + 2;
      let startY = Math.floor(state.centerY - worldHeight / 2) - 2;
      let endY = Math.ceil(state.centerY + worldHeight / 2) + 2;
      startX -= ((startX % EVEN_GRID_STEP) + EVEN_GRID_STEP) % EVEN_GRID_STEP;
      startY -= ((startY % EVEN_GRID_STEP) + EVEN_GRID_STEP) % EVEN_GRID_STEP;
      for (let x = startX; x <= endX; x += EVEN_GRID_STEP) {
        const sx = worldToScreen(x, 0).x;
        ctx.moveTo(sx, 0);
        ctx.lineTo(sx, canvas.height);
      }
      for (let y = startY; y <= endY; y += EVEN_GRID_STEP) {
        const sy = worldToScreen(0, y).y;
        ctx.moveTo(0, sy);
        ctx.lineTo(canvas.width, sy);
      }
      ctx.stroke();
      ctx.strokeStyle = palette.gridStrong;
      ctx.beginPath();
      for (let x = startX; x <= endX; x += EVEN_GRID_STEP * 4) {
        const sx = worldToScreen(x, 0).x;
        ctx.moveTo(sx, 0);
        ctx.lineTo(sx, canvas.height);
      }
      for (let y = startY; y <= endY; y += EVEN_GRID_STEP * 4) {
        const sy = worldToScreen(0, y).y;
        ctx.moveTo(0, sy);
        ctx.lineTo(canvas.width, sy);
      }
      ctx.stroke();
      ctx.strokeStyle = palette.origin;
      ctx.lineWidth = Math.max(1, dpr * 0.9);
      const originScreen = worldToScreen(0, 0);
      ctx.beginPath();
      ctx.moveTo(originScreen.x, 0);
      ctx.lineTo(originScreen.x, canvas.height);
      ctx.moveTo(0, originScreen.y);
      ctx.lineTo(canvas.width, originScreen.y);
      ctx.stroke();
      ctx.restore();
    }

    function drawStar(system, palette, scale) {
      const { screenX, screenY, star } = system;
      const baseRadius = clamp(6 * state.zoom * star.radiusFactor, 6, 32 * dpr);
      system.starRadius = baseRadius;
      const gradient = ctx.createRadialGradient(screenX, screenY, baseRadius * 0.2, screenX, screenY, baseRadius * 1.6);
      gradient.addColorStop(0, palette.starCore);
      gradient.addColorStop(0.4, star.color);
      gradient.addColorStop(1, palette.starGlow);
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = gradient;
      ctx.globalAlpha = star.brightness;
      ctx.arc(screenX, screenY, baseRadius * 1.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.fillStyle = star.color;
      ctx.beginPath();
      ctx.arc(screenX, screenY, baseRadius * 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawPlanets(system, palette) {
      const { x, y, screenX, screenY, details } = system;
      const planetCount = details.planetCount;
      const orbitScale = 1 / 3;
      const orbitSpacing = clamp(state.zoom * 22 * orbitScale, 14 * orbitScale, 42 * state.zoom * orbitScale);
      const baseOrbit = clamp(state.zoom * 38 * orbitScale, 28 * orbitScale, 72 * state.zoom * orbitScale);
      const rng = seededRandom(hash32('ORB', x | 0, y | 0));
      const positions = [];
      ctx.save();
      ctx.strokeStyle = palette.orbit;
      ctx.lineWidth = Math.max(1, dpr * 0.8);
      for (let i = 0; i < planetCount; i++) {
        const orbitRadius = baseOrbit + i * orbitSpacing;
        ctx.beginPath();
        ctx.arc(screenX, screenY, orbitRadius, 0, Math.PI * 2);
        ctx.stroke();
        const angle = rng() * Math.PI * 2;
        const px = screenX + Math.cos(angle) * orbitRadius;
        const py = screenY + Math.sin(angle) * orbitRadius;
        const info = getPlanetColor(x, y, i);
  const profile = getCachedPlanetProfile(x, y, i, info.profileKey || info.type);
        const planetScale = 16 + rng() * 12;
        const size = clamp(planetScale * state.zoom, 18, 84);
        let lightOverride = null;
        const dxToStar = screenX - px;
        const dyToStar = screenY - py;
        if (Math.abs(dxToStar) > 1e-6 || Math.abs(dyToStar) > 1e-6) {
          // Aim the light straight back toward the system's star in screen space (positive Y is downward).
          const planar = normalize([dxToStar, dyToStar, 0]);
          lightOverride = normalize([planar[0], planar[1], 0.6]);
        }
  const profileKey = info.profileKey || info.type;
  const entry = getPlanetSpriteImage(x, y, i, PLANET_TEXTURE_SIZE, profileKey, info.color, lightOverride);
        if (entry.ready) {
          ctx.drawImage(entry.img, px - size / 2, py - size / 2, size, size);
        } else {
          ctx.fillStyle = info.color || profile.baseColor || palette.accent;
          ctx.beginPath();
          ctx.arc(px, py, size / 2, 0, Math.PI * 2);
          ctx.fill();
        }
        if (state.selectedSystem && state.selectedSystem.x === x && state.selectedSystem.y === y && state.selectedPlanet === i) {
          ctx.strokeStyle = palette.orbitHighlight;
          ctx.lineWidth = Math.max(2, dpr * 1.5);
          ctx.beginPath();
          ctx.arc(px, py, size * 0.6, 0, Math.PI * 2);
          ctx.stroke();
          ctx.strokeStyle = palette.orbit;
          ctx.lineWidth = Math.max(1, dpr * 0.8);
        }
        positions.push({ index: i, screenX: px, screenY: py, radius: size / 2 });
      }
      ctx.restore();
      return positions;
    }

    function render() {
      resizeCanvas();
      const palette = getThemePalette();
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = palette.background;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const scale = state.zoom * BASE_SCALE;
      drawGrid(palette, scale);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = `${Math.max(12, 14 * state.zoom)}px "Inter", sans-serif`;
      visibleSystems = [];
      const worldWidth = canvas.width / scale;
      const worldHeight = canvas.height / scale;
      let startX = Math.floor(state.centerX - worldWidth / 2) - 2;
      let endX = Math.ceil(state.centerX + worldWidth / 2) + 2;
      let startY = Math.floor(state.centerY - worldHeight / 2) - 2;
      let endY = Math.ceil(state.centerY + worldHeight / 2) + 2;
      startX -= ((startX % EVEN_GRID_STEP) + EVEN_GRID_STEP) % EVEN_GRID_STEP;
      startY -= ((startY % EVEN_GRID_STEP) + EVEN_GRID_STEP) % EVEN_GRID_STEP;
      for (let gx = startX; gx <= endX; gx += EVEN_GRID_STEP) {
        for (let gy = startY; gy <= endY; gy += EVEN_GRID_STEP) {
          const screen = worldToScreen(gx, gy);
          const margin = 180 * state.zoom * dpr;
          if (screen.x < -margin || screen.x > canvas.width + margin || screen.y < -margin || screen.y > canvas.height + margin) continue;
          const details = getSystemDetails(gx, gy);
          const system = {
            x: gx,
            y: gy,
            screenX: screen.x,
            screenY: screen.y,
            star: details.star,
            details
          };
          drawStar(system, palette, scale);
          if (state.zoom >= PLANET_REVEAL_ZOOM) {
            system.planets = drawPlanets(system, palette);
          } else {
            system.planets = null;
          }
          if (state.selectedSystem && state.selectedSystem.x === gx && state.selectedSystem.y === gy) {
            ctx.save();
            ctx.strokeStyle = palette.orbitHighlight;
            ctx.lineWidth = Math.max(2, dpr * 1.5);
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, system.starRadius + 18, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
          if (state.zoom >= 1.1) {
            ctx.save();
            ctx.fillStyle = palette.accent;
            ctx.globalAlpha = 0.85;
            ctx.fillText(details.name, screen.x, screen.y + system.starRadius + 12);
            ctx.globalAlpha = 1;
            ctx.restore();
          }
          visibleSystems.push(system);
        }
      }
      ctx.restore();
      updateStatusOverlay();
      if (searchModal.classList.contains('open')) {
        updateSearchResults();
      }
    }

    loadThemePreference();
    resizeCanvas();
    updateInfoPanel();
    scheduleRender();
    window.addEventListener('resize', () => {
      resizeCanvas();
      scheduleRender();
    });
  })();

  // === Procedural generation utilities (shared with Space Trader) ===
  function hash32(...parts) {
    let hash = 0x811c9dc5;
    const FNV_PRIME = 0x01000193;
    for (const part of parts) {
      if (typeof part === 'number') {
        let n = part | 0;
        hash ^= n & 0xff; hash = Math.imul(hash, FNV_PRIME);
        hash ^= (n >>> 8) & 0xff; hash = Math.imul(hash, FNV_PRIME);
        hash ^= (n >>> 16) & 0xff; hash = Math.imul(hash, FNV_PRIME);
        hash ^= (n >>> 24) & 0xff; hash = Math.imul(hash, FNV_PRIME);
      } else {
        const s = String(part);
        for (let i = 0; i < s.length; i++) {
          hash ^= s.charCodeAt(i) & 0xff;
          hash = Math.imul(hash, FNV_PRIME);
        }
      }
    }
    return hash >>> 0;
  }

  function toLCGSeed(u32) {
    const mod = 2147483646;
    return (u32 % mod) + 1;
  }

  class SeededRNG {
    constructor(seed = 12345) {
      this.seed = seed;
    }
    next() {
      this.seed = (this.seed * 16807) % 2147483647;
      return (this.seed - 1) / 2147483646;
    }
    nextInt(min, max) {
      return Math.floor(this.next() * (max - min + 1)) + min;
    }
    choice(array) {
      return array[Math.floor(this.next() * array.length)];
    }
  }

  function seededRandom(seed) {
    return function() {
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function composeRotation(ax, az) {
    const sx = Math.sin(ax), cx = Math.cos(ax);
    const sz = Math.sin(az), cz = Math.cos(az);
    return [
      [cz, -sz * cx, sz * sx],
      [sz, cz * cx, -cz * sx],
      [0, sx, cx]
    ];
  }

  function applyMat(m, v) {
    return [
      m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2],
      m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2],
      m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2]
    ];
  }

  function makeValueNoise3D(seedU32) {
    const rnd = seededRandom(seedU32);
    const P = new Uint16Array(512);
    for (let i = 0; i < 256; i++) P[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(rnd() * (i + 1));
      const t = P[i]; P[i] = P[j]; P[j] = t;
    }
    for (let i = 0; i < 256; i++) P[i + 256] = P[i];
    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(a, b, t) { return a + (b - a) * t; }
    function grad(hash, x, y, z) {
      switch (hash & 0xF) {
        case 0x0: return x + y;
        case 0x1: return -x + y;
        case 0x2: return x - y;
        case 0x3: return -x - y;
        case 0x4: return x + z;
        case 0x5: return -x + z;
        case 0x6: return x - z;
        case 0x7: return -x - z;
        case 0x8: return y + z;
        case 0x9: return -y + z;
        case 0xA: return y - z;
        case 0xB: return -y - z;
        case 0xC: return y + x;
        case 0xD: return -y + x;
        case 0xE: return y - x;
        case 0xF: return -y - x;
        default: return 0;
      }
    }
    return function perlin3(x, y, z) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      const Z = Math.floor(z) & 255;
      x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
      const u = fade(x), v = fade(y), w = fade(z);
      const A = P[X] + Y, AA = P[A] + Z, AB = P[A + 1] + Z;
      const B = P[X + 1] + Y, BA = P[B] + Z, BB = P[B + 1] + Z;
      return lerp(
        lerp(
          lerp(grad(P[AA], x, y, z), grad(P[BA], x - 1, y, z), u),
          lerp(grad(P[AB], x, y - 1, z), grad(P[BB], x - 1, y - 1, z), u), v
        ),
        lerp(
          lerp(grad(P[AA + 1], x, y, z - 1), grad(P[BA + 1], x - 1, y, z - 1), u),
          lerp(grad(P[AB + 1], x, y - 1, z - 1), grad(P[BB + 1], x - 1, y - 1, z - 1), u), v
        ), w
      );
    };
  }

  function makeFractalNoise3D(seedU32, octaves = 4, persistence = 0.5) {
    const base = makeValueNoise3D(seedU32);
    return function(x, y, z) {
      let amp = 1, freq = 1, sum = 0, norm = 0;
      for (let i = 0; i < octaves; i++) {
        sum += base(x * freq, y * freq, z * freq) * amp;
        norm += amp; amp *= persistence; freq *= 2;
      }
      return sum / (norm || 1);
    };
  }

  function generateSolarSystemName(x, y) {
    const seed = hash32('SYS', x | 0, y | 0);
    const rng = seededRandom(seed);
    const consonants = 'BCDFGHJKLMNPQRSTVWXZ';
    const vowels = 'AEIOU';
    const syllables = Math.floor(rng() * 3) + 2;
    let name = '';
    for (let i = 0; i < syllables; i++) {
      name += consonants[Math.floor(rng() * consonants.length)];
      name += vowels[Math.floor(rng() * vowels.length)].toLowerCase();
    }
    return name.charAt(0).toUpperCase() + name.slice(1);
  }

  function generatePlanetName(x, y, planetIndex) {
    const seed = toLCGSeed(hash32('PLN', x | 0, y | 0, planetIndex | 0));
    const rng = new SeededRNG(seed);
    const C = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z'];
    const V = ['a','e','i','o','u','y'];
    const len = rng.nextInt(2, 3);
    let s = '';
    for (let i = 0; i < len; i++) {
      const cIndex = Math.floor(rng.next() * C.length);
      const vIndex = Math.floor(rng.next() * V.length);
      s += C[cIndex] + V[vIndex];
    }
    const suffixes = ['-I', '-II', '', '', '', ' Prime'];
    const sIndex = Math.floor(rng.next() * suffixes.length);
    return s.charAt(0).toUpperCase() + s.slice(1) + suffixes[sIndex];
  }

  function generatePlanetNames(x, y, count) {
    const names = [];
    for (let i = 0; i < count; i++) {
      names.push(generatePlanetName(x, y, i));
    }
    return names;
  }

  const PLANET_PROFILE_LIBRARY = [
    { key: 'Rocky', group: 'Rocky', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.6, seaLevel: -0.15, mountainAmp: 2.0, cloudCover: 0.2, polarCaps: true, baseColor: '#8B6F47', landColor: '#9b8060', oceanColor: '#2a4b7c', iceColor: '#e6f2ff', hazeColor: '#c9ddff', specular: 0.05, shininess: 24 },
    { key: 'Barren', group: 'Rocky', hasOceans: false, atmosphere: false, hasCraters: true, craterChance: 0.9, seaLevel: -0.5, mountainAmp: 1.1, cloudCover: 0.0, polarCaps: false, baseColor: '#9a8a78', landColor: '#a5937f', iceColor: '#f6f6f6' },
    { key: 'Desert', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.4, seaLevel: -0.3, mountainAmp: 1.4, cloudCover: 0.05, polarCaps: false, baseColor: '#C9A66B', landColor: '#d4b57d', iceColor: '#f6faff', hazeColor: '#ffd9a6', paletteKey: 'Desert', atmosphereThicknessRange: [1.1, 1.9], albedoGain: 1.12 },
    { key: 'Dune', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.3, seaLevel: -0.45, mountainAmp: 1.0, cloudCover: 0.02, polarCaps: false, baseColor: '#c9b07a', landColor: '#e0c890', iceColor: '#fffbe6', hazeColor: '#ffe3b3', paletteKey: 'Dune', atmosphereThicknessRange: [1.0, 1.7], albedoGain: 1.1 },
    { key: 'Salt Flats', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.35, seaLevel: -0.25, mountainAmp: 1.2, cloudCover: 0.04, polarCaps: false, baseColor: '#f3ede1', landColor: '#fff7d1', iceColor: '#ffffff', hazeColor: '#fff1c9', paletteKey: 'DesertSalt', atmosphereThicknessRange: [1.6, 2.4], specular: 0.18, shininess: 68, albedoGain: 1.18 },
    { key: 'Sulfur Sands', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.32, seaLevel: -0.35, mountainAmp: 1.3, cloudCover: 0.03, polarCaps: false, baseColor: '#f6d94f', landColor: '#ffeb80', iceColor: '#fff6cf', hazeColor: '#ffe886', paletteKey: 'DesertSulfur', atmosphereThicknessRange: [1.3, 2.1], specular: 0.2, shininess: 72, albedoGain: 1.2 },
    { key: 'Basalt Dunes', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.45, seaLevel: -0.4, mountainAmp: 1.6, cloudCover: 0.02, polarCaps: false, baseColor: '#2c2b30', landColor: '#3a383f', iceColor: '#f2f2f2', hazeColor: '#707683', paletteKey: 'DesertBasalt', atmosphereThicknessRange: [1.2, 2.0], specular: 0.22, shininess: 76, albedoGain: 1.22 },
    { key: 'Verdant Flats', group: 'Desert', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.28, seaLevel: -0.33, mountainAmp: 1.1, cloudCover: 0.04, polarCaps: false, baseColor: '#4c7f5f', landColor: '#7ac48f', iceColor: '#f2fff6', hazeColor: '#c9f1d8', paletteKey: 'DesertVerdant', atmosphereThicknessRange: [1.4, 2.2], specular: 0.19, shininess: 70, albedoGain: 1.18 },
    { key: 'Ocean', group: 'Ocean', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: 0.25, mountainAmp: 0.8, cloudCover: 0.45, polarCaps: true, baseColor: '#3B7BBF', landColor: '#6aa56a', oceanColor: '#1f4f8f', iceColor: '#f0fbff', hazeColor: '#b4d2ff', specular: 0.12, shininess: 64 },
    { key: 'Life', group: 'Life', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: 0.05, mountainAmp: 1.2, cloudCover: 0.35, polarCaps: true, baseColor: '#4E8E5E', landColor: '#74b36d', oceanColor: '#1e4b7f', iceColor: '#f0fbff', hazeColor: '#cbe8d5' },
    { key: 'Jungle', group: 'Life', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: 0.15, mountainAmp: 1.0, cloudCover: 0.55, polarCaps: true, baseColor: '#3f7a49', landColor: '#6fb36a', oceanColor: '#1b4a78', iceColor: '#edfaff', hazeColor: '#cfe9d2' },
    { key: 'Swamp', group: 'Life', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.2, seaLevel: 0.3, mountainAmp: 0.7, cloudCover: 0.5, polarCaps: false, baseColor: '#3a6a42', landColor: '#5e8a54', oceanColor: '#264f4a', iceColor: '#e9fff9', hazeColor: '#bde6d1', cloudColor: '#dcead9' },
    { key: 'Tundra', group: 'Frozen', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.5, seaLevel: -0.1, mountainAmp: 1.3, cloudCover: 0.2, polarCaps: true, baseColor: '#d3e8f3', landColor: '#eef9ff', iceColor: '#ffffff', hazeColor: '#e7f6ff' },
    { key: 'Ice World', group: 'Frozen', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.7, seaLevel: -0.25, mountainAmp: 1.2, cloudCover: 0.15, polarCaps: true, baseColor: '#BFD9E8', landColor: '#dbeaf2', iceColor: '#ffffff', hazeColor: '#e7f6ff' },
    { key: 'Frozen', group: 'Frozen', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.7, seaLevel: -0.3, mountainAmp: 1.0, cloudCover: 0.1, polarCaps: true, baseColor: '#D6EEF7', landColor: '#e8f6fc', iceColor: '#ffffff', hazeColor: '#ecfbff' },
    { key: 'Volcanic', group: 'Volcanic', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.2, seaLevel: -0.4, mountainAmp: 2.8, cloudCover: 0.1, polarCaps: false, baseColor: '#7A1E10', landColor: '#b2451b', iceColor: '#ffeeee', hazeColor: '#ffccb3', glowLava: true, lavaColor: '#ff5a1f' },
    { key: 'Lava Ocean', group: 'Volcanic', hasOceans: true, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: 0.35, mountainAmp: 0.3, cloudCover: 0.05, polarCaps: false, baseColor: '#66210f', landColor: '#7a2a12', oceanColor: '#ff3b00', iceColor: '#ffeeee', hazeColor: '#ffb199', glowLava: true, lavaColor: '#ff3b00' },
    { key: 'Sulfur', group: 'Sulfur', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.5, seaLevel: -0.35, mountainAmp: 1.6, cloudCover: 0.05, polarCaps: false, baseColor: '#C1B433', landColor: '#e0d24a', iceColor: '#ffffee', hazeColor: '#ffe573' },
    { key: 'Carbon', group: 'Carbon', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.6, seaLevel: -0.2, mountainAmp: 2.2, cloudCover: 0.05, polarCaps: false, baseColor: '#3a3a3a', landColor: '#575757', iceColor: '#e6e6e6', hazeColor: '#cfd6e0', specular: 0.2, shininess: 48 },
    { key: 'Metallic', group: 'Metallic', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.4, seaLevel: -0.2, mountainAmp: 1.1, cloudCover: 0.02, polarCaps: false, baseColor: '#6c6f77', landColor: '#8c8f99', iceColor: '#eff2f7', hazeColor: '#d6e0ff', specular: 0.35, shininess: 96 },
    { key: 'Crystal', group: 'Metallic', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.2, seaLevel: -0.3, mountainAmp: 1.4, cloudCover: 0.02, polarCaps: false, baseColor: '#86c5ff', landColor: '#a6d6ff', iceColor: '#f3fbff', hazeColor: '#cbe5ff', specular: 0.5, shininess: 128 },
    { key: 'MegaCity', group: 'Life', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.1, seaLevel: -0.2, mountainAmp: 0.9, cloudCover: 0.25, polarCaps: false, baseColor: '#6d6d6d', landColor: '#7a7a7a', iceColor: '#e6f2ff', hazeColor: '#d9e3ff', cityLights: true, cityColor: '#ffd080', specular: 0.18, shininess: 56 },
    { key: 'Toxic', group: 'Toxic', hasOceans: false, atmosphere: true, hasCraters: true, craterChance: 0.6, seaLevel: -0.3, mountainAmp: 1.3, cloudCover: 0.35, polarCaps: false, baseColor: '#6d7f2a', landColor: '#829640', iceColor: '#f6ffe6', hazeColor: '#bde34f', cloudColor: '#d9f266' },
    { key: 'Methane', group: 'Toxic', hasOceans: true, atmosphere: true, hasCraters: true, craterChance: 0.5, seaLevel: 0.2, mountainAmp: 0.7, cloudCover: 0.2, polarCaps: true, baseColor: '#5b7f86', landColor: '#6e8f96', oceanColor: '#2e4a66', iceColor: '#e9f8ff', hazeColor: '#9fd0ff', cloudColor: '#cfe6ff' },
    { key: 'Gas Giant', group: 'Gas Giant', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: -1.0, mountainAmp: 0.0, cloudCover: 0.0, polarCaps: false, baseColor: '#7BA5D6', landColor: '#d6c08b', iceColor: '#e6f2ff', gasBands: true, bandScale: 35, bandWarp: 2.0, gasPalette: ['#a5c4e6','#d8c49a','#e9d7b7','#88a7cf'] },
    { key: 'Ice Giant', group: 'Gas Giant', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: -1.0, mountainAmp: 0.0, cloudCover: 0.0, polarCaps: false, baseColor: '#7FC6FF', landColor: '#9ed1ff', iceColor: '#e6f2ff', gasBands: true, bandScale: 28, bandWarp: 1.2, gasPalette: ['#a6e1ff','#7fc6ff','#4aa6e0','#b9ecff'] },
    { key: 'Hot Jupiter', group: 'Gas Giant', hasOceans: false, atmosphere: true, hasCraters: false, craterChance: 0.0, seaLevel: -1.0, mountainAmp: 0.0, cloudCover: 0.0, polarCaps: false, baseColor: '#e6a36a', landColor: '#f0c48a', iceColor: '#ffe9cc', gasBands: true, bandScale: 22, bandWarp: 3.5, gasPalette: ['#f2c185','#e89054','#c65f3a','#ffe1a6'] }
  ];

  const PLANET_PROFILES_BY_GROUP = (() => {
    const map = new Map();
    for (const profile of PLANET_PROFILE_LIBRARY) {
      if (!map.has(profile.group)) map.set(profile.group, []);
      map.get(profile.group).push(profile);
    }
    return map;
  })();

  const PLANET_PROFILES_BY_KEY = (() => {
    const map = new Map();
    for (const profile of PLANET_PROFILE_LIBRARY) {
      if (!map.has(profile.key)) map.set(profile.key, []);
      map.get(profile.key).push(profile);
    }
    return map;
  })();

  const PLANET_GROUP_KEYS = Array.from(PLANET_PROFILES_BY_GROUP.keys());

  const PLANET_GROUP_COLOR_OPTIONS = (() => {
    const map = new Map();
    for (const [group, profiles] of PLANET_PROFILES_BY_GROUP.entries()) {
      const colors = new Set();
      for (const profile of profiles) {
        [
          profile.baseColor,
          profile.landColor,
          profile.oceanColor,
          profile.iceColor,
          profile.hazeColor,
          profile.cloudColor,
          profile.cityColor,
          profile.lavaColor
        ].forEach((hex) => {
          if (hex) colors.add(hex);
        });
        if (Array.isArray(profile.gasPalette)) {
          profile.gasPalette.forEach((hex) => {
            if (hex) colors.add(hex);
          });
        }
      }
      if (!colors.size) colors.add('#888888');
      map.set(group, Array.from(colors));
    }
    return map;
  })();

  function getPlanetColor(x, y, planetIndex) {
    const seed = toLCGSeed(hash32('COL', x | 0, y | 0, planetIndex | 0));
    const rng = new SeededRNG(seed);
    const groupIndex = Math.floor(rng.next() * PLANET_GROUP_KEYS.length);
    const group = PLANET_GROUP_KEYS[groupIndex];
    const groupProfiles = PLANET_PROFILES_BY_GROUP.get(group) || PLANET_PROFILE_LIBRARY;
    const profile = groupProfiles[Math.floor(rng.next() * groupProfiles.length)];

    const palette = PLANET_GROUP_COLOR_OPTIONS.get(group) || ['#888888'];
    const color = palette[Math.floor(rng.next() * palette.length)] || '#888888';

    return {
      type: group,
      profileKey: profile.key,
      color
    };
  }

  function getPlanetCount(x, y) {
    const seed = (x * 73856093) ^ (y * 19349663) + 54321;
    const rng = seededRandom(seed);
    return Math.floor(rng() * 8) + 1;
  }

  const ATMOSPHERE_PRESETS = {
    Ocean: { thickness: [1.6, 2.6], colorJitter: 0.06, intensity: 0.52, softness: 1.25 },
    Life: { thickness: [1.4, 2.4], colorJitter: 0.08, intensity: 0.48, softness: 1.15 },
    Desert: { thickness: [1.0, 1.8], colorJitter: 0.12, intensity: 0.44, softness: 1.05 },
    Rocky: { thickness: [0.9, 1.6], colorJitter: 0.1, intensity: 0.4, softness: 1.0 },
    Volcanic: { thickness: [1.1, 1.9], colorJitter: 0.14, intensity: 0.46, softness: 1.05 },
    Frozen: { thickness: [1.1, 1.9], colorJitter: 0.05, intensity: 0.42, softness: 1.2 },
    Default: { thickness: [1.0, 1.5], colorJitter: 0.08, intensity: 0.42, softness: 1.05 }
  };

  const PLANET_TEXTURE_SIZE = 192;
  const planetSpriteCache = new Map();

  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp255(x) { return Math.max(0, Math.min(255, Math.round(x))); }
  function lerpRgb(a, b, t) { return [lerp(a[0], b[0], t), lerp(a[1], b[1], t), lerp(a[2], b[2], t)]; }
  function scaleRgb(c, s) { return [c[0] * s, c[1] * s, c[2] * s]; }
  function hexToRgb(hex) {
    const h = hex.replace('#', '');
    const r = parseInt(h.slice(0, 2), 16), g = parseInt(h.slice(2, 4), 16), b = parseInt(h.slice(4, 6), 16);
    return [r, g, b];
  }

  function lightenRgb(rgb, t) {
    return [
      clamp255(lerp(rgb[0], 255, t)),
      clamp255(lerp(rgb[1], 255, t)),
      clamp255(lerp(rgb[2], 255, t))
    ];
  }

  function darkenRgb(rgb, t) {
    const k = Math.max(0, 1 - t);
    return [
      clamp255(rgb[0] * k),
      clamp255(rgb[1] * k),
      clamp255(rgb[2] * k)
    ];
  }

  function samplePalette(palette, t) {
    if (!palette || palette.length === 0) return [255, 255, 255];
    if (palette.length === 1) return palette[0];
    t = Math.max(0, Math.min(1, t));
    const scaled = t * (palette.length - 1);
    const i = Math.floor(scaled);
    const f = scaled - i;
    const c0 = palette[i];
    const c1 = palette[Math.min(palette.length - 1, i + 1)];
    return lerpRgb(c0, c1, f);
  }

  function normalize(v) {
    const l = Math.hypot(v[0], v[1], v[2]) || 1;
    return [v[0] / l, v[1] / l, v[2] / l];
  }

  function getSeededLightDir(x, y, planetIndex) {
    const r = seededRandom(hash32('LGT', x | 0, y | 0, planetIndex | 0));
    const phi = r() * Math.PI * 2;
    const cosA = 0.2 + r() * 0.8;
    const sinA = Math.sqrt(Math.max(0, 1 - cosA * cosA));
    const lx = sinA * Math.cos(phi);
    const ly = sinA * Math.sin(phi);
    const lz = cosA;
    const L = Math.hypot(lx, ly, lz) || 1;
    return [lx / L, ly / L, lz / L];
  }

  function choosePlanetProfile(rng, typeOverride) {
    let candidates = PLANET_PROFILE_LIBRARY;
    if (typeOverride) {
      const byGroup = PLANET_PROFILES_BY_GROUP.get(typeOverride);
      if (byGroup && byGroup.length) {
        candidates = byGroup;
      } else {
        const byKey = PLANET_PROFILES_BY_KEY.get(typeOverride);
        if (byKey && byKey.length) candidates = byKey;
      }
    }

    let chosen = candidates[Math.floor(rng() * candidates.length)];
    chosen = { ...chosen };

    const jitter = (v, amt) => v + (rng() * 2 - 1) * amt;
    if (typeof chosen.seaLevel === 'number') chosen.seaLevel = jitter(chosen.seaLevel, 0.08);
    if (typeof chosen.mountainAmp === 'number') chosen.mountainAmp = Math.max(0, jitter(chosen.mountainAmp, 0.3));
    if (typeof chosen.cloudCover === 'number') chosen.cloudCover = Math.max(0, Math.min(1, jitter(chosen.cloudCover, 0.08)));
    if (typeof chosen.craterChance === 'number') chosen.craterChance = Math.max(0, Math.min(1, jitter(chosen.craterChance, 0.1)));
    if (typeof chosen.bandScale === 'number') chosen.bandScale = Math.max(12, jitter(chosen.bandScale, 4));
    if (typeof chosen.bandWarp === 'number') chosen.bandWarp = Math.max(0, jitter(chosen.bandWarp, 0.6));
    if (typeof chosen.specular === 'number') chosen.specular = Math.max(0, jitter(chosen.specular, 0.05));
    if (typeof chosen.shininess === 'number') chosen.shininess = Math.max(8, jitter(chosen.shininess, 12));

    const varyHex = (hex, strength = 0.06) => {
      if (!hex) return hex;
      const rgb = hexToRgb(hex);
      const t = strength * (rng() * 2 - 1);
      const mixed = [
        clamp255(rgb[0] + rgb[0] * t),
        clamp255(rgb[1] + rgb[1] * t),
        clamp255(rgb[2] + rgb[2] * t)
      ];
      return `#${mixed[0].toString(16).padStart(2, '0')}${mixed[1].toString(16).padStart(2, '0')}${mixed[2].toString(16).padStart(2, '0')}`;
    };

    chosen.baseColor = varyHex(chosen.baseColor);
    if (chosen.landColor) chosen.landColor = varyHex(chosen.landColor, 0.08);
    if (chosen.oceanColor) chosen.oceanColor = varyHex(chosen.oceanColor, 0.08);
    if (chosen.hazeColor) chosen.hazeColor = varyHex(chosen.hazeColor, 0.04);
    if (chosen.cloudColor) chosen.cloudColor = varyHex(chosen.cloudColor, 0.05);
    if (Array.isArray(chosen.gasPalette)) {
      const rot = Math.floor(rng() * chosen.gasPalette.length);
      chosen.gasPalette = chosen.gasPalette.slice(rot).concat(chosen.gasPalette.slice(0, rot));
    }

    return chosen;
  }

  function getPlanetProfile(x, y, planetIndex, typeOverride) {
    const seedU32 = hash32('TEX', x | 0, y | 0, planetIndex | 0);
    const rng = seededRandom(seedU32);
    return choosePlanetProfile(rng, typeOverride);
  }

  function getPlanetSprite(x, y, planetIndex, size = 192, typeOverride, baseColorOverride, lightOverride) {
    const lightKey = lightOverride
      ? `|L:${lightOverride.map((v) => v.toFixed(4)).join(',')}`
      : '|L:seed';
    const key = `${x}|${y}|${planetIndex}|${size}|${typeOverride || ''}|${baseColorOverride || ''}${lightKey}`;
    const cached = planetSpriteCache.get(key);
    if (cached) return cached;

    // Seed derived from hashed coordinates; mirror the TEX namespace so sprites stay in sync with the cockpit renderer.
    const seedU32 = hash32('TEX', x | 0, y | 0, planetIndex | 0);
    const rng = seededRandom(seedU32);

    // Choose a planet profile deterministically using the shared TEX seed.
    const profile = choosePlanetProfile(rng, typeOverride);

    // Colors
    const baseHex = baseColorOverride || profile.baseColor;
    const baseRGB = hexToRgb(baseHex);
    const oceanRGB = hexToRgb(profile.oceanColor || '#204a87');
    const landRGB = hexToRgb(profile.landColor || '#8f7e5b');
    const iceRGB = hexToRgb(profile.iceColor || '#dfefff');
    let hazeRGB = hexToRgb(profile.hazeColor || '#b4d2ff');
    const cloudRGB = hexToRgb(profile.cloudColor || '#ffffff');
    const cityRGB = hexToRgb(profile.cityColor || '#ffd080');
    const lavaRGB = hexToRgb(profile.lavaColor || '#ff5a1f');
    const gasPalette = (profile.gasPalette || []).map(hexToRgb);

    // Atmosphere response derived from main renderer presets
    const hasAtmosphereEffect = (profile.atmosphere || profile.group === 'Ocean');
    const atmPreset = ATMOSPHERE_PRESETS[profile.group] || ATMOSPHERE_PRESETS.Default;
    let atmosphereThickness = 0;
    let haloIntensity = 0;
    let haloSoftness = 1.05;
    if (hasAtmosphereEffect) {
      const atmRng = seededRandom(hash32('ATM', seedU32));
      const thicknessRange = profile.atmosphereThicknessRange || atmPreset.thickness || [1, 1];
      const tMin = thicknessRange[0];
      const tMax = thicknessRange.length > 1 ? thicknessRange[1] : thicknessRange[0];
      const rawThickness = tMin + (tMax - tMin) * atmRng();
      atmosphereThickness = Math.max(0.75, Math.min(3.0, rawThickness));

      const jitterAmt = profile.hazeJitter ?? atmPreset.colorJitter ?? 0;
      if (jitterAmt > 1e-3) {
        const shift = (atmRng() * 2 - 1) * jitterAmt;
        if (shift > 1e-3) {
          hazeRGB = lightenRgb(hazeRGB, Math.min(0.45, shift));
        } else if (shift < -1e-3) {
          hazeRGB = darkenRgb(hazeRGB, Math.min(0.45, -shift));
        }
      }

      const baseIntensity = profile.atmosphereIntensity ?? atmPreset.intensity ?? 0.42;
      haloIntensity = baseIntensity * (0.8 + 0.2 * atmosphereThickness);
      const baseSoftness = profile.atmosphereSoftness ?? atmPreset.softness ?? 1.05;
      haloSoftness = baseSoftness * (0.9 + 0.18 * Math.min(atmosphereThickness, 3.0));
    }
    const allowHalo = hasAtmosphereEffect && profile.group !== 'Gas Giant';
    const haloScale = allowHalo ? (1.05 + 0.07 * haloSoftness) : 1.0;

    // Noise generators (hash-seeded to mirror the TEX/TN* namespaces used by the cockpit renderer)
    const nSeed0 = hash32('TN0', seedU32);
    const nSeed1 = hash32('TN1', seedU32);
    const nSeed2 = hash32('TN2', seedU32);
    const noise0 = makeFractalNoise3D(nSeed0, 4, 0.5); // base terrain
    const noise1 = makeFractalNoise3D(nSeed1, 5, 0.5); // detail/roughness
    const noise2 = makeFractalNoise3D(nSeed2, 3, 0.6); // clouds/bands

    // Offscreen canvas
    const cnv = document.createElement('canvas');
    cnv.width = size; cnv.height = size;
    const ctx = cnv.getContext('2d', { willReadFrequently: true });

  // Precompute lighting (seeded per-planet; override supplies screen-space light direction)
  const lightDir = lightOverride ? lightOverride : getSeededLightDir(x, y, planetIndex);

    // --- Seeded planetary rings parameters ---
    const ringRnd = seededRandom(hash32('RING', seedU32));
    const hasRings = false; // rings disabled for now
    // Predeclare for closures used by drawRingHalf
    let ringAngle = 0, ringOpenScale = 1, ringInner = 0, ringOuter = 0, ringPalette = null, ringPhase = 0, ringFreq = 0.2;
    let ringInnerRatio = 0, ringOuterRatio = 0;
    if (hasRings) {
      // Inclination (rotation in screen plane)
      ringAngle = ringRnd() * Math.PI; // 0..pi
      // Opening (tilt) -> ellipse minor/major ratio (avoid edge-on)
      ringOpenScale = 0.35 + ringRnd() * 0.55; // 0.35..0.9
      // Inner/outer radii as ratios of planet radius (resolved later)
      ringInnerRatio = 1.12 + ringRnd() * 0.55; // 1.12R .. 1.67R
      ringOuterRatio = Math.min(2.6, ringInnerRatio + (0.5 + ringRnd() * 0.9)); // cap outer
      // Seeded band colors: derive from planet base color and a seeded neutral mix
      const neutralA = [200, 182, 150];
      const neutralB = [120, 110, 100];
      const mixT = 0.35 + ringRnd() * 0.3;
      const seedColor = lerpRgb(baseRGB, lerpRgb(neutralA, neutralB, ringRnd()), mixT);
      const lightenRgb = (c, t) => [ lerp(c[0], 255, t), lerp(c[1], 255, t), lerp(c[2], 255, t) ];
      const darkenRgb  = (c, t) => [ c[0]*(1-t), c[1]*(1-t), c[2]*(1-t) ];
      ringPalette = [
        lightenRgb(seedColor, 0.25),
        lightenRgb(seedColor, 0.08),
        darkenRgb(seedColor, 0.06),
        darkenRgb(seedColor, 0.18)
      ];
      // Banding globals reused for both halves
      ringPhase = ringRnd() * Math.PI * 2;
      ringFreq = 0.12 + ringRnd() * 0.35;
    }

    // Helper to draw ring half ("far" drawn before planet, "near" after planet)
    function drawRingHalf(half) {
      if (!hasRings) return;
      const currentRadius = radius;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(ringAngle);
      ctx.scale(1, ringOpenScale);
      // Clip to half-plane in ring-local space
      ctx.beginPath();
      const pad = ringOuter * 1.1 + 8;
      if (half === 'far') {
        ctx.rect(-pad, -pad, pad*2, pad); // y < 0
      } else {
        ctx.rect(-pad, 0, pad*2, pad); // y >= 0
      }
      ctx.clip();

      // Draw matte banded texture using concentric arcs (transformed to ellipse)
      let r = ringInner;
      ctx.globalCompositeOperation = 'source-over';
      while (r < ringOuter) {
        // Vary band thickness with a smooth function for natural groupings
        const w = 0.8 + 2.4 * Math.max(0, Math.sin(r * ringFreq * 0.2 + ringPhase));
        const t = Math.max(0, Math.min(1, (r - ringInner) / Math.max(1e-5, (ringOuter - ringInner))));
        // Choose palette index with slight variation across radius
        const idx = Math.floor((t * (ringPalette.length - 1)) + (Math.sin(r * 0.08 + ringPhase) * 0.5 + 0.5) * 0.4);
        const c = ringPalette[Math.max(0, Math.min(ringPalette.length - 1, idx))];
        const alpha = 0.65 + 0.2 * Math.sin(r * 0.12 + ringPhase * 0.7);
        ctx.strokeStyle = `rgba(${clamp255(c[0])},${clamp255(c[1])},${clamp255(c[2])},${Math.max(0.05, Math.min(0.95, alpha))})`;
        ctx.lineWidth = Math.max(0.75, w);
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
        r += w;
      }

      // Planet shadow cast on rings (aligned with light direction)
      // Use multiply with a radial gradient offset opposite light
      const lx = lightDir[0], ly = lightDir[1];
      ctx.globalCompositeOperation = 'multiply';
      const g = ctx.createRadialGradient(-lx * currentRadius * 0.25, -ly * currentRadius * 0.25, currentRadius * 0.2,
                 -lx * currentRadius * 0.85, -ly * currentRadius * 0.85, ringOuter);
      g.addColorStop(0.0, 'rgba(0,0,0,0.28)');
      g.addColorStop(0.4, 'rgba(0,0,0,0.16)');
      g.addColorStop(1.0, 'rgba(0,0,0,0.0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
      ctx.moveTo(ringInner, 0);
      ctx.arc(0, 0, ringInner, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    // Render sphere by raymarching the screen-space circle and sampling mapped 3D noise
    let radius = (size * 0.5) - 1;
    const cx = size * 0.5, cy = size * 0.5;
    const img = ctx.createImageData(size, size);
    const data = img.data;

    // If rings exist, shrink planet radius slightly so the full ring fits inside the sprite
    if (hasRings) {
      // Compute maximum ellipse extents in x/y due to rotation+tilt
      const Rx = 1, Ry = ringOpenScale;
      const cosA = Math.cos(ringAngle), sinA = Math.sin(ringAngle);
      const shapeX = Math.sqrt((Rx*cosA)**2 + (Ry*sinA)**2);
      const shapeY = Math.sqrt((Rx*sinA)**2 + (Ry*cosA)**2);
      const padding = 2;
      const halfCap = (size * 0.5) - padding;
      const needX = ringOuterRatio * shapeX;
      const needY = ringOuterRatio * shapeY;
      const haloFrac = allowHalo ? Math.max(0, haloScale - 1) : (hasAtmosphereEffect ? 0.04 : 0);
      const rMax = Math.min(
        halfCap / (needX + haloFrac),
        halfCap / (needY + haloFrac),
        halfCap / haloScale
      );
      radius = Math.min(radius, rMax);
      ringInner = radius * ringInnerRatio;
      ringOuter = radius * ringOuterRatio;
    } else if (allowHalo) {
      const padding = 2; // leave a couple pixels so the gradient never clips
      const maxRadius = ((size * 0.5) - padding) / haloScale;
      radius = Math.min(radius, maxRadius);
    }

    // Axial tilt/band rotation
    const tilt = (rng() * 0.6 - 0.3) * Math.PI; // -0.3..0.3 rad
    const rot = rng() * Math.PI * 2; // rotation around axis
    const rotMat = composeRotation(tilt, rot);

    // Profile parameters
    const seaLevel = profile.seaLevel;
    const mountainAmp = profile.mountainAmp;
    const craterChance = profile.craterChance;
    const cloudCover = profile.cloudCover;
    const gasBands = profile.gasBands;
    const bandScale = profile.bandScale || 25;
    const bandWarp = profile.bandWarp || 0.0;
    const specular = profile.specular || 0.0;
    const shininess = profile.shininess || 32;
    const cityLights = !!profile.cityLights;
    const glowLava = !!profile.glowLava;

    // Simple crater field helper (sample sparse circular dimples in tangent space)
    const craterPRNG = seededRandom(hash32('TCR', seedU32));
    const craters = [];
    const craterCount = profile.hasCraters ? Math.floor(craterPRNG() * 120) + 40 : 0;
    for (let i = 0; i < craterCount; i++) {
      // random point on sphere via uniform sampling
      const u = craterPRNG();
      const v = craterPRNG();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const p = [
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
      ];
      const r = 0.01 + craterPRNG() * 0.05; // crater radius in sphere units
      craters.push({ p, r });
    }

    // Draw far half of ring behind the planet
    if (hasRings) {
      drawRingHalf('far');
    }

    // Per-pixel render (planet body)
    for (let y0 = 0, idx = 0; y0 < size; y0++) {
      const dy = y0 - cy;
      for (let x0 = 0; x0 < size; x0++, idx += 4) {
        const dx = x0 - cx;
        const d2 = dx*dx + dy*dy;
        if (d2 > radius*radius) {
          // Outside sphere
          data[idx+3] = 0;
          continue;
        }
        const dz = Math.sqrt(radius*radius - d2);
        // Map to unit sphere normal (N)
        let nx = dx / radius, ny = dy / radius, nz = dz / radius;
        // Rotate to give different band/orientation per planet
        const nRot = applyMat(rotMat, [nx, ny, nz]);
        nx = nRot[0]; ny = nRot[1]; nz = nRot[2];

        // Sample base terrain using 3D noise on sphere coordinates to avoid polar pinching
        // Use different scales for broad continents and details
        const cont = noise0(nx*1.2, ny*1.2, nz*1.2);
        const detail = noise1(nx*6.0, ny*6.0, nz*6.0);
        let height = cont * 0.7 + detail * 0.3;

        // Gas giants: band coordinate based on latitude with noise warp
        let bandT = 0;
        if (gasBands) {
          const s = ny * bandScale + noise2(nx*1.2, ny*1.2, nz*1.2) * bandWarp;
          bandT = 0.5 + 0.5 * Math.sin(s);
        }

        // Crater deformation for airless rocky/ice worlds
        if (profile.hasCraters) {
          let craterDepth = 0;
          for (let c = 0; c < craters.length; c++) {
            const cp = craters[c];
            const dot = nx*cp.p[0] + ny*cp.p[1] + nz*cp.p[2]; // cos(angle)
            const ang = Math.acos(Math.max(-1, Math.min(1, dot)));
            const s = ang / cp.r;
            if (s < 1.0) {
              // smooth bowl profile
              const t = 1 - s;
              craterDepth += t*t * 0.25; // depth
            }
          }
          height -= craterDepth * craterChance;
        }

        // Surface classification
        let surfaceRGB = baseRGB;
        if (!gasBands) {
          if (profile.hasOceans && height < seaLevel) {
            // Ocean color with depth-based darkening
            const depth = (seaLevel - height) / Math.max(1e-5, seaLevel + 1);
            surfaceRGB = lerpRgb(oceanRGB, baseRGB, 0.2 + 0.5 * Math.min(1, depth));
          } else {
            // Land: blend base and land, add mountain highlights
            let t = Math.max(0, height - seaLevel) * mountainAmp;
            t = Math.min(1, t);
            surfaceRGB = lerpRgb(landRGB, baseRGB, 0.4 + 0.6 * t);
            if (profile.polarCaps) {
              const pole = Math.pow(Math.abs(nz), 4);
              surfaceRGB = lerpRgb(surfaceRGB, iceRGB, 0.25 * pole);
            }
          }
        } else {
          // Gas giant palette blending across bands using provided palette
          if (gasPalette.length >= 2) {
            surfaceRGB = samplePalette(gasPalette, bandT);
          } else {
            surfaceRGB = lerpRgb(landRGB, baseRGB, bandT);
          }
        }

        // Clouds layer (if atmosphere exists)
        let outRGB = surfaceRGB;
        if (profile.atmosphere && cloudCover > 0) {
          const cloud = 0.5 + 0.5 * noise2(nx*3.5 + 20, ny*3.5 + 20, nz*3.5 + 20);
          const swirl = noise1(nx*1.5 - ny*1.5, ny*1.5 + nz*1.5, nz*1.5 - nx*1.5);
          const clouds = Math.max(0, cloud * 0.8 + swirl * 0.2 - (1.0 - cloudCover));
          outRGB = lerpRgb(outRGB, cloudRGB, 0.35 * Math.min(1, clouds));
        }

    // Lambert lighting
    const ndotl = Math.max(0, nx*lightDir[0] + ny*lightDir[1] + nz*lightDir[2]);
        const ambient = 0.25;
        let litRGB = scaleRgb(outRGB, ambient + ndotl * 0.9);

        // Ring shadow onto planet (attenuate only the direct component, only on day side)
        if (hasRings && ndotl > 0) {
          const cosA = Math.cos(ringAngle), sinA = Math.sin(ringAngle);
          const rx =  (dx)*cosA + (dy)*sinA;
          const ry = ((-dx)*sinA + (dy)*cosA) / Math.max(1e-5, ringOpenScale);
          const rr = Math.hypot(rx, ry);
          if (rr >= ringInner && rr <= ringOuter) {
            const t = Math.max(0, Math.min(1, (rr - ringInner) / Math.max(1e-5, (ringOuter - ringInner))));
            const atten = 1 - (0.35 * (0.7 + 0.3 * (1 - t)));
            litRGB = scaleRgb(litRGB, atten);
          }
        }

        // Specular highlight (simple Blinn-Phong approx with viewer ~ +Z)
        if (specular > 0) {
          const L = lightDir;
          const N = [nx, ny, nz];
          const V = [0, 0, 1];
          const Hx = (L[0]+V[0]);
          const Hy = (L[1]+V[1]);
          const Hz = (L[2]+V[2]);
          const Hn = normalize([Hx,Hy,Hz]);
          const ndoth = Math.max(0, N[0]*Hn[0] + N[1]*Hn[1] + N[2]*Hn[2]);
          const spec = Math.pow(ndoth, shininess) * specular;
          litRGB = lerpRgb(litRGB, [255,255,255], Math.min(1, spec));
        }

        // Rim atmosphere scattering (simple fresnel-style brighten at edge on lit side)
        if (hasAtmosphereEffect) {
          const viewNdot = Math.max(0, nz); // facing viewer
          const fres = Math.pow(1 - viewNdot, 3);
          const forward = Math.max(0, ndotl * 0.75 + 0.25);
          const rimStrength = (0.18 + haloIntensity * 0.82) * fres * forward;
          litRGB = lerpRgb(litRGB, hazeRGB, Math.min(0.85, rimStrength));
        }

        // City lights emission on night side (slightly more permissive near-terminator)
        if (cityLights) {
          const night = 1 - ndotl;
          if (night > 0.15) {
            const v = 0.5 + 0.5 * noise1(nx*50, ny*50, nz*50);
            if (v > 0.68) {
              const e = (v - 0.68) / 0.32 * night * 0.8;
              litRGB = [
                litRGB[0] + cityRGB[0] * e,
                litRGB[1] + cityRGB[1] * e,
                litRGB[2] + cityRGB[2] * e
              ];
            }
          }
        }

        // Lava glow fissures
        if (glowLava && !gasBands) {
          const fiss = 0.5 + 0.5 * noise2(nx*12.0, ny*12.0, nz*12.0);
          if (fiss > 0.82) {
            const e = (fiss - 0.82) / 0.18;
            litRGB = [
              litRGB[0] + lavaRGB[0] * e * 0.35,
              litRGB[1] + lavaRGB[1] * e * 0.35,
              litRGB[2] + lavaRGB[2] * e * 0.35
            ];
          }
        }

        // Write pixel
        data[idx] = clamp255(litRGB[0]);
        data[idx+1] = clamp255(litRGB[1]);
        data[idx+2] = clamp255(litRGB[2]);
        data[idx+3] = 255;
      }
    }

    // Draw with a crisp limb (no inner alpha feather) to avoid inner-ring artifacts when compositing halos
    // Pixels outside the sphere are already alpha=0; inside are opaque from per-pixel write above.
    ctx.putImageData(img, 0, 0);

    // Atmosphere halo outside limb (renderer-based, not CSS)
    if (allowHalo) {
      ctx.save();
    const haloOuter = radius * haloScale;
    const hazeColor = (alpha) => `rgba(${clamp255(hazeRGB[0])},${clamp255(hazeRGB[1])},${clamp255(hazeRGB[2])},${alpha})`;
    const rimInner = radius * (1 - 0.02 * Math.min(1.4, haloSoftness));
    const haloBaseAlpha = Math.min(0.7, 0.14 + haloIntensity * 0.6);
    const highlightAlpha = Math.min(0.65, haloBaseAlpha * (0.68 + 0.2 * Math.max(0, lightDir[2])));
      const nightDim = Math.min(0.45, 0.18 + haloIntensity * 0.45);

      ctx.globalCompositeOperation = 'screen';
      const baseGrad = ctx.createRadialGradient(cx, cy, rimInner, cx, cy, haloOuter);
      baseGrad.addColorStop(0, hazeColor(0));
      baseGrad.addColorStop(1, hazeColor(haloBaseAlpha));
      ctx.fillStyle = baseGrad;
      ctx.beginPath();
      ctx.arc(cx, cy, haloOuter, 0, Math.PI * 2);
      ctx.moveTo(cx + radius, cy);
      ctx.arc(cx, cy, radius, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();

    const highlightShift = radius * (0.45 + 0.25 * haloSoftness);
    const dayX = cx + lightDir[0] * highlightShift;
    const dayY = cy + lightDir[1] * highlightShift;
      const highlight = ctx.createRadialGradient(dayX, dayY, radius * 0.4, dayX, dayY, haloOuter);
      highlight.addColorStop(0, hazeColor(highlightAlpha));
      highlight.addColorStop(1, hazeColor(0));
      const innerHighlight = radius * Math.max(0.78, 0.92 - 0.08 * (haloSoftness - 1));
      ctx.fillStyle = highlight;
      ctx.beginPath();
      ctx.arc(cx, cy, haloOuter, 0, Math.PI * 2);
      ctx.moveTo(cx + innerHighlight, cy);
      ctx.arc(cx, cy, innerHighlight, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();

    ctx.globalCompositeOperation = 'multiply';
    const nightX0 = cx - lightDir[0] * haloOuter * 1.4;
    const nightY0 = cy - lightDir[1] * haloOuter * 1.4;
    const nightX1 = cx + lightDir[0] * haloOuter * 1.4;
    const nightY1 = cy + lightDir[1] * haloOuter * 1.4;
      const nightGrad = ctx.createLinearGradient(nightX0, nightY0, nightX1, nightY1);
      nightGrad.addColorStop(0, `rgba(0,0,0,${nightDim})`);
      nightGrad.addColorStop(0.55, 'rgba(0,0,0,0.1)');
      nightGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = nightGrad;
      ctx.beginPath();
      ctx.arc(cx, cy, haloOuter, 0, Math.PI * 2);
      ctx.moveTo(cx + radius, cy);
      ctx.arc(cx, cy, radius, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    // Draw near half of ring in front of the planet
    if (hasRings) {
      drawRingHalf('near');
    }

    const url = cnv.toDataURL('image/png');
    planetSpriteCache.set(key, url);
    return url;
  }
  </script>
</body>
</html>
