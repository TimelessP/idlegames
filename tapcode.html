<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="application-name" content="IdleGames">
  <meta name="theme-color" content="#2d3748">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <script src="assets/js/pwa.js" defer></script>
  <title>Tap Code</title>
  <style>
    :root {
      --bg-color: #f7fafc;
      --text-color: #2d3748;
      --text-muted: #718096;
      --panel-bg: #ffffff;
      --border-color: #e2e8f0;
      --accent: #4a5568;
      --accent-hover: #2d3748;
      --btn-bg: #edf2f7;
      --btn-hover: #e2e8f0;
      --btn-active: #cbd5e0;
      --btn-send: #48bb78;
      --btn-send-hover: #38a169;
      --btn-stop: #f56565;
      --btn-stop-hover: #e53e3e;
      --grid-highlight: #bee3f8;
      --grid-active: #3182ce;

      --selection-bg: var(--grid-highlight);
      --selection-text: var(--text-color);

      --scrollbar-track: var(--panel-bg);
      --scrollbar-thumb: var(--btn-active);
      --scrollbar-thumb-hover: var(--accent);
    }

    [data-theme="dark"] {
      --bg-color: #1a202c;
      --text-color: #e2e8f0;
      --text-muted: #a0aec0;
      --panel-bg: #2d3748;
      --border-color: #4a5568;
      --accent: #a0aec0;
      --accent-hover: #e2e8f0;
      --btn-bg: #4a5568;
      --btn-hover: #718096;
      --btn-active: #2d3748;
      --btn-send: #48bb78;
      --btn-send-hover: #68d391;
      --btn-stop: #fc8181;
      --btn-stop-hover: #f56565;
      --grid-highlight: #2c5282;
      --grid-active: #63b3ed;

      --selection-bg: var(--grid-highlight);
      --selection-text: var(--text-color);

      --scrollbar-track: var(--panel-bg);
      --scrollbar-thumb: var(--btn-hover);
      --scrollbar-thumb-hover: var(--accent-hover);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    ::selection {
      background: var(--selection-bg);
      color: var(--selection-text);
    }

    ::-moz-selection {
      background: var(--selection-bg);
      color: var(--selection-text);
    }
    
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      padding: 1rem;
      transition: background 0.3s, color 0.3s;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .theme-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 0.5rem;
      color: var(--text-color);
      transition: background 0.2s;
    }

    .theme-btn:hover {
      background: var(--btn-hover);
    }

    .theme-btn svg {
      width: 24px;
      height: 24px;
    }

    /* Tap Code Grid */
    .grid-section {
      margin-bottom: 1.5rem;
    }

    .section-label {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tap-grid {
      display: grid;
      grid-template-columns: auto repeat(5, 1fr);
      gap: 2px;
      background: var(--panel-bg);
      border-radius: 0.75rem;
      padding: 0.75rem;
      font-size: 1rem;
    }

    .grid-header {
      font-weight: 600;
      text-align: center;
      padding: 0.5rem;
      color: var(--text-muted);
    }

    .grid-cell {
      text-align: center;
      padding: 0.625rem;
      border-radius: 0.375rem;
      transition: background 0.15s;
    }

    .grid-cell.letter {
      font-weight: 500;
      font-size: 1.6rem;
      line-height: 1.1;
      letter-spacing: 0.02em;
    }

    .grid-cell.highlight {
      background: var(--grid-highlight);
    }

    .grid-cell.active {
      background: var(--grid-active);
      color: white;
    }

    .grid-cell.ck {
      font-size: 1.1rem;
      letter-spacing: 0;
    }

    /* Text areas */
    .io-section {
      margin-bottom: 1.5rem;
    }

    .io-label {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .io-label svg {
      width: 16px;
      height: 16px;
    }

    textarea {
      width: 100%;
      min-height: 100px;
      padding: 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      background: var(--panel-bg);
      color: var(--text-color);
      font-family: inherit;
      font-size: 1rem;
      resize: vertical;
      transition: border-color 0.2s;

      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
    }

    textarea::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    textarea::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
      border-radius: 999px;
    }

    textarea::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb);
      border-radius: 999px;
      border: 2px solid var(--scrollbar-track);
    }

    textarea::-webkit-scrollbar-thumb:hover {
      background-color: var(--scrollbar-thumb-hover);
    }

    textarea::-webkit-scrollbar-corner {
      background: var(--scrollbar-track);
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Buttons */
    .btn-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      border: none;
      border-radius: 0.5rem;
      font-size: 0.9375rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn svg {
      width: 18px;
      height: 18px;
    }

    .btn-send {
      background: var(--btn-send);
      color: white;
    }

    .btn-send:hover:not(:disabled) {
      background: var(--btn-send-hover);
    }

    .btn-stop {
      background: var(--btn-stop);
      color: white;
    }

    .btn-stop:hover:not(:disabled) {
      background: var(--btn-stop-hover);
    }

    .btn-receive {
      background: var(--btn-bg);
      color: var(--text-color);
    }

    .btn-receive:hover:not(:disabled) {
      background: var(--btn-hover);
    }

    /* TX frequency controls */
    .freq-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .freq-row label {
      font-size: 0.875rem;
      color: var(--text-muted);
      white-space: nowrap;
    }

    .freq-row input[type="number"] {
      width: 8.5rem;
      padding: 0.5rem 0.65rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      background: var(--panel-bg);
      color: var(--text-color);
      font-family: inherit;
      font-size: 0.9375rem;
    }

    .freq-row input[type="number"]:focus {
      outline: none;
      border-color: var(--accent);
    }

    .freq-row .btn {
      flex: 0 0 auto;
      padding: 0.5rem 0.75rem;
      font-size: 0.875rem;
    }

    /* Status indicator */
    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-muted);
      margin-top: 0.5rem;
      min-height: 1.5rem;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .status-dot.sending {
      background: var(--btn-send);
      animation: pulse 0.5s ease-in-out infinite;
    }

    .status-dot.recording {
      background: var(--btn-stop);
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Tap visualization */
    .tap-viz {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin-top: 0.5rem;
      min-height: 24px;
      font-family: monospace;
      font-size: 0.875rem;
      color: var(--text-muted);
    }

    /* Info section */
    .info {
      background: var(--panel-bg);
      border-radius: 0.75rem;
      padding: 1rem;
      font-size: 0.8125rem;
      color: var(--text-muted);
      line-height: 1.6;
    }

    .info h3 {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 0.5rem;
    }

    .info ul {
      margin: 0.5rem 0;
      padding-left: 1.25rem;
    }

    .info li {
      margin: 0.25rem 0;
    }

    .info code {
      background: var(--btn-bg);
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
    }

    /* Debug section */
    .debug {
      background: var(--panel-bg);
      border-radius: 0.75rem;
      padding: 1rem;
      border: 1px solid var(--border-color);
      margin-top: 1.5rem;
    }

    .debug h3 {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .debug p {
      font-size: 0.8125rem;
      color: var(--text-muted);
      line-height: 1.5;
      margin-bottom: 0.75rem;
    }

    .debug-grid {
      display: grid;
      gap: 0.75rem;
    }

    .debug-card {
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      padding: 0.75rem;
      background: var(--bg-color);
    }

    .debug-card {
      cursor: pointer;
    }

    .debug-card:focus {
      outline: 2px solid var(--grid-active);
      outline-offset: 2px;
    }

    .debug-title {
      font-size: 0.8125rem;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .debug-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    canvas.debug-canvas {
      width: 100%;
      height: 140px;
      display: block;
      border-radius: 0.375rem;
      background: var(--panel-bg);
    }

    /* Fullscreen debug modal */
    .dbg-modal {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      background: var(--panel-bg);
      touch-action: none;
    }

    .dbg-modal.open {
      display: block;
    }

    .dbg-modal canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .dbg-modal .dbg-modal-close {
      position: fixed;
      top: 0.75rem;
      right: 0.75rem;
      z-index: 10000;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.55rem 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.65rem;
      background: rgba(0, 0, 0, 0.06);
      color: var(--text-color);
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      touch-action: manipulation;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(6px);
    }

    [data-theme="dark"] .dbg-modal .dbg-modal-close {
      background: rgba(255, 255, 255, 0.08);
    }

    .dbg-modal .dbg-modal-close:hover {
      background: rgba(0, 0, 0, 0.10);
    }

    [data-theme="dark"] .dbg-modal .dbg-modal-close:hover {
      background: rgba(255, 255, 255, 0.12);
    }

    .dbg-modal .dbg-modal-close:active {
      transform: scale(0.98);
    }

    .dbg-modal .dbg-modal-close:focus {
      outline: 2px solid var(--grid-active);
      outline-offset: 2px;
    }

    @media (max-width: 480px) {
      .tap-grid {
        font-size: 0.75rem;
      }
      .grid-cell {
        padding: 0.5rem 0.25rem;
      }
      .grid-cell.letter {
        font-size: 1.25rem;
      }
      .grid-cell.ck {
        font-size: 0.95rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>
        <svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
          <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
          <line x1="12" y1="19" x2="12" y2="22"/>
        </svg>
        Tap Code
      </h1>
      <button class="theme-btn" id="themeBtn" aria-label="Toggle theme">
        <svg id="systemIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
          <rect x="3" y="4" width="18" height="12" rx="2" />
          <path d="M8 20h8" />
          <path d="M12 16v4" />
        </svg>
        <svg id="sunIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"/>
          <line x1="12" y1="1" x2="12" y2="3"/>
          <line x1="12" y1="21" x2="12" y2="23"/>
          <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
          <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
          <line x1="1" y1="12" x2="3" y2="12"/>
          <line x1="21" y1="12" x2="23" y2="12"/>
          <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
          <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
        </svg>
        <svg id="moonIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
        </svg>
      </button>
    </header>

    <!-- Tap Code Grid -->
    <section class="grid-section" aria-label="Tap Code Reference Grid">
      <div class="section-label">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <rect x="3" y="3" width="7" height="7"/>
          <rect x="14" y="3" width="7" height="7"/>
          <rect x="14" y="14" width="7" height="7"/>
          <rect x="3" y="14" width="7" height="7"/>
        </svg>
        Polybius Square (5×5)
      </div>
      <div class="tap-grid" id="tapGrid" role="grid" aria-label="Tap code grid">
        <div class="grid-header"></div>
        <div class="grid-header">1</div>
        <div class="grid-header">2</div>
        <div class="grid-header">3</div>
        <div class="grid-header">4</div>
        <div class="grid-header">5</div>
        
        <div class="grid-header">1</div>
        <div class="grid-cell letter" data-pos="1,1">A</div>
        <div class="grid-cell letter" data-pos="1,2">B</div>
        <div class="grid-cell letter ck" data-pos="1,3">C/K</div>
        <div class="grid-cell letter" data-pos="1,4">D</div>
        <div class="grid-cell letter" data-pos="1,5">E</div>
        
        <div class="grid-header">2</div>
        <div class="grid-cell letter" data-pos="2,1">F</div>
        <div class="grid-cell letter" data-pos="2,2">G</div>
        <div class="grid-cell letter" data-pos="2,3">H</div>
        <div class="grid-cell letter" data-pos="2,4">I</div>
        <div class="grid-cell letter" data-pos="2,5">J</div>
        
        <div class="grid-header">3</div>
        <div class="grid-cell letter" data-pos="3,1">L</div>
        <div class="grid-cell letter" data-pos="3,2">M</div>
        <div class="grid-cell letter" data-pos="3,3">N</div>
        <div class="grid-cell letter" data-pos="3,4">O</div>
        <div class="grid-cell letter" data-pos="3,5">P</div>
        
        <div class="grid-header">4</div>
        <div class="grid-cell letter" data-pos="4,1">Q</div>
        <div class="grid-cell letter" data-pos="4,2">R</div>
        <div class="grid-cell letter" data-pos="4,3">S</div>
        <div class="grid-cell letter" data-pos="4,4">T</div>
        <div class="grid-cell letter" data-pos="4,5">U</div>
        
        <div class="grid-header">5</div>
        <div class="grid-cell letter" data-pos="5,1">V</div>
        <div class="grid-cell letter" data-pos="5,2">W</div>
        <div class="grid-cell letter" data-pos="5,3">X</div>
        <div class="grid-cell letter" data-pos="5,4">Y</div>
        <div class="grid-cell letter" data-pos="5,5">Z</div>
      </div>
    </section>

    <!-- Send Section -->
    <section class="io-section" aria-label="Send message">
      <label class="io-label" for="sendInput">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <line x1="22" y1="2" x2="11" y2="13"/>
          <polygon points="22 2 15 22 11 13 2 9 22 2"/>
        </svg>
        Message to Send
      </label>
      <textarea id="sendInput" placeholder="Type message to send as tap code..." aria-describedby="sendHelp"></textarea>
      <div class="btn-group">
        <button class="btn btn-receive" id="encodeBtn" aria-label="Encode message to dot lines">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 7h16" />
            <path d="M4 12h10" />
            <path d="M4 17h16" />
            <circle cx="18" cy="12" r="1.5" fill="currentColor" stroke="none" />
            <circle cx="21" cy="12" r="1.5" fill="currentColor" stroke="none" />
          </svg>
          Encode
        </button>
        <button class="btn btn-send" id="sendBtn" aria-label="Start sending">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <polygon points="5 3 19 12 5 21 5 3"/>
          </svg>
          Send
        </button>
        <button class="btn btn-stop" id="stopSendBtn" disabled aria-label="Stop sending">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <rect x="6" y="6" width="12" height="12" rx="2"/>
          </svg>
          Stop
        </button>
      </div>

      <div class="freq-row" aria-label="Transmit tone frequency">
        <label for="txFreqHz">Tone (Hz)</label>
        <input id="txFreqHz" type="number" inputmode="numeric" min="200" max="4000" step="10" aria-label="Transmit tone frequency in Hz" />
        <button class="btn btn-receive" id="txFreqResetBtn" type="button" aria-label="Reset tone frequency">Reset</button>
      </div>

      <div class="btn-group" aria-label="Export audio">
        <button class="btn btn-receive" id="exportSendWavBtn" type="button" aria-label="Export current send message as WAV">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          Export WAV
        </button>
      </div>

      <label class="io-label" for="encodedDots" style="margin-top: 1rem;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M4 7h16" />
          <path d="M4 12h16" />
          <path d="M4 17h16" />
        </svg>
        Encoded (dots, one line per character)
      </label>
      <textarea id="encodedDots" class="mono" placeholder="Example:\n•• •••\n• •••••\n\n(blank line = space)" aria-label="Encoded dot lines"></textarea>
      <div class="btn-group">
        <button class="btn btn-receive" id="decodeDotsBtn" aria-label="Decode dot lines into received message">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M4 7h16" />
            <path d="M4 12h10" />
            <path d="M4 17h16" />
            <path d="M16 10l4 2-4 2" />
          </svg>
          Decode
        </button>
        <button class="btn btn-receive" id="copyDotsBtn" aria-label="Copy encoded dot lines to clipboard">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="9" y="9" width="13" height="13" rx="2" />
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
          </svg>
          Copy
        </button>
      </div>
      <div class="status" id="sendStatus">
        <span class="status-dot" id="sendDot"></span>
        <span id="sendStatusText">Ready to send</span>
      </div>
      <div class="tap-viz" id="sendViz" aria-live="polite"></div>
    </section>

    <!-- Receive Section -->
    <section class="io-section" aria-label="Receive message">
      <label class="io-label" for="receiveOutput">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="7 10 12 15 17 10"/>
          <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        Received Message
      </label>
      <textarea id="receiveOutput" readonly placeholder="Decoded message will appear here..."></textarea>
      <div class="btn-group">
        <button class="btn btn-receive" id="receiveBtn" aria-label="Start recording">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <circle cx="12" cy="12" r="10"/>
            <circle cx="12" cy="12" r="4" fill="currentColor"/>
          </svg>
          Record
        </button>
        <button class="btn btn-stop" id="stopReceiveBtn" disabled aria-label="Stop recording and decode">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <rect x="6" y="6" width="12" height="12" rx="2"/>
          </svg>
          Stop &amp; Decode
        </button>
        <button class="btn btn-receive" id="copyReceivedBtn" aria-label="Copy received message to clipboard">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="9" y="9" width="13" height="13" rx="2" />
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
          </svg>
          Copy
        </button>
      </div>

      <div class="btn-group" aria-label="Audio import and export">
        <button class="btn btn-receive" id="importAudioBtn" type="button" aria-label="Import audio file and decode">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          Import Audio
        </button>
        <input id="importAudioFile" type="file" accept="audio/*,.wav,.mp3,.ogg,.webm" style="display:none" />
      </div>
      <div class="status" id="receiveStatus">
        <span class="status-dot" id="receiveDot"></span>
        <span id="receiveStatusText">Ready to receive</span>
      </div>
    </section>

    <!-- Info Section -->
    <section class="info" aria-label="How it works">
      <h3>How Tap Code Works</h3>
      <p>Each letter is encoded as two numbers: <strong>row</strong> then <strong>column</strong>.</p>
      <ul>
        <li><strong>H</strong> = row 2, col 3 → <code>•• •••</code> (2 taps, pause, 3 taps)</li>
        <li><strong>K</strong> uses <strong>C</strong>'s position (1,3)</li>
        <li><strong>X</strong> alone can mean a full stop (.)</li>
      </ul>
      <p><strong>Timing:</strong> Short pause between row/col. Longer pause between letters. Longest pause between words.</p>
      <p><strong>Symbols:</strong> Numbers spelled out (ONE, TWO...). Special chars: <code>AMP</code> (&amp;), <code>AT</code> (@), etc.</p>
      <p><strong>Receiver:</strong> Uses 800Hz tone detection with SNR analysis—works even with low volume tones in noisy environments or with speech.</p>
    </section>

    <!-- Debug Section -->
    <section class="debug" aria-label="Receiver debug analysis">
      <h3>
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M4 19h16" />
          <path d="M4 15l4-4 4 4 4-8 4 4" />
        </svg>
        Debug (Receiver)
      </h3>
      <p>Shows the spectrum for each processing step (raw → filtered) and the final envelope used for edge detection.</p>

      <div class="debug-grid">
        <div class="debug-card" data-debug-open="raw-spectrum" role="button" tabindex="0" aria-label="Open raw mic spectrum fullscreen">
          <div class="debug-title">
            <span>Raw mic spectrum</span>
            <span class="debug-meta" id="dbgRawMeta">—</span>
          </div>
          <canvas class="debug-canvas" id="dbgRawSpectrum" width="900" height="200" aria-label="Raw spectrum canvas"></canvas>
        </div>

        <div class="debug-card" data-debug-open="raw-waterfall" role="button" tabindex="0" aria-label="Open raw waterfall fullscreen">
          <div class="debug-title">
            <span>Raw waterfall (sideways)</span>
            <span class="debug-meta" id="dbgRawWaterMeta">—</span>
          </div>
          <canvas class="debug-canvas" id="dbgRawWaterfall" width="900" height="220" aria-label="Raw sideways waterfall canvas"></canvas>
        </div>

        <div class="debug-card" data-debug-open="filtered-spectrum" role="button" tabindex="0" aria-label="Open filtered spectrum fullscreen">
          <div class="debug-title">
            <span>Filtered spectrum (band-pass)</span>
            <span class="debug-meta" id="dbgFiltMeta">—</span>
          </div>
          <canvas class="debug-canvas" id="dbgFilteredSpectrum" width="900" height="200" aria-label="Filtered spectrum canvas"></canvas>
        </div>

        <div class="debug-card" data-debug-open="filtered-waterfall" role="button" tabindex="0" aria-label="Open filtered waterfall fullscreen">
          <div class="debug-title">
            <span>Filtered waterfall (sideways)</span>
            <span class="debug-meta" id="dbgFiltWaterMeta">—</span>
          </div>
          <canvas class="debug-canvas" id="dbgFilteredWaterfall" width="900" height="220" aria-label="Filtered sideways waterfall canvas"></canvas>
        </div>

        <div class="debug-card" data-debug-open="envelope" role="button" tabindex="0" aria-label="Open envelope and detected taps fullscreen">
          <div class="debug-title">
            <span>Envelope + detected taps</span>
            <span class="debug-meta" id="dbgEnvMeta">—</span>
          </div>
          <canvas class="debug-canvas" id="dbgEnvelope" width="900" height="200" aria-label="Envelope canvas"></canvas>
        </div>

        <div class="debug-card" data-debug-open="time-domain" role="button" tabindex="0" aria-label="Open time-domain level and edges fullscreen">
          <div class="debug-title">
            <span>Time-domain level + edges (filtered)</span>
            <span class="debug-meta" id="dbgTimeMeta">—</span>
          </div>
          <canvas class="debug-canvas" id="dbgTimeDomain" width="900" height="220" aria-label="Time-domain debug canvas"></canvas>
        </div>
      </div>
    </section>

    <div class="dbg-modal" id="dbgModal" role="dialog" aria-modal="true" aria-label="Debug fullscreen view">
      <button class="dbg-modal-close" id="dbgModalCloseBtn" type="button" aria-label="Close fullscreen chart">Close</button>
      <canvas id="dbgModalCanvas"></canvas>
    </div>
  </div>

  <script>
    // Tap Code Grid: A-Z without K (C/K share position 1,3)
    const TAP_GRID = [
      ['A', 'B', 'C', 'D', 'E'],  // row 1
      ['F', 'G', 'H', 'I', 'J'],  // row 2
      ['L', 'M', 'N', 'O', 'P'],  // row 3
      ['Q', 'R', 'S', 'T', 'U'],  // row 4
      ['V', 'W', 'X', 'Y', 'Z']   // row 5
    ];

    // Letter to [row, col] mapping (1-indexed)
    const LETTER_TO_POS = {};
    TAP_GRID.forEach((row, ri) => {
      row.forEach((letter, ci) => {
        LETTER_TO_POS[letter] = [ri + 1, ci + 1];
      });
    });
    LETTER_TO_POS['K'] = [1, 3]; // K uses C's position

    // Position to letter (for decoding)
    const POS_TO_LETTER = {};
    TAP_GRID.forEach((row, ri) => {
      row.forEach((letter, ci) => {
        POS_TO_LETTER[`${ri + 1},${ci + 1}`] = letter;
      });
    });

    // Symbol substitutions
    const SYMBOL_MAP = {
      '.': 'X',       // Full stop
      ',': 'COMMA',
      '?': 'QM',
      '!': 'EM',
      "'": 'APO',
      '"': 'QUO',
      '@': 'AT',
      '&': 'AMP',
      '#': 'HASH',
      '$': 'DOL',
      '%': 'PCT',
      '+': 'PLUS',
      '-': 'DASH',
      '=': 'EQ',
      '/': 'SL',
      '\\': 'BSL',
      '*': 'STAR',
      '(': 'LP',
      ')': 'RP',
      '[': 'LB',
      ']': 'RB',
      '{': 'LC',
      '}': 'RC',
      '<': 'LT',
      '>': 'GT',
      ':': 'COL',
      ';': 'SEMI',
      '_': 'UND',
      '^': 'CAR',
      '~': 'TIL',
      '|': 'PIPE',
      '`': 'BT',
      '0': 'ZERO',
      '1': 'ONE',
      '2': 'TWO',
      '3': 'THREE',
      '4': 'FOUR',
      '5': 'FIVE',
      '6': 'SIX',
      '7': 'SEVEN',
      '8': 'EIGHT',
      '9': 'NINE'
    };

    // Reverse map for decoding SYM escapes back to original characters.
    const TOKEN_TO_SYMBOL = Object.fromEntries(
      Object.entries(SYMBOL_MAP).map(([symbol, token]) => [token, symbol])
    );

    // Timing constants (ms)
    const TIMING = {
      TAP_DURATION: 90,        // More robust over speaker/mic/phone
      INTRA_TAP: 90,           // 1x unit
      ROW_COL_PAUSE: 270,      // 3x unit (switch row->col)
      LETTER_PAUSE: 540,       // 6x unit (end of letter)
      WORD_PAUSE: 900          // word gap (>= ~10x)
    };

    const TX_DEFAULT_FREQ = 800; // Hz (within phone band)

    // Audio context
    let audioCtx = null;

    function getAudioContext() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }

    // Text preprocessing: convert to tap-codeable format
    // Output must be only A-Z and spaces (tap code can't represent digits directly).
    function preprocessText(text) {
      let result = '';
      const input = String(text ?? '');

      const hexDigitToTapToken = (hexDigit) => {
        // Keep A-F as-is, convert 0-9 to their word tokens.
        if (hexDigit >= '0' && hexDigit <= '9') return SYMBOL_MAP[hexDigit];
        return hexDigit; // A-F
      };

      const bytesToHex = (bytes) => {
        let hex = '';
        for (const b of bytes) hex += b.toString(16).padStart(2, '0');
        return hex.toUpperCase();
      };

      const encodeCharAsHexTokens = (ch) => {
        // Prefer UTF-8 bytes so emoji/multibyte characters are stable.
        try {
          if (typeof TextEncoder !== 'undefined') {
            const bytes = new TextEncoder().encode(ch);
            return bytesToHex(bytes);
          }
        } catch {
          // fall through
        }

        // Fallback: code points to hex (best effort).
        const cp = ch.codePointAt(0);
        if (typeof cp === 'number') return cp.toString(16).toUpperCase();
        return '3F';
      };

      // Iterate by Unicode code points (for..of over a string).
      for (const rawChar of input) {
        const charUpper = rawChar.toUpperCase();

        if (rawChar === ' ' || rawChar === '\n' || rawChar === '\t') {
          result += ' ';
          continue;
        }

        if (LETTER_TO_POS[charUpper]) {
          result += charUpper;
          continue;
        }

        if (SYMBOL_MAP[rawChar]) {
          // Use an explicit escape prefix so decode can safely round-trip punctuation.
          result += 'SYM' + SYMBOL_MAP[rawChar];
          continue;
        }

        // Fallback: encode unknown/unprintable characters as hex.
        // Convert hex digits into tap-codeable tokens so encoding never emits '?'.
        const hex = encodeCharAsHexTokens(rawChar);
        result += 'HEX';
        for (const hd of hex) {
          result += hexDigitToTapToken(hd);
        }
      }

      // Collapse multiple spaces
      return result.replace(/\s+/g, ' ').trim();
    }

    // Convert text to tap sequence
    function textToTaps(text) {
      const processed = preprocessText(text);
      const taps = [];
      
      for (let i = 0; i < processed.length; i++) {
        const char = processed[i];
        
        if (char === ' ') {
          taps.push({ type: 'word_pause' });
        } else {
          const pos = LETTER_TO_POS[char];
          if (pos) {
            taps.push({
              type: 'letter',
              char: char,
              row: pos[0],
              col: pos[1]
            });
          }
        }
      }
      
      return taps;
    }

    // State
    let isSending = false;
    let sendAbort = null;
    let sendSource = null;
    let sendUiTimers = [];
    let txFrequencyHz = TX_DEFAULT_FREQ;
    let isRecording = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let lastDecodedAudioBuffer = null;
    let isDecoding = false;
    let pendingRedecode = false;
    let manualEnvelopeThresholds = null; // { thOn, thOff } in envelope units
    let forceDecodeFreqHz = null; // when user picks freq via chart

    // DOM elements
    const sendInput = document.getElementById('sendInput');
    const sendBtn = document.getElementById('sendBtn');
    const stopSendBtn = document.getElementById('stopSendBtn');
    const encodeBtn = document.getElementById('encodeBtn');
    const sendDot = document.getElementById('sendDot');
    const sendStatusText = document.getElementById('sendStatusText');
    const sendViz = document.getElementById('sendViz');
    const txFreqHzInput = document.getElementById('txFreqHz');
    const txFreqResetBtn = document.getElementById('txFreqResetBtn');
    const exportSendWavBtn = document.getElementById('exportSendWavBtn');
    const encodedDots = document.getElementById('encodedDots');
    const decodeDotsBtn = document.getElementById('decodeDotsBtn');
    const copyDotsBtn = document.getElementById('copyDotsBtn');
    const receiveOutput = document.getElementById('receiveOutput');
    const receiveBtn = document.getElementById('receiveBtn');
    const stopReceiveBtn = document.getElementById('stopReceiveBtn');
    const copyReceivedBtn = document.getElementById('copyReceivedBtn');
    const receiveDot = document.getElementById('receiveDot');
    const receiveStatusText = document.getElementById('receiveStatusText');
    const importAudioBtn = document.getElementById('importAudioBtn');
    const importAudioFile = document.getElementById('importAudioFile');
    const tapGrid = document.getElementById('tapGrid');

    // Debug DOM
    const dbgRawSpectrum = document.getElementById('dbgRawSpectrum');
    const dbgFilteredSpectrum = document.getElementById('dbgFilteredSpectrum');
    const dbgEnvelope = document.getElementById('dbgEnvelope');
    const dbgRawWaterfall = document.getElementById('dbgRawWaterfall');
    const dbgFilteredWaterfall = document.getElementById('dbgFilteredWaterfall');
    const dbgTimeDomain = document.getElementById('dbgTimeDomain');
    const dbgRawMeta = document.getElementById('dbgRawMeta');
    const dbgFiltMeta = document.getElementById('dbgFiltMeta');
    const dbgEnvMeta = document.getElementById('dbgEnvMeta');
    const dbgRawWaterMeta = document.getElementById('dbgRawWaterMeta');
    const dbgFiltWaterMeta = document.getElementById('dbgFiltWaterMeta');
    const dbgTimeMeta = document.getElementById('dbgTimeMeta');

    const dbgModal = document.getElementById('dbgModal');
    const dbgModalCanvas = document.getElementById('dbgModalCanvas');
    const dbgModalCloseBtn = document.getElementById('dbgModalCloseBtn');

    const lastDebug = {
      detectedFreq: null,
      rawSpec: null,
      rawWf: null,
      filtSpec: null,
      filtWf: null,
      env: null,
      stepMs: null,
      taps: null,
      thresholds: null,
      edgeFlags: null,
      filteredSamples: null,
      sampleRate: null
    };

    let modalType = null;

    // Highlight grid cell
    function highlightCell(row, col, isActive = false) {
      const cells = tapGrid.querySelectorAll('.grid-cell.letter');
      cells.forEach(cell => {
        cell.classList.remove('highlight', 'active');
        const pos = cell.dataset.pos;
        if (pos) {
          const [r, c] = pos.split(',').map(Number);
          if (r === row && c === col) {
            cell.classList.add(isActive ? 'active' : 'highlight');
          }
        }
      });
    }

    function clearHighlight() {
      const cells = tapGrid.querySelectorAll('.grid-cell.letter');
      cells.forEach(cell => {
        cell.classList.remove('highlight', 'active');
      });
    }

    function clamp(n, lo, hi) {
      return Math.max(lo, Math.min(hi, n));
    }

    function sanitizeTxFrequencyHz(value) {
      const v = Number(value);
      if (!isFinite(v)) return TX_DEFAULT_FREQ;
      // Keep within a reasonable phone-speaker / mic band.
      return Math.round(clamp(v, 200, 4000));
    }

    function parseTxFrequencyHzInput(raw) {
      const s = String(raw ?? '').trim();
      if (!s) return null;
      const v = Number(s);
      if (!isFinite(v)) return null;
      return v;
    }

    function setTxFrequencyHz(value, opts = {}) {
      const { updateInput = true, forceUpdateInput = false } = opts;
      txFrequencyHz = sanitizeTxFrequencyHz(value);

      const isEditing = txFreqHzInput && document.activeElement === txFreqHzInput;
      if (updateInput && txFreqHzInput && (!isEditing || forceUpdateInput)) {
        txFreqHzInput.value = String(txFrequencyHz);
      }
    }

    if (txFreqHzInput) {
      txFreqHzInput.value = String(txFrequencyHz);

      const commitTxFreqInput = () => {
        const parsed = parseTxFrequencyHzInput(txFreqHzInput.value);
        if (parsed === null) {
          // User cleared/entered something invalid; revert to the last valid value.
          txFreqHzInput.value = String(txFrequencyHz);
          return;
        }
        setTxFrequencyHz(parsed, { updateInput: true, forceUpdateInput: true });
      };

      // Do NOT clamp while the user is typing. Only commit on blur/Enter.
      txFreqHzInput.addEventListener('input', () => {
        // Intentionally left blank: allow natural typing (empty/partial) without snapping to min.
      });

      txFreqHzInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          commitTxFreqInput();
          txFreqHzInput.blur();
          return;
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          txFreqHzInput.value = String(txFrequencyHz);
          txFreqHzInput.blur();
        }
      });

      txFreqHzInput.addEventListener('blur', () => {
        commitTxFreqInput();
      });
    }

    if (txFreqResetBtn) {
      txFreqResetBtn.addEventListener('click', () => {
        setTxFrequencyHz(TX_DEFAULT_FREQ);
      });
    }

    function writeAscii(view, offset, str) {
      for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
    }

    function audioBufferToWavBlob(audioBuffer) {
      // 16-bit PCM, mono (mix-down if needed)
      const sampleRate = audioBuffer.sampleRate;
      const numChannels = audioBuffer.numberOfChannels;
      const length = audioBuffer.length;

      const mono = new Float32Array(length);
      if (numChannels === 1) {
        mono.set(audioBuffer.getChannelData(0));
      } else {
        for (let ch = 0; ch < numChannels; ch++) {
          const data = audioBuffer.getChannelData(ch);
          for (let i = 0; i < length; i++) mono[i] += data[i] / numChannels;
        }
      }

      const bytesPerSample = 2;
      const blockAlign = bytesPerSample * 1;
      const byteRate = sampleRate * blockAlign;
      const dataSize = length * bytesPerSample;
      const headerSize = 44;
      const buffer = new ArrayBuffer(headerSize + dataSize);
      const view = new DataView(buffer);

      // RIFF header
      writeAscii(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeAscii(view, 8, 'WAVE');

      // fmt chunk
      writeAscii(view, 12, 'fmt ');
      view.setUint32(16, 16, true); // PCM
      view.setUint16(20, 1, true);  // audio format = PCM
      view.setUint16(22, 1, true);  // channels = 1
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true); // bits per sample

      // data chunk
      writeAscii(view, 36, 'data');
      view.setUint32(40, dataSize, true);

      // PCM samples
      let off = 44;
      for (let i = 0; i < mono.length; i++) {
        const s = Math.max(-1, Math.min(1, mono[i]));
        const pcm = s < 0 ? s * 0x8000 : s * 0x7fff;
        view.setInt16(off, Math.round(pcm), true);
        off += 2;
      }

      return new Blob([buffer], { type: 'audio/wav' });
    }

    async function importAndDecodeAudioFile(file) {
      if (!file) return;
      try {
        const ctx = getAudioContext();
        receiveStatusText.textContent = `Importing ${file.name}...`;

        const arrayBuffer = await file.arrayBuffer();
        const audioBuffer = await ctx.decodeAudioData(arrayBuffer);

        lastDecodedAudioBuffer = audioBuffer;

        // Decode using current overrides (if user has selected them).
        await decodeAudioBuffer(audioBuffer, {
          forcedFreqHz: forceDecodeFreqHz,
          forcedThresholds: manualEnvelopeThresholds,
          reason: 'import'
        });
      } catch (err) {
        console.error('Import decode error:', err);
        // Browser support varies (notably for webm on some platforms).
        receiveStatusText.textContent = `Import failed: ${err.message || err}`;
      }
    }

    if (importAudioBtn && importAudioFile) {
      importAudioBtn.addEventListener('click', () => {
        try { importAudioFile.value = ''; } catch {}
        importAudioFile.click();
      });
      importAudioFile.addEventListener('change', async () => {
        const file = importAudioFile.files && importAudioFile.files[0];
        await importAndDecodeAudioFile(file);
      });
    }

    if (exportSendWavBtn) {
      exportSendWavBtn.addEventListener('click', async () => {
        const text = String(sendInput?.value || '').trim();
        if (!text) {
          if (sendStatusText) sendStatusText.textContent = 'Nothing to export';
          return;
        }

        exportSendWavBtn.disabled = true;
        const prevStatus = sendStatusText ? sendStatusText.textContent : '';
        if (sendStatusText) sendStatusText.textContent = 'Encoding WAV...';

        try {
          const taps = textToTaps(text);
          if (!taps.length) {
            if (sendStatusText) sendStatusText.textContent = 'Nothing to export';
            return;
          }

          const timeline = buildSendTimeline(taps);
          const ctx = getAudioContext();
          const audioBuffer = await renderTapCodeAudioBuffer(timeline, ctx.sampleRate);
          const blob = audioBufferToWavBlob(audioBuffer);

          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `tapcode-send-${Date.now()}.wav`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 10_000);

          if (sendStatusText) sendStatusText.textContent = 'WAV downloaded';
          setTimeout(() => {
            if (sendStatusText && !isSending) sendStatusText.textContent = prevStatus || 'Ready to send';
          }, 900);
        } catch (err) {
          console.error('Export send WAV error:', err);
          if (sendStatusText) sendStatusText.textContent = `Export failed: ${err.message || err}`;
        } finally {
          exportSendWavBtn.disabled = false;
        }
      });
    }

    // Play a tap sound
    async function playTap(frequency = 800) {
      const ctx = getAudioContext();

      // Ensure the audio device is running (some browsers start suspended).
      if (ctx.state === 'suspended') {
        try { await ctx.resume(); } catch {}
      }
      
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      
      oscillator.type = 'sine';
      oscillator.frequency.value = frequency;
      
      gainNode.gain.setValueAtTime(0, ctx.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.5, ctx.currentTime + 0.005);
      gainNode.gain.linearRampToValueAtTime(0.3, ctx.currentTime + TIMING.TAP_DURATION / 1000);
      gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + TIMING.TAP_DURATION / 1000 + 0.01);
      
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      
      oscillator.start();
      const endTime = ctx.currentTime + TIMING.TAP_DURATION / 1000 + 0.02;
      oscillator.stop(endTime);

      // Resolve when the actual audio finishes (more accurate than setTimeout).
      return new Promise(resolve => {
        let done = false;
        const finish = () => {
          if (done) return;
          done = true;
          resolve();
        };
        oscillator.onended = finish;
        // Fallback in case onended is delayed/not fired.
        setTimeout(finish, Math.ceil(TIMING.TAP_DURATION + 60));
      });
    }

    // Play actual silent audio for a duration (ms).
    // This is intentionally not just a JS delay: it streams zero-valued samples
    // so audio output paths/drivers have time to spin up before the first tone.
    async function playSilence(ms, signal) {
      const ctx = getAudioContext();

      if (ctx.state === 'suspended') {
        try { await ctx.resume(); } catch {}
      }

      const durationSec = Math.max(0, (ms || 0) / 1000);
      const frameCount = Math.max(1, Math.ceil(ctx.sampleRate * durationSec));
      const buffer = ctx.createBuffer(1, frameCount, ctx.sampleRate);
      // AudioBuffer is zero-filled by default (silence).

      const src = ctx.createBufferSource();
      src.buffer = buffer;
      src.connect(ctx.destination);

      let aborted = false;
      const abortHandler = () => {
        aborted = true;
        try { src.stop(); } catch {}
      };
      if (signal) {
        if (signal.aborted) abortHandler();
        else signal.addEventListener('abort', abortHandler, { once: true });
      }

      return new Promise((resolve) => {
        src.onended = () => {
          if (signal) signal.removeEventListener('abort', abortHandler);
          resolve(!aborted);
        };
        try {
          src.start();
        } catch {
          if (signal) signal.removeEventListener('abort', abortHandler);
          resolve(false);
        }
      });
    }

    // Sleep utility
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function clearSendUiTimers() {
      for (const t of sendUiTimers) clearTimeout(t);
      sendUiTimers = [];
    }

    function buildSendTimeline(tapTokens) {
      // Build absolute time events (ms) for both audio rendering and UI scheduling.
      // Timeline begins with a warm-up silence (WORD_PAUSE) to avoid missing first tap.
      let t = 0;
      const events = [];

      const freq = sanitizeTxFrequencyHz(txFrequencyHz);

      function addSilence(ms, reason = 'pause') {
        if (ms > 0) {
          events.push({ kind: 'silence', reason, startMs: t, durMs: ms });
          t += ms;
        }
      }

      function addTap(ms, frequency, meta) {
        events.push({ kind: 'tap', startMs: t, durMs: ms, frequency, meta });
        t += ms;
      }

      // Warm-up
      addSilence(TIMING.WORD_PAUSE, 'warmup');

      for (let i = 0; i < tapTokens.length; i++) {
        const tok = tapTokens[i];

        if (tok.type === 'word_pause') {
          addSilence(TIMING.WORD_PAUSE, 'word');
          continue;
        }

        // Letter: row taps, row->col gap, col taps, optional letter gap
        events.push({ kind: 'ui', type: 'letterStart', startMs: t, meta: { row: tok.row, col: tok.col, char: tok.char } });

        for (let r = 0; r < tok.row; r++) {
          addTap(TIMING.TAP_DURATION, freq, { phase: 'row', idx: r, ...tok });
          if (r < tok.row - 1) addSilence(TIMING.INTRA_TAP, 'intra');
        }

        addSilence(TIMING.ROW_COL_PAUSE, 'rowcol');

        for (let c = 0; c < tok.col; c++) {
          addTap(TIMING.TAP_DURATION, freq, { phase: 'col', idx: c, ...tok });
          if (c < tok.col - 1) addSilence(TIMING.INTRA_TAP, 'intra');
        }

        events.push({ kind: 'ui', type: 'letterEnd', startMs: t, meta: { row: tok.row, col: tok.col, char: tok.char } });

        if (i < tapTokens.length - 1 && tapTokens[i + 1].type !== 'word_pause') {
          addSilence(TIMING.LETTER_PAUSE, 'letter');
        }
      }

      return { events, totalMs: t };
    }

    async function renderTapCodeAudioBuffer(events, sampleRate) {
      const totalMs = Math.max(0, events.totalMs || 0);
      const durationSec = Math.max(0.01, totalMs / 1000);
      const length = Math.max(1, Math.ceil(sampleRate * durationSec));
      const offline = new OfflineAudioContext(1, length, sampleRate);

      // Render taps by scheduling oscillators; silences are implicit.
      for (const ev of (events.events || [])) {
        if (ev.kind !== 'tap') continue;
        const osc = offline.createOscillator();
        const g = offline.createGain();

        const startSec = ev.startMs / 1000;
        const tapDurSec = (ev.durMs || TIMING.TAP_DURATION) / 1000;
        const endSec = startSec + tapDurSec + 0.02;

        osc.type = 'sine';
        osc.frequency.setValueAtTime(ev.frequency || TX_DEFAULT_FREQ, startSec);

        // Envelope similar to playTap()
        g.gain.setValueAtTime(0, startSec);
        g.gain.linearRampToValueAtTime(0.5, startSec + 0.005);
        g.gain.linearRampToValueAtTime(0.3, startSec + tapDurSec);
        g.gain.linearRampToValueAtTime(0, startSec + tapDurSec + 0.01);

        osc.connect(g);
        g.connect(offline.destination);

        osc.start(startSec);
        osc.stop(endSec);
      }

      return offline.startRendering();
    }

    // Send tap code
    async function sendTapCode() {
      const text = sendInput.value.trim();
      if (!text) return;

      // Keep the dot-text representation in sync when sending.
      try { handleEncode(); } catch {}
      
      const taps = textToTaps(text);
      if (taps.length === 0) return;
      
      isSending = true;
      sendAbort = new AbortController();
      
      sendBtn.disabled = true;
      stopSendBtn.disabled = false;
      sendDot.classList.add('sending');
      sendStatusText.textContent = 'Encoding audio...';
      
      try {
        clearSendUiTimers();

        // Pre-render the entire message audio, then stream it.
        const timeline = buildSendTimeline(taps);
        const ctx = getAudioContext();

        const audioBuffer = await renderTapCodeAudioBuffer(timeline, ctx.sampleRate);
        if (sendAbort.signal.aborted) throw new Error('aborted');

        // Schedule UI updates from the same timeline (UI only).
        const startedAt = performance.now();
        for (const ev of timeline.events) {
          if (ev.kind !== 'ui') continue;
          const delay = Math.max(0, ev.startMs - (performance.now() - startedAt));
          const timer = setTimeout(() => {
            if (!isSending || sendAbort.signal.aborted) return;
            if (ev.type === 'letterStart') {
              const m = ev.meta;
              highlightCell(m.row, m.col, true);
              sendStatusText.textContent = `Sending: ${m.char}`;
              sendViz.textContent = '•'.repeat(m.row) + ' ' + '•'.repeat(m.col);
            } else if (ev.type === 'letterEnd') {
              highlightCell(ev.meta.row, ev.meta.col, false);
            }
          }, delay);
          sendUiTimers.push(timer);
        }

        sendStatusText.textContent = 'Sending...';

        // Stream
        sendSource = ctx.createBufferSource();
        sendSource.buffer = audioBuffer;
        sendSource.connect(ctx.destination);

        await new Promise((resolve, reject) => {
          let done = false;
          const finish = (err) => {
            if (done) return;
            done = true;
            resolve(err);
          };

          const abortHandler = () => {
            try { sendSource.stop(); } catch {}
            finish(new Error('aborted'));
          };
          if (sendAbort.signal.aborted) abortHandler();
          else sendAbort.signal.addEventListener('abort', abortHandler, { once: true });

          sendSource.onended = () => {
            sendAbort.signal.removeEventListener('abort', abortHandler);
            finish(null);
          };

          try {
            sendSource.start();
          } catch (e) {
            sendAbort.signal.removeEventListener('abort', abortHandler);
            reject(e);
          }
        });

        sendStatusText.textContent = sendAbort.signal.aborted ? 'Stopped' : 'Complete';
      } catch (err) {
        console.error('Send error:', err);
        sendStatusText.textContent = sendAbort?.signal?.aborted ? 'Stopped' : ('Error: ' + err.message);
      } finally {
        isSending = false;
        try { if (sendSource) sendSource.disconnect(); } catch {}
        sendSource = null;
        clearSendUiTimers();
        sendBtn.disabled = false;
        stopSendBtn.disabled = true;
        sendDot.classList.remove('sending');
        clearHighlight();
        setTimeout(() => {
          if (!isSending) {
            sendViz.textContent = '';
            sendStatusText.textContent = 'Ready to send';
          }
        }, 2000);
      }
    }

    function stopSending() {
      if (sendAbort) {
        sendAbort.abort();
      }
      try {
        if (sendSource) sendSource.stop();
      } catch {}
    }

    function encodeTextToDotLines(text) {
      const processed = preprocessText(text);
      const lines = [];
      for (const ch of processed) {
        if (ch === ' ') {
          lines.push('');
          continue;
        }
        const pos = LETTER_TO_POS[ch];
        if (!pos) {
          lines.push('?');
          continue;
        }
        lines.push('•'.repeat(pos[0]) + ' ' + '•'.repeat(pos[1]));
      }
      return lines.join('\n');
    }

    function parseDotLineToPos(line) {
      const trimmed = (line || '').trim();
      if (!trimmed) return { type: 'space' };
      if (trimmed === '/' || trimmed.toUpperCase() === 'SPACE') return { type: 'space' };

      // Accept both bullet dot and '.' for convenience.
      const normalized = trimmed.replace(/\.+/g, (m) => '•'.repeat(m.length));
      const parts = normalized.split(/\s+/).filter(Boolean);
      if (parts.length < 2) return null;

      const row = (parts[0].match(/[•]/g) || []).length;
      const col = (parts[1].match(/[•]/g) || []).length;
      if (row < 1 || row > 5 || col < 1 || col > 5) return null;
      return { row, col };
    }

    function decodeHexEscapes(text) {
      const src = String(text ?? '');
      const digitWords = [
        ['ZERO', '0'],
        ['ONE', '1'],
        ['TWO', '2'],
        ['THREE', '3'],
        ['FOUR', '4'],
        ['FIVE', '5'],
        ['SIX', '6'],
        ['SEVEN', '7'],
        ['EIGHT', '8'],
        ['NINE', '9']
      ];

      const textDecoder = (() => {
        try {
          if (typeof TextDecoder !== 'undefined') return new TextDecoder('utf-8', { fatal: false });
        } catch {
          // ignore
        }
        return null;
      })();

      const isHexLetter = (c) => c >= 'A' && c <= 'F';

      let out = '';
      let i = 0;
      while (i < src.length) {
        if (src.startsWith('HEX', i)) {
          let j = i + 3;
          let hexDigits = '';

          while (j < src.length) {
            // Prefer digit-words first (EIGHT starts with 'E', FIVE starts with 'F')
            // so we don't accidentally consume just the leading hex letter.
            let matched = false;
            for (const [word, digit] of digitWords) {
              if (src.startsWith(word, j)) {
                hexDigits += digit;
                j += word.length;
                matched = true;
                break;
              }
            }
            if (matched) continue;

            const c = src[j];
            if (isHexLetter(c)) {
              hexDigits += c;
              j += 1;
              continue;
            }

            break;
          }

          if (hexDigits.length >= 2 && hexDigits.length % 2 === 0 && textDecoder) {
            const bytes = new Uint8Array(hexDigits.length / 2);
            let ok = true;
            for (let k = 0; k < hexDigits.length; k += 2) {
              const byte = parseInt(hexDigits.slice(k, k + 2), 16);
              if (!Number.isFinite(byte)) {
                ok = false;
                break;
              }
              bytes[k / 2] = byte;
            }
            if (ok) {
              out += textDecoder.decode(bytes);
              i = j;
              continue;
            }
          }

          // If invalid/unsupported, leave as literal text.
          out += 'HEX';
          i += 3;
          continue;
        }

        out += src[i];
        i += 1;
      }

      return out;
    }

    function decodeSymbolEscapes(text) {
      const src = String(text ?? '');
      const tokenList = Object.keys(TOKEN_TO_SYMBOL).slice().sort((a, b) => b.length - a.length);

      let out = '';
      let i = 0;
      while (i < src.length) {
        if (src.startsWith('SYM', i)) {
          const start = i + 3;
          let matched = false;
          for (const token of tokenList) {
            if (src.startsWith(token, start)) {
              out += TOKEN_TO_SYMBOL[token];
              i = start + token.length;
              matched = true;
              break;
            }
          }
          if (matched) continue;

          // Unknown escape; treat literally.
          out += 'SYM';
          i += 3;
          continue;
        }

        out += src[i];
        i += 1;
      }

      return out;
    }

    function decodeDotLinesToText(dotText) {
      const lines = (dotText || '').replace(/\r\n/g, '\n').split('\n');
      let out = '';
      for (const line of lines) {
        const pos = parseDotLineToPos(line);
        if (!pos) {
          out += '?';
          continue;
        }
        if (pos.type === 'space') {
          out += ' ';
          continue;
        }
        const char = POS_TO_LETTER[`${pos.row},${pos.col}`];
        out += char ? char : '?';
      }
      return decodeSymbolEscapes(decodeHexEscapes(out));
    }

    function lettersToDotLines(letters) {
      const lines = [];
      for (const letter of (letters || [])) {
        if (letter && letter.type === 'space') {
          lines.push('');
          continue;
        }
        if (!letter || typeof letter.row !== 'number' || typeof letter.col !== 'number') {
          lines.push('?');
          continue;
        }
        lines.push('•'.repeat(letter.row) + ' ' + '•'.repeat(letter.col));
      }
      return lines.join('\n');
    }

    function handleEncode() {
      const text = sendInput.value || '';
      encodedDots.value = encodeTextToDotLines(text);
    }

    function handleDecodeDots() {
      const decoded = decodeDotLinesToText(encodedDots.value);
      receiveOutput.value = decoded;
      receiveStatusText.textContent = 'Decoded from dot text';
    }

    async function copyTextToClipboard(text) {
      const str = String(text ?? '');
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(str);
        return;
      }

      // Fallback for older browsers / blocked Clipboard API.
      const ta = document.createElement('textarea');
      ta.value = str;
      ta.setAttribute('readonly', '');
      ta.style.position = 'fixed';
      ta.style.top = '-1000px';
      ta.style.left = '-1000px';
      ta.style.opacity = '0';
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      if (!ok) throw new Error('Copy failed');
    }

    function withTempButtonLabel(btn, nextLabel, ms = 900) {
      if (!btn) return;
      const prev = btn.textContent;
      btn.textContent = nextLabel;
      window.setTimeout(() => {
        btn.textContent = prev;
      }, ms);
    }

    async function handleCopyButton(btn, text) {
      if (!btn) return;
      const str = String(text ?? '').trimEnd();
      if (!str) {
        withTempButtonLabel(btn, 'Empty', 900);
        return;
      }
      try {
        await copyTextToClipboard(str);
        withTempButtonLabel(btn, 'Copied', 900);
      } catch {
        withTempButtonLabel(btn, 'Failed', 900);
      }
    }

    // Recording for receiving
    async function startRecording() {
      try {
        // Try to capture as "raw" as possible; echo cancellation / noise suppression can erase a pure tone.
        // Some browsers ignore these, so we fall back safely.
        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              channelCount: 1,
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            }
          });
        } catch {
          stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        }
        
        audioChunks = [];
        mediaRecorder = new MediaRecorder(stream);
        
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };
        
        mediaRecorder.onstop = async () => {
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());
          
          if (audioChunks.length > 0) {
            receiveStatusText.textContent = 'Decoding...';
            await decodeRecording();
          }
        };
        
        mediaRecorder.start(100); // Collect in 100ms chunks
        
        isRecording = true;
        receiveBtn.disabled = true;
        stopReceiveBtn.disabled = false;
        receiveDot.classList.add('recording');
        receiveStatusText.textContent = 'Recording...';
        
      } catch (err) {
        console.error('Recording error:', err);
        receiveStatusText.textContent = 'Error: ' + err.message;
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      
      isRecording = false;
      receiveBtn.disabled = false;
      stopReceiveBtn.disabled = true;
      receiveDot.classList.remove('recording');
    }

    // --- Robust decoder: Goertzel tone detection + adaptive thresholds ---
    // Works much better than plain energy, especially with noise / speech / phone codecs.
    function hannMultiplier(i, n) {
      if (n <= 1) return 1;
      return 0.5 * (1 - Math.cos(2 * Math.PI * i / (n - 1)));
    }

    function goertzelPower(samples, sampleRate, targetFreq) {
      const n = samples.length;
      if (n === 0) return 0;
      const k = Math.round(0.5 + (n * targetFreq) / sampleRate);
      const omega = (2 * Math.PI * k) / n;
      const coeff = 2 * Math.cos(omega);
      let s0 = 0;
      let s1 = 0;
      let s2 = 0;
      for (let i = 0; i < n; i++) {
        s0 = samples[i] + coeff * s1 - s2;
        s2 = s1;
        s1 = s0;
      }
      // power at the normalized frequency bin
      const power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
      return power / (n * n);
    }

    function median(values) {
      if (!values.length) return 0;
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    function mad(values, med) {
      if (!values.length) return 0;
      const deviations = values.map(v => Math.abs(v - med));
      return median(deviations);
    }

    function estimateToneFrequency(channelData, sampleRate, frameSize, hopSize) {
      // Scan a small frequency range to auto-lock the tone (helps if phone codecs shift/warp slightly).
      // Important: ignore silence / low-energy frames, otherwise the "best" frequency can be random.
      const candidates = [];
      for (let f = 500; f <= 1500; f += 25) candidates.push(f);

      const maxFrames = 120;
      const stride = Math.max(1, Math.floor((channelData.length - frameSize) / (maxFrames * hopSize)));
      const scores = new Array(candidates.length).fill(0);
      const rmsValues = [];
      const frames = [];

      // 1) Sample frames and compute RMS
      for (let pos = 0; pos + frameSize < channelData.length && frames.length < maxFrames; pos += hopSize * stride) {
        let sum = 0;
        for (let i = 0; i < frameSize; i++) {
          const v = channelData[pos + i];
          sum += v * v;
        }
        const rms = Math.sqrt(sum / frameSize);
        rmsValues.push(rms);
        frames.push({ pos, rms });
      }

      if (!frames.length) return TX_DEFAULT_FREQ;

      const rmsMed = median(rmsValues);
      const rmsMad = mad(rmsValues, rmsMed) || 1e-9;
      const rmsGate = rmsMed + 4 * rmsMad;

      // 2) Score candidates only on the more energetic frames
      let used = 0;
      for (const fr of frames) {
        if (fr.rms < rmsGate) continue;
        const frame = new Array(frameSize);
        for (let i = 0; i < frameSize; i++) frame[i] = channelData[fr.pos + i] * hannMultiplier(i, frameSize);
        for (let c = 0; c < candidates.length; c++) {
          scores[c] += goertzelPower(frame, sampleRate, candidates[c]);
        }
        used++;
      }

      // If we didn't find any energetic frames (quiet recording), fall back.
      if (used === 0) return TX_DEFAULT_FREQ;

      let bestIdx = 0;
      for (let i = 1; i < scores.length; i++) {
        if (scores[i] > scores[bestIdx]) bestIdx = i;
      }
      const bestFreq = candidates[bestIdx] || TX_DEFAULT_FREQ;
      return bestFreq;
    }

    function medianOfNumbers(values) {
      return median(values);
    }

    function segmentsFromBoolean(flags, hopMs) {
      const segments = [];
      let startIdx = null;
      for (let i = 0; i < flags.length; i++) {
        if (flags[i]) {
          if (startIdx === null) startIdx = i;
        } else if (startIdx !== null) {
          segments.push({
            startIdx,
            endIdx: i,
            startMs: startIdx * hopMs,
            endMs: i * hopMs,
            on: true
          });
          startIdx = null;
        }
      }
      if (startIdx !== null) {
        segments.push({
          startIdx,
          endIdx: flags.length,
          startMs: startIdx * hopMs,
          endMs: flags.length * hopMs,
          on: true
        });
      }
      return segments;
    }

    function mergeShortGaps(segments, minGapMs) {
      if (segments.length <= 1) return segments;
      const merged = [segments[0]];
      for (let i = 1; i < segments.length; i++) {
        const prev = merged[merged.length - 1];
        const cur = segments[i];
        const gap = cur.startMs - prev.endMs;
        if (gap > 0 && gap < minGapMs) {
          // merge by extending previous
          prev.endMs = cur.endMs;
          prev.endIdx = cur.endIdx;
        } else {
          merged.push(cur);
        }
      }
      return merged;
    }

    function classifyPause(gapMs, unitMs) {
      // Unit-based bucketing. We keep this tolerant because phone calls add jitter.
      const x = gapMs / Math.max(1, unitMs);
      if (x < 2.2) return 'intra';
      if (x < 4.8) return 'rowcol';
      if (x < 9.0) return 'letter';
      return 'word';
    }

    function computePauseBoundaries(gapsMs, unitMs) {
      // Learn per-recording pause boundaries from the gap distribution.
      // We fit 4 clusters to normalized gaps (in units): intra (~1u), rowcol (~3u),
      // letter (~6u), word (~10u+). This keeps decoding stable across tempo drift.
      const u = Math.max(1, unitMs);
      const xs = (gapsMs || [])
        .map(g => g / u)
        .filter(x => isFinite(x) && x > 0.05 && x < 30)
        .sort((a, b) => a - b);
      if (xs.length < 4) return null;

      let centers = [1.0, 3.0, 6.0, 11.0];
      const iters = 18;
      for (let it = 0; it < iters; it++) {
        const buckets = [[], [], [], []];
        for (const x of xs) {
          let best = 0;
          let bestD = Math.abs(x - centers[0]);
          for (let k = 1; k < centers.length; k++) {
            const d = Math.abs(x - centers[k]);
            if (d < bestD) {
              bestD = d;
              best = k;
            }
          }
          buckets[best].push(x);
        }

        const next = centers.slice();
        for (let k = 0; k < buckets.length; k++) {
          const b = buckets[k];
          if (!b.length) continue;
          // Median is robust to a few bridged/merged gaps.
          next[k] = b[Math.floor(b.length * 0.5)];
        }

        // Enforce increasing order + minimum separation to avoid degenerate solutions.
        for (let k = 1; k < next.length; k++) {
          if (!(next[k] > next[k - 1] + 0.15)) next[k] = next[k - 1] + 0.15;
        }

        centers = next;
      }

      const b1 = (centers[0] + centers[1]) * 0.5;
      const b2 = (centers[1] + centers[2]) * 0.5;
      const b3 = (centers[2] + centers[3]) * 0.5;

      // Sanity clamp in case of pathological recordings.
      if (!(b1 > 0.6 && b2 > b1 && b3 > b2)) return null;
      return { b1, b2, b3, centers };
    }

    function classifyPauseAdaptive(gapMs, unitMs, boundaries) {
      if (!boundaries) return classifyPause(gapMs, unitMs);
      const x = gapMs / Math.max(1, unitMs);
      if (x < boundaries.b1) return 'intra';
      if (x < boundaries.b2) return 'rowcol';
      if (x < boundaries.b3) return 'letter';
      return 'word';
    }

    function estimateUnitMs(taps, gapsMs) {
      // Prefer gaps when tap segments have been widened by envelope smoothing/thresholds.
      // If unitMs is too large, row->col gaps shrink in unit-space and get misclassified
      // as intra, yielding 0 letters even when taps are correct.
      const tapDurations = (taps || [])
        .map(t => (t.end - t.start))
        .filter(d => isFinite(d) && d > 10)
        .sort((a, b) => a - b);
      const tapUnit = tapDurations.length ? tapDurations[Math.floor(tapDurations.length * 0.5)] : 0;

      const gaps = (gapsMs || [])
        .filter(g => isFinite(g) && g > 10)
        .sort((a, b) => a - b);
      const gapUnit = gaps.length ? gaps[Math.floor(gaps.length * 0.2)] : 0;

      if (tapUnit > 0 && gapUnit > 0) {
        const hi = Math.max(tapUnit, gapUnit);
        const lo = Math.min(tapUnit, gapUnit);
        // If they disagree a lot, trust the smaller (usually gaps).
        if (hi > lo * 1.7) return lo;
        return (tapUnit * 0.6) + (gapUnit * 0.4);
      }
      return tapUnit || gapUnit || TIMING.INTRA_TAP;
    }

    function decodeTapsToLetters(taps, opts = {}) {
      const maxCount = opts.maxCount ?? 5;
      const forceRowcolInRowMode = opts.forceRowcolInRowMode ?? true;

      const result = {
        letters: [],
        gaps: [],
        unitMs: NaN,
        pauseBoundaries: null,
        pauseCounts: { intra: 0, rowcol: 0, letter: 0, word: 0 },
        invalidLetters: 0
      };

      if (!taps || taps.length === 0) return result;
      if (taps.length === 1) {
        result.invalidLetters = 1;
        return result;
      }

      const gaps = [];
      for (let i = 1; i < taps.length; i++) gaps.push(taps[i].start - taps[i - 1].end);
      result.gaps = gaps;
      if (!gaps.length) {
        result.invalidLetters = 1;
        return result;
      }

      const unitMs = estimateUnitMs(taps, gaps);
      result.unitMs = unitMs;

      const pauseBoundaries = computePauseBoundaries(gaps, unitMs);
      result.pauseBoundaries = pauseBoundaries;

      let mode = 'row';
      let rowCount = null;
      let count = 1;

      function commitLetter(colCount) {
        if (rowCount !== null && rowCount >= 1 && rowCount <= maxCount && colCount >= 1 && colCount <= maxCount) {
          result.letters.push({ row: rowCount, col: colCount });
          return true;
        }
        result.invalidLetters++;
        return false;
      }

      for (let i = 0; i < gaps.length; i++) {
        let pauseType = classifyPauseAdaptive(gaps[i], unitMs, pauseBoundaries);

        if (pauseType === 'intra') {
          result.pauseCounts.intra++;
          count++;
          continue;
        }

        // Protocol-aware fallback:
        // In tap code, the first non-intra gap after row taps is the row->col separator.
        // If timing estimation drifts, adaptive bucketing can mislabel this as 'letter'
        // which drops the whole letter. Prefer interpreting it as rowcol while in 'row'.
        if (forceRowcolInRowMode && mode === 'row' && pauseType !== 'rowcol') {
          pauseType = 'rowcol';
        }

        if (pauseType === 'rowcol') {
          result.pauseCounts.rowcol++;
          if (mode === 'row') {
            rowCount = count;
            mode = 'col';
            count = 1;
          } else {
            // Unexpected rowcol while already in col: treat as letter boundary.
            commitLetter(count);
            mode = 'row';
            rowCount = null;
            count = 1;
          }
          continue;
        }

        if (pauseType === 'letter') result.pauseCounts.letter++;
        if (pauseType === 'word') result.pauseCounts.word++;

        // letter/word boundary
        if (mode === 'col') {
          commitLetter(count);
        } else {
          // Boundary without a row->col split.
          result.invalidLetters++;
        }

        mode = 'row';
        rowCount = null;
        count = 1;

        if (pauseType === 'word') result.letters.push({ type: 'space' });
      }

      // Finalize at end
      if (mode === 'col') commitLetter(count);
      else result.invalidLetters++;

      return result;
    }

    function percentile(values, p) {
      if (!values.length) return 0;
      const sorted = [...values].sort((a, b) => a - b);
      const idx = Math.min(sorted.length - 1, Math.max(0, Math.floor(p * (sorted.length - 1))));
      return sorted[idx];
    }

    async function bandpassFilterBuffer(audioBuffer, centerFreq, q = 20) {
      // Pass 1: isolate the target tone band before doing any edge detection.
      const sampleRate = audioBuffer.sampleRate;
      const offline = new OfflineAudioContext(1, audioBuffer.length, sampleRate);
      const src = offline.createBufferSource();
      src.buffer = audioBuffer;

      const hp = offline.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 200;

      const bp = offline.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.value = centerFreq;
      bp.Q.value = q;

      // Optional gentle gain boost to improve numeric stability after filtering.
      const gain = offline.createGain();
      gain.gain.value = 3.0;

      src.connect(hp);
      hp.connect(bp);
      bp.connect(gain);
      gain.connect(offline.destination);
      src.start(0);

      const rendered = await offline.startRendering();
      return rendered;
    }

    function extractEnvelope(samples, sampleRate, stepMs = 5, smoothMs = 18) {
      // Pass 2: envelope extraction for edge detection.
      const step = Math.max(1, Math.floor(sampleRate * (stepMs / 1000)));
      // IMPORTANT: we update the envelope once per "step" window, not per sample.
      // Use an exponential smoother with the correct effective time constant.
      const smoothSamples = Math.max(1, sampleRate * (smoothMs / 1000));
      const smoothCoeff = Math.exp(-step / smoothSamples);
      const env = [];
      let smoothed = 0;

      for (let i = 0; i < samples.length; i += step) {
        const end = Math.min(samples.length, i + step);
        let sum = 0;
        for (let j = i; j < end; j++) sum += Math.abs(samples[j]);
        const meanAbs = sum / Math.max(1, end - i);

        // One-pole low-pass smoothing
        smoothed = smoothCoeff * smoothed + (1 - smoothCoeff) * meanAbs;
        env.push(smoothed);
      }

      return { env, stepMs };
    }

    function edgesFromEnvelope(env, stepMs, opts = {}) {
      // Hysteresis thresholding on envelope, plus cleanup.
      const p10 = percentile(env, 0.10);
      const p50 = percentile(env, 0.50);
      const p90 = percentile(env, 0.90);
      const span = Math.max(1e-9, p90 - p10);

      // Thresholds relative to distribution; works even with low absolute amplitude.
      const defaultThOn = p10 + span * 0.45;
      const defaultThOff = p10 + span * 0.30;

      // If there's essentially no contrast, we won't detect taps.
      const hasContrast = span > Math.max(1e-6, p50 * 0.10);

      const minTapMs = 35;
      const maxTapMs = 600;
      const minGapMs = Math.max(20, stepMs * 2);

      // In noisy/speech environments, two dots can sometimes get bridged into a single
      // long "on" segment. Recover by splitting long segments into multiple taps by
      // counting peaks using only the top 2/5 of the segment's envelope range.
      function splitSegmentByTopTwoFifthsPeaks(seg) {
        const durMs = seg.endMs - seg.startMs;
        // Only attempt splitting on suspiciously long segments.
        if (durMs < 130) return [seg];
        const start = Math.max(0, seg.startIdx);
        const end = Math.min(env.length, seg.endIdx);
        if (end - start < 6) return [seg];

        let localMin = Infinity;
        let localMax = -Infinity;
        for (let i = start; i < end; i++) {
          const v = env[i];
          if (v < localMin) localMin = v;
          if (v > localMax) localMax = v;
        }
        const localSpan = localMax - localMin;
        if (!(localSpan > 0)) return [seg];

        // Keep only the top two fifths (top 40%) of the envelope range.
        const thHi = localMin + localSpan * 0.60;

        const peaks = [];
        let ps = null;
        for (let i = start; i < end; i++) {
          const hi = env[i] >= thHi;
          if (hi) {
            if (ps === null) ps = i;
          } else if (ps !== null) {
            peaks.push({ startIdx: ps, endIdx: i });
            ps = null;
          }
        }
        if (ps !== null) peaks.push({ startIdx: ps, endIdx: end });

        // Filter tiny high blobs that are likely noise.
        const minPeakMs = 15;
        const filtered = peaks.filter(p => (p.endIdx - p.startIdx) * stepMs >= minPeakMs);
        if (filtered.length <= 1) return [seg];

        // Find split boundaries at the valley (minimum) between successive peaks.
        const boundaries = [start];
        for (let k = 0; k < filtered.length - 1; k++) {
          const gapStart = filtered[k].endIdx;
          const gapEnd = filtered[k + 1].startIdx;
          if (gapEnd <= gapStart) continue;
          let minIdx = gapStart;
          let minVal = env[gapStart];
          for (let i = gapStart + 1; i < gapEnd; i++) {
            if (env[i] < minVal) {
              minVal = env[i];
              minIdx = i;
            }
          }
          boundaries.push(minIdx);
        }
        boundaries.push(end);

        const out = [];
        for (let i = 0; i < boundaries.length - 1; i++) {
          const s = boundaries[i];
          const e = boundaries[i + 1];
          if (e <= s) continue;
          out.push({
            startIdx: s,
            endIdx: e,
            startMs: s * stepMs,
            endMs: e * stepMs,
            on: true
          });
        }

        return out.length ? out : [seg];
      }

      function buildTapsFromThresholds(thOn, thOff) {
        // 1) Hysteresis flags
        const flags = new Array(env.length).fill(false);
        let on = false;
        for (let i = 0; i < env.length; i++) {
          const v = env[i];
          if (!on) {
            if (v >= thOn) on = true;
          } else {
            if (v <= thOff) on = false;
          }
          flags[i] = on;
        }

        // 2) flags -> segments
        let segs = segmentsFromBoolean(flags, stepMs);

        // Fill tiny dropouts and ignore tiny spikes.
        segs = mergeShortGaps(segs, minGapMs);

        // 3) Split suspiciously long "on" segments
        const splitSegs = [];
        for (const s of segs) splitSegs.push(...splitSegmentByTopTwoFifthsPeaks(s));

        const taps = splitSegs
          .map(s => ({ start: s.startMs, end: s.endMs, dur: s.endMs - s.startMs }))
          .filter(t => t.dur >= minTapMs && t.dur <= maxTapMs);

        return { taps, flags };
      }

      function letterStatsFromTaps(taps) {
        const decoded = decodeTapsToLetters(taps, { maxCount: 5, forceRowcolInRowMode: true });
        const validLetters = decoded.letters.filter(l => !l.type).length;
        const invalidLetters = decoded.invalidLetters || 0;
        const totalLetters = validLetters + invalidLetters;
        const spaces = decoded.letters.filter(l => l.type === 'space').length;
        const gapCount = decoded.gaps ? decoded.gaps.length : 0;
        return {
          unitMs: decoded.unitMs,
          validLetters,
          invalidLetters,
          totalLetters,
          spaces,
          pauseCounts: decoded.pauseCounts,
          gapCount
        };
      }

      function scoreCandidate(taps, stats) {
        // Prefer candidates that yield many valid letters and few invalid ones.
        // Add light regularization to avoid extremely noisy solutions.
        const tooManyTaps = Math.max(0, (taps?.length || 0) - 400);
        const unitPenalty = (!isFinite(stats.unitMs) || stats.unitMs <= 0)
          ? 200
          : Math.max(0, Math.abs(stats.unitMs - TIMING.TAP_DURATION) - 60); // tolerate large jitter

        // Tap-code letters require a distinct row->col separator pause (about 3x unit).
        // If thresholds are too low, envelope valleys get eaten and rowcol gaps collapse
        // into intra-tap gaps; decoding then fails even if peaks are clear.
        const totalLetters = Math.max(0, stats.totalLetters || 0);
        const rowcol = stats.pauseCounts?.rowcol || 0;
        const gapCount = Math.max(1, stats.gapCount || 1);
        const rowcolMissing = Math.max(0, totalLetters - rowcol);
        const rowcolMissingPenalty = rowcolMissing * 120;

        // If almost all gaps are intra, we're probably bridging pauses.
        const intraFrac = (stats.pauseCounts?.intra || 0) / gapCount;
        const bridgingPenalty = intraFrac > 0.92 ? (intraFrac - 0.92) * 900 : 0;

        return (
          stats.validLetters * 120
          - stats.invalidLetters * 180
          - (taps?.length || 0) * 0.6
          - tooManyTaps * 5
          - unitPenalty
          - rowcolMissingPenalty
          - bridgingPenalty
        );
      }

      // Auto-tune thresholds per decode by trying a small grid and scoring
      // how well the result groups into valid tap-code letters.
      let thOn = defaultThOn;
      let thOff = defaultThOff;
      let best = null;

      const forcedTh = opts && opts.forcedThresholds ? opts.forcedThresholds : null;
      if (forcedTh && isFinite(forcedTh.thOn) && isFinite(forcedTh.thOff)) {
        thOn = forcedTh.thOn;
        thOff = forcedTh.thOff;
        // Enforce hysteresis ordering.
        if (thOff >= thOn) {
          thOff = thOn - Math.max(span * 0.02, 1e-12);
        }
        best = { thOn, thOff, score: 0, built: buildTapsFromThresholds(thOn, thOff), stats: null };
      }

      if (!best && hasContrast) {
        const evalCandidate = (candOn, candOff) => {
          const built = buildTapsFromThresholds(candOn, candOff);
          // Early reject: if absurdly noisy, skip expensive scoring.
          if (built.taps.length > 900) return { score: -1e18, built };
          const stats = letterStatsFromTaps(built.taps);
          const score = scoreCandidate(built.taps, stats);
          return { score, built, stats };
        };

        // Seed with default
        {
          const r = evalCandidate(defaultThOn, defaultThOff);
          best = { thOn: defaultThOn, thOff: defaultThOff, ...r };
        }

        // Grid search over percent-of-span thresholds.
        // thOnFactor picks the ON threshold, thOffFactor sits below it for hysteresis.
        // Keep the search away from very low thresholds that tend to bridge gaps.
        for (let onF = 0.38; onF <= 0.78; onF += 0.02) {
          for (let delta = 0.12; delta <= 0.30; delta += 0.02) {
            const offF = onF - delta;
            if (offF < 0.05) continue;
            const candOn = p10 + span * onF;
            const candOff = p10 + span * offF;
            const r = evalCandidate(candOn, candOff);
            if (!best || r.score > best.score) best = { thOn: candOn, thOff: candOff, ...r };
          }
        }

        // If scoring failed for some reason, fall back.
        if (best && isFinite(best.thOn) && isFinite(best.thOff)) {
          thOn = best.thOn;
          thOff = best.thOff;
        }
      }

      const { taps, flags } = best && best.built ? best.built : buildTapsFromThresholds(thOn, thOff);

      return { taps, flags, thOn, thOff, span, hasContrast };
    }

    function clearDebugCanvases() {
      const canvases = [dbgRawSpectrum, dbgFilteredSpectrum, dbgEnvelope, dbgRawWaterfall, dbgFilteredWaterfall, dbgTimeDomain];
      for (const c of canvases) {
        if (!c) continue;
        const ctx = c.getContext('2d');
        ctx.clearRect(0, 0, c.width, c.height);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
        ctx.fillRect(0, 0, c.width, c.height);
      }
      if (dbgRawMeta) dbgRawMeta.textContent = '—';
      if (dbgFiltMeta) dbgFiltMeta.textContent = '—';
      if (dbgEnvMeta) dbgEnvMeta.textContent = '—';
      if (dbgRawWaterMeta) dbgRawWaterMeta.textContent = '—';
      if (dbgFiltWaterMeta) dbgFiltWaterMeta.textContent = '—';
      if (dbgTimeMeta) dbgTimeMeta.textContent = '—';
    }

    function nextPow2(n) {
      let p = 1;
      while (p < n) p <<= 1;
      return p;
    }

    function fftRadix2ReIm(re, im) {
      // In-place iterative Cooley–Tukey radix-2 FFT
      const n = re.length;
      // bit-reversal
      for (let i = 1, j = 0; i < n; i++) {
        let bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) {
          [re[i], re[j]] = [re[j], re[i]];
          [im[i], im[j]] = [im[j], im[i]];
        }
      }

      for (let len = 2; len <= n; len <<= 1) {
        const ang = -2 * Math.PI / len;
        const wlenRe = Math.cos(ang);
        const wlenIm = Math.sin(ang);
        for (let i = 0; i < n; i += len) {
          let wRe = 1;
          let wIm = 0;
          for (let j = 0; j < len / 2; j++) {
            const uRe = re[i + j];
            const uIm = im[i + j];
            const vRe = re[i + j + len / 2] * wRe - im[i + j + len / 2] * wIm;
            const vIm = re[i + j + len / 2] * wIm + im[i + j + len / 2] * wRe;

            re[i + j] = uRe + vRe;
            im[i + j] = uIm + vIm;
            re[i + j + len / 2] = uRe - vRe;
            im[i + j + len / 2] = uIm - vIm;

            const nextWRe = wRe * wlenRe - wIm * wlenIm;
            const nextWIm = wRe * wlenIm + wIm * wlenRe;
            wRe = nextWRe;
            wIm = nextWIm;
          }
        }
      }
    }

    function computeAveragedSpectrum(samples, sampleRate, opts = {}) {
      const fftSize = opts.fftSize || 2048;
      const hop = opts.hop || Math.floor(fftSize / 2);
      const maxFrames = opts.maxFrames || 80;
      const startHz = opts.startHz || 0;
      const endHz = opts.endHz || Math.min(4000, sampleRate / 2);

      const size = nextPow2(fftSize);
      const half = Math.floor(size / 2);
      const startBin = Math.max(0, Math.floor((startHz / sampleRate) * size));
      const endBin = Math.min(half - 1, Math.ceil((endHz / sampleRate) * size));

      const mags = new Float32Array(endBin - startBin + 1);
      let framesUsed = 0;

      // Sample frames across the clip to avoid spending time on long recordings.
      const maxPositions = Math.max(1, Math.floor((samples.length - fftSize) / hop));
      const stride = Math.max(1, Math.floor(maxPositions / maxFrames));

      for (let p = 0, count = 0; p + fftSize < samples.length && count < maxFrames; p += hop * stride, count++) {
        const re = new Float32Array(size);
        const im = new Float32Array(size);

        // windowed frame into re[]
        for (let i = 0; i < fftSize; i++) {
          re[i] = samples[p + i] * hannMultiplier(i, fftSize);
        }

        // Simple RMS gate to ignore near-silence frames
        let sum = 0;
        for (let i = 0; i < fftSize; i++) sum += re[i] * re[i];
        const rms = Math.sqrt(sum / fftSize);
        if (rms < 1e-4) continue;

        fftRadix2ReIm(re, im);
        for (let b = startBin; b <= endBin; b++) {
          const rr = re[b];
          const ii = im[b];
          const m = Math.sqrt(rr * rr + ii * ii);
          mags[b - startBin] += m;
        }
        framesUsed++;
      }

      if (framesUsed > 0) {
        for (let i = 0; i < mags.length; i++) mags[i] /= framesUsed;
      }

      return {
        mags,
        startHz,
        endHz,
        framesUsed,
        fftSize: size,
        binHz: sampleRate / size
      };
    }

    function peakInRange(spec, minHz, maxHz) {
      const start = spec.startHz;
      const end = spec.endHz;
      const lo = Math.max(start, minHz);
      const hi = Math.min(end, maxHz);
      if (hi <= lo || !spec.mags || !spec.mags.length) return { hz: NaN, value: 0 };
      const startIdx = Math.max(0, Math.floor((lo - start) / spec.binHz));
      const endIdx = Math.min(spec.mags.length - 1, Math.ceil((hi - start) / spec.binHz));
      let bestIdx = startIdx;
      for (let i = startIdx + 1; i <= endIdx; i++) {
        if (spec.mags[i] > spec.mags[bestIdx]) bestIdx = i;
      }
      return { hz: start + bestIdx * spec.binHz, value: spec.mags[bestIdx] };
    }

    function drawRainbowSpectrumTo(ctx, w, h, spec, highlightHz = null) {

      // Background
      const panelBg = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
      ctx.fillStyle = panelBg;
      ctx.fillRect(0, 0, w, h);

      const mags = spec.mags;
      if (!mags || mags.length === 0) return;

      // Log-scale amplitude normalization
      let max = 0;
      for (let i = 0; i < mags.length; i++) if (mags[i] > max) max = mags[i];
      const eps = 1e-12;
      const denom = Math.log(max + eps);

      const bars = Math.min(w, mags.length);
      const step = mags.length / bars;

      for (let x = 0; x < bars; x++) {
        const idx = Math.min(mags.length - 1, Math.floor(x * step));
        const v = mags[idx];
        const a = denom > 0 ? (Math.log(v + eps) / denom) : 0;
        const barH = Math.max(0, Math.min(1, a)) * (h - 22);

        const hz = spec.startHz + idx * spec.binHz;
        const hue = 260 - 260 * ((hz - spec.startHz) / Math.max(1, (spec.endHz - spec.startHz)));
        ctx.fillStyle = `hsl(${hue}, 90%, 55%)`;
        ctx.fillRect(x, h - 1 - barH, 1, barH);
      }

      // Axis line + labels
      const muted = getComputedStyle(document.documentElement).getPropertyValue('--text-muted') || '#888';
      ctx.strokeStyle = muted;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(0, h - 1);
      ctx.lineTo(w, h - 1);
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.fillStyle = muted;
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText(`${Math.round(spec.startHz)}Hz`, 8, 14);
      const endLabel = `${Math.round(spec.endHz)}Hz`;
      const textW = ctx.measureText(endLabel).width;
      ctx.fillText(endLabel, w - textW - 8, 14);

      // Highlight frequency marker
      if (highlightHz !== null && isFinite(highlightHz)) {
        const x = Math.round(((highlightHz - spec.startHz) / Math.max(1, (spec.endHz - spec.startHz))) * w);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-active') || '#3182ce';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(x, 18);
        ctx.lineTo(x, h - 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    function drawRainbowSpectrum(canvas, spec, highlightHz = null) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      drawRainbowSpectrumTo(ctx, canvas.width, canvas.height, spec, highlightHz);
    }

    function drawEnvelopeTo(ctx, w, h, env, stepMs, taps = [], thresholds = null) {
      const panelBg = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
      const muted = getComputedStyle(document.documentElement).getPropertyValue('--text-muted') || '#888';
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--grid-active') || '#3182ce';

      ctx.fillStyle = panelBg;
      ctx.fillRect(0, 0, w, h);

      if (!env || env.length < 2) return;
      let max = 0;
      for (let i = 0; i < env.length; i++) if (env[i] > max) max = env[i];
      max = Math.max(max, 1e-9);

      const totalMs = env.length * stepMs;

      // Draw detected tap regions
      if (taps && taps.length) {
        ctx.fillStyle = accent;
        ctx.globalAlpha = 0.12;
        for (const t of taps) {
          const x0 = Math.floor((t.start / totalMs) * w);
          const x1 = Math.ceil((t.end / totalMs) * w);
          ctx.fillRect(x0, 18, Math.max(1, x1 - x0), h - 26);
        }
        ctx.globalAlpha = 1;
      }

      // Draw envelope trace
      ctx.strokeStyle = muted;
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < env.length; i++) {
        const x = (i / (env.length - 1)) * w;
        const y = (h - 8) - (env[i] / max) * (h - 30);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Threshold lines
      if (thresholds && isFinite(thresholds.thOn) && isFinite(thresholds.thOff)) {
        const yOn = (h - 8) - (thresholds.thOn / max) * (h - 30);
        const yOff = (h - 8) - (thresholds.thOff / max) * (h - 30);
        ctx.strokeStyle = accent;
        ctx.globalAlpha = 0.65;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(0, yOn);
        ctx.lineTo(w, yOn);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, yOff);
        ctx.lineTo(w, yOff);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
      }

      // Labels
      ctx.fillStyle = muted;
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText(`0ms`, 8, 14);
      const endLabel = `${Math.round(totalMs)}ms`;
      const tw = ctx.measureText(endLabel).width;
      ctx.fillText(endLabel, w - tw - 8, 14);
    }

    function drawEnvelope(canvas, env, stepMs, taps = [], thresholds = null) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      drawEnvelopeTo(ctx, canvas.width, canvas.height, env, stepMs, taps, thresholds);
    }

    function computeSidewaysWaterfall(samples, sampleRate, opts = {}) {
      const fftSize = opts.fftSize || 1024;
      const hop = opts.hop || Math.floor(fftSize / 2);
      const maxRows = opts.maxRows || 180;
      const startHz = opts.startHz || 0;
      const endHz = opts.endHz || Math.min(4000, sampleRate / 2);

      const size = nextPow2(fftSize);
      const half = Math.floor(size / 2);
      const startBin = Math.max(0, Math.floor((startHz / sampleRate) * size));
      const endBin = Math.min(half - 1, Math.ceil((endHz / sampleRate) * size));
      const bins = endBin - startBin + 1;

      const maxPositions = Math.max(1, Math.floor((samples.length - fftSize) / hop));
      const stride = Math.max(1, Math.floor(maxPositions / maxRows));

      const rows = [];
      const rowRms = [];

      for (let p = 0, count = 0; p + fftSize < samples.length && count < maxRows; p += hop * stride, count++) {
        const re = new Float32Array(size);
        const im = new Float32Array(size);
        for (let i = 0; i < fftSize; i++) {
          re[i] = samples[p + i] * hannMultiplier(i, fftSize);
        }
        let sum = 0;
        for (let i = 0; i < fftSize; i++) sum += re[i] * re[i];
        const rms = Math.sqrt(sum / fftSize);
        rowRms.push(rms);

        fftRadix2ReIm(re, im);
        const row = new Float32Array(bins);
        for (let b = startBin; b <= endBin; b++) {
          const rr = re[b];
          const ii = im[b];
          row[b - startBin] = Math.sqrt(rr * rr + ii * ii);
        }
        rows.push(row);
      }

      // Robust normalize (log space) using global max
      let globalMax = 0;
      for (const r of rows) {
        for (let i = 0; i < r.length; i++) if (r[i] > globalMax) globalMax = r[i];
      }
      globalMax = Math.max(globalMax, 1e-12);

      return {
        rows,
        rowCount: rows.length,
        binCount: bins,
        startHz,
        endHz,
        binHz: sampleRate / size,
        globalMax,
        approxHopMs: (hop * stride / sampleRate) * 1000,
        rmsMed: median(rowRms),
        rmsMad: mad(rowRms, median(rowRms)) || 0
      };
    }

    function drawSidewaysWaterfallTo(ctx, w, h, wf, highlightHz = null) {
      const panelBg = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
      const muted = getComputedStyle(document.documentElement).getPropertyValue('--text-muted') || '#888';

      ctx.fillStyle = panelBg;
      ctx.fillRect(0, 0, w, h);
      if (!wf || !wf.rows || wf.rowCount === 0) return;

      const topPad = 18;
      const bottomPad = 8;
      const leftPad = 0;
      const drawW = w - leftPad;
      const drawH = h - topPad - bottomPad;

      const rows = wf.rows;
      const rowStep = Math.max(1, Math.floor(drawH / rows.length));
      const colStep = wf.binCount / Math.max(1, drawW);
      const eps = 1e-12;
      const denom = Math.log(wf.globalMax + eps);

      // time goes down (sideways waterfall), frequency left->right
      for (let r = 0; r < rows.length; r++) {
        const y0 = topPad + r * rowStep;
        const row = rows[r];
        for (let x = 0; x < drawW; x++) {
          const idx = Math.min(row.length - 1, Math.floor(x * colStep));
          const v = row[idx];
          const a = denom > 0 ? (Math.log(v + eps) / denom) : 0;
          const t = Math.max(0, Math.min(1, a));
          const hz = wf.startHz + idx * wf.binHz;
          const hue = 260 - 260 * ((hz - wf.startHz) / Math.max(1, (wf.endHz - wf.startHz)));
          // lightness encodes magnitude
          ctx.fillStyle = `hsl(${hue}, 90%, ${18 + 55 * t}%)`;
          ctx.fillRect(leftPad + x, y0, 1, rowStep);
        }
      }

      // Labels
      ctx.fillStyle = muted;
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText(`${Math.round(wf.startHz)}Hz`, 8, 14);
      const endLabel = `${Math.round(wf.endHz)}Hz`;
      const tw = ctx.measureText(endLabel).width;
      ctx.fillText(endLabel, w - tw - 8, 14);

      // Highlight frequency marker
      if (highlightHz !== null && isFinite(highlightHz)) {
        const x = Math.round(((highlightHz - wf.startHz) / Math.max(1, (wf.endHz - wf.startHz))) * w);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-active') || '#3182ce';
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        ctx.moveTo(x, topPad);
        ctx.lineTo(x, h - bottomPad);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }

    function drawSidewaysWaterfall(canvas, wf, highlightHz = null) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      drawSidewaysWaterfallTo(ctx, canvas.width, canvas.height, wf, highlightHz);
    }

    function drawTimeDomainLevelAndEdgesTo(ctx, w, h, samples, sampleRate, env, stepMs, edgeFlags) {
      const panelBg = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
      const muted = getComputedStyle(document.documentElement).getPropertyValue('--text-muted') || '#888';
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--grid-active') || '#3182ce';
      const stop = getComputedStyle(document.documentElement).getPropertyValue('--btn-stop') || '#f56565';

      ctx.fillStyle = panelBg;
      ctx.fillRect(0, 0, w, h);
      if (!samples || samples.length < 2) return;

      const topPad = 18;
      const bottomPad = 10;
      const midY = topPad + (h - topPad - bottomPad) / 2;
      const ampH = (h - topPad - bottomPad) / 2;

      // Downsample waveform to canvas width
      const stride = Math.max(1, Math.floor(samples.length / w));
      ctx.strokeStyle = muted;
      ctx.globalAlpha = 0.7;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x = 0; x < w; x++) {
        const start = x * stride;
        const end = Math.min(samples.length, start + stride);
        let min = 1;
        let max = -1;
        for (let i = start; i < end; i++) {
          const v = samples[i];
          if (v < min) min = v;
          if (v > max) max = v;
        }
        const y1 = midY - max * ampH;
        const y2 = midY - min * ampH;
        ctx.moveTo(x, y1);
        ctx.lineTo(x, y2);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;

      // Envelope overlay (scaled 0..1)
      if (env && env.length > 2) {
        let envMax = 0;
        for (let i = 0; i < env.length; i++) if (env[i] > envMax) envMax = env[i];
        envMax = Math.max(envMax, 1e-9);
        ctx.strokeStyle = accent;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        for (let i = 0; i < env.length; i++) {
          const t = i / (env.length - 1);
          const x = t * w;
          const y = (h - bottomPad) - (env[i] / envMax) * (h - topPad - bottomPad);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      // Edge flags band at bottom
      if (edgeFlags && edgeFlags.length) {
        const totalMs = edgeFlags.length * stepMs;
        ctx.fillStyle = stop;
        ctx.globalAlpha = 0.20;
        for (let i = 0; i < edgeFlags.length; i++) {
          if (!edgeFlags[i]) continue;
          const x0 = Math.floor(((i * stepMs) / totalMs) * w);
          const x1 = Math.ceil((((i + 1) * stepMs) / totalMs) * w);
          ctx.fillRect(x0, h - bottomPad - 10, Math.max(1, x1 - x0), 10);
        }
        ctx.globalAlpha = 1;

        // Explicit 0/1 step trace (what the decoder believes)
        ctx.strokeStyle = stop;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.9;
        const y0 = h - bottomPad - 6; // 0 line
        const y1 = h - bottomPad - 18; // 1 line
        ctx.beginPath();
        for (let i = 0; i < edgeFlags.length; i++) {
          const t = (i / (edgeFlags.length - 1)) * w;
          const y = edgeFlags[i] ? y1 : y0;
          if (i === 0) ctx.moveTo(t, y);
          else ctx.lineTo(t, y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      // Labels
      ctx.fillStyle = muted;
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText('waveform + envelope', 8, 14);
      const durMs = (samples.length / sampleRate) * 1000;
      const label = `${Math.round(durMs)}ms`;
      const tw = ctx.measureText(label).width;
      ctx.fillText(label, w - tw - 8, 14);
    }

    function drawTimeDomainLevelAndEdges(canvas, samples, sampleRate, env, stepMs, edgeFlags) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      drawTimeDomainLevelAndEdgesTo(ctx, canvas.width, canvas.height, samples, sampleRate, env, stepMs, edgeFlags);
    }

    function setCanvasHiDpi(canvas, cssW, cssH) {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.style.width = `${cssW}px`;
      canvas.style.height = `${cssH}px`;
      canvas.width = Math.max(1, Math.floor(cssW * dpr));
      canvas.height = Math.max(1, Math.floor(cssH * dpr));
      const ctx = canvas.getContext('2d');
      // Draw using CSS pixel coordinates.
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return { ctx, w: cssW, h: cssH };
    }

    function renderModal() {
      if (!dbgModal || !dbgModalCanvas || !modalType) return;
      const { ctx, w, h } = setCanvasHiDpi(dbgModalCanvas, window.innerWidth, window.innerHeight);
      const modalWantsHzSelector = (
        modalType === 'raw-spectrum' ||
        modalType === 'raw-waterfall' ||
        modalType === 'filtered-spectrum' ||
        modalType === 'filtered-waterfall'
      );

      const f = modalWantsHzSelector ? txFrequencyHz : lastDebug.detectedFreq;

      const drawHzLabel = (startHz, endHz) => {
        if (f === null || !isFinite(f)) return;
        const x = Math.round(((f - startHz) / Math.max(1, (endHz - startHz))) * w);
        const accent = getComputedStyle(document.documentElement).getPropertyValue('--grid-active') || '#3182ce';
        const panelBg = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
        const text = `${Math.round(f)}Hz`;

        ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        const tw = ctx.measureText(text).width;
        const padX = 8;
        const boxW = tw + padX * 2;
        const boxH = 22;
        const boxX = clamp(x - boxW / 2, 8, w - boxW - 8);
        const boxY = 22;

        ctx.globalAlpha = 0.95;
        ctx.fillStyle = panelBg;
        ctx.fillRect(boxX, boxY, boxW, boxH);
        ctx.globalAlpha = 1;

        ctx.strokeStyle = accent;
        ctx.globalAlpha = 0.7;
        ctx.strokeRect(boxX + 0.5, boxY + 0.5, boxW - 1, boxH - 1);
        ctx.globalAlpha = 1;

        ctx.fillStyle = accent;
        ctx.fillText(text, boxX + padX, boxY + 15);
      };

      if (modalType === 'raw-spectrum' && lastDebug.rawSpec) {
        drawRainbowSpectrumTo(ctx, w, h, lastDebug.rawSpec, f);
        if (modalWantsHzSelector) drawHzLabel(lastDebug.rawSpec.startHz, lastDebug.rawSpec.endHz);
      } else if (modalType === 'raw-waterfall' && lastDebug.rawWf) {
        drawSidewaysWaterfallTo(ctx, w, h, lastDebug.rawWf, f);
        if (modalWantsHzSelector) drawHzLabel(lastDebug.rawWf.startHz, lastDebug.rawWf.endHz);
      } else if (modalType === 'filtered-spectrum' && lastDebug.filtSpec) {
        drawRainbowSpectrumTo(ctx, w, h, lastDebug.filtSpec, f);
        if (modalWantsHzSelector) drawHzLabel(lastDebug.filtSpec.startHz, lastDebug.filtSpec.endHz);
      } else if (modalType === 'filtered-waterfall' && lastDebug.filtWf) {
        drawSidewaysWaterfallTo(ctx, w, h, lastDebug.filtWf, f);
        if (modalWantsHzSelector) drawHzLabel(lastDebug.filtWf.startHz, lastDebug.filtWf.endHz);
      } else if (modalType === 'envelope' && lastDebug.env) {
        const th = manualEnvelopeThresholds || lastDebug.thresholds || null;
        drawEnvelopeTo(ctx, w, h, lastDebug.env, lastDebug.stepMs || 5, lastDebug.taps || [], th);

        if (th && isFinite(th.thOn) && isFinite(th.thOff)) {
          const max = modalEnvelopeMax();
          const yOn = (h - 8) - (th.thOn / max) * (h - 30);
          const yOff = (h - 8) - (th.thOff / max) * (h - 30);

          const accent = getComputedStyle(document.documentElement).getPropertyValue('--grid-active') || '#3182ce';
          const panelBg = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
          ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';

          const labelFor = (name, val, y) => {
            const pct = Math.round((val / max) * 100);
            const text = `${name} ${pct}%`;
            const tw = ctx.measureText(text).width;
            const padX = 8;
            const boxW = tw + padX * 2;
            const boxH = 22;
            const boxX = 12;
            const boxY = clamp(y - boxH / 2, 22, h - boxH - 10);

            ctx.globalAlpha = 0.95;
            ctx.fillStyle = panelBg;
            ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.globalAlpha = 1;

            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.7;
            ctx.strokeRect(boxX + 0.5, boxY + 0.5, boxW - 1, boxH - 1);
            ctx.globalAlpha = 1;

            ctx.fillStyle = accent;
            ctx.fillText(text, boxX + padX, boxY + 15);
          };

          labelFor(modalEnvelopeActiveKey === 'thOn' ? 'ON*' : 'ON', th.thOn, yOn);
          labelFor(modalEnvelopeActiveKey === 'thOff' ? 'OFF*' : 'OFF', th.thOff, yOff);
        }
      } else if (modalType === 'time-domain' && lastDebug.filteredSamples) {
        drawTimeDomainLevelAndEdgesTo(ctx, w, h, lastDebug.filteredSamples, lastDebug.sampleRate || 48000, lastDebug.env || null, lastDebug.stepMs || 5, lastDebug.edgeFlags || null);
      } else {
        const panelBg = getComputedStyle(document.documentElement).getPropertyValue('--panel-bg') || '#fff';
        ctx.fillStyle = panelBg;
        ctx.fillRect(0, 0, w, h);
      }
    }

    function openDebugModal(type) {
      if (!dbgModal) return;
      modalType = type;
      modalCloseArmedAfterSelect = false;
      modalSelectingHz = false;
      modalTapToCloseCandidate = false;
      modalSelectMoved = false;
      modalCloseArmedAfterEnvelope = false;
      modalSelectingEnvelope = false;
      modalEnvelopeTapToCloseCandidate = false;
      modalEnvelopeMoved = false;
      dbgModal.classList.add('open');
      dbgModal.tabIndex = -1;
      dbgModal.focus({ preventScroll: true });
      renderModal();
    }

    function closeDebugModal() {
      if (!dbgModal) return;
      dbgModal.classList.remove('open');
      modalType = null;
      modalCloseArmedAfterSelect = false;
      modalSelectingHz = false;
      modalTapToCloseCandidate = false;
      modalSelectMoved = false;
      modalCloseArmedAfterEnvelope = false;
      modalSelectingEnvelope = false;
      modalEnvelopeTapToCloseCandidate = false;
      modalEnvelopeMoved = false;
    }

    async function closeDebugModalWithOptionalRedecode() {
      if (!dbgModal || !dbgModal.classList.contains('open')) return;

      const shouldRedecodeFreq = modalSupportsHzSelector() && modalCloseArmedAfterSelect;
      const shouldRedecodeEnv = modalSupportsEnvelopeThresholds() && modalCloseArmedAfterEnvelope;
      const forcedFreqHz = forceDecodeFreqHz ?? (shouldRedecodeFreq ? txFrequencyHz : getCurrentDecodeCenterFreqHz());
      const forcedThresholds = manualEnvelopeThresholds;

      closeDebugModal();

      if (shouldRedecodeFreq) {
        await requestRedecodeWithOverrides({
          forcedFreqHz: forcedFreqHz ?? txFrequencyHz,
          forcedThresholds
        });
      } else if (shouldRedecodeEnv && forcedThresholds) {
        await requestRedecodeWithOverrides({
          forcedFreqHz,
          forcedThresholds
        });
      }
    }

    // Avoid "click-through": do not close on pointerdown.
    // Close on pointerup/touchend/keyup and consume events while modal is shown.
    let modalArmed = false;
    let modalCloseArmedAfterSelect = false;
    let modalSelectingHz = false;
    let modalTapToCloseCandidate = false;
    let modalSelectMoved = false;
    let modalStartX = 0;

    let modalCloseArmedAfterEnvelope = false;
    let modalSelectingEnvelope = false;
    let modalEnvelopeTapToCloseCandidate = false;
    let modalEnvelopeMoved = false;
    let modalStartY = 0;
    let modalEnvelopeActiveKey = 'thOn';

    function modalSupportsHzSelector() {
      return (
        modalType === 'raw-spectrum' ||
        modalType === 'raw-waterfall' ||
        modalType === 'filtered-spectrum' ||
        modalType === 'filtered-waterfall'
      );
    }

    function modalSupportsEnvelopeThresholds() {
      return modalType === 'envelope' && lastDebug && lastDebug.env && lastDebug.env.length > 2;
    }

    function modalEnvelopeMax() {
      const env = lastDebug?.env;
      if (!env || env.length < 2) return 0;
      let mx = 0;
      for (let i = 0; i < env.length; i++) if (env[i] > mx) mx = env[i];
      return Math.max(mx, 1e-9);
    }

    function modalEnvelopeThresholdsFromClientY(clientY) {
      if (!dbgModalCanvas || !modalSupportsEnvelopeThresholds()) return null;
      const rect = dbgModalCanvas.getBoundingClientRect();
      const y = clamp(clientY - rect.top, 0, rect.height);
      const h = rect.height;
      const max = modalEnvelopeMax();
      const denom = Math.max(1, (h - 30));
      const val = ((h - 8) - y) / denom * max;
      return clamp(val, 0, max);
    }

    function modalPickNearestEnvelopeKey(clientY) {
      if (!dbgModalCanvas || !modalSupportsEnvelopeThresholds()) return 'thOn';
      const rect = dbgModalCanvas.getBoundingClientRect();
      const y = clamp(clientY - rect.top, 0, rect.height);
      const h = rect.height;
      const max = modalEnvelopeMax();

      const th = manualEnvelopeThresholds || lastDebug.thresholds;
      const thOn = th && isFinite(th.thOn) ? th.thOn : max * 0.45;
      const thOff = th && isFinite(th.thOff) ? th.thOff : max * 0.30;
      const yOn = (h - 8) - (thOn / max) * (h - 30);
      const yOff = (h - 8) - (thOff / max) * (h - 30);
      return Math.abs(y - yOn) <= Math.abs(y - yOff) ? 'thOn' : 'thOff';
    }

    function modalHzFromClientX(clientX) {
      if (!dbgModalCanvas) return null;
      const rect = dbgModalCanvas.getBoundingClientRect();
      const x = clamp(clientX - rect.left, 0, rect.width);

      let startHz = 0;
      let endHz = 0;
      if (modalType === 'raw-spectrum' && lastDebug.rawSpec) {
        startHz = lastDebug.rawSpec.startHz;
        endHz = lastDebug.rawSpec.endHz;
      } else if (modalType === 'raw-waterfall' && lastDebug.rawWf) {
        startHz = lastDebug.rawWf.startHz;
        endHz = lastDebug.rawWf.endHz;
      } else if (modalType === 'filtered-spectrum' && lastDebug.filtSpec) {
        startHz = lastDebug.filtSpec.startHz;
        endHz = lastDebug.filtSpec.endHz;
      } else if (modalType === 'filtered-waterfall' && lastDebug.filtWf) {
        startHz = lastDebug.filtWf.startHz;
        endHz = lastDebug.filtWf.endHz;
      } else {
        return null;
      }

      const hz = startHz + (x / Math.max(1, rect.width)) * (endHz - startHz);
      return sanitizeTxFrequencyHz(hz);
    }
    function consumeEvent(e) {
      // Some browsers will synthesize a click after touchend; preventDefault helps cancel it.
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
      if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
    }

    function isModalCloseUiEventTarget(target) {
      if (!target || !dbgModalCloseBtn) return false;
      if (target === dbgModalCloseBtn) return true;
      if (typeof target.closest === 'function') return !!target.closest('#dbgModalCloseBtn');
      return false;
    }

    if (dbgModal) {
      dbgModal.addEventListener('pointerdown', (e) => {
        if (isModalCloseUiEventTarget(e.target)) return;
        modalArmed = true;

        if (modalSupportsEnvelopeThresholds()) {
          modalSelectingEnvelope = true;
          modalEnvelopeMoved = false;
          modalStartY = e.clientY;
          modalEnvelopeTapToCloseCandidate = modalCloseArmedAfterEnvelope;
          modalEnvelopeActiveKey = modalPickNearestEnvelopeKey(e.clientY);

          if (!modalEnvelopeTapToCloseCandidate) {
            const val = modalEnvelopeThresholdsFromClientY(e.clientY);
            if (val !== null) {
              const max = modalEnvelopeMax();
              const th = manualEnvelopeThresholds || lastDebug.thresholds || { thOn: max * 0.45, thOff: max * 0.30 };
              let thOn = th.thOn;
              let thOff = th.thOff;
              if (modalEnvelopeActiveKey === 'thOn') thOn = val;
              else thOff = val;
              if (thOff >= thOn) {
                if (modalEnvelopeActiveKey === 'thOn') thOff = thOn - max * 0.01;
                else thOn = thOff + max * 0.01;
              }
              thOn = clamp(thOn, 0, max);
              thOff = clamp(thOff, 0, max);
              manualEnvelopeThresholds = { thOn, thOff };
              lastDebug.thresholds = manualEnvelopeThresholds;
              renderModal();
            }
          }

          consumeEvent(e);
          return;
        }

        if (modalSupportsHzSelector()) {
          modalSelectingHz = true;
          modalSelectMoved = false;
          modalStartX = e.clientX;
          modalTapToCloseCandidate = modalCloseArmedAfterSelect;

          // First interaction sets the frequency immediately.
          if (!modalTapToCloseCandidate) {
            const hz = modalHzFromClientX(e.clientX);
            if (hz !== null) {
              setTxFrequencyHz(hz);
              forceDecodeFreqHz = hz;
              renderModal();
            }
          }
        }
        consumeEvent(e);
      });

      dbgModal.addEventListener('pointermove', (e) => {
        if (isModalCloseUiEventTarget(e.target)) return;
        if (modalSelectingEnvelope) {
          consumeEvent(e);

          const dy = Math.abs(e.clientY - modalStartY);
          if (dy > 4) {
            modalEnvelopeMoved = true;
            modalEnvelopeTapToCloseCandidate = false;
          }

          if (!modalEnvelopeTapToCloseCandidate) {
            const val = modalEnvelopeThresholdsFromClientY(e.clientY);
            if (val !== null) {
              const max = modalEnvelopeMax();
              const th = manualEnvelopeThresholds || lastDebug.thresholds || { thOn: max * 0.45, thOff: max * 0.30 };
              let thOn = th.thOn;
              let thOff = th.thOff;
              if (modalEnvelopeActiveKey === 'thOn') thOn = val;
              else thOff = val;
              if (thOff >= thOn) {
                if (modalEnvelopeActiveKey === 'thOn') thOff = thOn - max * 0.01;
                else thOn = thOff + max * 0.01;
              }
              thOn = clamp(thOn, 0, max);
              thOff = clamp(thOff, 0, max);
              manualEnvelopeThresholds = { thOn, thOff };
              lastDebug.thresholds = manualEnvelopeThresholds;
              renderModal();
            }
          }
          return;
        }
        if (!modalSelectingHz) return;
        consumeEvent(e);

        const dx = Math.abs(e.clientX - modalStartX);
        if (dx > 4) {
          modalSelectMoved = true;
          modalTapToCloseCandidate = false;
        }

        if (!modalTapToCloseCandidate) {
          const hz = modalHzFromClientX(e.clientX);
          if (hz !== null) {
            setTxFrequencyHz(hz);
            forceDecodeFreqHz = hz;
            renderModal();
          }
        }
      });

      dbgModal.addEventListener('pointerup', (e) => {
        if (isModalCloseUiEventTarget(e.target)) return;
        consumeEvent(e);

        if (modalSelectingEnvelope) {
          modalSelectingEnvelope = false;

          // Finish selection; Close button dismisses the modal.
          const val = modalEnvelopeThresholdsFromClientY(e.clientY);
          if (val !== null) {
            const max = modalEnvelopeMax();
            const th = manualEnvelopeThresholds || lastDebug.thresholds || { thOn: max * 0.45, thOff: max * 0.30 };
            let thOn = th.thOn;
            let thOff = th.thOff;
            if (modalEnvelopeActiveKey === 'thOn') thOn = val;
            else thOff = val;
            if (thOff >= thOn) {
              if (modalEnvelopeActiveKey === 'thOn') thOff = thOn - max * 0.01;
              else thOn = thOff + max * 0.01;
            }
            thOn = clamp(thOn, 0, max);
            thOff = clamp(thOff, 0, max);
            manualEnvelopeThresholds = { thOn, thOff };
            lastDebug.thresholds = manualEnvelopeThresholds;
            renderModal();
          }
          modalCloseArmedAfterEnvelope = true;

          modalEnvelopeTapToCloseCandidate = false;
          modalEnvelopeMoved = false;
          modalArmed = false;
          return;
        }

        if (modalSupportsHzSelector()) {
          modalSelectingHz = false;

          // Finish selection; Close button dismisses the modal.
          const hz = modalHzFromClientX(e.clientX);
          if (hz !== null) {
            setTxFrequencyHz(hz);
            forceDecodeFreqHz = hz;
            renderModal();
          }
          modalCloseArmedAfterSelect = true;

          modalTapToCloseCandidate = false;
          modalSelectMoved = false;
          modalArmed = false;
          return;
        }

        // Modal no longer closes on background taps.
        modalArmed = false;
      });
      dbgModal.addEventListener('pointercancel', (e) => {
        if (isModalCloseUiEventTarget(e.target)) return;
        consumeEvent(e);
        if (modalSelectingEnvelope) {
          modalSelectingEnvelope = false;
          modalEnvelopeTapToCloseCandidate = false;
          modalEnvelopeMoved = false;
          modalCloseArmedAfterEnvelope = true;
          modalArmed = false;
          return;
        }
        if (modalSupportsHzSelector()) {
          modalSelectingHz = false;
          modalTapToCloseCandidate = false;
          modalSelectMoved = false;
          modalCloseArmedAfterSelect = true;
          modalArmed = false;
          return;
        }

        // Modal no longer closes on background taps.
        modalArmed = false;
      });

      // iOS Safari can still emit touch events in some cases.
      dbgModal.addEventListener('touchstart', (e) => {
        if (isModalCloseUiEventTarget(e.target)) return;
        modalArmed = true;
        consumeEvent(e);
      }, { passive: false });
      dbgModal.addEventListener('touchend', (e) => {
        if (isModalCloseUiEventTarget(e.target)) return;
        consumeEvent(e);
        if (modalSupportsEnvelopeThresholds()) modalCloseArmedAfterEnvelope = true;
        if (modalSupportsHzSelector()) modalCloseArmedAfterSelect = true;
        modalArmed = false;
      }, { passive: false });

      // Belt-and-suspenders: consume click on the modal surface.
      dbgModal.addEventListener('click', (e) => {
        if (isModalCloseUiEventTarget(e.target)) return;
        consumeEvent(e);
      }, true);

      dbgModal.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') {
          consumeEvent(e);
          return;
        }
        consumeEvent(e);
        closeDebugModalWithOptionalRedecode();
      });
    }

    // If a click still happens during/after closing, block it while modal is open.
    // Allow the explicit Close button to work.
    document.addEventListener('click', (e) => {
      if (!dbgModal || !dbgModal.classList.contains('open')) return;
      if (isModalCloseUiEventTarget(e.target)) return;
      consumeEvent(e);
    }, true);

    if (dbgModalCloseBtn) {
      dbgModalCloseBtn.addEventListener('click', (e) => {
        consumeEvent(e);
        closeDebugModalWithOptionalRedecode();
      });
    }

    window.addEventListener('resize', () => {
      if (dbgModal && dbgModal.classList.contains('open')) renderModal();
    });

    document.querySelectorAll('[data-debug-open]').forEach(el => {
      el.addEventListener('click', () => openDebugModal(el.dataset.debugOpen));
      el.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          openDebugModal(el.dataset.debugOpen);
        }
      });
    });

    function getCurrentDecodeCenterFreqHz() {
      const f = lastDebug?.detectedFreq;
      return (f !== null && f !== undefined && isFinite(f)) ? f : null;
    }

    async function requestRedecodeWithOverrides(overrides = {}) {
      if (!lastDecodedAudioBuffer || isRecording) return;
      pendingRedecode = true;
      if (isDecoding) return;
      pendingRedecode = false;

      const forcedFreqHz = overrides.forcedFreqHz ?? null;
      const forcedThresholds = overrides.forcedThresholds ?? null;
      await decodeAudioBuffer(lastDecodedAudioBuffer, { forcedFreqHz, forcedThresholds, reason: 'modal' });
    }

    async function decodeAudioBuffer(audioBuffer, opts = {}) {
      if (!audioBuffer) return;
      if (isDecoding) {
        pendingRedecode = true;
        return;
      }
      isDecoding = true;

      try {
        clearDebugCanvases();

        // Get audio data
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;

        // Frame settings: near-20ms frames work well over typical sample rates.
        const frameSize = Math.max(512, Math.min(2048, 1 << Math.round(Math.log2(sampleRate * 0.021))));
        const hopSize = Math.floor(frameSize / 2);

        const forced = opts.forcedFreqHz !== null && opts.forcedFreqHz !== undefined;
        const forcedFreq = forced ? sanitizeTxFrequencyHz(opts.forcedFreqHz) : null;
        const detectedFreq = forced ? forcedFreq : estimateToneFrequency(channelData, sampleRate, frameSize, hopSize);

        receiveStatusText.textContent = forced
          ? `Filtering (forced tone ${Math.round(detectedFreq)}Hz)...`
          : `Filtering (tone ~${Math.round(detectedFreq)}Hz)...`;

        lastDebug.detectedFreq = detectedFreq;
        lastDebug.sampleRate = sampleRate;

        // Debug: raw spectrum
        try {
          const rawSpec = computeAveragedSpectrum(channelData, sampleRate, { fftSize: 2048, startHz: 0, endHz: Math.min(4000, sampleRate / 2), maxFrames: 80 });
          const peak = peakInRange(rawSpec, 500, 1500);
          drawRainbowSpectrum(dbgRawSpectrum, rawSpec, detectedFreq);
          if (dbgRawMeta) dbgRawMeta.textContent = `${rawSpec.framesUsed} frames, bin ${rawSpec.binHz.toFixed(1)}Hz, peak ${Math.round(peak.hz)}Hz`;
          lastDebug.rawSpec = rawSpec;
        } catch {
          if (dbgRawMeta) dbgRawMeta.textContent = 'spectrum error';
        }

        // Debug: raw waterfall
        try {
          const wf = computeSidewaysWaterfall(channelData, sampleRate, { fftSize: 1024, startHz: 0, endHz: Math.min(4000, sampleRate / 2), maxRows: 170 });
          drawSidewaysWaterfall(dbgRawWaterfall, wf, detectedFreq);
          if (dbgRawWaterMeta) dbgRawWaterMeta.textContent = `${wf.rowCount} rows, ~${wf.approxHopMs.toFixed(0)}ms/row`;
          lastDebug.rawWf = wf;
        } catch {
          if (dbgRawWaterMeta) dbgRawWaterMeta.textContent = 'waterfall error';
        }

        // Pass 1: Filter
        // Slightly wider than before; too-high Q can miss if detection is off by ~tens of Hz.
        const filtered = await bandpassFilterBuffer(audioBuffer, detectedFreq, 8);
        const filteredSamples = filtered.getChannelData(0);
        lastDebug.filteredSamples = filteredSamples;

        // Debug: filtered spectrum
        try {
          const filtSpec = computeAveragedSpectrum(filteredSamples, sampleRate, { fftSize: 2048, startHz: 0, endHz: Math.min(4000, sampleRate / 2), maxFrames: 80 });
          const peak = peakInRange(filtSpec, 500, 1500);
          drawRainbowSpectrum(dbgFilteredSpectrum, filtSpec, detectedFreq);
          if (dbgFiltMeta) {
            dbgFiltMeta.textContent = `Q 8 @ ${Math.round(detectedFreq)}Hz, ${filtSpec.framesUsed} frames, peak ${Math.round(peak.hz)}Hz`;
          }
          lastDebug.filtSpec = filtSpec;
        } catch {
          if (dbgFiltMeta) dbgFiltMeta.textContent = 'spectrum error';
        }

        // Debug: filtered waterfall
        try {
          const wf = computeSidewaysWaterfall(filteredSamples, sampleRate, { fftSize: 1024, startHz: 0, endHz: Math.min(4000, sampleRate / 2), maxRows: 170 });
          drawSidewaysWaterfall(dbgFilteredWaterfall, wf, detectedFreq);
          if (dbgFiltWaterMeta) dbgFiltWaterMeta.textContent = `Q 8 @ ${Math.round(detectedFreq)}Hz, ${wf.rowCount} rows`;
          lastDebug.filtWf = wf;
        } catch {
          if (dbgFiltWaterMeta) dbgFiltWaterMeta.textContent = 'waterfall error';
        }

        // Pass 2: Envelope + edge detection
        const { env, stepMs } = extractEnvelope(filteredSamples, sampleRate, 5, 18);
        const edge = edgesFromEnvelope(env, stepMs, { forcedThresholds: opts.forcedThresholds });
        const { taps, hasContrast } = edge;

        lastDebug.env = env;
        lastDebug.stepMs = stepMs;
        lastDebug.taps = taps;
        lastDebug.thresholds = { thOn: edge.thOn, thOff: edge.thOff };
        lastDebug.edgeFlags = edge.flags;

        // Debug: envelope + taps
        try {
          drawEnvelope(dbgEnvelope, env, stepMs, taps, { thOn: edge.thOn, thOff: edge.thOff });
          if (dbgEnvMeta) dbgEnvMeta.textContent = `step ${stepMs}ms, span ${edge.span.toExponential(2)}`;
        } catch {
          if (dbgEnvMeta) dbgEnvMeta.textContent = 'envelope error';
        }

        // Debug: time-domain level + edges
        try {
          drawTimeDomainLevelAndEdges(dbgTimeDomain, filteredSamples, sampleRate, env, stepMs, edge.flags);
          if (dbgTimeMeta) dbgTimeMeta.textContent = `${Math.round((filteredSamples.length / sampleRate) * 1000)}ms, step ${stepMs}ms`;
        } catch {
          if (dbgTimeMeta) dbgTimeMeta.textContent = 'time-domain error';
        }

        if (dbgModal && dbgModal.classList.contains('open')) renderModal();

        receiveStatusText.textContent = forced
          ? `Decoding (forced ${Math.round(detectedFreq)}Hz, taps ${taps.length})...`
          : `Decoding (tone ~${Math.round(detectedFreq)}Hz, taps ${taps.length})...`;

        if (taps.length === 0) {
          receiveStatusText.textContent = hasContrast
            ? `No taps detected after filtering (${forced ? 'forced' : 'tone ~'}${Math.round(detectedFreq)}Hz). Try higher volume / closer mic.`
            : `No usable tone contrast detected. Try higher volume / quieter room.`;
          receiveOutput.value = '';
          return;
        }

        const decodedTiming = decodeTapsToLetters(taps, { maxCount: 5, forceRowcolInRowMode: true });
        const letters = decodedTiming.letters;

        // Convert to text (tap-code letters)
        let decoded = '';
        for (const letter of letters) {
          if (letter.type === 'space') {
            decoded += ' ';
          } else {
            const key = `${letter.row},${letter.col}`;
            const char = POS_TO_LETTER[key];
            decoded += char ? char : '?';
          }
        }

        // Also populate the dot-lines textarea with what we heard.
        encodedDots.value = lettersToDotLines(letters);

        // Apply HEX/SYM escape decoding so received messages round-trip.
        const decodedDisplay = decodeSymbolEscapes(decodeHexEscapes(decoded));

        receiveOutput.value = decodedDisplay;
        receiveStatusText.textContent = `Decoded ${letters.filter(l => !l.type).length} letters`;
      } catch (err) {
        console.error('Decode error:', err);
        receiveStatusText.textContent = 'Decode error: ' + err.message;
      } finally {
        isDecoding = false;
        if (pendingRedecode && lastDecodedAudioBuffer && !isRecording) {
          pendingRedecode = false;
          // Re-run once with the latest selected tone.
          decodeAudioBuffer(lastDecodedAudioBuffer, {
            forcedFreqHz: forceDecodeFreqHz ?? getCurrentDecodeCenterFreqHz(),
            forcedThresholds: manualEnvelopeThresholds,
            reason: 'pending'
          });
        }
      }
    }

    // Decode the recorded audio
    async function decodeRecording() {
      try {
        const blob = new Blob(audioChunks, { type: 'audio/webm' });
        const arrayBuffer = await blob.arrayBuffer();

        const ctx = getAudioContext();
        const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
        lastDecodedAudioBuffer = audioBuffer;
        await decodeAudioBuffer(audioBuffer);
      } catch (err) {
        console.error('Decode error:', err);
        receiveStatusText.textContent = 'Decode error: ' + err.message;
      }
    }

    // Event listeners
    sendBtn.addEventListener('click', sendTapCode);
    stopSendBtn.addEventListener('click', stopSending);
    encodeBtn.addEventListener('click', handleEncode);
    decodeDotsBtn.addEventListener('click', handleDecodeDots);
    copyDotsBtn.addEventListener('click', () => handleCopyButton(copyDotsBtn, encodedDots.value));
    receiveBtn.addEventListener('click', startRecording);
    stopReceiveBtn.addEventListener('click', stopRecording);
    copyReceivedBtn.addEventListener('click', () => handleCopyButton(copyReceivedBtn, receiveOutput.value));

    // Theme handling
    const themeBtn = document.getElementById('themeBtn');
    const systemIcon = document.getElementById('systemIcon');
    const sunIcon = document.getElementById('sunIcon');
    const moonIcon = document.getElementById('moonIcon');
    const STORAGE_KEY = 'idlegames-tapcode-theme';

    function getSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    function updateThemeIcon(themePref) {
      systemIcon.style.display = themePref === 'system' ? 'block' : 'none';
      sunIcon.style.display = themePref === 'light' ? 'block' : 'none';
      moonIcon.style.display = themePref === 'dark' ? 'block' : 'none';
      themeBtn.setAttribute('aria-label', `Theme: ${themePref}. Click to change.`);
    }

    function applyTheme(themePref) {
      const effectiveTheme = themePref === 'system' ? getSystemTheme() : themePref;
      document.documentElement.dataset.theme = effectiveTheme;
      updateThemeIcon(themePref);
    }

    function cycleTheme() {
      const current = localStorage.getItem(STORAGE_KEY) || 'system';
      let next;
      
      if (current === 'system') {
        next = 'light';
      } else if (current === 'light') {
        next = 'dark';
      } else {
        next = 'system';
      }
      
      localStorage.setItem(STORAGE_KEY, next);
      applyTheme(next);
    }

    // Initialize theme
    const savedTheme = localStorage.getItem(STORAGE_KEY) || 'system';
    applyTheme(savedTheme);

    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      const current = localStorage.getItem(STORAGE_KEY) || 'system';
      if (current === 'system') {
        applyTheme('system');
      }
    });

    themeBtn.addEventListener('click', cycleTheme);
  </script>
  <script src="parental.js" defer></script>
</body>
</html>
