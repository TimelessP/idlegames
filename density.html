<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#1a1a1a">
    <title>Density</title>
    <link rel="icon" type="image/png" sizes="512x512" href="assets/appicons/idle-games-512x512px.png">
    <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512px.png">
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        :root {
            --tile-bg: #ffffff;
            --tile-bg-rgb: 255, 255, 255;
            --text-color: #1a1a1a;
            --text-muted: #666666;
            --shadow-color: rgba(0, 0, 0, 0.25);
            --inset-shadow: rgba(0, 0, 0, 0.15);
            --button-hover: rgba(0, 0, 0, 0.06);
            --button-active: rgba(0, 0, 0, 0.1);
            --accent-spin: #5a8a6e;
            --accent-add: #5a7a9a;
            --accent-delete: #9a6a6a;
            --accent-reset: #8a7a5a;
            --accent-up: #6a7a8a;
            --accent-down: #7a6a8a;
            --noise-opacity: 0.03;
            --grid-gap: 16px;
            --tile-radius: 8px;
            --button-radius: 6px;
            --base-unit: min(calc((100vw - 48px) / 2), 180px);
        }

        [data-theme="dark"] {
            --tile-bg: #1a1a1a;
            --tile-bg-rgb: 26, 26, 26;
            --text-color: #e8e8e8;
            --text-muted: #888888;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --inset-shadow: rgba(0, 0, 0, 0.4);
            --button-hover: rgba(255, 255, 255, 0.08);
            --button-active: rgba(255, 255, 255, 0.12);
            --accent-spin: #6a9a7e;
            --accent-add: #6a8aaa;
            --accent-delete: #aa7a7a;
            --accent-reset: #9a8a6a;
            --accent-up: #7a8a9a;
            --accent-down: #8a7a9a;
            --noise-opacity: 0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            min-height: 100vh;
            padding: var(--grid-gap);
            padding-top: max(var(--grid-gap), env(safe-area-inset-top));
            padding-bottom: max(var(--grid-gap), env(safe-area-inset-bottom));
            padding-left: max(var(--grid-gap), env(safe-area-inset-left));
            padding-right: max(var(--grid-gap), env(safe-area-inset-right));
            color: var(--text-color);
            transition: background 0.3s ease;
        }

        /* In fullscreen, ignore safe areas */
        :fullscreen body,
        ::backdrop {
            padding: var(--grid-gap) !important;
        }

        [data-theme="light"] body {
            background: linear-gradient(135deg, #e8e8f0 0%, #d8d8e0 100%);
        }

        [data-theme="dark"] body {
            background: linear-gradient(135deg, #0a0a0f 0%, #151520 100%);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, var(--base-unit));
            gap: var(--grid-gap);
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .tile {
            background-color: var(--tile-bg);
            border-radius: var(--tile-radius);
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 8px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .tile::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: var(--noise-opacity);
            pointer-events: none;
        }

        .tile.size-1x1 {
            width: var(--base-unit);
            height: var(--base-unit);
        }

        .tile.size-2x2 {
            width: calc(var(--base-unit) * 2 + var(--grid-gap));
            height: calc(var(--base-unit) * 2 + var(--grid-gap));
            grid-column: span 2;
            grid-row: span 2;
        }

        .tile.size-1x2 {
            width: calc(var(--base-unit) * 2 + var(--grid-gap));
            height: var(--base-unit);
            grid-column: span 2;
        }

        /* Buttons */
        .btn {
            background: var(--tile-bg);
            border: 2px solid currentColor;
            border-radius: var(--button-radius);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
            transition: background 0.15s ease, color 0.15s ease, transform 0.1s ease;
            position: relative;
            flex-shrink: 0;
        }

        .btn:hover {
            background: var(--button-hover);
        }

        .btn:active {
            background: var(--button-active);
            transform: scale(0.96);
        }

        .btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .btn.accent-spin { color: var(--accent-spin); }
        .btn.accent-add { color: var(--accent-add); }
        .btn.accent-delete { color: var(--accent-delete); }
        .btn.accent-reset { color: var(--accent-reset); }
        .btn.accent-up { color: var(--accent-up); }
        .btn.accent-down { color: var(--accent-down); }

        .btn-small {
            width: 32px;
            height: 32px;
        }

        .btn-small svg {
            width: 16px;
            height: 16px;
        }

        /* Input boxes */
        .input-inset {
            background: var(--tile-bg);
            border: none;
            border-radius: var(--button-radius);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            color: var(--text-color);
            font-size: 14px;
            padding: 8px 10px;
            width: 100%;
            outline: none;
            transition: box-shadow 0.2s ease;
        }

        .input-inset:focus {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .input-inset::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        select.input-inset {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23666'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 18px;
            padding-right: 30px;
        }

        [data-theme="dark"] select.input-inset {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23888'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
        }

        /* Widget specific styles */
        .widget-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        /* No special header spacing for backhere - keep default widget header styling */

        .widget-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .widget-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
        }

        /* Backhere overlay when stationary - keep container transparent so the rose isn't boxed */
        .backhere-overlay {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0; /* no full-tile padding */
            color: var(--text-color);
            background: transparent; /* let the rose show through */
            font-size: 13px;
            pointer-events: none;
            line-height: 1.2;
            word-break: break-word;
            border-radius: 0;
            box-shadow: none;
        }

        .backhere-overlay-text {
            color: var(--text-color);
            font-weight: 700;
            line-height: 1.1;
            display: inline-block;
            padding: 6px 10px;
            border-radius: 10px;
            /* use a small semi-transparent pill behind the label instead of a full-tile box */
            background: rgba(var(--tile-bg-rgb), 0.75);
            position: relative;
            z-index: 2;
            pointer-events: none;
            /* outline via text-shadow so the label stays on top */
            text-shadow: -1px -1px 0 var(--tile-bg), 1px -1px 0 var(--tile-bg), -1px 1px 0 var(--tile-bg), 1px 1px 0 var(--tile-bg);
        }

        /* Pseudo-element outline removed â€” using text-shadow instead so text is rendered on top */

        /* Add Widget Tile */
        .add-widget-tile .widget-content {
            justify-content: center;
        }

        .add-widget-row {
            display: flex;
            gap: 8px;
        }

        .add-widget-row select {
            flex: 1;
            min-width: 0;
            margin: 2px;
        }

        /* Spinner Widget */
        .spinner-input-row {
            display: flex;
            gap: 4px;
        }

        .spinner-input-row .input-inset {
            flex: 1;
            min-width: 0;
            font-size: 13px;
            padding: 6px 8px;
        }

        .spinner-input-row .input-inset.spinning {
            animation: pulse 0.1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .spinner-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Audio Widget */
        .audio-display {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            font-size: 12px;
            text-align: left;
            padding: 4px 8px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            overflow: hidden;
            white-space: nowrap;
            color: var(--text-color);
            position: relative;
        }

        .audio-display .track-name {
            display: inline-block;
            white-space: nowrap;
        }

        .audio-display .track-name.scrolling {
            animation: marquee-ping-pong var(--scroll-duration, 6s) ease-in-out infinite;
        }

        @keyframes marquee-ping-pong {
            0%, 10% { transform: translateX(0); }
            45%, 55% { transform: translateX(var(--scroll-distance, 0px)); }
            90%, 100% { transform: translateX(0); }
        }

        .audio-display.empty {
            justify-content: center;
            color: var(--text-muted);
            opacity: 0.6;
        }

        /* Chirper Widget (status label should not consume vertical space) */
        .chirper-widget .chirper-display {
            flex: 0 0 auto;
            height: 36px;
            justify-content: center;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 6px 8px;
        }

        /* Audio controls (used by the Audio widget and others) */
        .audio-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .chirper-widget .chirper-mode-btn.active {
            background: var(--button-active);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
        }

        /* Chirper: combined grid for play/stop + modes */
        .chirper-widget .chirper-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            justify-content: center;
        }

        .chirper-widget .chirper-controls .btn {
            width: 100%;
            height: 32px;
            padding: 0;
        }

        .tile.drop-active {
            outline: 2px dashed var(--accent-add);
            outline-offset: -4px;
        }

        .tile.drop-active::after {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--accent-add);
            opacity: 0.1;
            pointer-events: none;
            z-index: 5;
        }

        .audio-file-input {
            display: none;
        }

        /* Tasks Widget */
        .task-input-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            padding: 4px 8px;
            background: var(--tile-bg);
        }

        .task-input-wrapper:focus-within {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .task-check-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: color 0.15s ease;
        }

        .task-check-btn:hover {
            color: var(--accent-spin);
        }

        .task-check-btn.checked {
            color: var(--accent-spin);
        }

        .task-check-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .task-input {
            flex: 1;
            min-width: 0;
            border: none;
            background: transparent;
            color: var(--text-color);
            font-size: 13px;
            outline: none;
            padding: 2px 0;
        }

        .task-input::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        .task-input.checked {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .task-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Timer Widget */
        .timer-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .timer-segment {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .timer-value {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 28px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            background: var(--tile-bg);
            font-variant-numeric: tabular-nums;
            user-select: none;
            cursor: pointer;
            transition: box-shadow 0.15s ease;
        }

        .timer-value:focus {
            outline: none;
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .timer-value.editing {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-spin);
        }

        .timer-colon {
            font-size: 16px;
            color: var(--text-muted);
            padding: 0 1px;
        }

        .timer-adjust {
            display: flex;
            gap: 2px;
        }

        .timer-adjust-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s ease;
        }

        .timer-adjust-btn:hover {
            color: var(--text-color);
        }

        .timer-adjust-btn svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        .timer-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .timer-display.alarming .timer-value {
            animation: alarm-pulse 0.5s ease-in-out infinite;
        }

        @keyframes alarm-pulse {
            0%, 100% { background: var(--tile-bg); }
            50% { background: var(--accent-delete); color: white; }
        }

        /* Notepad Widget */
        .notepad-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .notepad-textarea {
            flex: 1;
            width: 100%;
            resize: none;
            border: none;
            background: var(--tile-bg);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            line-height: 1.5;
            padding: 10px;
            outline: none;
            overflow-x: hidden;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .notepad-textarea:focus {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .notepad-textarea::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        /* Themed scrollbars for notepad */
        .notepad-textarea,
        .notepad-preview {
            scrollbar-width: thin;
            scrollbar-color: var(--text-muted) transparent;
        }

        .notepad-textarea::-webkit-scrollbar,
        .notepad-preview::-webkit-scrollbar {
            width: 8px;
        }

        .notepad-textarea::-webkit-scrollbar-track,
        .notepad-preview::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 4px;
        }

        .notepad-textarea::-webkit-scrollbar-thumb,
        .notepad-preview::-webkit-scrollbar-thumb {
            background: var(--text-muted);
            border-radius: 4px;
            opacity: 0.5;
        }

        .notepad-textarea::-webkit-scrollbar-thumb:hover,
        .notepad-preview::-webkit-scrollbar-thumb:hover {
            background: var(--text-color);
        }

        .notepad-preview {
            flex: 1;
            overflow-x: hidden;
            overflow-y: auto;
            padding: 10px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            background: var(--tile-bg);
            font-size: 13px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .notepad-preview h1,
        .notepad-preview h2,
        .notepad-preview h3 {
            margin: 0.5em 0 0.3em;
            line-height: 1.3;
        }

        .notepad-preview h1 { font-size: 1.4em; }
        .notepad-preview h2 { font-size: 1.2em; }
        .notepad-preview h3 { font-size: 1.1em; }

        .notepad-preview p {
            margin: 0.4em 0;
        }

        .notepad-preview ul, .notepad-preview ol {
            margin: 0.4em 0;
            padding-left: 1.5em;
        }

        .notepad-preview ul ul,
        .notepad-preview ul ol,
        .notepad-preview ol ul,
        .notepad-preview ol ol {
            margin: 0.2em 0;
        }

        .notepad-preview li {
            margin: 0.1em 0;
        }

        .notepad-preview li:has(.checkbox) {
            list-style: none;
            margin-left: -1.5em;
        }

        .notepad-preview .checkbox {
            cursor: pointer;
            user-select: none;
            display: inline-flex;
            align-items: center;
            gap: 0.4em;
            vertical-align: middle;
            line-height: 1;
        }

        .notepad-preview .checkbox-box {
            width: 14px;
            height: 14px;
            border: 2px solid var(--text-muted);
            border-radius: 3px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.15s ease, border-color 0.15s ease;
            position: relative;
        }

        .notepad-preview .checkbox:hover .checkbox-box {
            border-color: var(--accent-spin);
        }

        .notepad-preview .checkbox.checked .checkbox-box {
            background: var(--accent-spin);
            border-color: var(--accent-spin);
        }

        .notepad-preview .checkbox.checked .checkbox-box::after {
            content: '';
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
            position: absolute;
            top: 0px;
            left: 3px;
        }

        .notepad-preview .checkbox.checked .checkbox-text {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .notepad-preview code {
            background: var(--button-hover);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }

        .notepad-preview pre {
            background: var(--button-hover);
            padding: 0.6em;
            border-radius: var(--button-radius);
            overflow-x: auto;
            margin: 0.4em 0;
        }

        .notepad-preview pre code {
            background: none;
            padding: 0;
        }

        .notepad-preview blockquote {
            border-left: 3px solid var(--accent-add);
            margin: 0.4em 0;
            padding-left: 0.8em;
            color: var(--text-muted);
        }

        .notepad-preview a {
            color: var(--accent-add);
            text-decoration: none;
        }

        .notepad-preview a:hover {
            text-decoration: underline;
        }

        .notepad-controls {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .notepad-btn.active {
            background: var(--button-active);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
        }

        /* Data Widget */
        .data-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            justify-content: center;
        }

        .data-row {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .data-btn {
            flex: 1;
            height: 32px;
        }

        .data-btn.armed {
            background: var(--accent-delete);
            color: white;
            border-color: var(--accent-delete);
        }

        .data-btn.armed:hover {
            background: var(--accent-delete);
            filter: brightness(1.1);
        }

        .data-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .data-file-input {
            display: none;
        }

        /* Draggable Widgets */
        .tile.draggable {
            cursor: grab;
        }

        .tile.draggable:active {
            cursor: grabbing;
        }

        .tile.dragging {
            opacity: 0.6;
            z-index: 1000;
            box-shadow: 0 8px 24px var(--shadow-color);
        }

        .tile.drag-over {
            outline: 2px dashed var(--accent-add);
            outline-offset: -4px;
        }

        .tile.drag-over::after {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--accent-add);
            opacity: 0.1;
            pointer-events: none;
            z-index: 5;
        }

        .drag-handle {
            cursor: grab;
            color: var(--text-muted);
            opacity: 0.5;
            transition: opacity 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
        }

        .drag-handle:hover {
            opacity: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        /* Clock Widget */
        .clock-display {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'DSEG7 Classic', monospace;
            font-size: 28px;
            letter-spacing: 2px;
            color: var(--text-color);
        }

        /* Calendar Widget */
        .calendar-widget {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 4px;
        }

        .calendar-nav .month-year {
            font-weight: 600;
            font-size: 13px;
            flex: 1;
            text-align: center;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
            font-size: 12px;
        }

        .calendar-grid .day-header {
            text-align: center;
            font-weight: 600;
            font-size: 10px;
            color: var(--text-muted);
            padding: 3px 0;
        }

        .calendar-grid .day-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 4px;
            border: 1px solid transparent;
            transition: background 0.15s;
            font-size: 12px;
            padding: 5px 0;
            min-height: 26px;
        }

        .calendar-grid .day-cell:hover {
            background: var(--button-hover);
        }

        .calendar-grid .day-cell.other-month {
            color: var(--text-muted);
            opacity: 0.5;
        }

        .calendar-grid .day-cell.today {
            border: 1px dotted var(--accent-add);
            border-radius: 4px;
        }

        .calendar-grid .day-cell.selected {
            border: 1px solid var(--accent-add);
            border-radius: 4px;
            background: var(--button-hover);
        }

        .calendar-grid .day-cell.has-events::after {
            content: '';
            position: absolute;
            bottom: 2px;
            width: 4px;
            height: 4px;
            background: var(--accent-add);
            border-radius: 50%;
        }

        .calendar-grid .day-cell {
            position: relative;
        }

        .calendar-actions {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .calendar-events {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-height: 0;
        }

        .calendar-event-nav {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .calendar-event-display {
            flex: 1;
            display: flex;
            align-items: center;
            font-size: 11px;
            padding: 4px 8px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            overflow: hidden;
            white-space: nowrap;
            min-width: 0;
        }

        .calendar-event-display.empty {
            color: var(--text-muted);
            opacity: 0.6;
            justify-content: center;
        }

        .calendar-event-input {
            flex: 1;
            font-size: 11px;
        }

        /* Dictaphone Widget */
        .dictaphone-widget {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .dictaphone-display {
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'DSEG7 Classic', monospace;
            font-size: 20px;
            padding: 6px 8px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            color: var(--text-color);
        }

        .dictaphone-display.recording {
            color: var(--accent-delete);
        }

        .dictaphone-controls {
            display: flex;
            gap: 4px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .dictaphone-controls .btn {
            flex: 0 0 auto;
        }

        /* Sheet Widget */
        .sheet-widget {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .sheet-toolbar {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .sheet-cell-ref {
            font-size: 10px;
            font-weight: 600;
            min-width: 28px;
            text-align: center;
            color: var(--text-muted);
        }

        .sheet-formula-bar {
            flex: 1;
            min-width: 0;
            padding: 2px 6px;
            font-size: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--button-radius);
            background: var(--tile-bg);
            color: var(--text-color);
            box-shadow: inset 0 1px 3px var(--inset-shadow);
        }

        .sheet-formula-bar:focus {
            outline: none;
            border-color: var(--accent-add);
        }

        .sheet-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-radius: var(--button-radius);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
        }

        .sheet-scroll-wrapper {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }

        .sheet-scroll-wrapper::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .sheet-scroll-wrapper::-webkit-scrollbar-track {
            background: var(--tile-bg);
            border-radius: 4px;
        }

        .sheet-scroll-wrapper::-webkit-scrollbar-thumb {
            background: var(--button-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .sheet-scroll-wrapper::-webkit-scrollbar-thumb:hover {
            background: var(--button-hover);
        }

        .sheet-scroll-wrapper::-webkit-scrollbar-corner {
            background: var(--tile-bg);
        }

        .sheet-table {
            border-collapse: collapse;
            font-size: 10px;
            min-width: 100%;
        }

        .sheet-table th,
        .sheet-table td {
            border: 1px solid var(--border-color);
            padding: 2px 3px;
            min-width: 42px;
            max-width: 70px;
            height: 18px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sheet-table th {
            background: var(--button-bg);
            font-weight: 600;
            font-size: 9px;
            color: var(--text-muted);
            position: sticky;
            top: 0;
            z-index: 2;
        }

        .sheet-table th.row-header {
            position: sticky;
            left: 0;
            z-index: 3;
        }

        .sheet-table th.corner {
            position: sticky;
            top: 0;
            left: 0;
            z-index: 4;
        }

        .sheet-table td {
            background: var(--tile-bg);
            cursor: cell;
        }

        .sheet-table td.selected {
            outline: 2px solid var(--accent-add);
            outline-offset: -2px;
        }

        .sheet-table td input {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            font-size: 10px;
            color: var(--text-color);
            padding: 0;
            margin: 0;
            outline: none;
        }

        .sheet-table td.formula {
            color: var(--accent-spin);
        }

        .sheet-table td.numeric {
            text-align: right;
        }

        /* About Widget */
        .about-widget {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .about-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 8px;
        }

        .about-authors {
            font-size: 10px;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .about-authors strong {
            color: var(--text-color);
            display: block;
            margin-bottom: 2px;
        }

        .about-bmac {
            display: block;
        }

        .about-bmac img {
            height: 32px;
            width: auto;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.2s ease;
        }

        .about-bmac:hover img {
            transform: scale(1.05);
        }

        .about-heart {
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
        }

        .about-heart svg {
            width: 12px;
            height: 12px;
        }

        .about-heart svg:first-of-type {
            fill: var(--accent-delete);
        }

        .about-heart svg:last-of-type {
            fill: var(--accent-spin);
        }

        /* Boids Widget */
        .boids-widget {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .boids-container {
            flex: 1;
            position: relative;
            border-radius: var(--button-radius);
            overflow: hidden;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
        }

        .boids-canvas-caustics {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .boids-canvas-fish {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Responsive adjustments */
        @media (max-width: 400px) {
            :root {
                --base-unit: calc((100vw - 48px) / 2);
                --grid-gap: 12px;
            }
            
            .tile {
                padding: 10px;
            }
            
            .btn-small {
                width: 28px;
                height: 28px;
            }
        }

        @media (min-width: 600px) {
            :root {
                --base-unit: 160px;
            }
        }

        /* Back Here widget visuals removed to avoid layout changes; use default widget styling */

        .backhere-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            position: relative;
            background: transparent !important;
            box-shadow: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Ensure any direct child doesn't draw its own box */
        .backhere-container > * {
            background: transparent !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        .backhere-rose {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
        }

        .backhere-distance {
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            user-select: all;
            transition: background .18s ease, color .18s ease;
        }

        .backhere-distance.copied {
            background: rgba(var(--accent-add-rgb, 120,140,160), 0.12);
            color: var(--text-color);
            border-radius: 6px;
            padding: 2px 6px;
        }
        @media (min-width: 900px) {
            :root {
                --base-unit: 180px;
            }
        }
    </style>
</head>
<body>
    <div class="grid" id="widgetGrid">
        <!-- Add Widget tile is always first, rendered by JS -->
    </div>

    <script>
        // SVG Icons
        const icons = {
            plus: `<svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>`,
            close: `<svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`,
            up: `<svg viewBox="0 0 24 24"><path d="M7 14l5-5 5 5z"/></svg>`,
            down: `<svg viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>`,
            spin: `<svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>`,
            spinRemove: `<svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/><line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2"/></svg>`,
            reset: `<svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>`,
            delete: `<svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`,
            sun: `<svg viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0a.996.996 0 000-1.41l-1.06-1.06zm1.06-10.96a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/></svg>`,
            moon: `<svg viewBox="0 0 24 24"><path d="M12 3a9 9 0 109 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 01-4.4 2.26 5.403 5.403 0 01-3.14-9.8c-.44-.06-.9-.1-1.36-.1z"/></svg>`,
            system: `<svg viewBox="0 0 24 24"><path d="M20 3H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h3l-1 1v2h12v-2l-1-1h3c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 13H4V5h16v11z"/></svg>`,
            check: `<svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>`,
            checkBox: `<svg viewBox="0 0 24 24"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/></svg>`,
            checkBoxChecked: `<svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`,
            play: `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`,
            pause: `<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`,
            stop: `<svg viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>`,
            prev: `<svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>`,
            next: `<svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>`,
            shuffle: `<svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>`,
            volumeOn: `<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>`,
            volumeOff: `<svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>`,
            edit: `<svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`,
            eye: `<svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`,
            drag: `<svg viewBox="0 0 24 24"><path d="M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>`,
            download: `<svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>`,
            upload: `<svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/></svg>`,
            warning: `<svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>`,
            lock: `<svg viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>`,
            unlock: `<svg viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"/></svg>`,
            clock: `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67V7z"/></svg>`,
            calendar: `<svg viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM9 10H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm-8 4H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/></svg>`,
            chevronLeft: `<svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>`,
            chevronRight: `<svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>`,
            today: `<svg viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM12 10h5v5h-5z"/></svg>`,
            mic: `<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.91-3c-.49 0-.9.36-.98.85C16.52 14.2 14.47 16 12 16s-4.52-1.8-4.93-4.15c-.08-.49-.49-.85-.98-.85-.61 0-1.09.54-1 1.14.49 3 2.89 5.35 5.91 5.78V20c0 .55.45 1 1 1s1-.45 1-1v-2.08c3.02-.43 5.42-2.78 5.91-5.78.1-.6-.39-1.14-1-1.14z"/></svg>`,
            micOff: `<svg viewBox="0 0 24 24"><path d="M19 11c0 1.19-.34 2.3-.9 3.28l-1.23-1.23c.27-.62.44-1.32.44-2.05h1.69zm-4.02.01L9 5.03V5c0-1.66 1.34-3 3-3s3 1.34 3 3v6c0 .03-.01.05-.01.08l.01-.07zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V20c0 .55.45 1 1 1s1-.45 1-1v-2.28c.91-.13 1.77-.45 2.54-.9l4.19 4.19 1.27-1.27L4.27 3z"/></svg>`,
            skipBack: `<svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>`,
            skipForward: `<svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>`,
            sigma: `<svg viewBox="0 0 24 24"><path d="M18 7V4H6v3h12zm-6 5l-6 6h12l-6-6zm0-2L6 4h12l-6 6z"/></svg>`,
            copy: `<svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>`,
            paste: `<svg viewBox="0 0 24 24"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0S9.6.84 9.18 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/></svg>`,
            grid: `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"/></svg>`,
            info: `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>`,
            heart: `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`,
            robot: `<svg viewBox="0 0 24 24"><path d="M12 2a2 2 0 012 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 017 7h1a1 1 0 011 1v3a1 1 0 01-1 1h-1v1a2 2 0 01-2 2H6a2 2 0 01-2-2v-1H3a1 1 0 01-1-1v-3a1 1 0 011-1h1a7 7 0 017-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 012-2zM7.5 13A1.5 1.5 0 006 14.5 1.5 1.5 0 007.5 16 1.5 1.5 0 009 14.5 1.5 1.5 0 007.5 13zm9 0a1.5 1.5 0 00-1.5 1.5 1.5 1.5 0 001.5 1.5 1.5 1.5 0 001.5-1.5 1.5 1.5 0 00-1.5-1.5z"/></svg>`,
            fullscreen: `<svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>`,
            fullscreenExit: `<svg viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>`,
            coffee: `<svg viewBox="0 0 24 24"><path d="M18.5 3H6c-1.1 0-2 .9-2 2v5.71c0 3.83 2.95 7.18 6.78 7.29 3.96.12 7.22-3.06 7.22-7v-1h.5c1.93 0 3.5-1.57 3.5-3.5S20.43 3 18.5 3zM16 5v3h2.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5H16v-1c0-2.76-2.24-5-5-5H6V5h10zM6 18h10v2H6z"/></svg>`,
            mode1: `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/></svg>`,
            mode2: `<svg viewBox="0 0 24 24"><circle cx="9" cy="12" r="2.6"/><circle cx="15" cy="12" r="2.6"/></svg>`,
            mode3: `<svg viewBox="0 0 24 24"><circle cx="7" cy="12" r="2.4"/><circle cx="12" cy="12" r="2.4"/><circle cx="17" cy="12" r="2.4"/></svg>`,
            mode4: `<svg viewBox="0 0 24 24"><rect x="9" y="9" width="6" height="6"/></svg>`,
            mode5: `<svg viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M3 12h2l1-3 2 6 2-8 2 8 2-6 1 3h2"/><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" d="M19 9c2 2 2 4 0 6"/></svg>`,
            mode6: `<svg viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M4 15c3-4 6-4 8 0 2-3 5-3 8 0"/></svg>`
        };

        // Widget Types Registry
        const widgetTypes = {
            spinner: {
                name: 'Spinner',
                size: '1x1',
                create: createSpinnerWidget
            },
            tasks: {
                name: 'Tasks',
                size: '1x1',
                create: createTasksWidget
            },
            audio: {
                name: 'Audio',
                size: '1x1',
                create: createAudioWidget
            },
            chirper: {
                name: 'Chirper',
                size: '1x1',
                create: createChirperWidget
            },
            timer: {
                name: 'Timer',
                size: '1x1',
                create: createTimerWidget
            },
            clock: {
                name: 'Clock',
                size: '1x1',
                create: createClockWidget
            },
            calendar: {
                name: 'Calendar',
                size: '2x2',
                create: createCalendarWidget
            },
            dictaphone: {
                name: 'Dictaphone',
                size: '1x1',
                create: createDictaphoneWidget
            },
            sheet: {
                name: 'Sheet',
                size: '2x2',
                create: createSheetWidget
            },
            notepad: {
                name: 'Notepad',
                size: '2x2',
                create: createNotepadWidget
            },
            data: {
                name: 'Data',
                size: '1x1',
                create: createDataWidget
            },
            about: {
                name: 'About',
                size: '1x1',
                create: createAboutWidget
            },
            boids: {
                name: 'Fish pond',
                size: '2x2',
                create: createBoidsWidget
            },
            backhere: {
                name: 'Back here',
                size: '1x1',
                create: createBackHereWidget
            },
            sleep: {
                name: 'Sleep',
                size: '1x1',
                create: createSleepTimerWidget
            }
        };

        // Global alarm audio context tracker for emergency cleanup
        const activeAlarmContexts = new Set();

        function registerAlarmContext(ctx) {
            activeAlarmContexts.add(ctx);
        }

        // ---------------------------------------------------------------------
        // Chirper (SAR-style non-alarm beacon)
        // ---------------------------------------------------------------------
        // Design goals:
        // - Not alarm-like: no siren warble, no panic/harsh beeps.
        // - â€œPenetrating & permeatingâ€ across environments: broadband-ish energy
        //   concentrated roughly 400â€“3000 Hz, with some taper > ~4 kHz.
        // - Works on mobile/laptop speakers: avoids very low bass & extreme highs.
        // - Procedurally generate the chirp sample ONCE (first Play), then reuse
        //   that same sample for each emission. Temporal spacing is scheduled.
        // - Touch/click friendly, Chrome/Safari compatible (Android/macOS/Windows/Linux).
        const CHIRPER_DEFAULTS = {
            // Pulse profile (a single emitted â€œeventâ€)
            chirpSeconds: 0.42,
            attackSeconds: 0.012,
            releaseSeconds: 0.09,
            // Mode 2/3/4 pulse lengths (scheduler uses buffer.duration)
            mode2Seconds: 3.2,
            mode3Seconds: 0.62,
            // Mode 4: deliberately â€œbadâ€ locator test.
            // A very short monotone beep can be hard to localize because it may end
            // before a person can orient their head/ears to improve ITD/ILD cues.
            mode4Seconds: 0.030,
            mode4Hz: 2000,
            mode4GapBaseSeconds: 30.0,
            mode4GapJitterSeconds: 0.00,
            // Mode 5: mosquito tone (high pitched, mostly audible to younger listeners)
            // Commercial anti-loitering â€œMosquitoâ€ devices are commonly described as using ~17.4 kHz.
            // We'll synthesize a pure continuous tone at this frequency.
            mode5Hz: 17400,
            mode5Level: 0.90,
            // Mode 6: random bird-call synthesis (scheduled every N seconds, independent of sound length)
            mode6Seconds: 1.25,
            mode6PeriodSeconds: 20.0,
            mode6MaxSegments: 4,
            mode6SpacingSeconds: 0.12,
            // Temporal pattern (cognitive SAR intervals: short pulse, long gap)
            gapBaseSeconds: 3.0,
            gapJitterSeconds: 0.5,
            // Spectral design
            voices: [
                // Two parallel sweeps (a fifth-ish apart) to support ITD/ILD cues.
                { fStart: 480, fEnd: 2600 },
                { fStart: 720, fEnd: 3600 }
            ],
            // Distance-carry assist: a subtle low-mid carrier under the chirp.
            // This helps propagation in foliage/terrain while staying within small-speaker limits.
            carrierHz: 560,
            carrierHarmonics: 3,
            carrierLevel: 0.10,
            // Mode-specific distance assist (optional overrides)
            mode2CarrierHz: 560,
            mode2CarrierLevel: 0.12,
            mode3CarrierHz: 520,
            mode3CarrierLevel: 0.18,
            harmonicsPerVoice: 4,
            // Higher partials decay to keep it chime-like (not harsh).
            harmonicFalloff: 0.22,
            // Taper energy above ~4 kHz to avoid wasted/irritating energy.
            highHzSoftCap: 4200,
            highHzRolloff: 1200,
            // Output level (kept moderate; user can raise device volume as needed).
            masterGain: 0.22,
            // Gentle saturation for speaker translation (adds â€œpresenceâ€ without piercing).
            drive: 1.15,
            // Optional onset â€œair clickâ€ (very short, very quiet) to improve perceived
            // localizability (adds broadband edges) without sounding like an alarm.
            onsetNoiseLevel: 0.015,
            onsetNoiseSeconds: 0.010,
            // Stereo strategy:
            // Emit on both channels simultaneously, but with a tiny L/R detune.
            // This creates slow-moving beat patterns in air (and sometimes â€œbloomsâ€ on
            // stereo speaker pairs) without relying on alternating channel playback.
            stereoDetuneCents: 10,

            // Output EQ (keeps energy in mobile-speaker-friendly range).
            // These nodes are lightweight and applied at playback time.
            hpHz: 180,
            lpHz: 6500,
            presenceHz: 2800,
            presenceGainDb: 2.5,
            presenceQ: 0.8,
            // Scheduler
            scheduleAheadSeconds: 2.0,
            schedulerTickMs: 100
        };

        function createChirperWidget(widget) {
            const data = widget.data;
            if (!data.mode) data.mode = 1;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.chirper.size} chirper-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Chirper</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="audio-display chirper-display empty">Ready</div>
                <div class="chirper-controls">
                    <button class="btn btn-small accent-add chirper-play" title="Play">${icons.play}</button>
                    <button class="btn btn-small accent-reset chirper-stop" title="Stop">${icons.stop}</button>
                    <button class="btn btn-small accent-add chirper-mode-btn" data-mode="1" title="Mode 1: SAR chirp">${icons.mode1}</button>
                    <button class="btn btn-small accent-spin chirper-mode-btn" data-mode="2" title="Mode 2: Melody">${icons.mode2}</button>
                    <button class="btn btn-small accent-delete chirper-mode-btn" data-mode="3" title="Mode 3: Alarm">${icons.mode3}</button>
                    <button class="btn btn-small accent-reset chirper-mode-btn" data-mode="4" title="Mode 4: 2kHz short beep (hard to localize)">${icons.mode4}</button>
                    <button class="btn btn-small accent-delete chirper-mode-btn" data-mode="5" title="Mode 5: Mosquito tone">${icons.mode5}</button>
                    <button class="btn btn-small chirper-mode-btn" data-mode="6" title="Mode 6: Random bird call (every 20s)">${icons.mode6}</button>
                </div>
            `;

            const statusEl = tile.querySelector('.chirper-display');
            const playBtn = tile.querySelector('.chirper-play');
            const stopBtn = tile.querySelector('.chirper-stop');
            const removeBtn = tile.querySelector('.widget-header .btn');
            const modeBtns = Array.from(tile.querySelectorAll('.chirper-mode-btn'));

            // WebAudio state is kept per-widget (so multiple Chirpers can exist if desired).
            // iOS/Safari requires audio context creation/resume inside a user gesture.
            let audioCtx = null;
            const buffersByMode = new Map();
            let outputGain = null;
            let eqIn = null;
            let schedulerTimerId = null;
            let nextChirpTime = 0;
            let chirpIndex = 0;
            let isRunning = false;
            const liveSources = new Set();

            // Mode 5 (continuous tone) state
            let mosquitoOsc = null;
            let mosquitoGain = null;

            let visibilityHandler = null;

            const cfg = { ...CHIRPER_DEFAULTS };
            let mode = Number(data.mode) || 1;

            function setStatus(text, isMuted = false) {
                statusEl.textContent = text;
                statusEl.classList.toggle('empty', !!isMuted);
            }

            function ensureAudioContext() {
                if (audioCtx) return audioCtx;
                const Ctx = window.AudioContext || window.webkitAudioContext;
                if (!Ctx) throw new Error('Web Audio API not supported');

                // Safari versions vary in constructor support; fall back gracefully.
                try {
                    audioCtx = new Ctx({ latencyHint: 'interactive' });
                } catch (e) {
                    audioCtx = new Ctx();
                }
                outputGain = audioCtx.createGain();
                outputGain.gain.value = 1;

                // Simple EQ chain for audibility on phone/laptop speakers.
                // (Keeps rumble out, avoids harsh ultrahighs, adds slight presence.)
                const hp = audioCtx.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.value = cfg.hpHz;
                hp.Q.value = 0.707;

                const presence = audioCtx.createBiquadFilter();
                presence.type = 'peaking';
                presence.frequency.value = cfg.presenceHz;
                presence.gain.value = cfg.presenceGainDb;
                presence.Q.value = cfg.presenceQ;

                const lp = audioCtx.createBiquadFilter();
                lp.type = 'lowpass';
                lp.frequency.value = cfg.lpHz;
                lp.Q.value = 0.707;

                outputGain.connect(hp);
                hp.connect(presence);
                presence.connect(lp);
                lp.connect(audioCtx.destination);
                eqIn = hp;
                return audioCtx;
            }

                // Procedurally generate each mode's sample once, then reuse.
            function ensureModeBuffer(ctx, targetMode) {
                if (buffersByMode.has(targetMode)) return buffersByMode.get(targetMode);
                let buf;
                if (targetMode === 1) {
                    buf = generateChirpBuffer(ctx, cfg);
                } else if (targetMode === 2) {
                    buf = generateTriumphantMelodyBuffer(ctx, cfg);
                } else if (targetMode === 3) {
                    // Mode 3 is intentionally alarm-like; keep volume capped via masterGain.
                    buf = generateAlarmBuffer(ctx, cfg);
                } else if (targetMode === 4) {
                    // Mode 4 is a deliberately â€œbadâ€ locator test: short monotone beep.
                    buf = generateMonotoneBeepBuffer(ctx, cfg);
                } else if (targetMode === 5) {
                    // Mode 5 is continuous streaming (OscillatorNode), not a buffer.
                    buf = null;
                } else {
                    buf = generateMonotoneBeepBuffer(ctx, cfg);
                }
                if (buf) buffersByMode.set(targetMode, buf);
                return buf;
            }

                // --- Mode 6 bird-call synthesis (ported + adapted from bird-sound-demo.html) ---
                const MODE6_CATALOG = [
                    'chirp', 'tweet', 'twitter', 'trill', 'warble', 'chatter', 'cheep', 'cheer',
                    'coo', 'hoot', 'caw', 'whistle', 'whip', 'buzz', 'rattle', 'croak',
                    'yodel', 'glissando', 'zip', 'click'
                ];

                function hashString(value) {
                    let h = 0;
                    for (let i = 0; i < value.length; i++) {
                        h = Math.imul(31, h) + value.charCodeAt(i);
                        h |= 0;
                    }
                    return h >>> 0;
                }

                class PRNG {
                    constructor(seed) {
                        this.seed = seed >>> 0;
                    }
                    next() {
                        let t = (this.seed += 0x6d2b79f5);
                        t = Math.imul(t ^ (t >>> 15), t | 1);
                        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                    }
                    range(min, max) {
                        return min + (max - min) * this.next();
                    }
                    choice(arr) {
                        return arr[Math.floor(this.next() * arr.length)];
                    }
                }

                function createBirdSoundProfile(id, seedSalt) {
                    const seed = (hashString(id) ^ seedSalt) >>> 0;
                    const rng = new PRNG(seed);
                    const waves = ['sine', 'triangle', 'sawtooth'];
                    const modWaves = ['sine', 'triangle'];
                    const duration = rng.range(0.22, 0.82);
                    const release = rng.range(0.08, 0.24);
                    const profile = {
                        id,
                        duration,
                        release,
                        attack: rng.range(0.01, 0.08),
                        amplitude: rng.range(0.40, 0.75),
                        baseFreq: rng.range(320, 1800),
                        sweep: rng.range(0.7, 1.45),
                        waveform: rng.choice(waves),
                        modWave: rng.choice(modWaves),
                        modFreq: rng.range(2, 10),
                        modDepth: rng.range(5, 120),
                        noiseLevel: rng.next() < 0.35 ? rng.range(0.08, 0.45) : 0,
                        pulses: rng.next() < 0.35 ? (2 + Math.floor(rng.range(0, 3.9))) : 1,
                        trill: rng.next() < 0.28,
                        jitter: rng.range(-0.08, 0.08),
                        seed
                    };
                    if (profile.trill) {
                        profile.modFreq = rng.range(18, 52);
                        profile.modDepth = rng.range(35, 160);
                    }
                    return profile;
                }

                function createSeededNoiseBuffer(ctx, durationSeconds, seed) {
                    const rng = new PRNG((seed ^ 0x9e3779b9) >>> 0);
                    const length = Math.max(1, Math.ceil(durationSeconds * ctx.sampleRate));
                    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < length; i++) {
                        data[i] = rng.range(-1, 1) * 0.7;
                    }
                    return buffer;
                }

                function registerLiveNode(node) {
                    if (!node) return;
                    liveSources.add(node);
                    node.onended = () => {
                        liveSources.delete(node);
                    };
                }

                function startMosquitoTone(atTime) {
                    const ctx = audioCtx;
                    if (mosquitoOsc) return;

                    // Pure tone: oscillator + gain only; bypass EQ filters.
                    mosquitoGain = ctx.createGain();
                    mosquitoGain.gain.setValueAtTime(0.0001, atTime);

                    // Use a tiny ramp to avoid speaker clicks (still a pure tone after ramp).
                    const targetGain = Math.max(0, Math.min(1, (cfg.masterGain || 0.2) * (cfg.mode5Level || 1)));
                    mosquitoGain.gain.linearRampToValueAtTime(targetGain, atTime + 0.008);

                    mosquitoOsc = ctx.createOscillator();
                    mosquitoOsc.type = 'sine';
                    mosquitoOsc.frequency.setValueAtTime(Math.max(1000, cfg.mode5Hz || 17400), atTime);

                    mosquitoOsc.connect(mosquitoGain);
                    mosquitoGain.connect(ctx.destination);

                    mosquitoOsc.start(atTime);
                    registerLiveNode(mosquitoOsc);
                }

                function stopMosquitoTone(atTime) {
                    if (!mosquitoOsc) return;
                    try {
                        if (mosquitoGain) {
                            const current = mosquitoGain.gain.value;
                            mosquitoGain.gain.setValueAtTime(Math.max(0.0001, current), atTime);
                            mosquitoGain.gain.linearRampToValueAtTime(0.0001, atTime + 0.008);
                        }
                    } catch (e) {}
                    try { mosquitoOsc.stop(atTime + 0.01); } catch (e) {}
                    mosquitoOsc = null;
                    mosquitoGain = null;
                }

                function scheduleBirdSegment(ctx, profile, startTime) {
                    const osc = ctx.createOscillator();
                    osc.type = profile.waveform;
                    const gain = ctx.createGain();
                    gain.gain.setValueAtTime(0.0001, startTime);

                    const endTime = startTime + profile.duration + profile.release;
                    const amplitude = profile.amplitude;

                    if (profile.pulses > 1) {
                        const pulseLength = profile.duration / profile.pulses;
                        let cursor = startTime;
                        for (let i = 0; i < profile.pulses; i++) {
                            const aEnd = cursor + Math.min(profile.attack, pulseLength * 0.3);
                            gain.gain.setValueAtTime(0.0001, cursor);
                            gain.gain.exponentialRampToValueAtTime(amplitude, aEnd);
                            const sustainEnd = cursor + pulseLength * 0.7;
                            gain.gain.exponentialRampToValueAtTime(amplitude * 0.85, sustainEnd);
                            const rEnd = cursor + pulseLength;
                            gain.gain.exponentialRampToValueAtTime(0.0001, rEnd);
                            cursor += pulseLength * 0.95;
                        }
                        gain.gain.setValueAtTime(0.0001, endTime);
                    } else {
                        const attackEnd = startTime + profile.attack;
                        const sustainEnd = startTime + profile.duration - profile.release * 0.5;
                        gain.gain.exponentialRampToValueAtTime(amplitude, attackEnd);
                        gain.gain.exponentialRampToValueAtTime(amplitude * 0.88, sustainEnd);
                        gain.gain.exponentialRampToValueAtTime(0.0001, endTime);
                    }

                    const targetFreq = profile.baseFreq * profile.sweep;
                    osc.frequency.setValueAtTime(profile.baseFreq, startTime);
                    osc.frequency.exponentialRampToValueAtTime(targetFreq, startTime + profile.duration + profile.jitter);

                    if (profile.modDepth > 0) {
                        const lfo = ctx.createOscillator();
                        lfo.type = profile.modWave;
                        lfo.frequency.setValueAtTime(profile.modFreq, startTime);
                        const lfoGain = ctx.createGain();
                        lfoGain.gain.setValueAtTime(profile.modDepth, startTime);
                        lfo.connect(lfoGain).connect(osc.frequency);
                        lfo.start(startTime);
                        lfo.stop(endTime);
                        registerLiveNode(lfo);
                    }

                    osc.connect(gain).connect(outputGain);
                    osc.start(startTime);
                    osc.stop(endTime);
                    registerLiveNode(osc);

                    if (profile.noiseLevel > 0) {
                        const noise = ctx.createBufferSource();
                        noise.buffer = createSeededNoiseBuffer(ctx, profile.duration + profile.release, profile.seed);
                        const noiseGain = ctx.createGain();
                        noiseGain.gain.setValueAtTime(0.0001, startTime);
                        const peak = startTime + Math.min(profile.attack * 1.5, 0.12);
                        noiseGain.gain.exponentialRampToValueAtTime(profile.noiseLevel, peak);
                        noiseGain.gain.exponentialRampToValueAtTime(0.0001, endTime);
                        noise.connect(noiseGain).connect(outputGain);
                        noise.start(startTime);
                        noise.stop(endTime);
                        registerLiveNode(noise);
                    }

                    return endTime;
                }

                function scheduleRandomBirdSound(atTime) {
                    const ctx = audioCtx;
                    const seedSalt = ((Math.random() * 0xFFFFFFFF) >>> 0) ^ (chirpIndex * 2654435761);
                    const rng = new PRNG(seedSalt);

                    const maxSegments = Math.max(1, Math.min(8, cfg.mode6MaxSegments || 4));
                    const spacing = Math.max(0, cfg.mode6SpacingSeconds || 0.12);
                    const segCount = 1 + Math.floor(rng.next() * maxSegments);

                    let cursor = atTime;
                    for (let i = 0; i < segCount; i++) {
                        const id = rng.choice(MODE6_CATALOG);
                        const profile = createBirdSoundProfile(id, seedSalt ^ (i * 0x9e3779b9));
                        cursor = scheduleBirdSegment(ctx, profile, cursor);
                        if (i < segCount - 1) cursor += spacing;
                    }
                    return cursor;
                }

            function randomSignedUnit() {
                return (Math.random() * 2) - 1;
            }

            function computeNextGapSeconds() {
                if (mode === 4) {
                    return Math.max(0, (cfg.mode4GapBaseSeconds || 0) + (cfg.mode4GapJitterSeconds || 0) * randomSignedUnit());
                }
                if (mode === 5) {
                    // Mode 5 is continuous (no scheduled gaps).
                    return 0;
                }
                // Long silence reduces habituation and avoids â€œalarmâ€ character.
                return Math.max(0, cfg.gapBaseSeconds + cfg.gapJitterSeconds * randomSignedUnit());
            }

            function scheduleOneChirp(atTime, index, buffer) {
                const ctx = audioCtx;
                const source = ctx.createBufferSource();
                source.buffer = buffer;

                registerLiveNode(source);

                // Buffers are generated as true stereo for all modes.
                source.connect(outputGain);

                // Use a hard stop shortly after to prevent any tail from lingering.
                source.start(atTime);
                source.stop(atTime + buffer.duration + 0.05);
            }

            function schedulerTick() {
                if (!isRunning || !audioCtx) return;
                const ctx = audioCtx;
                const horizon = ctx.currentTime + cfg.scheduleAheadSeconds;

                if (mode === 5) {
                    // Continuous tone; nothing to schedule.
                    return;
                }

                if (mode === 6) {
                    const period = Math.max(1, cfg.mode6PeriodSeconds || 20);
                    while (nextChirpTime < horizon) {
                        scheduleRandomBirdSound(nextChirpTime);
                        nextChirpTime += period;
                        chirpIndex += 1;
                    }
                    return;
                }

                const buffer = buffersByMode.get(mode);
                if (!buffer) return;

                while (nextChirpTime < horizon) {
                    scheduleOneChirp(nextChirpTime, chirpIndex, buffer);
                    const gap = computeNextGapSeconds();
                    nextChirpTime += buffer.duration + gap;
                    chirpIndex += 1;
                }
            }

            async function start() {
                if (isRunning) return;
                setStatus('Startingâ€¦', true);

                const ctx = ensureAudioContext();
                // Resume is required on some platforms even after construction.
                try { await ctx.resume(); } catch (e) {}

                // Generate once (procedural audio data), then schedule repeated emissions.
                setStatus('Generatingâ€¦', true);
                // Keep generation synchronous but allow the UI to paint first.
                await new Promise(r => setTimeout(r, 0));

                if (mode !== 6 && mode !== 5) ensureModeBuffer(ctx, mode);

                // Apply master level at runtime for buffer-based modes.
                outputGain.gain.value = cfg.masterGain;

                isRunning = true;
                chirpIndex = 0;
                nextChirpTime = ctx.currentTime + 0.05;

                if (mode === 5) {
                    setStatus('Playing (continuous)', false);
                    startMosquitoTone(ctx.currentTime + 0.01);
                    return;
                }

                setStatus('Playing', false);
                schedulerTimerId = setInterval(schedulerTick, cfg.schedulerTickMs);
                schedulerTick();
            }

            function stop(immediateStatus = true) {
                if (!audioCtx) {
                    if (immediateStatus) setStatus('Ready', true);
                    return;
                }

                isRunning = false;
                if (schedulerTimerId) {
                    clearInterval(schedulerTimerId);
                    schedulerTimerId = null;
                }

                // Stop any already-scheduled-but-not-ended sources immediately.
                for (const src of Array.from(liveSources)) {
                    try { src.stop(); } catch (e) {}
                }
                liveSources.clear();

                // Stop continuous mosquito tone if active.
                stopMosquitoTone(audioCtx.currentTime);

                // Suspend saves battery on mobile without losing generated buffer.
                try { audioCtx.suspend(); } catch (e) {}

                if (immediateStatus) setStatus('Ready', true);
            }

            function updateModeButtons() {
                for (const btn of modeBtns) {
                    const m = Number(btn.dataset.mode);
                    btn.classList.toggle('active', m === mode);
                }
            }

            function setMode(newMode) {
                const m = Number(newMode);
                if (![1, 2, 3, 4, 5, 6].includes(m)) return;
                if (m === mode) return;
                mode = m;
                updateModeButtons();
                updateWidgetData(widget.id, { mode });

                // Switching modes while running restarts immediately with the new buffer.
                if (isRunning) {
                    stop(false);
                    start().catch(err => {
                        console.error('Chirper start failed:', err);
                        setStatus('Audio unavailable', true);
                    });
                }
            }

            function destroy() {
                stop(false);
                if (visibilityHandler) {
                    document.removeEventListener('visibilitychange', visibilityHandler);
                    visibilityHandler = null;
                }
                if (audioCtx) {
                    try { audioCtx.close(); } catch (e) {}
                }
                audioCtx = null;
                buffersByMode.clear();
                outputGain = null;
                eqIn = null;
            }

            // Controls
            playBtn.addEventListener('click', () => {
                start().catch(err => {
                    console.error('Chirper start failed:', err);
                    setStatus('Audio unavailable', true);
                });
            });
            stopBtn.addEventListener('click', () => stop(true));

            for (const btn of modeBtns) {
                btn.addEventListener('click', () => setMode(btn.dataset.mode));
            }

            // Stop chirping when the tab is backgrounded (prevents accidental continuous play).
            visibilityHandler = () => {
                if (document.hidden) stop(true);
            };
            document.addEventListener('visibilitychange', visibilityHandler);

            removeBtn.addEventListener('click', () => {
                destroy();
                removeWidget(widget.id);
            });

            updateModeButtons();

            return tile;
        }


        // Mode 2: triumphant "completion" melody.
        // Goal: washing-machine-completion-chime vibes - bright, major-key, two phrases
        // (question + answer / call + response), ending with a satisfying resolution.
        // Original composition; no pitch-bend silliness.
        function generateTriumphantMelodyBuffer(ctx, cfg) {
            const sr = ctx.sampleRate;
            const dur = cfg.mode2Seconds;
            const length = Math.max(1, Math.floor(dur * sr));
            const buffer = ctx.createBuffer(2, length, sr);
            const left = buffer.getChannelData(0);
            const right = buffer.getChannelData(1);

            const detuneRatio = Math.pow(2, (cfg.stereoDetuneCents || 0) / 1200);
            const ratioL = 1 / Math.sqrt(detuneRatio);
            const ratioR = Math.sqrt(detuneRatio);

            // Base pitch: G4 (pleasant, not too high).
            const baseHz = 391.995; // G4

            // Two-phrase melody: phrase 1 ("question") rises, phrase 2 ("answer") resolves.
            // All semitones relative to G4.
            const melody = [
                // === Phrase 1: ascending question ===
                { t0: 0.08, dur: 0.18, semi: 0 },     // G4
                { t0: 0.28, dur: 0.16, semi: 2 },     // A4
                { t0: 0.46, dur: 0.18, semi: 4 },     // B4
                { t0: 0.66, dur: 0.22, semi: 7 },     // D5
                { t0: 0.90, dur: 0.32, semi: 9 },     // E5 (phrase 1 peak, slight hold)
                // === brief pause ===
                // === Phrase 2: triumphant answer/resolution ===
                { t0: 1.36, dur: 0.16, semi: 12 },    // G5
                { t0: 1.54, dur: 0.14, semi: 11 },    // F#5
                { t0: 1.70, dur: 0.16, semi: 9 },     // E5
                { t0: 1.88, dur: 0.18, semi: 7 },     // D5
                { t0: 2.08, dur: 0.14, semi: 4 },     // B4
                { t0: 2.24, dur: 0.16, semi: 2 },     // A4
                { t0: 2.42, dur: 0.60, semi: 0, level: 1.12 },  // G4 (final resolve, held)
                // Gentle high sparkle at the very end
                { t0: 2.85, dur: 0.22, semi: 12, level: 0.25 }  // G5 (quiet shimmer)
            ];

            // Chord progression supporting the two phrases.
            // Phrase 1: I -> ii -> IV (rising tension)
            // Phrase 2: I -> vi -> IV -> I (triumphant cadence)
            const chordBaseHz = 195.998; // G3
            const chords = [
                // Phrase 1
                { t0: 0.08, dur: 0.36, notes: [0, 4, 7] },        // G
                { t0: 0.46, dur: 0.36, notes: [2, 5, 9] },        // Am
                { t0: 0.84, dur: 0.42, notes: [5, 9, 12] },       // C
                // Phrase 2
                { t0: 1.36, dur: 0.32, notes: [0, 4, 7] },        // G
                { t0: 1.70, dur: 0.32, notes: [4, 7, 11] },       // Em
                { t0: 2.04, dur: 0.32, notes: [5, 9, 12] },       // C
                { t0: 2.38, dur: 0.68, notes: [0, 4, 7, 11] }     // Gmaj7 (warm resolve)
            ];

            // Bell-like timbre: moderate harmonics, gentle falloff.
            const melodyHarm = { harmonics: 5, falloff: 0.45 };
            const chordHarm = { harmonics: 3, falloff: 0.55 };

            // Clean attack, smooth release (no clicks, no slapstick).
            const atkMel = 0.012;
            const relMel = 0.280;
            const atkChord = 0.025;
            const relChord = 0.260;

            // Distance assist: subtle low-mid carrier.
            const carrierHz = cfg.mode2CarrierHz || cfg.carrierHz || 560;
            const carrierLevel = cfg.mode2CarrierLevel || Math.min(0.12, (cfg.carrierLevel || 0.10));

            function hzFromSemis(base, semi) {
                return base * Math.pow(2, semi / 12);
            }

            function envAD(t, t0, durS, atkS, relS) {
                const t1 = t0 + durS;
                if (t < t0 || t > t1) return 0;
                const local = t - t0;
                const total = durS;
                const a = Math.min(atkS, total * 0.5);
                const r = Math.min(relS, total * 0.9);
                if (local < a) return local / a;
                if (local > total - r) return Math.max(0, (total - local) / r);
                // Natural decay for bell-like quality.
                return 1 - 0.30 * (local / total);
            }

            function addHarmonics(sum, f0, t, harmonics, falloff) {
                let s = sum;
                for (let h = 1; h <= harmonics; h++) {
                    const amp = (1 / h) * Math.exp(-falloff * (h - 1));
                    s += Math.sin(2 * Math.PI * (f0 * h) * t) * amp;
                }
                return s;
            }

            function synthAtTime(t, freqRatio) {
                let melodySum = 0;
                let chordSum = 0;
                let melodyEnvMax = 0;
                let chordEnvMax = 0;

                // Melody layer (no pitch bend, no vibrato - clean and dignified).
                for (const n of melody) {
                    const e = envAD(t, n.t0, n.dur, atkMel, relMel);
                    if (e <= 0) continue;
                    melodyEnvMax = Math.max(melodyEnvMax, e);

                    const f0 = hzFromSemis(baseHz, n.semi) * freqRatio;

                    let note = 0;
                    note = addHarmonics(note, f0, t, melodyHarm.harmonics, melodyHarm.falloff);
                    // Subtle bell-ish inharmonic partials for shimmer.
                    const e2 = e * e;
                    note += Math.sin(2 * Math.PI * (f0 * 2.76) * t) * 0.09 * e2;
                    note += Math.sin(2 * Math.PI * (f0 * 4.07) * t) * 0.05 * e2;

                    const level = (n.level !== undefined ? n.level : 1.0);
                    melodySum += note * e * level;
                }

                // Chord bed.
                for (const c of chords) {
                    const e = envAD(t, c.t0, c.dur, atkChord, relChord);
                    if (e <= 0) continue;
                    chordEnvMax = Math.max(chordEnvMax, e);
                    let chord = 0;
                    for (const semi of c.notes) {
                        const f0 = hzFromSemis(chordBaseHz, semi) * freqRatio;
                        chord = addHarmonics(chord, f0, t, chordHarm.harmonics, chordHarm.falloff);
                    }
                    chordSum += chord * e;
                }

                // Balance: melody forward, chords supportive.
                let s = melodySum * 0.88 + chordSum * 0.16;

                // Low-mid carrier for distance propagation.
                const energy = Math.min(1, melodyEnvMax * 0.90 + chordEnvMax * 0.40);
                if (energy > 0.0001) {
                    const carF = carrierHz * freqRatio;
                    const car =
                        Math.sin(2 * Math.PI * carF * t) * 1.0 +
                        Math.sin(2 * Math.PI * (carF * 2) * t) * 0.32 +
                        Math.sin(2 * Math.PI * (carF * 3) * t) * 0.15;
                    s += car * energy * carrierLevel;
                }

                // Gentle saturation for presence.
                return Math.tanh(s * 1.15) / Math.tanh(1.15);
            }

            for (let i = 0; i < length; i++) {
                const t = i / sr;
                // Both channels emit simultaneously; small detune can create a "bloom" on
                // real stereo pairs via beating/interference in air.
                left[i] = synthAtTime(t, ratioL);
                right[i] = synthAtTime(t, ratioR);
            }

            // Normalize peak with headroom.
            let peak = 0;
            for (let i = 0; i < length; i++) {
                peak = Math.max(peak, Math.abs(left[i]), Math.abs(right[i]));
            }
            if (peak > 0) {
                const gain = 0.95 / peak;
                for (let i = 0; i < length; i++) {
                    left[i] *= gain;
                    right[i] *= gain;
                }
            }
            return buffer;
        }
        // Mode 3: alarm-like signal (more urgent/irritating by design).
        // Still volume-capped by masterGain; user controls device volume.
        function generateAlarmBuffer(ctx, cfg) {
            const sr = ctx.sampleRate;
            const dur = cfg.mode3Seconds;
            const length = Math.max(1, Math.floor(dur * sr));
            const buffer = ctx.createBuffer(2, length, sr);
            const left = buffer.getChannelData(0);
            const right = buffer.getChannelData(1);

            const detuneRatio = Math.pow(2, (cfg.stereoDetuneCents || 0) / 1200);
            const ratioL = 1 / Math.sqrt(detuneRatio);
            const ratioR = Math.sqrt(detuneRatio);

            // Two-tone alarm core (serious/urgent). Keep in the â€œcuts-throughâ€ band.
            const baseA = 930;
            const baseB = 1510;
            const burstPattern = [
                { t0: 0.00, t1: 0.14 },
                { t0: 0.18, t1: 0.32 },
                { t0: 0.36, t1: dur }
            ];
            // Sharp edges: no soft siney fades. (Clicks are acceptable for an alarm.)
            const atk = 0.0012;
            const rel = 0.012;

            // Distance assist: low-mid carrier under the alarm (travels better than pure highs).
            const carrierHz = Math.max(0, cfg.mode3CarrierHz || cfg.carrierHz || 520);
            const carrierLevel = Math.max(0, cfg.mode3CarrierLevel || (cfg.carrierLevel || 0.10));

            // â€œHardnessâ€ controls: harmonics + saturation.
            const toneHarmonics = 7;
            const drive = 2.35;
            const driveNorm = Math.tanh(drive);

            // Broadband onset edge (short, per-burst) for salience at distance.
            const edgeSeconds = 0.010;
            const edgeSamples = Math.max(1, Math.floor(edgeSeconds * sr));
            const edgeLevel = 0.055;

            function inBurst(t) {
                for (const b of burstPattern) {
                    if (t >= b.t0 && t <= b.t1) return b;
                }
                return null;
            }

            function burstEnv(t, b) {
                const local = t - b.t0;
                const total = b.t1 - b.t0;
                const a = Math.min(atk, total * 0.5);
                const r = Math.min(rel, total * 0.8);
                let e;
                if (local < a) e = local / a;
                else if (local > total - r) e = Math.max(0, (total - local) / r);
                else e = 1;
                // Slight intra-burst â€œpressureâ€ decay (keeps it aggressive without being flat).
                e *= (1 - 0.10 * (local / Math.max(1e-6, total)));
                // Sharpen edges a touch.
                return Math.pow(Math.max(0, Math.min(1, e)), 1.25);
            }

            function onsetEdge(localT) {
                if (localT < 0) return 0;
                const i = Math.floor(localT * sr);
                if (i < 0 || i >= edgeSamples) return 0;
                const x = i / edgeSamples;
                // Quick rise + rapid decay so it reads as a crack/edge, not hiss.
                const env = (x < 0.12 ? (x / 0.12) : 1) * (1 - x);
                // White noise sample.
                return (Math.random() * 2 - 1) * env;
            }

            function addSawish(sum, f0, t, harmonics) {
                // Additive saw-ish tone: strong harmonic series, very â€œhardâ€ and alarm-like.
                let s = sum;
                for (let h = 1; h <= harmonics; h++) {
                    s += Math.sin(2 * Math.PI * (f0 * h) * t) * (1 / h);
                }
                return s;
            }

            function alarmSample(t, freqRatio) {
                const b = inBurst(t);
                if (!b) return 0;

                const env = burstEnv(t, b);
                const local = t - b.t0;
                const a = baseA * freqRatio;
                const c = baseB * freqRatio;

                // Two-tone with close detunes to induce roughness (panic/urgency).
                let s = 0;
                s = addSawish(s, a - 21, t, toneHarmonics) * 0.55;
                s = addSawish(s, a + 19, t, toneHarmonics) * 0.50;
                s = addSawish(s, c - 29, t, toneHarmonics) * 0.45;
                s = addSawish(s, c + 27, t, toneHarmonics) * 0.42;

                // Add a high â€œbiteâ€ component.
                s += Math.sin(2 * Math.PI * (c * 2.0) * t) * 0.18;

                // Low-mid carrier (distance travel) under the whole burst.
                if (carrierHz > 0 && carrierLevel > 0) {
                    const carF = carrierHz * freqRatio;
                    const car =
                        Math.sin(2 * Math.PI * carF * t) * 1.0 +
                        Math.sin(2 * Math.PI * (carF * 2) * t) * 0.35 +
                        Math.sin(2 * Math.PI * (carF * 3) * t) * 0.18;
                    s += car * carrierLevel;
                }

                // Short broadband edge at each burst onset.
                s += onsetEdge(local) * edgeLevel;

                // Aggressive saturation for urgency.
                s = Math.tanh(s * drive) / driveNorm;
                s *= env;
                return s;
            }

            for (let i = 0; i < length; i++) {
                const t = i / sr;
                // Both channels emit simultaneously with tiny detune.
                left[i] = alarmSample(t, ratioL);
                right[i] = alarmSample(t, ratioR);
            }

            // Normalize peak with headroom.
            let peak = 0;
            for (let i = 0; i < length; i++) {
                peak = Math.max(peak, Math.abs(left[i]), Math.abs(right[i]));
            }
            if (peak > 0) {
                const gain = 0.95 / peak;
                for (let i = 0; i < length; i++) {
                    left[i] *= gain;
                    right[i] *= gain;
                }
            }
            return buffer;
        }

        // Mode 4: intentionally â€œbadâ€ locator test.
        // Very short monotone beep at 2000 Hz, identical L/R (no detune, no spatial cues).
        // The point is to demonstrate that a very short blip can be hard to localize.
        function generateMonotoneBeepBuffer(ctx, cfg) {
            const sr = ctx.sampleRate;
            const dur = Math.max(0.005, cfg.mode4Seconds || 0.03);
            const f0 = Math.max(20, cfg.mode4Hz || 2000);

            const length = Math.max(1, Math.floor(dur * sr));
            const buffer = ctx.createBuffer(2, length, sr);
            const left = buffer.getChannelData(0);
            const right = buffer.getChannelData(1);

            // Keep a minimal ramp to avoid harsh clicks, but still â€œbeep-likeâ€.
            const atk = Math.min(0.0012, dur * 0.45);
            const rel = Math.min(0.0045, dur * 0.70);
            const twoPiF = 2 * Math.PI * f0;

            function env(t) {
                let e = 1;
                if (t < atk) e = t / atk;
                else if (t > dur - rel) e = Math.max(0, (dur - t) / rel);
                return Math.max(0, Math.min(1, e));
            }

            for (let i = 0; i < length; i++) {
                const t = i / sr;
                const s = Math.sin(twoPiF * t) * env(t);
                left[i] = s;
                right[i] = s;
            }

            // Normalize peak with headroom.
            let peak = 0;
            for (let i = 0; i < length; i++) {
                peak = Math.max(peak, Math.abs(left[i]));
            }
            if (peak > 0) {
                const gain = 0.95 / peak;
                for (let i = 0; i < length; i++) {
                    left[i] *= gain;
                    right[i] *= gain;
                }
            }
            return buffer;
        }

        // Generate a single chirp (AudioBuffer) using additive synthesis with two sweeping voices.
        // This is intentionally â€œchime-likeâ€: sharp onset, rich midrange harmonics, no warble.
        function generateChirpBuffer(ctx, cfg) {
            const sr = ctx.sampleRate;
            // We will create a concatenated buffer: first the original chirp (cfg.chirpSeconds),
            // then a second chirp generated over double that duration. This results in total
            // length = 3 * cfg.chirpSeconds.
            const dur1 = Math.max(0.001, cfg.chirpSeconds);
            const dur2 = Math.max(0.001, cfg.chirpSeconds * 2);
            const length1 = Math.max(1, Math.floor(dur1 * sr));
            const length2 = Math.max(1, Math.floor(dur2 * sr));
            const totalLength = length1 + length2;
            const buffer = ctx.createBuffer(2, totalLength, sr);
            const left = buffer.getChannelData(0);
            const right = buffer.getChannelData(1);

            const twoPi = Math.PI * 2;
            const capHz = cfg.highHzSoftCap;
            const rollHz = Math.max(1, cfg.highHzRolloff);
            const drive = Math.max(0.01, cfg.drive);
            const driveNorm = Math.tanh(drive);
            const detuneRatio = Math.pow(2, (cfg.stereoDetuneCents || 0) / 1200);
            const ratioL = 1 / Math.sqrt(detuneRatio);
            const ratioR = Math.sqrt(detuneRatio);
            const noiseLevel = Math.max(0, cfg.onsetNoiseLevel || 0);
            const noiseSamples1 = Math.max(0, Math.floor((cfg.onsetNoiseSeconds || 0) * sr));
            const noiseSamples2 = noiseSamples1; // same onset duration per chirp

            const carrierHz = Math.max(0, cfg.carrierHz || 0);
            const carrierHarmonics = Math.max(0, Math.min(8, cfg.carrierHarmonics || 0));
            const carrierLevel = Math.max(0, cfg.carrierLevel || 0);

            function lerp(a, b, t) { return a + (b - a) * t; }
            function highFreqRolloff(fHz) {
                if (fHz <= capHz) return 1;
                return Math.exp(-(fHz - capHz) / rollHz);
            }

            function generateBlock(dur, length, outLeft, outRight, offset) {
                const atk = Math.min(cfg.attackSeconds, dur * 0.45);
                const rel = Math.min(cfg.releaseSeconds, dur * 0.7);
                const harmonicBase = 0.9;

                const phasesL = cfg.voices.map(() => Array.from({ length: cfg.harmonicsPerVoice }, () => 0));
                const phasesR = cfg.voices.map(() => Array.from({ length: cfg.harmonicsPerVoice }, () => 0));
                let carrierPhaseL = 0;
                let carrierPhaseR = 0;

                function envelopeLocal(t) {
                    let e = 1;
                    if (t < atk) e = t / atk;
                    else if (t > dur - rel) e = Math.max(0, (dur - t) / rel);
                    const tilt = 1 - 0.22 * (t / dur);
                    return e * tilt;
                }

                function onsetNoiseEnv(i, noiseSamples) {
                    if (noiseSamples <= 0 || i >= noiseSamples) return 0;
                    const x = i / noiseSamples;
                    return (x < 0.15 ? (x / 0.15) : 1) * (1 - x);
                }

                for (let i = 0; i < length; i++) {
                    const t = i / sr;
                    const x = t / dur;
                    const env = envelopeLocal(t);

                    let sL = 0;
                    let sR = 0;

                    for (let v = 0; v < cfg.voices.length; v++) {
                        const voice = cfg.voices[v];
                        const f0 = lerp(voice.fStart, voice.fEnd, x);
                        for (let h = 1; h <= cfg.harmonicsPerVoice; h++) {
                            const f = f0 * h;
                            const fL = f * ratioL;
                            const fR = f * ratioR;
                            const rollL = highFreqRolloff(fL);
                            const rollR = highFreqRolloff(fR);
                            if (rollL < 0.001 && rollR < 0.001) continue;
                            const partialDecay = Math.exp(-cfg.harmonicFalloff * (h - 1));
                            const ampBase = (harmonicBase / h) * partialDecay;

                            const incL = twoPi * (fL / sr);
                            const incR = twoPi * (fR / sr);
                            phasesL[v][h - 1] += incL;
                            phasesR[v][h - 1] += incR;
                            if (phasesL[v][h - 1] > 1e9) phasesL[v][h - 1] %= twoPi;
                            if (phasesR[v][h - 1] > 1e9) phasesR[v][h - 1] %= twoPi;

                            sL += Math.sin(phasesL[v][h - 1]) * (ampBase * rollL);
                            sR += Math.sin(phasesR[v][h - 1]) * (ampBase * rollR);
                        }
                    }

                    // carrier
                    if (carrierHz > 0 && carrierLevel > 0 && carrierHarmonics > 0) {
                        const carrierEnv = env * (1 - 0.25 * x);
                        const baseAmp = carrierLevel * carrierEnv;
                        const incCL = twoPi * ((carrierHz * ratioL) / sr);
                        const incCR = twoPi * ((carrierHz * ratioR) / sr);
                        carrierPhaseL += incCL;
                        carrierPhaseR += incCR;
                        if (carrierPhaseL > 1e9) carrierPhaseL %= twoPi;
                        if (carrierPhaseR > 1e9) carrierPhaseR %= twoPi;
                        for (let h = 1; h <= carrierHarmonics; h++) {
                            const fall = Math.exp(-0.33 * (h - 1));
                            const amp = baseAmp * (1 / h) * fall;
                            const fHL = (carrierHz * ratioL) * h;
                            const fHR = (carrierHz * ratioR) * h;
                            const rollL = highFreqRolloff(fHL);
                            const rollR = highFreqRolloff(fHR);
                            if (rollL > 0.001) sL += Math.sin(carrierPhaseL * h) * (amp * rollL);
                            if (rollR > 0.001) sR += Math.sin(carrierPhaseR * h) * (amp * rollR);
                        }
                    }

                    // onset noise
                    const noiseSamples = Math.max(0, Math.floor((cfg.onsetNoiseSeconds || 0) * sr));
                    if (noiseLevel > 0 && i < noiseSamples) {
                        const n0 = (Math.random() * 2 - 1);
                        const n1 = (Math.random() * 2 - 1);
                        const n = (n0 - 0.6 * n1);
                        const ne = onsetNoiseEnv(i, noiseSamples) * noiseLevel;
                        sL += n * ne;
                        sR += n * ne;
                    }

                    sL = Math.tanh(sL * drive) / driveNorm;
                    sR = Math.tanh(sR * drive) / driveNorm;
                    outLeft[offset + i] = sL * env;
                    outRight[offset + i] = sR * env;
                }
            }

            // Generate first, original-duration chirp into first block
            generateBlock(dur1, length1, left, right, 0);
            // Generate second chirp (double duration) into next block
            generateBlock(dur2, length2, left, right, length1);

            // Normalize peak to prevent clipping
            let peak = 0;
            for (let i = 0; i < totalLength; i++) {
                peak = Math.max(peak, Math.abs(left[i]), Math.abs(right[i]));
            }
            if (peak > 0) {
                const gain = 0.95 / peak;
                for (let i = 0; i < totalLength; i++) {
                    left[i] *= gain;
                    right[i] *= gain;
                }
            }
            return buffer;
        }

        // Mode 5 is generated as a continuous OscillatorNode stream inside `createChirperWidget`.

        // Mode 6: simple birdsong placeholder - a few short plinky notes with soft envelopes.
        function generateBirdPlaceholderBuffer(ctx, cfg) {
            const sr = ctx.sampleRate;
            const dur = Math.max(0.8, cfg.mode6Seconds || 1.6);
            const length = Math.max(1, Math.floor(dur * sr));
            const buffer = ctx.createBuffer(2, length, sr);
            const left = buffer.getChannelData(0);
            const right = buffer.getChannelData(1);

            const base = 4200; // a bright, bird-like region
            const sequence = [0, 3, 7, 10, 7, 3, 0];
            const noteDur = dur / (sequence.length + 1);

            function envAD(t, t0, td) {
                const a = Math.min(0.018, td * 0.18);
                const r = Math.min(0.06, td * 0.35);
                if (t < t0 || t > t0 + td) return 0;
                const local = t - t0;
                if (local < a) return local / a;
                if (local > td - r) return Math.max(0, (td - local) / r);
                return 1;
            }

            for (let i = 0; i < length; i++) {
                const t = i / sr;
                let s = 0;
                for (let n = 0; n < sequence.length; n++) {
                    const t0 = 0.08 + n * noteDur;
                    const td = noteDur * 0.86;
                    const e = envAD(t, t0, td);
                    if (e <= 0) continue;
                    const f = base * Math.pow(2, sequence[n] / 12) * (1 + 0.002 * Math.sin(t * 12));
                    // small harmonic content
                    s += Math.sin(2 * Math.PI * f * t) * (0.9 * e);
                    s += Math.sin(2 * Math.PI * f * 2 * t) * (0.18 * e);
                }
                // gentle stereo spread via tiny detune
                left[i] = Math.tanh(s * 0.85) * 0.9;
                right[i] = Math.tanh(s * 0.85) * 0.9;
            }

            // Normalize
            let peak = 0;
            for (let i = 0; i < length; i++) peak = Math.max(peak, Math.abs(left[i]), Math.abs(right[i]));
            if (peak > 0) {
                const g = 0.92 / peak;
                for (let i = 0; i < length; i++) { left[i] *= g; right[i] *= g; }
            }
            return buffer;
        }

        function unregisterAlarmContext(ctx) {
            activeAlarmContexts.delete(ctx);
        }

        function stopAllAlarms() {
            activeAlarmContexts.forEach(ctx => {
                try {
                    ctx.close();
                } catch (e) {}
            });
            activeAlarmContexts.clear();
            console.log('All alarms stopped');
        }

        // Expose globally for debugging orphan alarms
        window.stopAllAlarms = stopAllAlarms;

        // Audio IndexedDB Storage
        const AUDIO_DB_NAME = 'density-audio';
        const AUDIO_DB_VERSION = 1;
        const AUDIO_STORE_NAME = 'tracks';

        // IndexedDB helper functions
        function openAudioDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(AUDIO_DB_NAME, AUDIO_DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(AUDIO_STORE_NAME)) {
                        db.createObjectStore(AUDIO_STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveAudioBlob(id, blob, type) {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readwrite');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                store.put({ id, blob, type });
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = () => { db.close(); reject(tx.error); };
            });
        }

        async function getAudioBlob(id) {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readonly');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => { db.close(); resolve(request.result); };
                request.onerror = () => { db.close(); reject(request.error); };
            });
        }

        async function deleteAudioBlob(id) {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readwrite');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                store.delete(id);
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = () => { db.close(); reject(tx.error); };
            });
        }

        async function clearAllAudio() {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readwrite');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                store.clear();
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = () => { db.close(); reject(tx.error); };
            });
        }

                // Check whether a given cacheKey is referenced by any widget
                function isCacheKeyInUse(cacheKey, excludingWidgetId = null) {
                    if (!cacheKey) return false;
                    for (const w of widgets) {
                        if (excludingWidgetId != null && w.id === excludingWidgetId) continue;
                        if (!w.data) continue;
                        if (w.type === 'audio' && Array.isArray(w.data.tracks)) {
                            if (w.data.tracks.some(t => t && t.cacheKey === cacheKey)) return true;
                        }
                        if (w.type === 'dictaphone') {
                            if (w.data.cacheKey === cacheKey) return true;
                        }
                    }
                    return false;
                }

                // Cleanup a list of cacheKeys: delete from IndexedDB if unused and remove lingering refs from saved localStorage
                async function cleanupUnusedAudioKeys(keys, excludingWidgetId = null) {
                    if (!Array.isArray(keys) || keys.length === 0) return;
                    for (const key of keys) {
                        try {
                            if (!key) continue;
                            if (!isCacheKeyInUse(key, excludingWidgetId)) {
                                try {
                                    await deleteAudioBlob(key);
                                } catch (e) {
                                    console.error('Failed to delete audio blob during cleanup:', key, e);
                                }

                                // Remove any lingering references from persisted widget list
                                try {
                                    const raw = localStorage.getItem('density-widgets');
                                    if (raw) {
                                        const arr = JSON.parse(raw);
                                        let changed = false;
                                        for (const w of arr) {
                                            if (!w.data) continue;
                                            if (w.type === 'audio' && Array.isArray(w.data.tracks)) {
                                                const before = w.data.tracks.length;
                                                w.data.tracks = w.data.tracks.filter(t => t && t.cacheKey !== key);
                                                if (w.data.tracks.length !== before) changed = true;
                                            }
                                            if (w.type === 'dictaphone' && w.data.cacheKey === key) {
                                                w.data.cacheKey = null;
                                                changed = true;
                                            }
                                        }
                                        if (changed) localStorage.setItem('density-widgets', JSON.stringify(arr));
                                    }
                                } catch (e) {
                                    console.error('Failed to remove cacheKey from saved widgets:', e);
                                }
                            }
                        } catch (e) {
                            console.error('Error while cleaning up audio key', key, e);
                        }
                    }
                }

        // State
        let widgets = [];
        let widgetIdCounter = 0;

        // Back here geolocation tracking
        let _backHereWatchId = null;
        let _lastGeoPos = null;
        let _geoHistory = [];
        let _prevGeoPos = null;
        let _movementHeadingDegrees = null; // derived from GPS movement, degrees
        const _backHereListeners = new Map(); // widgetId -> updater fn
        // Device orientation (facing) - used to rotate the rose relative to where the device is facing
        let _deviceHeading = null; // degrees, 0 = device facing north/up depending on alpha handling
        let _deviceAbsolute = false; // whether the orientation event is absolute (magnetometer fused)
        let _deviceOrientationStarted = false;
        let _deviceOrientationHandler = null;

        function ensureDeviceOrientationStarted() {
            if (_deviceOrientationStarted) return;
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS requires a permission prompt. Request absolute (magnetometer) if possible.
                try {
                    // Try to request absolute (includes magnetometer) so `absolute` events are provided if allowed
                    DeviceOrientationEvent.requestPermission(true).then((resp) => {
                        if (resp === 'granted') {
                            _deviceOrientationHandler = (e) => handleDeviceOrientation(e);
                            window.addEventListener('deviceorientation', _deviceOrientationHandler, true);
                            _deviceOrientationStarted = true;
                        } else {
                            // fallback to non-absolute request
                            DeviceOrientationEvent.requestPermission().then((r2) => {
                                if (r2 === 'granted') {
                                    _deviceOrientationHandler = (e) => handleDeviceOrientation(e);
                                    window.addEventListener('deviceorientation', _deviceOrientationHandler, true);
                                    _deviceOrientationStarted = true;
                                }
                            }).catch(() => {});
                        }
                    }).catch(() => {
                        // fallback silent
                    });
                } catch (e) {}
            } else {
                _deviceOrientationHandler = (e) => handleDeviceOrientation(e);
                window.addEventListener('deviceorientation', _deviceOrientationHandler, true);
                _deviceOrientationStarted = true;
            }
        }

        function stopDeviceOrientationIfNone() {
            const any = widgets.some(w => w.type === 'backhere');
            if (!any && _deviceOrientationStarted) {
                try { window.removeEventListener('deviceorientation', _deviceOrientationHandler, true); } catch (e) {}
                _deviceOrientationHandler = null;
                _deviceOrientationStarted = false;
                _deviceHeading = null;
            }
        }

        function handleDeviceOrientation(e) {
            // Compute device facing heading from Euler angles (alpha, beta, gamma)
            // Convert to radians
            const toRad = v => v * Math.PI / 180;
            const a = (typeof e.alpha === 'number') ? toRad(e.alpha) : 0;
            const b = (typeof e.beta === 'number') ? toRad(e.beta) : 0;
            const g = (typeof e.gamma === 'number') ? toRad(e.gamma) : 0;

            // Rotation matrices (Z * X * Y) per DeviceOrientation spec
            const cA = Math.cos(a), sA = Math.sin(a);
            const cB = Math.cos(b), sB = Math.sin(b);
            const cG = Math.cos(g), sG = Math.sin(g);

            // Build combined rotation matrix R = Rz(a) * Rx(b) * Ry(g)
            const m11 = cA * cG - sA * sB * sG;
            const m12 = - cB * sA;
            const m13 = cA * sG + cG * sA * sB;

            const m21 = cG * sA + cA * sB * sG;
            const m22 = cA * cB;
            const m23 = sA * sG - cA * cG * sB;

            const m31 = - cB * sG;
            const m32 = sB;
            const m33 = cB * cG;

            // Use the worked example from the DeviceOrientation spec (Z-X-Y)
            // to compute the horizontal compass-like heading from alpha/beta/gamma.
            // This computes the horizontal components Vx,Vy of the device 'out-of-screen'
            // vector and then extracts the azimuth (heading) avoiding pitch/roll coupling.
            const sX = Math.sin(b), sY = Math.sin(g), sZ = Math.sin(a);
            const cX = Math.cos(b), cY = Math.cos(g), cZ = Math.cos(a);

            // Vx, Vy per spec example A.1
            const Vx = - cZ * sY - sZ * sX * cY;
            const Vy = - sZ * sY + cZ * sX * cY;

            // Use atan2 to get correct quadrant. result is radians where 0 points to +Y
            let headingRad = Math.atan2(Vx, Vy);
            let headingDeg = headingRad * 180 / Math.PI;
            if (headingDeg < 0) headingDeg += 360;
            _deviceHeading = headingDeg;

            // notify widgets to re-render using latest device heading
            for (const fn of _backHereListeners.values()) {
                try { fn(_lastGeoPos); } catch (err) { console.error(err); }
            }
        }

        function _computeDistanceMeters(aLat, aLon, bLat, bLon) {
            const R = 6371000; // metres
            const toRad = v => v * Math.PI / 180;
            const dLat = toRad(bLat - aLat);
            const dLon = toRad(bLon - aLon);
            const lat1 = toRad(aLat);
            const lat2 = toRad(bLat);
            const sinDLat = Math.sin(dLat/2);
            const sinDLon = Math.sin(dLon/2);
            const a = sinDLat*sinDLat + Math.cos(lat1)*Math.cos(lat2)*sinDLon*sinDLon;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function _computeBearingDegrees(aLat, aLon, bLat, bLon) {
            const toRad = v => v * Math.PI / 180;
            const toDeg = v => v * 180 / Math.PI;
            const phi1 = toRad(aLat);
            const phi2 = toRad(bLat);
            const lambda1 = toRad(aLon);
            const lambda2 = toRad(bLon);
            const y = Math.sin(lambda2-lambda1) * Math.cos(phi2);
            const x = Math.cos(phi1)*Math.sin(phi2) - Math.sin(phi1)*Math.cos(phi2)*Math.cos(lambda2-lambda1);
            const brng = toDeg(Math.atan2(y, x));
            return (brng + 360) % 360;
        }

        function ensureBackHereWatchStarted() {
            if (_backHereWatchId !== null) return;
            if (!navigator.geolocation) return;
            _backHereWatchId = navigator.geolocation.watchPosition((pos) => {
                // maintain a short history of fixes to compute heading over >=1s intervals
                try {
                    // push current pos into history
                    _geoHistory.push(pos);
                    const nowTs = pos.timestamp || Date.now();
                    // prune old entries >5s to keep array small
                    while (_geoHistory.length > 0 && (nowTs - (_geoHistory[0].timestamp || nowTs)) > 5000) _geoHistory.shift();

                    // find earliest entry at least 1000ms older than now
                    let older = null;
                    for (let i = 0; i < _geoHistory.length; i++) {
                        const ent = _geoHistory[i];
                        const dt = nowTs - (ent.timestamp || nowTs);
                        if (dt >= 1000) { older = ent; break; }
                    }

                    if (older && _lastGeoPos) {
                        const prev = older.coords;
                        const cur = pos.coords;
                        const moved = _computeDistanceMeters(prev.latitude, prev.longitude, cur.latitude, cur.longitude);
                        const dt = (pos.timestamp || Date.now()) - (older.timestamp || Date.now());
                        if (dt > 0 && dt <= 60000 && moved > 1) {
                            // prefer reported speed on the newest fix
                            let speed_m_s = null;
                            if (typeof cur.speed === 'number' && !isNaN(cur.speed) && cur.speed >= 0) {
                                speed_m_s = cur.speed;
                            } else {
                                speed_m_s = moved / (dt / 1000);
                            }
                            if (typeof speed_m_s === 'number' && speed_m_s > 0.5) {
                                _movementHeadingDegrees = _computeBearingDegrees(prev.latitude, prev.longitude, cur.latitude, cur.longitude);
                                _prevGeoPos = older;
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Failed to compute movement heading', e);
                }
                // If any backhere widget hasn't had its initial `here` set yet, set it now
                try {
                    for (const w of widgets) {
                        if (w.type === 'backhere') {
                            if (!w.data) w.data = {};
                            if (!w.data.here) {
                                w.data.here = { lat: pos.coords.latitude, lon: pos.coords.longitude, ts: pos.timestamp };
                                // Note: continue loop to set for any other widgets missing 'here'
                            }
                        }
                    }
                    // Persist any new here values
                    saveWidgets();
                } catch (e) {
                    console.error('Failed to set initial here for backhere widgets', e);
                }

                _lastGeoPos = pos;
                // notify listeners
                for (const fn of _backHereListeners.values()) {
                    try { fn(pos); } catch (e) { console.error(e); }
                }
            }, (err) => {
                console.warn('BackHere geolocation error', err);
            }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 });
        }

        function stopBackHereWatchIfNone() {
            const any = widgets.some(w => w.type === 'backhere');
            if (!any && _backHereWatchId !== null) {
                try { navigator.geolocation.clearWatch(_backHereWatchId); } catch (e) {}
                _backHereWatchId = null;
                _lastGeoPos = null;
            }
        }

        // Theme Management
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Enumerate all stored audio keys in IndexedDB
        async function listAllAudioKeys() {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                try {
                    const tx = db.transaction(AUDIO_STORE_NAME, 'readonly');
                    const store = tx.objectStore(AUDIO_STORE_NAME);
                    const keys = [];
                    const req = store.openCursor();
                    req.onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            if (cursor.key) keys.push(cursor.key);
                            cursor.continue();
                        }
                    };
                    tx.oncomplete = () => { db.close(); resolve(keys); };
                    tx.onerror = () => { db.close(); reject(tx.error); };
                } catch (err) {
                    db.close();
                    reject(err);
                }
            });
        }

        // Scan IndexedDB for orphaned audio blobs (no widget/localStorage refs) and delete them
        async function scanAndCleanupOrphanedAudio() {
            try {
                const allKeys = await listAllAudioKeys();
                if (!allKeys || allKeys.length === 0) return;
                const toDelete = [];
                for (const key of allKeys) {
                    if (!isCacheKeyInUse(key, null)) toDelete.push(key);
                }
                if (toDelete.length === 0) return;
                console.info('Density: removing orphaned audio keys:', toDelete);
                await cleanupUnusedAudioKeys(toDelete, null);
            } catch (e) {
                console.error('Failed to scan/cleanup orphaned audio:', e);
            }
        }

        function applyTheme(theme) {
            const effectiveTheme = theme === 'system' ? getSystemTheme() : theme;
            document.documentElement.setAttribute('data-theme', effectiveTheme);
            localStorage.setItem('density-theme', theme);
            updateAllThemeButtons(theme);
        }

        function updateAllThemeButtons(theme) {
            // Update root theme button
            const rootThemeBtn = document.querySelector('#rootThemeBtn');
            if (rootThemeBtn) {
                const iconMap = { system: icons.system, light: icons.sun, dark: icons.moon };
                rootThemeBtn.innerHTML = iconMap[theme];
                rootThemeBtn.dataset.theme = theme;
                rootThemeBtn.title = `Theme: ${theme.charAt(0).toUpperCase() + theme.slice(1)}`;
            }
        }

        function cycleTheme() {
            const themes = ['system', 'light', 'dark'];
            const current = localStorage.getItem('density-theme') || 'system';
            const nextIndex = (themes.indexOf(current) + 1) % themes.length;
            applyTheme(themes[nextIndex]);
        }

        function initTheme() {
            const saved = localStorage.getItem('density-theme') || 'system';
            applyTheme(saved);
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                const current = localStorage.getItem('density-theme') || 'system';
                if (current === 'system') applyTheme('system');
            });
        }

        // Widget Management
        let isLoading = false;

        function saveWidgets() {
            if (isLoading) {
                console.log('Skipping save during load');
                return; // Don't save while loading
            }
            const data = widgets.map(w => ({
                id: w.id,
                type: w.type,
                data: w.data
            }));
            localStorage.setItem('density-widgets', JSON.stringify(data));
        }

        function loadWidgets() {
            isLoading = true;
            try {
                const saved = localStorage.getItem('density-widgets');
                if (saved) {
                    const data = JSON.parse(saved);
                    data.forEach(w => {
                        addWidget(w.type, w.data, w.id);
                    });
                }
            } catch (e) {
                console.error('Failed to load widgets:', e);
            }
            isLoading = false;
        }

        function addWidget(type, data = {}, existingId = null) {
            const widgetType = widgetTypes[type];
            if (!widgetType) {
                console.error('Unknown widget type:', type);
                return;
            }

            const id = existingId || ++widgetIdCounter;
            if (id > widgetIdCounter) widgetIdCounter = id;

            const widget = {
                id,
                type,
                data: { ...data }
            };

            try {
                const element = widgetType.create(widget);
                document.getElementById('widgetGrid').appendChild(element);
                widgets.push(widget); // Only add to array if creation succeeded
            } catch (e) {
                console.error('Failed to create widget:', type, e);
                return;
            }
            
            if (!existingId) saveWidgets();
            return widget;
        }

        function removeWidget(id) {
            const index = widgets.findIndex(w => w.id === id);
            if (index > -1) {
                widgets.splice(index, 1);
                const element = document.querySelector(`[data-widget-id="${id}"]`);
                if (element) {
                    element.style.transform = 'scale(0.9)';
                    element.style.opacity = '0';
                    setTimeout(() => element.remove(), 200);
                }
                saveWidgets();
                // If no more Back here widgets remain, stop the global geolocation watch
                try { stopBackHereWatchIfNone(); } catch (e) {}
            }
        }

        function updateWidgetData(id, data) {
            const widget = widgets.find(w => w.id === id);
            if (widget) {
                Object.assign(widget.data, data);
                saveWidgets();
            }
        }

        // Add Widget Tile
        function createAddWidgetTile() {
            const tile = document.createElement('div');
            tile.className = 'tile size-1x1 add-widget-tile';
            tile.innerHTML = `
                <div class="widget-header">
                    <span class="widget-title">Add Widget</span>
                </div>
                <div class="widget-content">
                    <div class="add-widget-row">
                        <select class="input-inset" id="widgetTypeSelect">
                            ${Object.entries(widgetTypes).map(([key, val]) => 
                                `<option value="${key}">${val.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="add-widget-row">
                        <button class="btn accent-add" style="flex:1; height: 36px;" id="addWidgetBtn" title="Add widget">
                            ${icons.plus}
                        </button>
                        <button class="btn" style="flex:1; height: 36px;" id="rootThemeBtn" data-theme="${localStorage.getItem('density-theme') || 'system'}" title="Theme: System">
                            ${icons.system}
                        </button>
                        <button class="btn" style="flex:1; height: 36px;" id="rootFullscreenBtn" title="Toggle fullscreen">
                            ${icons.fullscreen}
                        </button>
                    </div>
                </div>
            `;

            // Initialize theme button icon
            const currentTheme = localStorage.getItem('density-theme') || 'system';
            const themeBtn = tile.querySelector('#rootThemeBtn');
            const iconMap = { system: icons.system, light: icons.sun, dark: icons.moon };
            themeBtn.innerHTML = iconMap[currentTheme];
            themeBtn.title = `Theme: ${currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1)}`;

            tile.querySelector('#addWidgetBtn').addEventListener('click', () => {
                const type = tile.querySelector('#widgetTypeSelect').value;
                addWidget(type);
            });

            themeBtn.addEventListener('click', cycleTheme);

            const fullscreenBtn = tile.querySelector('#rootFullscreenBtn');
            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(() => {});
                } else {
                    document.exitFullscreen().catch(() => {});
                }
            });

            // Update fullscreen icon on change
            document.addEventListener('fullscreenchange', () => {
                fullscreenBtn.innerHTML = document.fullscreenElement ? icons.fullscreenExit : icons.fullscreen;
                fullscreenBtn.title = document.fullscreenElement ? 'Exit fullscreen' : 'Toggle fullscreen';
            });

            return tile;
        }

        // Spinner Widget
        function createSpinnerWidget(widget) {
            const data = widget.data;
            if (!data.allItems) data.allItems = [];
            if (!data.items) data.items = [];
            if (data.currentIndex === undefined) data.currentIndex = 0;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.spinner.size}`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Spinner</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="spinner-input-row">
                    <input type="text" class="input-inset spinner-input" placeholder="â€”">
                </div>
                <div class="spinner-controls">
                    <button class="btn btn-small accent-up" title="Previous">${icons.up}</button>
                    <button class="btn btn-small accent-down" title="Next">${icons.down}</button>
                    <button class="btn btn-small accent-add" title="Add new">${icons.plus}</button>
                    <button class="btn btn-small accent-delete spinner-delete" title="Delete">${icons.delete}</button>
                    <button class="btn btn-small accent-spin spinner-spin" title="Spin">${icons.spin}</button>
                    <button class="btn btn-small accent-spin spinner-remove-spin" title="Remove and spin">${icons.spinRemove}</button>
                    <button class="btn btn-small accent-reset spinner-reset" title="Reset">${icons.reset}</button>
                </div>
            `;

            const input = tile.querySelector('.spinner-input');
            let isSpinning = false;

            function updateDisplay() {
                if (data.allItems.length === 0) {
                    input.value = '';
                    input.placeholder = 'â€”';
                } else {
                    input.value = data.allItems[data.currentIndex] || '';
                }
            }

            function saveCurrentInput() {
                const val = input.value;
                if (data.allItems.length === 0) {
                    // Create first item in both lists
                    data.items.push(val);
                    data.allItems.push(val);
                    data.currentIndex = 0;
                } else {
                    // Update current item in allItems
                    const oldVal = data.allItems[data.currentIndex];
                    data.allItems[data.currentIndex] = val;
                    // Also update in visible items if present
                    const visIdx = data.items.indexOf(oldVal);
                    if (visIdx !== -1) {
                        data.items[visIdx] = val;
                    }
                }
                updateWidgetData(widget.id, { items: data.items, allItems: data.allItems, currentIndex: data.currentIndex });
            }

            function addNewItem() {
                // Save current first if we have content
                if (data.allItems.length > 0) {
                    const oldVal = data.allItems[data.currentIndex];
                    const newVal = input.value;
                    data.allItems[data.currentIndex] = newVal;
                    const visIdx = data.items.indexOf(oldVal);
                    if (visIdx !== -1) {
                        data.items[visIdx] = newVal;
                    }
                }
                // Add new empty item to both lists
                data.items.push('');
                data.allItems.push('');
                data.currentIndex = data.allItems.length - 1;
                updateDisplay();
                input.focus();
                updateWidgetData(widget.id, { items: data.items, allItems: data.allItems, currentIndex: data.currentIndex });
            }

            function navigate(dir) {
                if (data.allItems.length === 0) return;
                // Re-align currentIndex to allItems based on current displayed value
                const currentVal = input.value;
                const alignedIndex = data.allItems.indexOf(currentVal);
                if (alignedIndex !== -1) {
                    data.currentIndex = alignedIndex;
                }
                // Now navigate
                data.currentIndex = (data.currentIndex + dir + data.allItems.length) % data.allItems.length;
                const currentItem = data.allItems[data.currentIndex];
                // Add back to visible list if not present
                if (!data.items.includes(currentItem)) {
                    data.items.push(currentItem);
                }
                updateDisplay();
                updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
            }

            function deleteCurrent() {
                if (data.allItems.length === 0) return;
                const removed = data.allItems.splice(data.currentIndex, 1)[0];
                // Also remove from visible items
                const visIdx = data.items.indexOf(removed);
                if (visIdx !== -1) {
                    data.items.splice(visIdx, 1);
                }
                if (data.allItems.length === 0) {
                    data.currentIndex = 0;
                } else if (data.currentIndex >= data.allItems.length) {
                    data.currentIndex = data.allItems.length - 1;
                }
                updateDisplay();
                updateWidgetData(widget.id, { items: data.items, allItems: data.allItems, currentIndex: data.currentIndex });
            }

            function spin() {
                if (isSpinning || data.items.length === 0) return;
                isSpinning = true;
                input.classList.add('spinning');

                const duration = 3000;
                const interval = 100;
                const steps = duration / interval;
                let step = 0;

                const finalIndex = Math.floor(Math.random() * data.items.length);

                const spinInterval = setInterval(() => {
                    const randomIdx = Math.floor(Math.random() * data.items.length);
                    input.value = data.items[randomIdx];
                    step++;

                    if (step >= steps) {
                        clearInterval(spinInterval);
                        data.currentIndex = finalIndex;
                        input.value = data.items[finalIndex];
                        input.classList.remove('spinning');
                        isSpinning = false;
                        updateWidgetData(widget.id, { currentIndex: data.currentIndex });
                    }
                }, interval);
            }

            function removeAndSpin() {
                if (isSpinning || data.items.length === 0) return;
                // Remove current item from visible list only (stays in allItems)
                data.items.splice(data.currentIndex, 1);
                if (data.items.length === 0) {
                    data.currentIndex = 0;
                    updateDisplay();
                    updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
                    return;
                }
                if (data.currentIndex >= data.items.length) {
                    data.currentIndex = data.items.length - 1;
                }
                // Then spin remaining items
                isSpinning = true;
                input.classList.add('spinning');

                const duration = 3000;
                const interval = 100;
                const steps = duration / interval;
                let step = 0;

                const finalIndex = Math.floor(Math.random() * data.items.length);

                const spinInterval = setInterval(() => {
                    const randomIdx = Math.floor(Math.random() * data.items.length);
                    input.value = data.items[randomIdx];
                    step++;

                    if (step >= steps) {
                        clearInterval(spinInterval);
                        data.currentIndex = finalIndex;
                        input.value = data.items[finalIndex];
                        input.classList.remove('spinning');
                        isSpinning = false;
                        updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
                    }
                }, interval);
            }

            function reset() {
                // Restore visible list from full list
                data.items = [...data.allItems];
                data.currentIndex = data.items.length > 0 ? 0 : 0;
                updateDisplay();
                updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
            }

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));
            tile.querySelector('.btn.accent-add').addEventListener('click', addNewItem);
            tile.querySelector('.btn.accent-up').addEventListener('click', () => navigate(-1));
            tile.querySelector('.btn.accent-down').addEventListener('click', () => navigate(1));
            tile.querySelector('.spinner-delete').addEventListener('click', deleteCurrent);
            tile.querySelector('.spinner-spin').addEventListener('click', spin);
            tile.querySelector('.spinner-remove-spin').addEventListener('click', removeAndSpin);
            tile.querySelector('.spinner-reset').addEventListener('click', reset);
            input.addEventListener('input', saveCurrentInput);

            updateDisplay();
            return tile;
        }

        // Tasks Widget
        function createTasksWidget(widget) {
            const data = widget.data;
            if (!data.tasks) data.tasks = [];
            if (data.currentIndex === undefined) data.currentIndex = 0;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.tasks.size} tasks-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Tasks</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="task-input-wrapper">
                    <button class="task-check-btn" title="Toggle complete">${icons.checkBox}</button>
                    <input type="text" class="task-input" placeholder="â€”">
                </div>
                <div class="task-controls">
                    <button class="btn btn-small accent-up task-prev" title="Previous">${icons.up}</button>
                    <button class="btn btn-small accent-down task-next" title="Next">${icons.down}</button>
                    <button class="btn btn-small accent-add task-add" title="Add task">${icons.plus}</button>
                    <button class="btn btn-small accent-delete task-delete" title="Delete task">${icons.delete}</button>
                </div>
            `;

            const input = tile.querySelector('.task-input');
            const checkBtn = tile.querySelector('.task-check-btn');

            function updateDisplay() {
                if (data.tasks.length === 0) {
                    input.value = '';
                    input.placeholder = 'â€”';
                    input.classList.remove('checked');
                    checkBtn.innerHTML = icons.checkBox;
                    checkBtn.classList.remove('checked');
                } else {
                    const task = data.tasks[data.currentIndex];
                    input.value = task ? task.text : '';
                    input.classList.toggle('checked', task && task.done);
                    checkBtn.innerHTML = task && task.done ? icons.checkBoxChecked : icons.checkBox;
                    checkBtn.classList.toggle('checked', task && task.done);
                }
            }

            function saveCurrentInput() {
                const val = input.value;
                if (data.tasks.length === 0) {
                    data.tasks.push({ text: val, done: false });
                    data.currentIndex = 0;
                } else {
                    data.tasks[data.currentIndex].text = val;
                }
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            function addNewTask() {
                if (data.tasks.length > 0) {
                    data.tasks[data.currentIndex].text = input.value;
                }
                data.tasks.push({ text: '', done: false });
                data.currentIndex = data.tasks.length - 1;
                updateDisplay();
                input.focus();
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            function navigate(dir) {
                if (data.tasks.length === 0) return;
                data.currentIndex = (data.currentIndex + dir + data.tasks.length) % data.tasks.length;
                updateDisplay();
                updateWidgetData(widget.id, { currentIndex: data.currentIndex });
            }

            function deleteCurrent() {
                if (data.tasks.length === 0) return;
                data.tasks.splice(data.currentIndex, 1);
                if (data.tasks.length === 0) {
                    data.currentIndex = 0;
                } else if (data.currentIndex >= data.tasks.length) {
                    data.currentIndex = data.tasks.length - 1;
                }
                updateDisplay();
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            function toggleCheck() {
                if (data.tasks.length === 0) {
                    // Create first task if none exists
                    const val = input.value.trim();
                    if (val) {
                        data.tasks.push({ text: val, done: true });
                        data.currentIndex = 0;
                    } else {
                        return;
                    }
                } else {
                    data.tasks[data.currentIndex].done = !data.tasks[data.currentIndex].done;
                }
                updateDisplay();
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));
            tile.querySelector('.task-add').addEventListener('click', addNewTask);
            tile.querySelector('.task-prev').addEventListener('click', () => navigate(-1));
            tile.querySelector('.task-next').addEventListener('click', () => navigate(1));
            tile.querySelector('.task-delete').addEventListener('click', deleteCurrent);
            checkBtn.addEventListener('click', toggleCheck);
            input.addEventListener('input', saveCurrentInput);

            updateDisplay();
            return tile;
        }

        // Audio Widget
        function createAudioWidget(widget) {
            const data = widget.data;
            if (!data.tracks) data.tracks = [];
            if (data.currentIndex === undefined) data.currentIndex = 0;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.audio.size} audio-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Audio</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="audio-display empty">â€”</div>
                <div class="audio-controls">
                    <button class="btn btn-small accent-up audio-prev" title="Previous">${icons.prev}</button>
                    <button class="btn btn-small accent-down audio-next" title="Next">${icons.next}</button>
                    <button class="btn btn-small accent-add audio-add" title="Add track">${icons.plus}</button>
                    <button class="btn btn-small accent-delete audio-delete" title="Delete track">${icons.delete}</button>
                    <button class="btn btn-small accent-spin audio-play" title="Play">${icons.play}</button>
                    <button class="btn btn-small accent-spin audio-pause" title="Pause">${icons.pause}</button>
                    <button class="btn btn-small accent-reset audio-stop" title="Stop">${icons.stop}</button>
                    <button class="btn btn-small accent-reset audio-shuffle" title="Shuffle">${icons.shuffle}</button>
                </div>
                <input type="file" class="audio-file-input" accept="audio/mpeg,audio/ogg,audio/wav,.mp3,.ogg,.wav" multiple>
            `;

            const display = tile.querySelector('.audio-display');
            const fileInput = tile.querySelector('.audio-file-input');
            const pauseBtn = tile.querySelector('.audio-pause');
            let audio = new Audio();
            let isPlaying = false;
            let isPaused = false;

            // Validate tracks against IndexedDB on load
            async function validateTracks() {
                if (data.tracks.length === 0) return;
                try {
                    const validTracks = [];
                    for (const track of data.tracks) {
                        const stored = await getAudioBlob(track.cacheKey);
                        if (stored) {
                            validTracks.push(track);
                        }
                    }
                    if (validTracks.length !== data.tracks.length) {
                        data.tracks = validTracks;
                        if (data.currentIndex >= data.tracks.length) {
                            data.currentIndex = Math.max(0, data.tracks.length - 1);
                        }
                        updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                    }
                } catch (e) {
                    console.error('Failed to validate audio storage:', e);
                }
                updateDisplay();
            }

            function updateDisplay() {
                if (data.tracks.length === 0) {
                    display.innerHTML = '<span class="track-name">â€”</span>';
                    display.classList.add('empty');
                } else {
                    const track = data.tracks[data.currentIndex];
                    const name = track ? track.name : 'â€”';
                    display.innerHTML = `<span class="track-name">${name.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>`;
                    display.classList.remove('empty');
                    // Check for overflow and add scrolling animation
                    requestAnimationFrame(() => {
                        const span = display.querySelector('.track-name');
                        if (span) {
                            span.classList.remove('scrolling');
                            span.style.removeProperty('--scroll-distance');
                            span.style.removeProperty('--scroll-duration');
                            // Account for container padding (8px on each side)
                            const style = getComputedStyle(display);
                            const paddingLeft = parseFloat(style.paddingLeft) || 0;
                            const paddingRight = parseFloat(style.paddingRight) || 0;
                            const availableWidth = display.clientWidth - paddingLeft - paddingRight;
                            const overflow = span.scrollWidth - availableWidth;
                            if (overflow > 0) {
                                const distance = -overflow - 4; // Small extra buffer
                                const duration = Math.max(4, Math.min(12, overflow / 30)); // 4-12s based on length
                                span.style.setProperty('--scroll-distance', `${distance}px`);
                                span.style.setProperty('--scroll-duration', `${duration}s`);
                                span.classList.add('scrolling');
                            }
                        }
                    });
                }
            }

            async function addFiles(files) {
                try {
                    for (const file of files) {
                        if (!file.type.match(/^audio\/(mpeg|ogg|wav)$/)) continue;
                        const cacheKey = `audio-${widget.id}-${Date.now()}-${file.name}`;
                        await saveAudioBlob(cacheKey, file, file.type);
                        data.tracks.push({
                            name: file.name.replace(/\.[^.]+$/, ''),
                            cacheKey: cacheKey
                        });
                    }
                    data.currentIndex = data.tracks.length - 1;
                    updateDisplay();
                    updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                    // Load but don't auto-play
                    await loadTrack();
                } catch (e) {
                    console.error('Failed to store audio:', e);
                }
            }

            function navigate(dir) {
                if (data.tracks.length === 0) return;
                const wasPlaying = isPlaying && !isPaused;
                data.currentIndex = (data.currentIndex + dir + data.tracks.length) % data.tracks.length;
                updateDisplay();
                updateWidgetData(widget.id, { currentIndex: data.currentIndex });
                if (isPlaying || isPaused) {
                    // Load new track from start
                    loadTrack().then(() => {
                        if (wasPlaying) {
                            audio.play();
                        }
                    });
                }
            }

            async function loadTrack() {
                if (data.tracks.length === 0) return;
                try {
                    const track = data.tracks[data.currentIndex];
                    const stored = await getAudioBlob(track.cacheKey);
                    if (!stored) {
                        data.tracks.splice(data.currentIndex, 1);
                        if (data.currentIndex >= data.tracks.length) {
                            data.currentIndex = Math.max(0, data.tracks.length - 1);
                        }
                        updateDisplay();
                        updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                        return;
                    }
                    const url = URL.createObjectURL(stored.blob);
                    audio.src = url;
                    audio.currentTime = 0;
                } catch (e) {
                    console.error('Failed to load audio:', e);
                }
            }

            async function playTrack() {
                if (data.tracks.length === 0) return;
                // If paused, just resume
                if (isPaused) {
                    audio.play();
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                    return;
                }
                try {
                    const track = data.tracks[data.currentIndex];
                    const stored = await getAudioBlob(track.cacheKey);
                    if (!stored) {
                        // Track no longer in storage, remove it
                        data.tracks.splice(data.currentIndex, 1);
                        if (data.currentIndex >= data.tracks.length) {
                            data.currentIndex = Math.max(0, data.tracks.length - 1);
                        }
                        updateDisplay();
                        updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                        return;
                    }
                    const url = URL.createObjectURL(stored.blob);
                    audio.src = url;
                    audio.play();
                    isPlaying = true;
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                } catch (e) {
                    console.error('Failed to play audio:', e);
                }
            }

            function stopTrack() {
                audio.pause();
                audio.currentTime = 0;
                isPlaying = false;
                isPaused = false;
                pauseBtn.classList.remove('active');
            }

            function togglePause() {
                if (data.tracks.length === 0) return;
                if (isPaused) {
                    audio.play();
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                } else if (isPlaying) {
                    audio.pause();
                    isPaused = true;
                    pauseBtn.classList.add('active');
                }
            }

            async function deleteCurrent() {
                if (data.tracks.length === 0) return;
                const track = data.tracks[data.currentIndex];
                try {
                    // Only delete the blob if no other widget references this cacheKey
                    await cleanupUnusedAudioKeys([track.cacheKey], widget.id);
                } catch (e) {
                    console.error('Failed to delete from storage:', e);
                }
                data.tracks.splice(data.currentIndex, 1);
                if (data.currentIndex >= data.tracks.length) {
                    data.currentIndex = Math.max(0, data.tracks.length - 1);
                }
                stopTrack();
                updateDisplay();
                updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
            }

            async function shuffle() {
                if (data.tracks.length < 2) return;
                for (let i = data.tracks.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [data.tracks[i], data.tracks[j]] = [data.tracks[j], data.tracks[i]];
                }
                data.currentIndex = 0;
                updateDisplay();
                updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                // Load and optionally play shuffled track
                await loadTrack();
                if (!isPaused) {
                    audio.play();
                    isPlaying = true;
                }
            }

            // Auto-play next track when current ends
            audio.addEventListener('ended', () => {
                if (data.tracks.length > 1) {
                    data.currentIndex = (data.currentIndex + 1) % data.tracks.length;
                    updateDisplay();
                    updateWidgetData(widget.id, { currentIndex: data.currentIndex });
                    playTrack();
                } else {
                    isPlaying = false;
                }
            });

            // Drag and drop
            tile.addEventListener('dragover', (e) => {
                e.preventDefault();
                tile.classList.add('drop-active');
            });

            tile.addEventListener('dragleave', (e) => {
                e.preventDefault();
                tile.classList.remove('drop-active');
            });

            tile.addEventListener('drop', (e) => {
                e.preventDefault();
                tile.classList.remove('drop-active');
                const files = Array.from(e.dataTransfer.files).filter(f => 
                    f.type === 'audio/mpeg' || f.type === 'audio/ogg' || f.type === 'audio/wav'
                );
                if (files.length > 0) addFiles(files);
            });

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', async () => {
                stopTrack();
                // Clean up any audio blobs owned by this widget that are not referenced elsewhere
                try {
                    const keys = (data.tracks || []).map(t => t && t.cacheKey).filter(Boolean);
                    await cleanupUnusedAudioKeys(keys, widget.id);
                } catch (e) {
                    console.error('Error cleaning up audio for removed widget:', e);
                }
                removeWidget(widget.id);
            });
            tile.querySelector('.audio-add').addEventListener('click', () => fileInput.click());
            tile.querySelector('.audio-prev').addEventListener('click', () => navigate(-1));
            tile.querySelector('.audio-next').addEventListener('click', () => navigate(1));
            tile.querySelector('.audio-play').addEventListener('click', playTrack);
            tile.querySelector('.audio-pause').addEventListener('click', togglePause);
            tile.querySelector('.audio-stop').addEventListener('click', stopTrack);
            tile.querySelector('.audio-delete').addEventListener('click', deleteCurrent);
            tile.querySelector('.audio-shuffle').addEventListener('click', shuffle);
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    addFiles(Array.from(e.target.files));
                    e.target.value = '';
                }
            });

            // Validate cache on load
            validateTracks();

            return tile;
        }

        // Service Worker timer sync (for background notifications)
        const DENSITY_PAGE_URL = window.location.href;

        function postTimerMessageToServiceWorker(message) {
            if (!('serviceWorker' in navigator) || !message) return;
            navigator.serviceWorker.ready.then((registration) => {
                const target = registration.active || navigator.serviceWorker.controller;
                target?.postMessage(message);
            }).catch(() => {});
        }

        function syncTimerWithServiceWorker(timerId, timerName, endTime) {
            if (!endTime) {
                postTimerMessageToServiceWorker({ type: 'timer-cancel', timerId });
            } else {
                postTimerMessageToServiceWorker({
                    type: 'timer-sync',
                    timers: [{
                        id: timerId,
                        name: timerName || 'Timer',
                        endTime: endTime,
                        startUrl: DENSITY_PAGE_URL,
                        notify: true
                    }]
                });
            }
        }

        // Listen for service worker timer completion
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (!event.data || event.data.type !== 'timer-finished') return;
                // Timer finished in background - find matching widget and trigger alarm
                const timerId = event.data.timerId;
                document.querySelectorAll('.timer-widget').forEach(tile => {
                    const widgetId = tile.dataset.widgetId;
                    if (widgetId === timerId) {
                        // Dispatch a custom event the widget can listen for
                        tile.dispatchEvent(new CustomEvent('timer-background-finish'));
                    }
                });
            });
        }

        // Timer Widget
        function createTimerWidget(widget) {
            const data = widget.data;
            if (data.hours === undefined) data.hours = 0;
            if (data.minutes === undefined) data.minutes = 5;
            if (data.seconds === undefined) data.seconds = 0;
            if (data.soundEnabled === undefined) data.soundEnabled = true;
            // endTime stores the absolute timestamp when timer will finish (for background handling)
            if (data.endTime === undefined) data.endTime = null;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.timer.size} timer-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Timer</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="timer-display">
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="hours" tabindex="0">00</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="hours" data-dir="1" title="Increase hours">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="hours" data-dir="-1" title="Decrease hours">${icons.down}</button>
                        </div>
                    </div>
                    <span class="timer-colon">:</span>
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="minutes" tabindex="0">05</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="minutes" data-dir="1" title="Increase minutes">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="minutes" data-dir="-1" title="Decrease minutes">${icons.down}</button>
                        </div>
                    </div>
                    <span class="timer-colon">:</span>
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="seconds" tabindex="0">00</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="seconds" data-dir="1" title="Increase seconds">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="seconds" data-dir="-1" title="Decrease seconds">${icons.down}</button>
                        </div>
                    </div>
                </div>
                <div class="timer-controls">
                    <button class="btn btn-small accent-spin timer-start" title="Start">${icons.play}</button>
                    <button class="btn btn-small accent-spin timer-pause" title="Pause">${icons.pause}</button>
                    <button class="btn btn-small accent-reset timer-reset" title="Reset">${icons.reset}</button>
                    <button class="btn btn-small accent-add timer-sound" title="Toggle sound">${data.soundEnabled ? icons.volumeOn : icons.volumeOff}</button>
                </div>
            `;

            const timerDisplay = tile.querySelector('.timer-display');
            const hoursEl = tile.querySelector('[data-unit="hours"].timer-value');
            const minutesEl = tile.querySelector('[data-unit="minutes"].timer-value');
            const secondsEl = tile.querySelector('[data-unit="seconds"].timer-value');
            const startBtn = tile.querySelector('.timer-start');
            const pauseBtn = tile.querySelector('.timer-pause');
            const soundBtn = tile.querySelector('.timer-sound');

            let remainingMs = 0;
            let intervalId = null;
            let isRunning = false;
            let isPaused = false;
            let isAlarming = false;
            let audioCtx = null;
            let oscillator = null;
            let gainNode = null;

            function pad(n) {
                return String(n).padStart(2, '0');
            }

            function updateDisplay() {
                const totalSec = Math.ceil(remainingMs / 1000);
                const h = Math.floor(totalSec / 3600);
                const m = Math.floor((totalSec % 3600) / 60);
                const s = totalSec % 60;
                hoursEl.textContent = pad(h);
                minutesEl.textContent = pad(m);
                secondsEl.textContent = pad(s);
            }

            function updateFromData() {
                remainingMs = (data.hours * 3600 + data.minutes * 60 + data.seconds) * 1000;
                updateDisplay();
            }

            function adjustUnit(unit, dir) {
                if (isRunning && !isPaused) return;
                stopAlarm();
                const limits = { hours: 99, minutes: 59, seconds: 59 };
                data[unit] = Math.max(0, Math.min(limits[unit], data[unit] + dir));
                updateFromData();
                updateWidgetData(widget.id, { hours: data.hours, minutes: data.minutes, seconds: data.seconds });
            }

            function tick() {
                if (!data.endTime) return;
                remainingMs = Math.max(0, data.endTime - Date.now());
                updateDisplay();
                if (remainingMs <= 0) {
                    clearInterval(intervalId);
                    intervalId = null;
                    isRunning = false;
                    data.endTime = null;
                    updateWidgetData(widget.id, { endTime: null });
                    syncTimerWithServiceWorker(widget.id, 'Timer', null);
                    triggerAlarm();
                }
            }

            function startTimer() {
                if (isAlarming) {
                    stopAlarm();
                    return;
                }
                if (isRunning && !isPaused) return;
                if (isPaused) {
                    // Resume - set new endTime based on remaining time
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                    data.endTime = Date.now() + remainingMs;
                } else {
                    // Fresh start
                    updateFromData();
                    if (remainingMs <= 0) return;
                    data.endTime = Date.now() + remainingMs;
                }
                isRunning = true;
                updateWidgetData(widget.id, { endTime: data.endTime });
                syncTimerWithServiceWorker(widget.id, 'Timer', data.endTime);
                intervalId = setInterval(tick, 100);
            }

            function pauseTimer() {
                if (!isRunning || isPaused) return;
                if (isAlarming) {
                    stopAlarm();
                    return;
                }
                clearInterval(intervalId);
                intervalId = null;
                // Capture remaining time
                remainingMs = Math.max(0, data.endTime - Date.now());
                data.endTime = null;
                updateWidgetData(widget.id, { endTime: null });
                syncTimerWithServiceWorker(widget.id, 'Timer', null);
                isPaused = true;
                pauseBtn.classList.add('active');
            }

            function resetTimer() {
                stopAlarm();
                stopAlarmSound(); // Extra safety - always stop sound on reset
                clearInterval(intervalId);
                intervalId = null;
                isRunning = false;
                isPaused = false;
                data.endTime = null;
                updateWidgetData(widget.id, { endTime: null });
                syncTimerWithServiceWorker(widget.id, 'Timer', null);
                pauseBtn.classList.remove('active');
                updateFromData();
            }

            // Restore running timer on page load/visibility change
            function restoreRunningTimer() {
                if (data.endTime) {
                    const remaining = data.endTime - Date.now();
                    if (remaining > 0) {
                        remainingMs = remaining;
                        isRunning = true;
                        isPaused = false;
                        if (!intervalId) {
                            intervalId = setInterval(tick, 100);
                        }
                        updateDisplay();
                    } else {
                        // Timer finished while away
                        data.endTime = null;
                        updateWidgetData(widget.id, { endTime: null });
                        remainingMs = 0;
                        updateDisplay();
                        triggerAlarm();
                    }
                }
            }

            // Handle visibility change
            function handleVisibilityChange() {
                if (document.visibilityState === 'visible') {
                    restoreRunningTimer();
                }
            }

            document.addEventListener('visibilitychange', handleVisibilityChange);

            function triggerAlarm() {
                isAlarming = true;
                timerDisplay.classList.add('alarming');
                if (data.soundEnabled) {
                    playAlarmSound();
                }
            }

            function stopAlarm() {
                if (!isAlarming) return;
                isAlarming = false;
                timerDisplay.classList.remove('alarming');
                stopAlarmSound();
            }

            function playAlarmSound() {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    registerAlarmContext(audioCtx);
                    gainNode = audioCtx.createGain();
                    gainNode.connect(audioCtx.destination);
                    gainNode.gain.value = 0.3;

                    // Soft pulsing sine wave
                    oscillator = audioCtx.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440;
                    oscillator.connect(gainNode);
                    oscillator.start();

                    // Gentle pulse effect
                    const pulseGain = () => {
                        if (!isAlarming || !gainNode || !audioCtx) return;
                        const now = audioCtx.currentTime;
                        gainNode.gain.setValueAtTime(0.3, now);
                        gainNode.gain.linearRampToValueAtTime(0.1, now + 0.25);
                        gainNode.gain.linearRampToValueAtTime(0.3, now + 0.5);
                        setTimeout(pulseGain, 500);
                    };
                    pulseGain();
                } catch (e) {
                    console.error('Failed to play alarm:', e);
                }
            }

            function stopAlarmSound() {
                if (oscillator) {
                    try { oscillator.stop(); } catch (e) {}
                    oscillator = null;
                }
                if (audioCtx) {
                    unregisterAlarmContext(audioCtx);
                    try { audioCtx.close(); } catch (e) {}
                    audioCtx = null;
                }
                gainNode = null;
            }

            function toggleSound() {
                data.soundEnabled = !data.soundEnabled;
                soundBtn.innerHTML = data.soundEnabled ? icons.volumeOn : icons.volumeOff;
                updateWidgetData(widget.id, { soundEnabled: data.soundEnabled });
                if (!data.soundEnabled && isAlarming) {
                    stopAlarmSound();
                } else if (data.soundEnabled && isAlarming) {
                    playAlarmSound();
                }
            }

            // Handle direct value editing
            function handleValueClick(el, unit) {
                if (isRunning && !isPaused) return;
                stopAlarm();
                el.classList.add('editing');
                const currentVal = data[unit];
                el.textContent = '';
                el.contentEditable = true;
                el.focus();

                const finishEdit = () => {
                    el.contentEditable = false;
                    el.classList.remove('editing');
                    const val = parseInt(el.textContent) || 0;
                    const limits = { hours: 99, minutes: 59, seconds: 59 };
                    data[unit] = Math.max(0, Math.min(limits[unit], val));
                    updateFromData();
                    updateWidgetData(widget.id, { hours: data.hours, minutes: data.minutes, seconds: data.seconds });
                };

                el.addEventListener('blur', finishEdit, { once: true });
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        el.blur();
                    } else if (e.key === 'Escape') {
                        el.textContent = pad(currentVal);
                        el.blur();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        adjustUnit(unit, 1);
                        el.blur();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        adjustUnit(unit, -1);
                        el.blur();
                    }
                });
            }

            // Keyboard navigation on timer values
            [hoursEl, minutesEl, secondsEl].forEach(el => {
                const unit = el.dataset.unit;
                el.addEventListener('click', () => handleValueClick(el, unit));
                el.addEventListener('keydown', (e) => {
                    if (el.contentEditable === 'true') return;
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        adjustUnit(unit, 1);
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        adjustUnit(unit, -1);
                    } else if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleValueClick(el, unit);
                    }
                });
            });

            // Adjust buttons (touch/mouse)
            tile.querySelectorAll('.timer-adjust-btn').forEach(btn => {
                const unit = btn.dataset.unit;
                const dir = parseInt(btn.dataset.dir);
                
                let intervalId = null;
                let timeoutId = null;

                const startAdjust = (e) => {
                    e.preventDefault();
                    adjustUnit(unit, dir);
                    timeoutId = setTimeout(() => {
                        intervalId = setInterval(() => adjustUnit(unit, dir), 100);
                    }, 400);
                };

                const stopAdjust = () => {
                    clearTimeout(timeoutId);
                    clearInterval(intervalId);
                };

                btn.addEventListener('mousedown', startAdjust);
                btn.addEventListener('mouseup', stopAdjust);
                btn.addEventListener('mouseleave', stopAdjust);
                btn.addEventListener('touchstart', startAdjust, { passive: false });
                btn.addEventListener('touchend', stopAdjust);
                btn.addEventListener('touchcancel', stopAdjust);
            });

            // Handle background timer completion
            tile.addEventListener('timer-background-finish', () => {
                clearInterval(intervalId);
                intervalId = null;
                isRunning = false;
                data.endTime = null;
                remainingMs = 0;
                updateDisplay();
                updateWidgetData(widget.id, { endTime: null });
                if (document.visibilityState === 'visible') {
                    triggerAlarm();
                }
            });

            // Control buttons
            tile.querySelector('.widget-header .btn').addEventListener('click', () => {
                stopAlarm();
                clearInterval(intervalId);
                syncTimerWithServiceWorker(widget.id, 'Timer', null);
                document.removeEventListener('visibilitychange', handleVisibilityChange);
                removeWidget(widget.id);
            });
            startBtn.addEventListener('click', startTimer);
            pauseBtn.addEventListener('click', pauseTimer);
            tile.querySelector('.timer-reset').addEventListener('click', resetTimer);
            soundBtn.addEventListener('click', toggleSound);

            // Initialize and restore running timer if applicable
            updateFromData();
            restoreRunningTimer();
            return tile;
        }

        // Sleep Timer Widget - redirects to index.html when timer expires
        function createSleepTimerWidget(widget) {
            const data = widget.data;
            if (data.hours === undefined) data.hours = 0;
            if (data.minutes === undefined) data.minutes = 30;
            if (data.seconds === undefined) data.seconds = 0;
            // endTime stores absolute timestamp (no background needed - only works on page)
            if (data.endTime === undefined) data.endTime = null;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.sleep.size} timer-widget sleep-timer-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Sleep</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="timer-display">
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="hours" tabindex="0">00</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="hours" data-dir="1" title="Increase hours">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="hours" data-dir="-1" title="Decrease hours">${icons.down}</button>
                        </div>
                    </div>
                    <span class="timer-colon">:</span>
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="minutes" tabindex="0">30</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="minutes" data-dir="1" title="Increase minutes">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="minutes" data-dir="-1" title="Decrease minutes">${icons.down}</button>
                        </div>
                    </div>
                    <span class="timer-colon">:</span>
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="seconds" tabindex="0">00</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="seconds" data-dir="1" title="Increase seconds">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="seconds" data-dir="-1" title="Decrease seconds">${icons.down}</button>
                        </div>
                    </div>
                </div>
                <div class="timer-controls">
                    <button class="btn btn-small accent-spin timer-start" title="Start">${icons.play}</button>
                    <button class="btn btn-small accent-spin timer-pause" title="Pause">${icons.pause}</button>
                    <button class="btn btn-small accent-reset timer-reset" title="Reset">${icons.reset}</button>
                </div>
            `;

            const hoursEl = tile.querySelector('[data-unit="hours"].timer-value');
            const minutesEl = tile.querySelector('[data-unit="minutes"].timer-value');
            const secondsEl = tile.querySelector('[data-unit="seconds"].timer-value');
            const startBtn = tile.querySelector('.timer-start');
            const pauseBtn = tile.querySelector('.timer-pause');

            let remainingMs = 0;
            let intervalId = null;
            let isRunning = false;
            let isPaused = false;

            function pad(n) {
                return String(n).padStart(2, '0');
            }

            function updateDisplay() {
                const totalSec = Math.ceil(remainingMs / 1000);
                const h = Math.floor(totalSec / 3600);
                const m = Math.floor((totalSec % 3600) / 60);
                const s = totalSec % 60;
                hoursEl.textContent = pad(h);
                minutesEl.textContent = pad(m);
                secondsEl.textContent = pad(s);
            }

            function updateFromData() {
                remainingMs = (data.hours * 3600 + data.minutes * 60 + data.seconds) * 1000;
                updateDisplay();
            }

            function adjustUnit(unit, dir) {
                if (isRunning && !isPaused) return;
                const limits = { hours: 99, minutes: 59, seconds: 59 };
                data[unit] = Math.max(0, Math.min(limits[unit], data[unit] + dir));
                updateFromData();
                updateWidgetData(widget.id, { hours: data.hours, minutes: data.minutes, seconds: data.seconds });
            }

            function tick() {
                if (!data.endTime) return;
                remainingMs = Math.max(0, data.endTime - Date.now());
                updateDisplay();
                if (remainingMs <= 0) {
                    // Sleep timer finished - redirect to index to stop all audio
                    clearInterval(intervalId);
                    data.endTime = null;
                    updateWidgetData(widget.id, { endTime: null });
                    window.location.href = 'index.html';
                }
            }

            function startTimer() {
                if (isRunning && !isPaused) return;
                if (isPaused) {
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                    data.endTime = Date.now() + remainingMs;
                } else {
                    updateFromData();
                    if (remainingMs <= 0) return;
                    data.endTime = Date.now() + remainingMs;
                }
                isRunning = true;
                updateWidgetData(widget.id, { endTime: data.endTime });
                intervalId = setInterval(tick, 100);
            }

            function pauseTimer() {
                if (!isRunning || isPaused) return;
                clearInterval(intervalId);
                intervalId = null;
                remainingMs = Math.max(0, data.endTime - Date.now());
                data.endTime = null;
                updateWidgetData(widget.id, { endTime: null });
                isPaused = true;
                pauseBtn.classList.add('active');
            }

            function resetTimer() {
                clearInterval(intervalId);
                intervalId = null;
                isRunning = false;
                isPaused = false;
                data.endTime = null;
                updateWidgetData(widget.id, { endTime: null });
                pauseBtn.classList.remove('active');
                updateFromData();
            }

            // Restore running sleep timer on page load
            function restoreRunningTimer() {
                if (data.endTime) {
                    const remaining = data.endTime - Date.now();
                    if (remaining > 0) {
                        remainingMs = remaining;
                        isRunning = true;
                        isPaused = false;
                        if (!intervalId) {
                            intervalId = setInterval(tick, 100);
                        }
                        updateDisplay();
                    } else {
                        // Timer finished while away - redirect now
                        data.endTime = null;
                        updateWidgetData(widget.id, { endTime: null });
                        window.location.href = 'index.html';
                    }
                }
            }

            // Handle direct value editing
            function handleValueClick(el, unit) {
                if (isRunning && !isPaused) return;
                el.classList.add('editing');
                const currentVal = data[unit];
                el.textContent = '';
                el.contentEditable = true;
                el.focus();

                const finishEdit = () => {
                    el.contentEditable = false;
                    el.classList.remove('editing');
                    const val = parseInt(el.textContent) || 0;
                    const limits = { hours: 99, minutes: 59, seconds: 59 };
                    data[unit] = Math.max(0, Math.min(limits[unit], val));
                    updateFromData();
                    updateWidgetData(widget.id, { hours: data.hours, minutes: data.minutes, seconds: data.seconds });
                };

                el.addEventListener('blur', finishEdit, { once: true });
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        el.blur();
                    } else if (e.key === 'Escape') {
                        el.textContent = pad(currentVal);
                        el.blur();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        adjustUnit(unit, 1);
                        el.blur();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        adjustUnit(unit, -1);
                        el.blur();
                    }
                });
            }

            // Keyboard navigation on timer values
            [hoursEl, minutesEl, secondsEl].forEach(el => {
                const unit = el.dataset.unit;
                el.addEventListener('click', () => handleValueClick(el, unit));
                el.addEventListener('keydown', (e) => {
                    if (el.contentEditable === 'true') return;
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        adjustUnit(unit, 1);
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        adjustUnit(unit, -1);
                    } else if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleValueClick(el, unit);
                    }
                });
            });

            // Adjust buttons
            tile.querySelectorAll('.timer-adjust-btn').forEach(btn => {
                const unit = btn.dataset.unit;
                const dir = parseInt(btn.dataset.dir);
                
                let adjIntervalId = null;
                let timeoutId = null;

                const startAdjust = (e) => {
                    e.preventDefault();
                    adjustUnit(unit, dir);
                    timeoutId = setTimeout(() => {
                        adjIntervalId = setInterval(() => adjustUnit(unit, dir), 100);
                    }, 400);
                };

                const stopAdjust = () => {
                    clearTimeout(timeoutId);
                    clearInterval(adjIntervalId);
                };

                btn.addEventListener('mousedown', startAdjust);
                btn.addEventListener('mouseup', stopAdjust);
                btn.addEventListener('mouseleave', stopAdjust);
                btn.addEventListener('touchstart', startAdjust, { passive: false });
                btn.addEventListener('touchend', stopAdjust);
                btn.addEventListener('touchcancel', stopAdjust);
            });

            // Control buttons
            tile.querySelector('.widget-header .btn').addEventListener('click', () => {
                clearInterval(intervalId);
                removeWidget(widget.id);
            });
            startBtn.addEventListener('click', startTimer);
            pauseBtn.addEventListener('click', pauseTimer);
            tile.querySelector('.timer-reset').addEventListener('click', resetTimer);

            // Initialize and restore running timer if applicable
            updateFromData();
            restoreRunningTimer();
            return tile;
        }

        // Sheet Widget
        function createSheetWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.sheet.size} sheet-widget`;
            tile.dataset.widgetId = widget.id;

            const data = widget.data || { cells: {}, cols: 26, rows: 100 };
            if (!data.cells) data.cells = {};
            const numCols = data.cols || 26;
            const numRows = data.rows || 100;
            let selectedCell = null;
            let selectedRow = 0;
            let selectedCol = 0;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Sheet</span>
                    <button class="btn btn-small arm-btn" title="Unlock to allow removal">${icons.lock}</button>
                    <button class="btn btn-small accent-delete close-btn" title="Remove widget" disabled>${icons.close}</button>
                </div>
                <div class="sheet-toolbar">
                    <span class="sheet-cell-ref">A1</span>
                    <input type="text" class="sheet-formula-bar" placeholder="Enter value or =formula">
                    <button class="btn btn-small accent-spin" title="Sum">${icons.sigma}</button>
                    <button class="btn btn-small accent-add" title="Copy">${icons.copy}</button>
                    <button class="btn btn-small accent-add" title="Paste">${icons.paste}</button>
                </div>
                <div class="sheet-container">
                    <div class="sheet-scroll-wrapper">
                        <table class="sheet-table"></table>
                    </div>
                </div>
            `;

            const table = tile.querySelector('.sheet-table');
            const cellRefDisplay = tile.querySelector('.sheet-cell-ref');
            const formulaBar = tile.querySelector('.sheet-formula-bar');
            const armBtn = tile.querySelector('.arm-btn');
            const closeBtn = tile.querySelector('.close-btn');
            const sumBtn = tile.querySelector('[title="Sum"]');
            const copyBtn = tile.querySelector('[title="Copy"]');
            const pasteBtn = tile.querySelector('[title="Paste"]');
            let isArmed = false;

            // Formula bar editing
            formulaBar.addEventListener('input', () => {
                if (selectedCell) {
                    const key = cellKey(selectedRow, selectedCol);
                    data.cells[key] = formulaBar.value;
                    if (formulaBar.value === '') delete data.cells[key];
                    saveData();
                    updateCellDisplay(selectedRow, selectedCol);
                }
            });

            formulaBar.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Move to next row
                    if (selectedRow < numRows - 1) {
                        const nextTd = table.querySelector(`td[data-row="${selectedRow + 1}"][data-col="${selectedCol}"]`);
                        if (nextTd) selectCell(nextTd);
                    }
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    const nextCol = e.shiftKey ? selectedCol - 1 : selectedCol + 1;
                    if (nextCol >= 0 && nextCol < numCols) {
                        const nextTd = table.querySelector(`td[data-row="${selectedRow}"][data-col="${nextCol}"]`);
                        if (nextTd) selectCell(nextTd);
                    }
                } else if (e.key === 'Escape') {
                    formulaBar.blur();
                }
            });

            function colToLetter(col) {
                let letter = '';
                while (col >= 0) {
                    letter = String.fromCharCode(65 + (col % 26)) + letter;
                    col = Math.floor(col / 26) - 1;
                }
                return letter;
            }

            function letterToCol(letter) {
                let col = 0;
                for (let i = 0; i < letter.length; i++) {
                    col = col * 26 + (letter.charCodeAt(i) - 64);
                }
                return col - 1;
            }

            function cellKey(row, col) {
                return `${colToLetter(col)}${row + 1}`;
            }

            function parseValue(val) {
                if (val === '' || val === undefined || val === null) return '';
                const str = String(val);
                if (str.startsWith("'")) return { type: 'text', raw: str, display: str.slice(1) };
                if (str.startsWith('=')) return { type: 'formula', raw: str, display: str };
                const num = parseFloat(str);
                if (!isNaN(num) && isFinite(num) && str.trim() !== '') {
                    return { type: 'numeric', raw: str, display: num };
                }
                return { type: 'text', raw: str, display: str };
            }

            function getCellValue(key) {
                const raw = data.cells[key];
                if (raw === undefined || raw === '') return 0;
                const parsed = parseValue(raw);
                if (parsed.type === 'numeric') return parsed.display;
                if (parsed.type === 'formula') return evaluateFormula(raw, key);
                return 0; // Text treated as 0 for calculations
            }

            function evaluateFormula(formula, selfKey) {
                if (!formula.startsWith('=')) return formula;
                const expr = formula.slice(1).toUpperCase();
                
                // SUM(range)
                const sumMatch = expr.match(/^SUM\(([A-Z]+)(\d+):([A-Z]+)(\d+)\)$/);
                if (sumMatch) {
                    const startCol = letterToCol(sumMatch[1]);
                    const startRow = parseInt(sumMatch[2]) - 1;
                    const endCol = letterToCol(sumMatch[3]);
                    const endRow = parseInt(sumMatch[4]) - 1;
                    let sum = 0;
                    for (let r = startRow; r <= endRow; r++) {
                        for (let c = startCol; c <= endCol; c++) {
                            const key = cellKey(r, c);
                            if (key !== selfKey) sum += getCellValue(key);
                        }
                    }
                    return sum;
                }
                return '#ERR';
            }

            function getDisplayValue(key) {
                const raw = data.cells[key];
                if (raw === undefined || raw === '') return '';
                const parsed = parseValue(raw);
                if (parsed.type === 'formula') {
                    const result = evaluateFormula(raw, key);
                    return typeof result === 'number' ? result : result;
                }
                return parsed.display;
            }

            function saveData() {
                updateWidgetData(widget.id, { cells: data.cells, cols: numCols, rows: numRows });
            }

            function renderTable() {
                let html = '<thead><tr><th class="corner"></th>';
                for (let c = 0; c < numCols; c++) {
                    html += `<th>${colToLetter(c)}</th>`;
                }
                html += '</tr></thead><tbody>';
                
                for (let r = 0; r < numRows; r++) {
                    html += `<tr><th class="row-header">${r + 1}</th>`;
                    for (let c = 0; c < numCols; c++) {
                        const key = cellKey(r, c);
                        const raw = data.cells[key] || '';
                        const display = getDisplayValue(key);
                        const parsed = parseValue(raw);
                        let classes = '';
                        if (parsed.type === 'formula') classes += ' formula';
                        if (parsed.type === 'numeric' || (parsed.type === 'formula' && typeof display === 'number')) classes += ' numeric';
                        const escaped = String(display).replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        html += `<td data-row="${r}" data-col="${c}" class="${classes}">${escaped}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</tbody>';
                table.innerHTML = html;
                
                // Add click handlers
                table.querySelectorAll('td').forEach(td => {
                    td.addEventListener('click', () => selectCell(td));
                    td.addEventListener('dblclick', () => editCell(td));
                });
            }

            function selectCell(td) {
                if (selectedCell) selectedCell.classList.remove('selected');
                selectedCell = td;
                td.classList.add('selected');
                selectedRow = parseInt(td.dataset.row);
                selectedCol = parseInt(td.dataset.col);
                const key = cellKey(selectedRow, selectedCol);
                cellRefDisplay.textContent = key;
                formulaBar.value = data.cells[key] || '';
            }

            function updateCellDisplay(row, col) {
                const td = table.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                if (!td) return;
                const key = cellKey(row, col);
                const raw = data.cells[key] || '';
                const display = getDisplayValue(key);
                const parsed = parseValue(raw);
                td.className = '';
                if (parsed.type === 'formula') td.classList.add('formula');
                if (parsed.type === 'numeric' || (parsed.type === 'formula' && typeof display === 'number')) td.classList.add('numeric');
                td.textContent = display;
                // Also re-render dependent cells (formulas that might reference this cell)
                table.querySelectorAll('td').forEach(cell => {
                    const r = parseInt(cell.dataset.row);
                    const c = parseInt(cell.dataset.col);
                    const k = cellKey(r, c);
                    const v = data.cells[k];
                    if (v && v.startsWith('=') && k !== key) {
                        const disp = getDisplayValue(k);
                        cell.textContent = disp;
                    }
                });
            }

            function editCell(td) {
                selectCell(td);
                formulaBar.focus();
                formulaBar.select();
            }

            function insertSum() {
                if (!selectedCell) return;
                const key = cellKey(selectedRow, selectedCol);
                
                // Look for data above or to the left
                let formula = '';
                
                // Check column above
                let aboveCount = 0;
                for (let r = selectedRow - 1; r >= 0; r--) {
                    const val = data.cells[cellKey(r, selectedCol)];
                    if (val !== undefined && val !== '') aboveCount++;
                    else break;
                }
                
                // Check row to the left
                let leftCount = 0;
                for (let c = selectedCol - 1; c >= 0; c--) {
                    const val = data.cells[cellKey(selectedRow, c)];
                    if (val !== undefined && val !== '') leftCount++;
                    else break;
                }
                
                if (aboveCount > 0 && aboveCount >= leftCount) {
                    // Sum column
                    formula = `=SUM(${colToLetter(selectedCol)}${selectedRow - aboveCount + 1}:${colToLetter(selectedCol)}${selectedRow})`;
                } else if (leftCount > 0) {
                    // Sum row
                    formula = `=SUM(${colToLetter(selectedCol - leftCount)}${selectedRow + 1}:${colToLetter(selectedCol - 1)}${selectedRow + 1})`;
                } else {
                    formula = '=SUM(A1:A1)';
                }
                
                data.cells[key] = formula;
                saveData();
                updateCellDisplay(selectedRow, selectedCol);
                formulaBar.value = formula;
            }

            async function copyData() {
                // Copy all cells as CSV
                let csv = '';
                for (let r = 0; r < numRows; r++) {
                    const rowData = [];
                    for (let c = 0; c < numCols; c++) {
                        const key = cellKey(r, c);
                        const display = getDisplayValue(key);
                        let val = String(display);
                        if (val.includes(',') || val.includes('\n') || val.includes('"')) {
                            val = '"' + val.replace(/"/g, '""') + '"';
                        }
                        rowData.push(val);
                    }
                    csv += rowData.join(',') + '\n';
                }
                try {
                    await navigator.clipboard.writeText(csv.trim());
                } catch (e) {
                    console.error('Failed to copy:', e);
                }
            }

            async function pasteData() {
                try {
                    const text = await navigator.clipboard.readText();
                    const lines = text.split(/\r?\n/);
                    const startRow = selectedRow;
                    const startCol = selectedCol;
                    
                    for (let r = 0; r < lines.length && startRow + r < numRows; r++) {
                        const line = lines[r];
                        // Simple CSV parse (handles basic cases)
                        const values = [];
                        let current = '';
                        let inQuotes = false;
                        for (let i = 0; i < line.length; i++) {
                            const ch = line[i];
                            if (ch === '"') {
                                if (inQuotes && line[i + 1] === '"') {
                                    current += '"';
                                    i++;
                                } else {
                                    inQuotes = !inQuotes;
                                }
                            } else if (ch === ',' && !inQuotes) {
                                values.push(current);
                                current = '';
                            } else if (ch === '\t' && !inQuotes) {
                                values.push(current);
                                current = '';
                            } else {
                                current += ch;
                            }
                        }
                        values.push(current);
                        
                        for (let c = 0; c < values.length && startCol + c < numCols; c++) {
                            const key = cellKey(startRow + r, startCol + c);
                            if (values[c] === '') {
                                delete data.cells[key];
                            } else {
                                data.cells[key] = values[c];
                            }
                        }
                    }
                    saveData();
                    renderTable();
                    // Reselect the original cell
                    const td = table.querySelector(`td[data-row="${startRow}"][data-col="${startCol}"]`);
                    if (td) selectCell(td);
                } catch (e) {
                    console.error('Failed to paste:', e);
                }
            }

            function toggleArm() {
                isArmed = !isArmed;
                armBtn.innerHTML = isArmed ? icons.unlock : icons.lock;
                armBtn.title = isArmed ? 'Lock to protect' : 'Unlock to allow removal';
                armBtn.classList.toggle('accent-delete', isArmed);
                closeBtn.disabled = !isArmed;
            }

            armBtn.addEventListener('click', toggleArm);
            closeBtn.addEventListener('click', () => {
                if (isArmed) removeWidget(widget.id);
            });
            sumBtn.addEventListener('click', insertSum);
            copyBtn.addEventListener('click', copyData);
            pasteBtn.addEventListener('click', pasteData);

            renderTable();

            return tile;
        }

        // Notepad Widget
        function createNotepadWidget(widget) {
            const data = widget.data;
            if (data.content === undefined) data.content = '';
            if (data.mode === undefined) data.mode = 'edit';

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.notepad.size} notepad-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Notepad</span>
                    <button class="btn btn-small arm-btn" title="Unlock to allow removal">${icons.lock}</button>
                    <button class="btn btn-small accent-delete close-btn" title="Remove widget" disabled>${icons.close}</button>
                </div>
                <div class="notepad-content">
                    <textarea id="notepad-${widget.id}-textarea" class="notepad-textarea" placeholder="Write something..." aria-label="Notepad"></textarea>
                    <div id="notepad-${widget.id}-preview" class="notepad-preview" style="display: none;" aria-hidden="true"></div>
                </div>
                <div class="notepad-controls">
                    <button class="btn btn-small accent-add notepad-btn notepad-edit active" title="Edit">${icons.edit}</button>
                    <button class="btn btn-small accent-add notepad-btn notepad-preview-btn" title="Preview">${icons.eye}</button>
                </div>
            `;

            const textarea = tile.querySelector('.notepad-textarea');
            const preview = tile.querySelector('.notepad-preview');
            const editBtn = tile.querySelector('.notepad-edit');
            const previewBtn = tile.querySelector('.notepad-preview-btn');

            textarea.value = data.content;

            function parseMarkdown(text) {
                const lines = text.split('\n');
                let html = '';
                let inCodeBlock = false;
                let codeBlockContent = '';
                let listStack = []; // Stack of { type: 'ul'|'ol', indent: number }
                
                function escapeHtml(str) {
                    return str
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }
                
                function processInline(str) {
                    // Inline code (before other processing)
                    str = str.replace(/`([^`]+)`/g, '<code>$1</code>');
                    
                    // Bold and italic
                    str = str.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
                    str = str.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                    str = str.replace(/\*(.+?)\*/g, '<em>$1</em>');
                    str = str.replace(/___(.+?)___/g, '<strong><em>$1</em></strong>');
                    str = str.replace(/__(.+?)__/g, '<strong>$1</strong>');
                    str = str.replace(/_(.+?)_/g, '<em>$1</em>');
                    
                    // Links
                    str = str.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
                    
                    return str;
                }
                
                function closeListsToIndent(targetIndent) {
                    while (listStack.length > 0 && listStack[listStack.length - 1].indent >= targetIndent) {
                        const list = listStack.pop();
                        html += `</${list.type}>`;
                    }
                }
                
                function closeAllLists() {
                    while (listStack.length > 0) {
                        const list = listStack.pop();
                        html += `</${list.type}>`;
                    }
                }
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Code blocks
                    if (line.trim().startsWith('```')) {
                        if (inCodeBlock) {
                            html += '<pre><code>' + escapeHtml(codeBlockContent.slice(0, -1)) + '</code></pre>';
                            codeBlockContent = '';
                            inCodeBlock = false;
                        } else {
                            closeAllLists();
                            inCodeBlock = true;
                        }
                        continue;
                    }
                    
                    if (inCodeBlock) {
                        codeBlockContent += line + '\n';
                        continue;
                    }
                    
                    // Count leading spaces/tabs for indentation
                    const indentMatch = line.match(/^([ \t]*)/);
                    const indent = indentMatch ? indentMatch[1].replace(/\t/g, '    ').length : 0;
                    const trimmedLine = line.trim();
                    
                    // Empty line
                    if (trimmedLine === '') {
                        closeAllLists();
                        html += '<br>';
                        continue;
                    }
                    
                    // Headers
                    const headerMatch = trimmedLine.match(/^(#{1,3}) (.+)$/);
                    if (headerMatch) {
                        closeAllLists();
                        const level = headerMatch[1].length;
                        html += `<h${level}>${processInline(escapeHtml(headerMatch[2]))}</h${level}>`;
                        continue;
                    }
                    
                    // Blockquotes
                    if (trimmedLine.startsWith('> ')) {
                        closeAllLists();
                        html += `<blockquote>${processInline(escapeHtml(trimmedLine.slice(2)))}</blockquote>`;
                        continue;
                    }
                    
                    // Checkbox items - [ ] or [x]
                    const checkboxMatch = trimmedLine.match(/^[\*\-] \[([ xX])\] (.*)$/);
                    if (checkboxMatch) {
                        const isChecked = checkboxMatch[1].toLowerCase() === 'x';
                        const checkboxText = checkboxMatch[2];
                        const lineIndex = i;
                        
                        // Close lists that are deeper than current indent
                        closeListsToIndent(indent + 1);
                        
                        // Open new list if needed
                        if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                            html += '<ul>';
                            listStack.push({ type: 'ul', indent: indent });
                        }
                        
                        html += `<li><span class="checkbox ${isChecked ? 'checked' : ''}" data-line="${lineIndex}"><span class="checkbox-box"></span><span class="checkbox-text">${processInline(escapeHtml(checkboxText))}</span></span></li>`;
                        continue;
                    }
                    
                    // Unordered list items
                    const ulMatch = trimmedLine.match(/^[\*\-] (.*)$/);
                    if (ulMatch) {
                        // Close lists that are deeper than current indent
                        closeListsToIndent(indent + 1);
                        
                        // Open new list if needed
                        if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                            html += '<ul>';
                            listStack.push({ type: 'ul', indent: indent });
                        }
                        
                        html += `<li>${processInline(escapeHtml(ulMatch[1]))}</li>`;
                        continue;
                    }
                    
                    // Ordered list items
                    const olMatch = trimmedLine.match(/^\d+\. (.*)$/);
                    if (olMatch) {
                        // Close lists that are deeper than current indent
                        closeListsToIndent(indent + 1);
                        
                        // Open new list if needed
                        if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                            html += '<ol>';
                            listStack.push({ type: 'ol', indent: indent });
                        }
                        
                        html += `<li>${processInline(escapeHtml(olMatch[1]))}</li>`;
                        continue;
                    }
                    
                    // Regular paragraph text
                    closeAllLists();
                    html += `<p>${processInline(escapeHtml(trimmedLine))}</p>`;
                }
                
                // Close any remaining open lists
                closeAllLists();
                
                // Clean up consecutive <br> tags
                html = html.replace(/(<br>)+/g, '<br>');
                html = html.replace(/^<br>/, '');
                html = html.replace(/<br>$/, '');
                
                return html;
            }

            function setMode(mode) {
                data.mode = mode;
                if (mode === 'edit') {
                    textarea.style.display = '';
                    preview.style.display = 'none';
                    editBtn.classList.add('active');
                    previewBtn.classList.remove('active');
                } else {
                    preview.innerHTML = parseMarkdown(data.content);
                    textarea.style.display = 'none';
                    preview.style.display = '';
                    editBtn.classList.remove('active');
                    previewBtn.classList.add('active');
                    
                    // Add click handlers for checkboxes
                    preview.querySelectorAll('.checkbox').forEach(cb => {
                        cb.addEventListener('click', () => {
                            const lineIndex = parseInt(cb.dataset.line);
                            const lines = data.content.split('\n');
                            if (lineIndex >= 0 && lineIndex < lines.length) {
                                const line = lines[lineIndex];
                                // Toggle checkbox state
                                if (line.match(/^([ \t]*)[\*\-] \[ \]/)) {
                                    lines[lineIndex] = line.replace(/^([ \t]*[\*\-]) \[ \]/, '$1 [x]');
                                } else if (line.match(/^([ \t]*)[\*\-] \[[xX]\]/)) {
                                    lines[lineIndex] = line.replace(/^([ \t]*[\*\-]) \[[xX]\]/, '$1 [ ]');
                                }
                                data.content = lines.join('\n');
                                textarea.value = data.content;
                                updateWidgetData(widget.id, { content: data.content });
                                // Re-render preview
                                preview.innerHTML = parseMarkdown(data.content);
                                // Re-attach click handlers
                                setMode('preview');
                            }
                        });
                    });
                }
                updateWidgetData(widget.id, { mode: data.mode });
            }

            textarea.addEventListener('input', () => {
                data.content = textarea.value;
                updateWidgetData(widget.id, { content: data.content });
            });

            editBtn.addEventListener('click', () => setMode('edit'));
            previewBtn.addEventListener('click', () => setMode('preview'));

            const armBtn = tile.querySelector('.arm-btn');
            const closeBtn = tile.querySelector('.close-btn');
            let isArmed = false;

            function toggleArm() {
                isArmed = !isArmed;
                armBtn.innerHTML = isArmed ? icons.unlock : icons.lock;
                armBtn.title = isArmed ? 'Lock to protect' : 'Unlock to allow removal';
                armBtn.classList.toggle('accent-delete', isArmed);
                closeBtn.disabled = !isArmed;
            }

            armBtn.addEventListener('click', toggleArm);
            closeBtn.addEventListener('click', () => {
                if (isArmed) removeWidget(widget.id);
            });

            // Initialize mode
            setMode(data.mode);

            return tile;
        }

        // Data Widget
        function createDataWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.data.size} data-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Data</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="data-controls">
                    <div class="data-row">
                        <button class="btn btn-small accent-add data-btn data-export" title="Export data">${icons.download}</button>
                        <button class="btn btn-small accent-add data-btn data-import" title="Import data">${icons.upload}</button>
                    </div>
                    <div class="data-row">
                        <button class="btn btn-small accent-reset data-btn data-arm" title="Arm delete">${icons.lock}</button>
                        <button class="btn btn-small accent-delete data-btn data-delete" title="Delete all" disabled>${icons.delete}</button>
                    </div>
                </div>
                <input type="file" class="data-file-input" accept=".json,application/json">
            `;

            const exportBtn = tile.querySelector('.data-export');
            const importBtn = tile.querySelector('.data-import');
            const armBtn = tile.querySelector('.data-arm');
            const deleteBtn = tile.querySelector('.data-delete');
            const fileInput = tile.querySelector('.data-file-input');
            let isArmed = false;

            // Export all data
            async function exportData() {
                // Save current state first to ensure we capture latest
                saveWidgets();
                
                const data = {
                    version: 1,
                    exportDate: new Date().toISOString(),
                    theme: localStorage.getItem('density-theme'),
                    // Exclude audio widgets - audio files are too large to export
                    widgets: widgets
                        .filter(w => w.type !== 'audio')
                        .map(w => ({
                            id: w.id,
                            type: w.type,
                            data: JSON.parse(JSON.stringify(w.data)) // Deep copy
                        }))
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `density-backup-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            // Import and merge data
            async function importData(file) {
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    if (!data.version) {
                        return;
                    }

                    // Merge theme (only if not set)
                    if (data.theme && !localStorage.getItem('density-theme')) {
                        localStorage.setItem('density-theme', data.theme);
                        applyTheme(data.theme);
                    }

                    // Merge widgets - preserve order from import
                    if (data.widgets && Array.isArray(data.widgets)) {
                        // Find max ID to avoid conflicts
                        let maxId = Math.max(0, ...widgets.map(w => w.id), widgetIdCounter);
                        const existingIds = new Set(widgets.map(w => w.id));
                        const hasDataWidget = widgets.some(w => w.type === 'data');
                        
                        // Add imported widgets in order, assigning new IDs only for conflicts
                        for (const importedWidget of data.widgets) {
                            // Skip data widget if we already have one
                            if (importedWidget.type === 'data' && hasDataWidget) {
                                continue;
                            }
                            
                            let newId = importedWidget.id;
                            if (existingIds.has(newId)) {
                                newId = ++maxId;
                            }
                            existingIds.add(newId);
                            // Deep copy the data to preserve all values
                            const widgetData = JSON.parse(JSON.stringify(importedWidget.data || {}));
                            addWidget(importedWidget.type, widgetData, newId);
                        }
                    }
                } catch (e) {
                    console.error('Import failed:', e);
                }
            }

            // Delete all data
            async function deleteAllData() {
                if (!isArmed) return;

                // Clear localStorage
                localStorage.removeItem('density-widgets');
                localStorage.removeItem('density-theme');

                // Clear audio IndexedDB
                try {
                    await clearAllAudio();
                } catch (e) {
                    console.error('Failed to delete audio storage:', e);
                }

                // Reset state and reload
                widgets = [];
                widgetIdCounter = 0;
                
                // Reload the page to reset everything
                location.reload();
            }

            // Toggle arm state
            function toggleArm() {
                isArmed = !isArmed;
                if (isArmed) {
                    armBtn.innerHTML = icons.unlock;
                    armBtn.classList.add('armed');
                    deleteBtn.disabled = false;
                    // Auto-disarm after 5 seconds
                    setTimeout(() => {
                        if (isArmed) {
                            isArmed = false;
                            armBtn.innerHTML = icons.lock;
                            armBtn.classList.remove('armed');
                            deleteBtn.disabled = true;
                        }
                    }, 5000);
                } else {
                    armBtn.innerHTML = icons.lock;
                    armBtn.classList.remove('armed');
                    deleteBtn.disabled = true;
                }
            }

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));
            exportBtn.addEventListener('click', exportData);
            importBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    importData(e.target.files[0]);
                    e.target.value = '';
                }
            });
            armBtn.addEventListener('click', toggleArm);
            deleteBtn.addEventListener('click', deleteAllData);

            return tile;
        }

        // Dictaphone Widget
        function createDictaphoneWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.dictaphone.size} dictaphone-widget`;
            tile.dataset.widgetId = widget.id;

            const data = widget.data || { cacheKey: null, duration: 0 };
            let cacheKey = data.cacheKey;
            let audioDuration = data.duration || 0;
            let audioBlob = null;
            let audioUrl = null;
            let audio = new Audio();
            let audioContext = null;
            let existingBuffer = null; // Decoded existing audio as AudioBuffer
            let mediaStream = null;
            let mediaRecorder = null;
            let recordedChunks = [];
            let isRecording = false;
            let isPlaying = false;
            let recordStartTime = 0;
            let recordStartPosition = 0;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Dictaphone</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="dictaphone-display">00:00</div>
                <div class="dictaphone-controls">
                    <button class="btn btn-small accent-down" data-action="skipBack" title="-10s">${icons.skipBack}</button>
                    <button class="btn btn-small accent-delete" data-action="record" title="Record">${icons.mic}</button>
                    <button class="btn btn-small accent-spin" data-action="play" title="Play">${icons.play}</button>
                    <button class="btn btn-small accent-spin" data-action="pause" title="Pause">${icons.pause}</button>
                    <button class="btn btn-small accent-reset" data-action="stop" title="Stop">${icons.stop}</button>
                    <button class="btn btn-small accent-up" data-action="skipForward" title="+10s">${icons.skipForward}</button>
                    <button class="btn btn-small accent-add" data-action="export" title="Export">${icons.download}</button>
                    <button class="btn btn-small accent-add" data-action="import" title="Import">${icons.upload}</button>
                    <input type="file" class="dictaphone-file-input" accept="audio/mpeg,audio/ogg,audio/wav,audio/webm" style="display:none">
                </div>
            `;

            const display = tile.querySelector('.dictaphone-display');
            const fileInput = tile.querySelector('.dictaphone-file-input');

            function formatTime(seconds) {
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            }

            function updateDisplay(time) {
                display.textContent = formatTime(time || 0);
            }

            function saveData() {
                updateWidgetData(widget.id, { cacheKey, duration: audioDuration });
            }

            function getAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                return audioContext;
            }

            // Convert AudioBuffer to WAV Blob
            function audioBufferToWav(buffer) {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const format = 1; // PCM
                const bitDepth = 16;
                const bytesPerSample = bitDepth / 8;
                const blockAlign = numChannels * bytesPerSample;
                const dataLength = buffer.length * blockAlign;
                const bufferLength = 44 + dataLength;
                const arrayBuffer = new ArrayBuffer(bufferLength);
                const view = new DataView(arrayBuffer);

                // WAV header
                const writeString = (offset, str) => {
                    for (let i = 0; i < str.length; i++) {
                        view.setUint8(offset + i, str.charCodeAt(i));
                    }
                };
                writeString(0, 'RIFF');
                view.setUint32(4, bufferLength - 8, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // fmt chunk size
                view.setUint16(20, format, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * blockAlign, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitDepth, true);
                writeString(36, 'data');
                view.setUint32(40, dataLength, true);

                // Interleave channels and write samples
                const channels = [];
                for (let c = 0; c < numChannels; c++) {
                    channels.push(buffer.getChannelData(c));
                }
                let offset = 44;
                for (let i = 0; i < buffer.length; i++) {
                    for (let c = 0; c < numChannels; c++) {
                        const sample = Math.max(-1, Math.min(1, channels[c][i]));
                        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(offset, intSample, true);
                        offset += 2;
                    }
                }

                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            // Concatenate two AudioBuffers
            function concatenateBuffers(buffer1, buffer2) {
                const ctx = getAudioContext();
                const numberOfChannels = Math.max(buffer1?.numberOfChannels || 1, buffer2?.numberOfChannels || 1);
                const sampleRate = buffer1?.sampleRate || buffer2?.sampleRate || 44100;
                const length1 = buffer1?.length || 0;
                const length2 = buffer2?.length || 0;
                const result = ctx.createBuffer(numberOfChannels, length1 + length2, sampleRate);

                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const resultData = result.getChannelData(channel);
                    if (buffer1 && channel < buffer1.numberOfChannels) {
                        resultData.set(buffer1.getChannelData(channel), 0);
                    }
                    if (buffer2 && channel < buffer2.numberOfChannels) {
                        resultData.set(buffer2.getChannelData(channel), length1);
                    }
                }
                return result;
            }

            async function decodeAudioBlob(blob) {
                const ctx = getAudioContext();
                const arrayBuffer = await blob.arrayBuffer();
                return await ctx.decodeAudioData(arrayBuffer);
            }

            async function loadAudio() {
                if (!cacheKey) return;
                try {
                    const stored = await getAudioBlob(cacheKey);
                    if (stored) {
                        audioBlob = stored.blob;
                        existingBuffer = await decodeAudioBlob(audioBlob);
                        if (audioUrl) URL.revokeObjectURL(audioUrl);
                        audioUrl = URL.createObjectURL(audioBlob);
                        audio.src = audioUrl;
                        audioDuration = existingBuffer.duration;
                        updateDisplay(audioDuration);
                        saveData();
                    }
                } catch (e) {
                    console.error('Failed to load dictaphone audio:', e);
                }
            }

            async function saveAudio(blob, buffer) {
                try {
                    if (!cacheKey) {
                        cacheKey = `dictaphone-${widget.id}-${Date.now()}`;
                    }
                    await saveAudioBlob(cacheKey, blob, blob.type);
                    audioBlob = blob;
                    existingBuffer = buffer;
                    if (audioUrl) URL.revokeObjectURL(audioUrl);
                    audioUrl = URL.createObjectURL(blob);
                    audio.src = audioUrl;
                    audioDuration = buffer.duration;
                    updateDisplay(audioDuration);
                    saveData();
                } catch (e) {
                    console.error('Failed to save dictaphone audio:', e);
                }
            }

            async function startRecording() {
                if (isRecording) return;
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    recordedChunks = [];
                    recordStartPosition = audioDuration;
                    
                    mediaRecorder = new MediaRecorder(mediaStream);
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) recordedChunks.push(e.data);
                    };
                    mediaRecorder.onstop = async () => {
                        mediaStream.getTracks().forEach(t => t.stop());
                        
                        // Decode the new recording
                        const newBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                        let newBuffer;
                        try {
                            newBuffer = await decodeAudioBlob(newBlob);
                        } catch (e) {
                            console.error('Failed to decode recording:', e);
                            isRecording = false;
                            display.classList.remove('recording');
                            return;
                        }
                        
                        // Concatenate with existing audio
                        let combinedBuffer;
                        if (existingBuffer) {
                            combinedBuffer = concatenateBuffers(existingBuffer, newBuffer);
                        } else {
                            combinedBuffer = newBuffer;
                        }
                        
                        // Convert to WAV and save
                        const wavBlob = audioBufferToWav(combinedBuffer);
                        await saveAudio(wavBlob, combinedBuffer);
                        
                        isRecording = false;
                        display.classList.remove('recording');
                        
                        // Cue to where this recording started
                        audio.currentTime = recordStartPosition;
                        updateDisplay(recordStartPosition);
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    recordStartTime = Date.now();
                    display.classList.add('recording');
                    updateRecordingTime();
                } catch (e) {
                    console.error('Failed to start recording:', e);
                }
            }

            function updateRecordingTime() {
                if (!isRecording) return;
                const elapsed = (Date.now() - recordStartTime) / 1000;
                updateDisplay(audioDuration + elapsed);
                requestAnimationFrame(updateRecordingTime);
            }

            function stopRecording() {
                if (!isRecording || !mediaRecorder) return;
                mediaRecorder.stop();
            }

            function play() {
                if (isRecording) return;
                if (!audioUrl) return;
                audio.play();
                isPlaying = true;
            }

            function pause() {
                audio.pause();
                isPlaying = false;
            }

            function stop() {
                if (isRecording) stopRecording();
                audio.pause();
                audio.currentTime = 0;
                isPlaying = false;
                updateDisplay(0);
            }

            function skip(delta) {
                if (isRecording) return;
                audio.currentTime = Math.max(0, Math.min(audioDuration, audio.currentTime + delta));
                updateDisplay(audio.currentTime);
            }

            async function exportAudio() {
                if (!audioBlob) return;
                const url = URL.createObjectURL(audioBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dictaphone-${new Date().toISOString().slice(0, 10)}.wav`;
                a.click();
                URL.revokeObjectURL(url);
            }

            async function importAudio(file) {
                try {
                    const blob = new Blob([await file.arrayBuffer()], { type: file.type });
                    const buffer = await decodeAudioBlob(blob);
                    // Convert to WAV for consistent format
                    const wavBlob = audioBufferToWav(buffer);
                    await saveAudio(wavBlob, buffer);
                } catch (e) {
                    console.error('Failed to import audio:', e);
                }
            }

            audio.addEventListener('timeupdate', () => {
                if (isPlaying) updateDisplay(audio.currentTime);
            });

            audio.addEventListener('ended', () => {
                isPlaying = false;
                updateDisplay(audioDuration);
            });

            tile.querySelector('.widget-header .btn').addEventListener('click', async () => {
                if (cacheKey) {
                    try {
                        await cleanupUnusedAudioKeys([cacheKey], widget.id);
                    } catch (e) {
                        console.error('Failed to cleanup dictaphone audio on widget removal:', e);
                    }
                }
                removeWidget(widget.id);
            });

            tile.querySelectorAll('.dictaphone-controls .btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.dataset.action;
                    if (action === 'record') isRecording ? stopRecording() : startRecording();
                    else if (action === 'play') play();
                    else if (action === 'pause') pause();
                    else if (action === 'stop') stop();
                    else if (action === 'skipBack') skip(-10);
                    else if (action === 'skipForward') skip(10);
                });
            });

            tile.querySelector('[data-action="export"]').addEventListener('click', exportAudio);
            tile.querySelector('[data-action="import"]').addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    importAudio(e.target.files[0]);
                    e.target.value = '';
                }
            });

            // Load existing audio
            loadAudio();
            updateDisplay(audioDuration);

            return tile;
        }

        // Calendar Widget
        function createCalendarWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.calendar.size} calendar-widget`;
            tile.dataset.widgetId = widget.id;

            const data = widget.data || { events: {}, viewYear: null, viewMonth: null, selectedDate: null };
            const today = new Date();
            let viewYear = data.viewYear ?? today.getFullYear();
            let viewMonth = data.viewMonth ?? today.getMonth();
            let selectedDate = data.selectedDate ?? `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
            let events = data.events || {};
            let currentEventIndex = 0;
            let isEditing = false;

            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const dayNames = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Calendar</span>
                    <button class="btn btn-small arm-btn" title="Unlock to allow removal">${icons.lock}</button>
                    <button class="btn btn-small accent-delete close-btn" title="Remove widget" disabled>${icons.close}</button>
                </div>
                <div class="calendar-nav">
                    <button class="btn btn-small" title="Previous month">${icons.chevronLeft}</button>
                    <span class="month-year"></span>
                    <button class="btn btn-small" title="Next month">${icons.chevronRight}</button>
                </div>
                <div class="calendar-grid"></div>
                <div class="calendar-actions">
                    <button class="btn btn-small" title="Go to today">${icons.today}</button>
                </div>
                <div class="calendar-events">
                    <div class="calendar-event-nav">
                        <button class="btn btn-small" title="Previous event">${icons.up}</button>
                        <button class="btn btn-small" title="Next event">${icons.down}</button>
                        <div class="calendar-event-display empty">No events</div>
                        <button class="btn btn-small accent-add" title="Add event">${icons.plus}</button>
                        <button class="btn btn-small accent-delete" title="Delete event">${icons.delete}</button>
                    </div>
                </div>
            `;

            const monthYearEl = tile.querySelector('.month-year');
            const gridEl = tile.querySelector('.calendar-grid');
            const eventDisplay = tile.querySelector('.calendar-event-display');
            const [prevBtn, nextBtn] = tile.querySelectorAll('.calendar-nav .btn');
            const todayBtn = tile.querySelector('.calendar-actions .btn');
            const [prevEventBtn, nextEventBtn] = tile.querySelectorAll('.calendar-event-nav .btn');
            const addEventBtn = tile.querySelector('.calendar-event-nav .accent-add');
            const deleteEventBtn = tile.querySelector('.calendar-event-nav .accent-delete');

            function saveData() {
                updateWidgetData(widget.id, { events, viewYear, viewMonth, selectedDate });
            }

            function getDateKey(year, month, day) {
                return `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            }

            function getTodayKey() {
                const t = new Date();
                return getDateKey(t.getFullYear(), t.getMonth(), t.getDate());
            }

            function renderCalendar() {
                monthYearEl.textContent = `${monthNames[viewMonth]} ${viewYear}`;

                const firstDay = new Date(viewYear, viewMonth, 1);
                const lastDay = new Date(viewYear, viewMonth + 1, 0);
                const startDay = firstDay.getDay();
                const daysInMonth = lastDay.getDate();

                const prevMonthLast = new Date(viewYear, viewMonth, 0).getDate();

                let html = dayNames.map(d => `<div class="day-header">${d}</div>`).join('');

                const todayKey = getTodayKey();
                let dayNum = 1;
                let nextMonthDay = 1;

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 7; col++) {
                        const cellIndex = row * 7 + col;
                        let cellDate, cellKey, isOtherMonth = false, displayDay;

                        if (cellIndex < startDay) {
                            // Previous month
                            displayDay = prevMonthLast - startDay + cellIndex + 1;
                            const pm = viewMonth === 0 ? 11 : viewMonth - 1;
                            const py = viewMonth === 0 ? viewYear - 1 : viewYear;
                            cellKey = getDateKey(py, pm, displayDay);
                            isOtherMonth = true;
                        } else if (dayNum > daysInMonth) {
                            // Next month
                            displayDay = nextMonthDay++;
                            const nm = viewMonth === 11 ? 0 : viewMonth + 1;
                            const ny = viewMonth === 11 ? viewYear + 1 : viewYear;
                            cellKey = getDateKey(ny, nm, displayDay);
                            isOtherMonth = true;
                        } else {
                            // Current month
                            displayDay = dayNum;
                            cellKey = getDateKey(viewYear, viewMonth, dayNum);
                            dayNum++;
                        }

                        const isToday = cellKey === todayKey;
                        const isSelected = cellKey === selectedDate;
                        const hasEvents = events[cellKey] && events[cellKey].length > 0;

                        let classes = 'day-cell';
                        if (isOtherMonth) classes += ' other-month';
                        if (isToday) classes += ' today';
                        if (isSelected) classes += ' selected';
                        if (hasEvents) classes += ' has-events';

                        html += `<div class="${classes}" data-date="${cellKey}">${displayDay}</div>`;
                    }
                    if (dayNum > daysInMonth && row >= 3) break;
                }

                gridEl.innerHTML = html;

                gridEl.querySelectorAll('.day-cell').forEach(cell => {
                    cell.addEventListener('click', () => selectDate(cell.dataset.date));
                });

                updateEventDisplay();
            }

            function selectDate(dateKey) {
                if (isEditing) finishEditing();
                selectedDate = dateKey;
                currentEventIndex = 0;
                saveData();
                renderCalendar();
            }

            function updateEventDisplay() {
                const dayEvents = events[selectedDate] || [];
                if (dayEvents.length === 0) {
                    eventDisplay.innerHTML = 'No events';
                    eventDisplay.classList.add('empty');
                } else {
                    if (currentEventIndex >= dayEvents.length) currentEventIndex = dayEvents.length - 1;
                    if (currentEventIndex < 0) currentEventIndex = 0;
                    const evt = dayEvents[currentEventIndex];
                    eventDisplay.innerHTML = `<span style="color:var(--text-muted);margin-right:4px;">${currentEventIndex + 1}/${dayEvents.length}</span> ${evt.replace(/</g, '&lt;')}`;
                    eventDisplay.classList.remove('empty');
                }
            }

            function navigateMonth(delta) {
                if (isEditing) finishEditing();
                viewMonth += delta;
                if (viewMonth < 0) { viewMonth = 11; viewYear--; }
                if (viewMonth > 11) { viewMonth = 0; viewYear++; }
                saveData();
                renderCalendar();
            }

            function goToToday() {
                if (isEditing) finishEditing();
                const t = new Date();
                viewYear = t.getFullYear();
                viewMonth = t.getMonth();
                selectedDate = getTodayKey();
                currentEventIndex = 0;
                saveData();
                renderCalendar();
            }

            function navigateEvent(delta) {
                if (isEditing) return;
                const dayEvents = events[selectedDate] || [];
                if (dayEvents.length === 0) return;
                currentEventIndex += delta;
                if (currentEventIndex < 0) currentEventIndex = dayEvents.length - 1;
                if (currentEventIndex >= dayEvents.length) currentEventIndex = 0;
                updateEventDisplay();
            }

            function startEditing(existingText = '') {
                isEditing = true;
                eventDisplay.innerHTML = `<input type="text" class="input-inset calendar-event-input" value="${existingText.replace(/"/g, '&quot;')}" placeholder="Event description">`;
                eventDisplay.classList.remove('empty');
                const input = eventDisplay.querySelector('input');
                input.focus();
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') finishEditing();
                    if (e.key === 'Escape') cancelEditing();
                });
                input.addEventListener('blur', () => {
                    setTimeout(() => { if (isEditing) finishEditing(); }, 100);
                });
            }

            function finishEditing() {
                if (!isEditing) return;
                const input = eventDisplay.querySelector('input');
                const text = input?.value.trim();
                isEditing = false;

                if (text) {
                    if (!events[selectedDate]) events[selectedDate] = [];
                    const dayEvents = events[selectedDate];
                    if (currentEventIndex < dayEvents.length) {
                        // Editing existing
                        dayEvents[currentEventIndex] = text;
                    } else {
                        // Adding new
                        dayEvents.push(text);
                        currentEventIndex = dayEvents.length - 1;
                    }
                    saveData();
                }
                renderCalendar();
            }

            function cancelEditing() {
                isEditing = false;
                renderCalendar();
            }

            function addEvent() {
                if (isEditing) finishEditing();
                const dayEvents = events[selectedDate] || [];
                currentEventIndex = dayEvents.length;
                startEditing();
            }

            function deleteEvent() {
                if (isEditing) { cancelEditing(); return; }
                const dayEvents = events[selectedDate];
                if (!dayEvents || dayEvents.length === 0) return;
                dayEvents.splice(currentEventIndex, 1);
                if (dayEvents.length === 0) delete events[selectedDate];
                if (currentEventIndex >= (events[selectedDate]?.length || 0)) {
                    currentEventIndex = Math.max(0, (events[selectedDate]?.length || 0) - 1);
                }
                saveData();
                renderCalendar();
            }

            // Click on event display to edit
            eventDisplay.addEventListener('click', () => {
                if (isEditing) return;
                const dayEvents = events[selectedDate] || [];
                if (dayEvents.length > 0) {
                    startEditing(dayEvents[currentEventIndex]);
                }
            });

            const armBtn = tile.querySelector('.arm-btn');
            const closeBtn = tile.querySelector('.close-btn');
            let isArmed = false;

            function toggleArm() {
                isArmed = !isArmed;
                armBtn.innerHTML = isArmed ? icons.unlock : icons.lock;
                armBtn.title = isArmed ? 'Lock to protect' : 'Unlock to allow removal';
                armBtn.classList.toggle('accent-delete', isArmed);
                closeBtn.disabled = !isArmed;
            }

            armBtn.addEventListener('click', toggleArm);
            closeBtn.addEventListener('click', () => {
                if (isArmed) removeWidget(widget.id);
            });
            prevBtn.addEventListener('click', () => navigateMonth(-1));
            nextBtn.addEventListener('click', () => navigateMonth(1));
            todayBtn.addEventListener('click', goToToday);
            prevEventBtn.addEventListener('click', () => navigateEvent(-1));
            nextEventBtn.addEventListener('click', () => navigateEvent(1));
            addEventBtn.addEventListener('click', addEvent);
            deleteEventBtn.addEventListener('click', deleteEvent);

            renderCalendar();

            return tile;
        }

        // Clock Widget
        function createClockWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.clock.size} clock-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Clock</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="clock-display">--:--:--</div>
            `;

            const display = tile.querySelector('.clock-display');

            function updateClock() {
                const now = new Date();
                const h = String(now.getHours()).padStart(2, '0');
                const m = String(now.getMinutes()).padStart(2, '0');
                const s = String(now.getSeconds()).padStart(2, '0');
                display.textContent = `${h}:${m}:${s}`;
            }

            updateClock();
            const intervalId = setInterval(updateClock, 1000);

            // Cleanup when widget is removed
            const observer = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    for (const node of mutation.removedNodes) {
                        if (node === tile || node.contains?.(tile)) {
                            clearInterval(intervalId);
                            observer.disconnect();
                            return;
                        }
                    }
                }
            });
            observer.observe(document.body, { childList: true, subtree: true });

            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));

            return tile;
        }

        // Back here Widget
        function createBackHereWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.backhere.size} backhere-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Back here</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="backhere-container" style="flex:1; display:flex; align-items:center; justify-content:center; min-height:0; position:relative;">
                    <svg class="backhere-rose" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
                        <defs>
                            <filter id="bh-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                <feDropShadow dx="0" dy="1" stdDeviation="1" flood-color="rgba(0,0,0,0.25)"/>
                            </filter>
                        </defs>
                        <!-- outer circle -->
                        <circle cx="50" cy="50" r="38" fill="none" stroke="var(--accent-add)" stroke-width="2" opacity="0.9" />
                        <!-- destination dot (moved by JS) -->
                        <circle class="backhere-dot" cx="50" cy="14" r="3.8" fill="var(--accent-spin)" filter="url(#bh-shadow)" />
                        <!-- teardrop pointer: curved base around centre, tip at 80% of rose radius -->
                        <!-- rose radius = 38 -> tip Y = 50 - 0.8*38 = 19.6 -->
                        <path class="backhere-arrow" d="M58 50 A8 8 0 1 1 42 50 C42 50 46 36 50 19.6 C54 36 58 50 58 50 Z" fill="var(--accent-up)" />
                    </svg>
                    <div class="backhere-overlay" aria-hidden="true"></div>
                </div>
                <div class="backhere-distance">â€”</div>
            `;

            const closeBtn = tile.querySelector('.widget-header .btn');
            const dot = tile.querySelector('.backhere-dot');
            const arrow = tile.querySelector('.backhere-arrow');
            const roseSvg = tile.querySelector('svg.backhere-rose');
            const overlay = tile.querySelector('.backhere-overlay');
            const distEl = tile.querySelector('.backhere-distance');


            let lastPos = null;

            let displayMode = (widget.data && Number.isInteger(widget.data.displayMode)) ? widget.data.displayMode : 0; // 0=distance,1=lat,lon+distance,2=lat,lon,alt+distance,3=lat,lon+distance+speed
            function updateRose() {
                const here = widget.data && widget.data.here;
                if (!here || !lastPos) {
                    distEl.textContent = 'â€”';
                    return;
                }
                const lat = lastPos.coords.latitude;
                const lon = lastPos.coords.longitude;
                const d = _computeDistanceMeters(lat, lon, here.lat, here.lon);
                const bearing = _computeBearingDegrees(lat, lon, here.lat, here.lon);
                // compute current speed: prefer device-reported speed, fall back to prev/last computed speed
                let currentSpeed = null;
                try {
                    if (lastPos.coords && typeof lastPos.coords.speed === 'number' && !isNaN(lastPos.coords.speed) && lastPos.coords.speed >= 0) {
                        currentSpeed = lastPos.coords.speed;
                    } else if (_prevGeoPos && _lastGeoPos && _prevGeoPos.coords && _lastGeoPos.coords) {
                        const movedForSpeed = _computeDistanceMeters(_prevGeoPos.coords.latitude, _prevGeoPos.coords.longitude, _lastGeoPos.coords.latitude, _lastGeoPos.coords.longitude);
                        const dtForSpeed = (_lastGeoPos.timestamp || Date.now()) - (_prevGeoPos.timestamp || Date.now());
                        if (dtForSpeed > 0 && dtForSpeed <= 60000) {
                            currentSpeed = movedForSpeed / (dtForSpeed / 1000);
                        }
                    }
                } catch (e) { currentSpeed = null; }
                // Use movement-derived heading exclusively (no magnetic support).
                let deviceHeading = (typeof _movementHeadingDegrees === 'number') ? _movementHeadingDegrees : 0;
                // If speed is too slow, do not update needle/dot but show overlay prompt
                const SPEED_THRESHOLD = 0.5; // m/s
                const shouldUpdateDirection = (typeof currentSpeed === 'number' && currentSpeed > SPEED_THRESHOLD);
                if (!shouldUpdateDirection) {
                    if (overlay) { overlay.style.display = 'flex'; overlay.innerHTML = '<span class="backhere-overlay-text" data-label="move for direction">move for direction</span>'; }
                    // leave dot/arrow visible but don't update their position below
                } else {
                    if (overlay) overlay.style.display = 'none';
                }
                // Compute destination vector robustly on the sphere: ECEF -> local ENU at current position
                const toRad = v => v * Math.PI / 180;
                const Rm = 6371000; // metres (approx earth radius)
                const phi1 = toRad(lat);
                const lambda1 = toRad(lon);
                const phi2 = toRad(here.lat);
                const lambda2 = toRad(here.lon);
                // ECEF for current
                const cosPhi1 = Math.cos(phi1), sinPhi1 = Math.sin(phi1);
                const cosLam1 = Math.cos(lambda1), sinLam1 = Math.sin(lambda1);
                const x1 = Rm * cosPhi1 * cosLam1;
                const y1 = Rm * cosPhi1 * sinLam1;
                const z1 = Rm * sinPhi1;
                // ECEF for destination
                const cosPhi2 = Math.cos(phi2), sinPhi2 = Math.sin(phi2);
                const cosLam2 = Math.cos(lambda2), sinLam2 = Math.sin(lambda2);
                const x2 = Rm * cosPhi2 * cosLam2;
                const y2 = Rm * cosPhi2 * sinLam2;
                const z2 = Rm * sinPhi2;
                // delta in ECEF (meters, chord vector)
                const dx = x2 - x1;
                const dy = y2 - y1;
                const dz = z2 - z1;
                // Convert delta to local ENU at current position
                // east = -sin(lambda1)*dx + cos(lambda1)*dy
                // north = -sin(phi1)*cos(lambda1)*dx - sin(phi1)*sin(lambda1)*dy + cos(phi1)*dz
                const east = -sinLam1 * dx + cosLam1 * dy;
                const north = -sinPhi1 * cosLam1 * dx - sinPhi1 * sinLam1 * dy + cosPhi1 * dz;
                // deviceHeading is degrees clockwise from north; convert to radians
                const hd = (typeof deviceHeading === 'number') ? ((deviceHeading % 360) + 360) % 360 : 0;
                const hdRad = toRad(hd);
                const cH = Math.cos(hdRad), sH = Math.sin(hdRad);
                // Rotate world vector into device-local coordinates (forward = +Y)
                // use rotation sign so deviceHeading aligns forward correctly
                const xRel = east * cH - north * sH; // local right (east) component
                const yRel = east * sH + north * cH; // local forward (north) component
                // angle where 0 = forward/up, positive clockwise
                const angle = Math.atan2(xRel, yRel);
                const r = 30;
                const cx = 50 + Math.sin(angle) * r;
                const cy = 50 - Math.cos(angle) * r;
                // only update dot position when we have recent movement-based heading
                if (shouldUpdateDirection) {
                    dot.setAttribute('cx', String(cx));
                    dot.setAttribute('cy', String(cy));
                }
                const formatDistance = (m) => m < 1000 ? `${Math.round(m)}m` : `${(m/1000).toFixed(2)}km`;
                const distanceStr = formatDistance(d);
                // Mode 0: distance only
                // Mode 1: lat, lon + distance
                // Mode 2: lat, lon, alt + distance
                if (displayMode === 0) {
                    distEl.textContent = distanceStr;
                } else if (displayMode === 1) {
                    distEl.textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)} ${distanceStr}`;
                } else if (displayMode === 2) {
                    const alt = (lastPos.coords.altitude === null) ? 'â€”' : `${Math.round(lastPos.coords.altitude)}m`;
                    distEl.textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)} ${alt} ${distanceStr}`;
                } else if (displayMode === 3) {
                    // speed in m/s: prefer device-reported speed if present, otherwise compute from prev/last with dt validation
                    let speedStr = 'â€”';
                    try {
                        if (_lastGeoPos && _lastGeoPos.coords && typeof _lastGeoPos.coords.speed === 'number' && !isNaN(_lastGeoPos.coords.speed) && _lastGeoPos.coords.speed >= 0) {
                            speedStr = `${_lastGeoPos.coords.speed.toFixed(1)}m/s`;
                        } else if (_prevGeoPos && _lastGeoPos && _prevGeoPos.coords && _lastGeoPos.coords) {
                            const moved = _computeDistanceMeters(_prevGeoPos.coords.latitude, _prevGeoPos.coords.longitude, _lastGeoPos.coords.latitude, _lastGeoPos.coords.longitude);
                            const dtMs = (_lastGeoPos.timestamp || Date.now()) - (_prevGeoPos.timestamp || Date.now());
                            if (dtMs > 0 && dtMs <= 60000) {
                                const speed = moved / (dtMs / 1000);
                                speedStr = `${speed.toFixed(1)}m/s`;
                            }
                        }
                    } catch (e) { /* ignore */ }
                    const alt = (lastPos.coords.altitude === null) ? 'â€”' : `${Math.round(lastPos.coords.altitude)}m`;
                    distEl.textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)} ${alt} ${distanceStr} ${speedStr}`;
                }
                // Keep arrow fixed (up = device facing) â€” no rotation of SVG needed
            }

            function updateFromPosition(pos) {
                lastPos = pos;
                updateRose();
            }

            // If we don't have an initial here, set it from last known pos or request one-shot
            function ensureHereSet() {
                if (widget.data && widget.data.here) return Promise.resolve();
                if (_lastGeoPos) {
                    widget.data = widget.data || {};
                    widget.data.here = { lat: _lastGeoPos.coords.latitude, lon: _lastGeoPos.coords.longitude, ts: _lastGeoPos.timestamp };
                    saveWidgets();
                    return Promise.resolve();
                }
                return new Promise((resolve) => {
                    if (!navigator.geolocation) return resolve();
                    navigator.geolocation.getCurrentPosition((pos) => {
                        widget.data = widget.data || {};
                        widget.data.here = { lat: pos.coords.latitude, lon: pos.coords.longitude, ts: pos.timestamp };
                        saveWidgets();
                        resolve();
                    }, () => resolve(), { enableHighAccuracy: true, timeout: 10000 });
                });
            }

            // Register listener

            const updater = (pos) => updateFromPosition(pos);
            _backHereListeners.set(widget.id, updater);
            ensureHereSet().then(() => {
                if (_lastGeoPos) updater(_lastGeoPos);
            });

            // Start global watch (movement-derived heading)
            ensureBackHereWatchStarted();

            // Make the whole rose area clickable/tappable: cycle display mode
            if (roseSvg) {
                roseSvg.style.cursor = 'pointer';
                roseSvg.addEventListener('click', (ev) => {
                    ev.preventDefault();
                    ev.stopPropagation();
                    displayMode = (displayMode + 1) % 4;
                    widget.data = widget.data || {};
                    widget.data.displayMode = displayMode;
                    saveWidgets();
                    updateRose();
                });
                // also handle touchend to be more responsive on mobile
                roseSvg.addEventListener('touchend', (ev) => {
                    ev.preventDefault();
                    ev.stopPropagation();
                    displayMode = (displayMode + 1) % 4;
                    widget.data = widget.data || {};
                    widget.data.displayMode = displayMode;
                    saveWidgets();
                    updateRose();
                }, { passive: false });
            }

            // Copy metrics label to clipboard on click/tap with a brief visual flash
            async function copyTextToClipboard(text) {
                if (!text) return false;
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(text);
                        return true;
                    }
                } catch (e) {
                    // fall through to legacy approach
                }
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.style.position = 'fixed';
                    ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    const ok = document.execCommand && document.execCommand('copy');
                    document.body.removeChild(ta);
                    return !!ok;
                } catch (e) {
                    return false;
                }
            }

            function flashCopied() {
                if (!distEl) return;
                distEl.classList.add('copied');
                setTimeout(() => distEl.classList.remove('copied'), 700);
            }

            if (distEl) {
                distEl.addEventListener('click', async (ev) => {
                    ev.preventDefault();
                    ev.stopPropagation();
                    const txt = distEl.textContent?.trim();
                    if (!txt) return;
                    const ok = await copyTextToClipboard(txt);
                    if (ok) flashCopied();
                });
                distEl.addEventListener('touchend', async (ev) => {
                    ev.preventDefault();
                    ev.stopPropagation();
                    const txt = distEl.textContent?.trim();
                    if (!txt) return;
                    const ok = await copyTextToClipboard(txt);
                    if (ok) flashCopied();
                }, { passive: false });
            }


            // Cleanup when removed: remove listener and stop global watch if none remain
            const observer = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    for (const node of mutation.removedNodes) {
                        if (node === tile || node.contains?.(tile)) {
                            _backHereListeners.delete(widget.id);
                            stopBackHereWatchIfNone();
                            stopDeviceOrientationIfNone();
                            observer.disconnect();
                            return;
                        }
                    }
                }
            });
            observer.observe(document.body, { childList: true, subtree: true });

            closeBtn.addEventListener('click', () => removeWidget(widget.id));

            return tile;
        }

        // Boids Widget
        function createBoidsWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.boids.size} boids-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Fish pond</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="boids-container">
                    <canvas class="boids-canvas-caustics"></canvas>
                    <canvas class="boids-canvas-fish"></canvas>
                </div>
            `;

            const container = tile.querySelector('.boids-container');
            const causticsCanvas = tile.querySelector('.boids-canvas-caustics');
            const fishCanvas = tile.querySelector('.boids-canvas-fish');
            const causticsCtx = causticsCanvas.getContext('2d');
            const fishCtx = fishCanvas.getContext('2d');

            let animationId = null;
            let lastFrame = 0;
            let causticsTime = 0;
            let width = 0;
            let height = 0;

            // Wind system
            let windX = 0, windY = 0;
            let targetWindX = 0, targetWindY = 0;
            let windChangeTimer = 0;
            let plantTime = 0; // For leaf animation

            // Plants
            const plants = [];

            // Food pellets (from user clicks)
            const foodPellets = [];

            class FoodPellet {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.size = 2 + Math.random() * 1.5;
                    this.sinkSpeed = 3 + Math.random() * 2; // Slowly sinks
                    this.eaten = false;
                    this.age = 0;
                }

                update(dt) {
                    this.y += this.sinkSpeed * dt;
                    this.age += dt;
                    // Disappear after 10 seconds if not eaten
                    if (this.age > 10) this.eaten = true;
                }

                draw(ctx) {
                    ctx.fillStyle = 'rgba(180, 120, 60, 0.9)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class Plant {
                constructor(x, y, size) {
                    this.x = x || Math.random() * 300;
                    this.y = y || Math.random() * 300;
                    this.size = size || (12 + Math.random() * 10);
                    this.leaves = [];
                    const numLeaves = 5 + Math.floor(Math.random() * 4);
                    for (let i = 0; i < numLeaves; i++) {
                        this.leaves.push({
                            angle: (i / numLeaves) * Math.PI * 2 + Math.random() * 0.5,
                            length: 0.6 + Math.random() * 0.5,
                            width: 0.25 + Math.random() * 0.2,
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }

                update(dt, w, h) {
                    // Drift with wind (plants drift slower than wind)
                    this.x += windX * dt * 0.5;
                    this.y += windY * dt * 0.5;

                    // Torus wrap
                    if (this.x < -this.size) this.x += w + this.size * 2;
                    if (this.x > w + this.size) this.x -= w + this.size * 2;
                    if (this.y < -this.size) this.y += h + this.size * 2;
                    if (this.y > h + this.size) this.y -= h + this.size * 2;
                }

                draw(ctx) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Draw leaves
                    for (const leaf of this.leaves) {
                        const sway = Math.sin(plantTime * 2 + leaf.phase) * 0.15;
                        const angle = leaf.angle + sway;
                        const len = this.size * leaf.length;
                        const w = this.size * leaf.width;
                        
                        ctx.save();
                        ctx.rotate(angle);
                        
                        // Leaf shape - elongated oval (sunlit green)
                        ctx.fillStyle = 'rgba(85, 160, 50, 0.8)';
                        ctx.beginPath();
                        ctx.ellipse(len * 0.5, 0, len * 0.5, w * 0.4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Darker center vein
                        ctx.strokeStyle = 'rgba(50, 110, 30, 0.7)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(len * 0.9, 0);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                    
                    // Center of plant
                    ctx.fillStyle = 'rgba(70, 130, 45, 0.85)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pink flower on larger plants (size > 30)
                    if (this.size > 30) {
                        const flowerSize = this.size * 0.25;
                        const petalCount = 5;
                        // Petals
                        ctx.fillStyle = 'rgba(255, 150, 180, 0.9)';
                        for (let i = 0; i < petalCount; i++) {
                            const pAngle = (i / petalCount) * Math.PI * 2 + plantTime * 0.3;
                            ctx.beginPath();
                            ctx.ellipse(
                                Math.cos(pAngle) * flowerSize * 0.4,
                                Math.sin(pAngle) * flowerSize * 0.4,
                                flowerSize * 0.35,
                                flowerSize * 0.2,
                                pAngle,
                                0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        // Yellow center
                        ctx.fillStyle = 'rgba(255, 220, 100, 0.95)';
                        ctx.beginPath();
                        ctx.arc(0, 0, flowerSize * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }

                getAvoidanceRadius() {
                    return this.size * 0.8;
                }
            }

            // Boids parameters
            const NUM_BOIDS = 25;
            const boids = [];

            class Boid {
                constructor() {
                    this.x = Math.random() * 300;
                    this.y = Math.random() * 300;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.size = 4 + Math.random() * 3;
                    this.isGoldfish = Math.random() < 0.25; // 25% are goldfish
                    // Fish behavior timers
                    this.wiggleTimer = Math.random() * 2;
                    this.wiggleDir = 0;
                    this.dartTimer = Math.random() * 5;
                    this.dartBoost = 0;
                    this.foodTimer = Math.random() * 8;
                    this.foodX = 0;
                    this.foodY = 0;
                    this.chasingFood = false;
                }

                update(dt, w, h) {
                    // Boid rules
                    let sepX = 0, sepY = 0, sepCount = 0;
                    let alignX = 0, alignY = 0, alignCount = 0;
                    let cohX = 0, cohY = 0, cohCount = 0;
                    let avoidX = 0, avoidY = 0;

                    const sepDist = 20;
                    const alignDist = 40;
                    const cohDist = 60;

                    for (const other of boids) {
                        if (other === this) continue;
                        
                        // Torus distance
                        let dx = other.x - this.x;
                        let dy = other.y - this.y;
                        if (dx > w / 2) dx -= w;
                        if (dx < -w / 2) dx += w;
                        if (dy > h / 2) dy -= h;
                        if (dy < -h / 2) dy += h;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Separation
                        if (dist < sepDist && dist > 0) {
                            sepX -= dx / dist;
                            sepY -= dy / dist;
                            sepCount++;
                        }
                        // Alignment
                        if (dist < alignDist) {
                            alignX += other.vx;
                            alignY += other.vy;
                            alignCount++;
                        }
                        // Cohesion
                        if (dist < cohDist) {
                            cohX += dx;
                            cohY += dy;
                            cohCount++;
                        }
                    }

                    // Avoid plants
                    for (const plant of plants) {
                        let dx = plant.x - this.x;
                        let dy = plant.y - this.y;
                        if (dx > w / 2) dx -= w;
                        if (dx < -w / 2) dx += w;
                        if (dy > h / 2) dy -= h;
                        if (dy < -h / 2) dy += h;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const avoidRadius = plant.getAvoidanceRadius() + 15;
                        if (dist < avoidRadius && dist > 0) {
                            const strength = (avoidRadius - dist) / avoidRadius;
                            avoidX -= (dx / dist) * strength * 3;
                            avoidY -= (dy / dist) * strength * 3;
                        }
                    }

                    // Apply rules
                    if (sepCount > 0) {
                        this.vx += sepX * 0.05;
                        this.vy += sepY * 0.05;
                    }
                    if (alignCount > 0) {
                        this.vx += (alignX / alignCount - this.vx) * 0.02;
                        this.vy += (alignY / alignCount - this.vy) * 0.02;
                    }
                    if (cohCount > 0) {
                        this.vx += (cohX / cohCount) * 0.003;
                        this.vy += (cohY / cohCount) * 0.003;
                    }
                    // Apply plant avoidance (strong)
                    this.vx += avoidX;
                    this.vy += avoidY;

                    // Fish-like perturbations
                    // Wiggle: small random angle changes
                    this.wiggleTimer -= dt;
                    if (this.wiggleTimer <= 0) {
                        this.wiggleDir = (Math.random() - 0.5) * 0.8; // Random turn
                        this.wiggleTimer = 0.2 + Math.random() * 0.4; // Every 0.2-0.6 sec
                    }
                    // Apply wiggle as rotation
                    const cos = Math.cos(this.wiggleDir * dt * 3);
                    const sin = Math.sin(this.wiggleDir * dt * 3);
                    const nvx = this.vx * cos - this.vy * sin;
                    const nvy = this.vx * sin + this.vy * cos;
                    this.vx = nvx;
                    this.vy = nvy;

                    // Dart: occasional speed bursts
                    this.dartTimer -= dt;
                    if (this.dartTimer <= 0) {
                        this.dartBoost = 1.5 + Math.random(); // Burst multiplier
                        this.dartTimer = 2 + Math.random() * 4; // Every 2-6 sec
                    }
                    // Decay dart boost
                    if (this.dartBoost > 0) {
                        this.vx *= 1 + this.dartBoost * dt * 2;
                        this.vy *= 1 + this.dartBoost * dt * 2;
                        this.dartBoost -= dt * 3; // Fade over ~0.5 sec
                    }

                    // Food spotting: occasionally veer toward imaginary food
                    this.foodTimer -= dt;
                    if (this.foodTimer <= 0) {
                        // Spot food at a random nearby location
                        const foodDist = 30 + Math.random() * 50;
                        const foodAngle = Math.random() * Math.PI * 2;
                        this.foodX = this.x + Math.cos(foodAngle) * foodDist;
                        this.foodY = this.y + Math.sin(foodAngle) * foodDist;
                        this.chasingFood = true;
                        this.foodTimer = 4 + Math.random() * 6; // Every 4-10 sec
                    }
                    // Chase food briefly
                    if (this.chasingFood) {
                        let fdx = this.foodX - this.x;
                        let fdy = this.foodY - this.y;
                        const fdist = Math.sqrt(fdx * fdx + fdy * fdy);
                        if (fdist < 5) {
                            this.chasingFood = false; // Reached food
                        } else {
                            // Steer toward food
                            this.vx += (fdx / fdist) * 15 * dt;
                            this.vy += (fdy / fdist) * 15 * dt;
                        }
                    }

                    // Real food: chase nearby pellets (within 25% of viewport)
                    const sightRange = Math.max(w, h) * 0.25;
                    let nearestFood = null;
                    let nearestDist = sightRange;
                    for (const pellet of foodPellets) {
                        if (pellet.eaten) continue;
                        const fdx = pellet.x - this.x;
                        const fdy = pellet.y - this.y;
                        const fdist = Math.sqrt(fdx * fdx + fdy * fdy);
                        if (fdist < nearestDist) {
                            nearestDist = fdist;
                            nearestFood = pellet;
                        }
                    }
                    if (nearestFood) {
                        const fdx = nearestFood.x - this.x;
                        const fdy = nearestFood.y - this.y;
                        // Strong attraction to real food!
                        this.vx += (fdx / nearestDist) * 40 * dt;
                        this.vy += (fdy / nearestDist) * 40 * dt;
                        // Eat it if close enough
                        if (nearestDist < this.size + nearestFood.size) {
                            nearestFood.eaten = true;
                        }
                    }

                    // Speed limit
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    const maxSpeed = 15;
                    const minSpeed = 5;
                    if (speed > maxSpeed) {
                        this.vx = (this.vx / speed) * maxSpeed;
                        this.vy = (this.vy / speed) * maxSpeed;
                    } else if (speed < minSpeed) {
                        this.vx = (this.vx / speed) * minSpeed;
                        this.vy = (this.vy / speed) * minSpeed;
                    }

                    // Move
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;

                    // Torus wrap
                    if (this.x < 0) this.x += w;
                    if (this.x >= w) this.x -= w;
                    if (this.y < 0) this.y += h;
                    if (this.y >= h) this.y -= h;
                }

                draw(ctx) {
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    
                    // Fish body - black or goldfish orange
                    ctx.fillStyle = this.isGoldfish ? 'rgba(255, 160, 50, 0.9)' : 'rgba(0, 0, 0, 0.8)';
                    ctx.beginPath();
                    // Body ellipse
                    ctx.ellipse(0, 0, this.size, this.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail
                    ctx.beginPath();
                    ctx.moveTo(-this.size, 0);
                    ctx.lineTo(-this.size - this.size * 0.6, -this.size * 0.4);
                    ctx.lineTo(-this.size - this.size * 0.6, this.size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            function initBoids() {
                boids.length = 0;
                for (let i = 0; i < NUM_BOIDS; i++) {
                    const b = new Boid();
                    b.x = Math.random() * width;
                    b.y = Math.random() * height;
                    boids.push(b);
                }
            }

            function initPlants() {
                plants.length = 0;
                const NUM_PLANTS = 5 + Math.floor(Math.random() * 4); // 5-8 plants
                for (let i = 0; i < NUM_PLANTS; i++) {
                    plants.push(new Plant(
                        Math.random() * width,
                        Math.random() * height,
                        20 + Math.random() * 25 // Size 20-45
                    ));
                }
            }

            function updateWind(dt) {
                windChangeTimer -= dt;
                if (windChangeTimer <= 0) {
                    // Pick new target wind
                    const angle = Math.random() * Math.PI * 2;
                    const strength = 5 + Math.random() * 15; // Wind strength 5-20
                    targetWindX = Math.cos(angle) * strength;
                    targetWindY = Math.sin(angle) * strength;
                    windChangeTimer = 3 + Math.random() * 5; // Change every 3-8 seconds
                }
                // Ease toward target
                windX += (targetWindX - windX) * 0.02;
                windY += (targetWindY - windY) * 0.02;
            }

            function renderCaustics(dt) {
                causticsTime += dt;
                const time = causticsTime * 2.5;

                const w = causticsCanvas.width;
                const h = causticsCanvas.height;
                const imageData = causticsCtx.createImageData(w, h);
                const data = imageData.data;

                // Ocean blue base: rgb(30, 90, 140) with azure caustics
                const baseR = 30, baseG = 90, baseB = 140;
                const caustR = 180, caustG = 230, caustB = 255;

                for (let py = 0; py < h; py++) {
                    for (let px = 0; px < w; px++) {
                        // Long wavelength modulation to break up repeating patterns
                        const longX = Math.sin(px * 0.008 + time * 0.15) * 0.3 + 1;
                        const longY = Math.sin(py * 0.011 + time * 0.12) * 0.3 + 1;
                        const longDiag = Math.sin((px + py) * 0.006 - time * 0.08) * 0.2 + 1;

                        // Layer 1: Large slow-moving cells
                        const n1 = Math.sin(px * 0.04 * longX + time * 0.5) *
                                   Math.sin(py * 0.05 * longY + time * 0.4) *
                                   Math.sin((px + py) * 0.03 * longDiag - time * 0.3);

                        // Layer 2: Medium faster cells
                        const n2 = Math.sin(px * 0.06 * longY - time * 0.7) *
                                   Math.sin(py * 0.04 * longX + time * 0.6) *
                                   Math.cos((px - py) * 0.04 * longDiag + time * 0.5);

                        // Layer 3: Small quick shimmer
                        const n3 = Math.sin(px * 0.1 * longDiag + time * 1.2) *
                                   Math.sin(py * 0.08 * longX - time * 0.9);

                        // Combine layers
                        const cellValue = n1 * 0.5 + n2 * 0.35 + n3 * 0.15;

                        // Bright at edges (where value crosses zero)
                        let brightness = 1 - Math.abs(cellValue) * 2.5;
                        brightness = Math.max(0, brightness);
                        brightness = brightness * brightness * 0.1;

                        const idx = (py * w + px) * 4;
                        data[idx] = baseR + (caustR - baseR) * brightness;
                        data[idx + 1] = baseG + (caustG - baseG) * brightness;
                        data[idx + 2] = baseB + (caustB - baseB) * brightness;
                        data[idx + 3] = 255;
                    }
                }

                causticsCtx.putImageData(imageData, 0, 0);
            }

            function renderFish() {
                fishCtx.clearRect(0, 0, width, height);
                // Draw food pellets first (sink to bottom)
                for (const pellet of foodPellets) {
                    if (!pellet.eaten) pellet.draw(fishCtx);
                }
                // Draw fish
                for (const boid of boids) {
                    boid.draw(fishCtx);
                }
                // Draw plants on top
                for (const plant of plants) {
                    plant.draw(fishCtx);
                }
            }

            function resize() {
                const rect = container.getBoundingClientRect();
                width = Math.floor(rect.width);
                height = Math.floor(rect.height);
                causticsCanvas.width = width;
                causticsCanvas.height = height;
                fishCanvas.width = width;
                fishCanvas.height = height;
                if (boids.length === 0) initBoids();
                if (plants.length === 0) initPlants();
            }

            function animate(timestamp) {
                const elapsed = timestamp - lastFrame;
                if (elapsed >= 50) { // ~20 FPS
                    const dt = elapsed / 1000;
                    lastFrame = timestamp;
                    
                    // Update wind
                    updateWind(dt);
                    
                    // Update plant animation time
                    plantTime += dt;
                    
                    // Update food pellets
                    for (const pellet of foodPellets) {
                        pellet.update(dt);
                    }
                    // Remove eaten pellets
                    for (let i = foodPellets.length - 1; i >= 0; i--) {
                        if (foodPellets[i].eaten) foodPellets.splice(i, 1);
                    }
                    
                    // Update plants
                    for (const plant of plants) {
                        plant.update(dt, width, height);
                    }
                    
                    // Update boids
                    for (const boid of boids) {
                        boid.update(dt, width, height);
                    }
                    
                    renderCaustics(dt);
                    renderFish();
                }
                animationId = requestAnimationFrame(animate);
            }

            function start() {
                resize();
                lastFrame = performance.now();
                animationId = requestAnimationFrame(animate);
            }

            function stop() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }

            // ResizeObserver for container size changes
            const resizeObserver = new ResizeObserver(() => {
                resize();
            });
            resizeObserver.observe(container);

            // Start animation when visible
            const intersectionObserver = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting) {
                    start();
                } else {
                    stop();
                }
            });
            intersectionObserver.observe(tile);

            tile.querySelector('.widget-header .btn').addEventListener('click', () => {
                stop();
                resizeObserver.disconnect();
                intersectionObserver.disconnect();
                removeWidget(widget.id);
            });

            // Initial start
            setTimeout(start, 100);

            // Click/touch to feed fish
            function spawnFood(x, y) {
                const numPellets = 4 + Math.floor(Math.random() * 3); // 4-6 pellets
                for (let i = 0; i < numPellets; i++) {
                    const offsetX = (Math.random() - 0.5) * 30;
                    const offsetY = (Math.random() - 0.5) * 30;
                    foodPellets.push(new FoodPellet(x + offsetX, y + offsetY));
                }
            }

            fishCanvas.addEventListener('click', (e) => {
                const rect = fishCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                spawnFood(x, y);
            });

            // Touch: only feed on tap, not scroll
            let touchStartPos = null;
            let touchStartTime = 0;
            fishCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartTime = Date.now();
                }
            }, { passive: true });

            fishCanvas.addEventListener('touchend', (e) => {
                if (touchStartPos && e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    const dx = touch.clientX - touchStartPos.x;
                    const dy = touch.clientY - touchStartPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const duration = Date.now() - touchStartTime;
                    // Only spawn food if it was a tap (short distance, short time)
                    if (dist < 15 && duration < 300) {
                        const rect = fishCanvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        spawnFood(x, y);
                    }
                }
                touchStartPos = null;
            }, { passive: true });

            return tile;
        }

        

        // About Widget
        function createAboutWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.about.size} about-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">About</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="about-content">
                    <div class="about-authors">
                        <strong>Authors</strong>
                        Timeless Prototype<br>
                        Claude Opus 4.5
                    </div>
                    <a href="https://buymeacoffee.com/timelessp" target="_blank" rel="noopener noreferrer" class="about-bmac" title="Buy us a coffee">
                        <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee">
                    </a>
                    <div class="about-heart">
                        Made with ${icons.heart} and ${icons.robot}
                    </div>
                </div>
            `;

            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));

            return tile;
        }

        // Drag and Drop for Widget Reordering
        function initDragAndDrop() {
            const grid = document.getElementById('widgetGrid');
            let draggedWidget = null;
            let draggedElement = null;
            let placeholder = null;
            let touchStartX = 0;
            let touchStartY = 0;
            let touchOffsetX = 0;
            let touchOffsetY = 0;
            let isDragging = false;

            function getWidgetElements() {
                return Array.from(grid.querySelectorAll('.tile[data-widget-id]'));
            }

            function createPlaceholder(element) {
                const ph = document.createElement('div');
                ph.className = element.className + ' drag-placeholder';
                ph.style.opacity = '0.4';
                ph.style.pointerEvents = 'none';
                ph.style.border = '2px dashed var(--accent-add)';
                ph.style.background = 'var(--button-hover)';
                return ph;
            }

            function getInsertPosition(x, y, exclude) {
                const elements = getWidgetElements().filter(el => el !== exclude);
                const addTile = grid.querySelector('.add-widget-tile');
                
                // Check each widget to find insertion point
                for (let i = 0; i < elements.length; i++) {
                    const el = elements[i];
                    const rect = el.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    // If cursor is in the left half or top half of element, insert before
                    if (y < rect.bottom && y >= rect.top) {
                        if (x < centerX) {
                            return { element: el, position: 'before' };
                        }
                    }
                    // If cursor is above this row
                    if (y < rect.top) {
                        return { element: el, position: 'before' };
                    }
                }
                
                // If we're past all elements, insert at end
                if (elements.length > 0) {
                    return { element: null, position: 'end' };
                }
                
                // Insert after add tile
                return { element: addTile, position: 'after' };
            }

            function handleDragStart(e, element) {
                // Don't drag the add-widget tile
                if (element.classList.contains('add-widget-tile')) return false;
                
                // Check if we clicked on an interactive element
                const target = e.target;
                if (target.closest('input, textarea, button, select, .timer-value, .audio-display')) {
                    return false;
                }

                // Only allow drag from header or drag handle
                if (!target.closest('.widget-header, .drag-handle')) {
                    return false;
                }

                draggedElement = element;
                draggedWidget = widgets.find(w => w.id === parseInt(element.dataset.widgetId));
                
                return true;
            }

            function startDragging(element, clientX, clientY) {
                isDragging = true;
                element.classList.add('dragging');
                
                const rect = element.getBoundingClientRect();
                touchOffsetX = clientX - rect.left;
                touchOffsetY = clientY - rect.top;
                
                // Create placeholder and insert where the element was
                placeholder = createPlaceholder(element);
                element.parentNode.insertBefore(placeholder, element);
                
                // Make element fixed for dragging
                element.style.position = 'fixed';
                element.style.left = rect.left + 'px';
                element.style.top = rect.top + 'px';
                element.style.width = rect.width + 'px';
                element.style.zIndex = '1000';
                element.style.pointerEvents = 'none';
            }

            function moveDragging(clientX, clientY) {
                if (!draggedElement || !isDragging) return;
                
                // Move the dragged element
                draggedElement.style.left = (clientX - touchOffsetX) + 'px';
                draggedElement.style.top = (clientY - touchOffsetY) + 'px';
                
                // Find where to show the placeholder
                const insertPos = getInsertPosition(clientX, clientY, draggedElement);
                
                if (insertPos.position === 'end') {
                    // Append to end of grid
                    grid.appendChild(placeholder);
                } else if (insertPos.element && insertPos.element !== placeholder) {
                    if (insertPos.position === 'before') {
                        insertPos.element.parentNode.insertBefore(placeholder, insertPos.element);
                    } else {
                        insertPos.element.parentNode.insertBefore(placeholder, insertPos.element.nextSibling);
                    }
                }
            }

            function endDragging(clientX, clientY) {
                if (!draggedElement || !isDragging) {
                    cleanup();
                    return;
                }
                
                // Reset styles
                draggedElement.classList.remove('dragging');
                draggedElement.style.position = '';
                draggedElement.style.left = '';
                draggedElement.style.top = '';
                draggedElement.style.width = '';
                draggedElement.style.zIndex = '';
                draggedElement.style.pointerEvents = '';
                
                // Insert the dragged element where the placeholder is
                if (placeholder && placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(draggedElement, placeholder);
                    
                    // Rebuild widgets array based on new DOM order
                    const newOrder = [];
                    getWidgetElements().forEach(el => {
                        const w = widgets.find(w => w.id === parseInt(el.dataset.widgetId));
                        if (w) newOrder.push(w);
                    });
                    widgets = newOrder;
                    saveWidgets();
                }
                
                cleanup();
            }

            function cleanup() {
                if (placeholder && placeholder.parentNode) {
                    placeholder.remove();
                }
                placeholder = null;
                draggedWidget = null;
                draggedElement = null;
                isDragging = false;
            }

            // Mouse events
            grid.addEventListener('mousedown', (e) => {
                const tile = e.target.closest('.tile[data-widget-id]');
                if (tile && handleDragStart(e, tile)) {
                    e.preventDefault();
                    touchStartX = e.clientX;
                    touchStartY = e.clientY;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!draggedElement) return;
                
                if (!isDragging) {
                    const dx = Math.abs(e.clientX - touchStartX);
                    const dy = Math.abs(e.clientY - touchStartY);
                    if (dx > 5 || dy > 5) {
                        startDragging(draggedElement, touchStartX, touchStartY);
                    }
                }
                
                if (isDragging) {
                    e.preventDefault();
                    moveDragging(e.clientX, e.clientY);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (draggedElement) {
                    endDragging(e.clientX, e.clientY);
                }
            });

            // Touch events
            grid.addEventListener('touchstart', (e) => {
                const tile = e.target.closest('.tile[data-widget-id]');
                if (tile && handleDragStart(e, tile)) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!draggedElement) return;
                
                const touch = e.touches[0];
                
                if (!isDragging) {
                    const dx = Math.abs(touch.clientX - touchStartX);
                    const dy = Math.abs(touch.clientY - touchStartY);
                    if (dx > 10 || dy > 10) {
                        startDragging(draggedElement, touchStartX, touchStartY);
                    }
                }
                
                if (isDragging) {
                    e.preventDefault();
                    moveDragging(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (draggedElement) {
                    const touch = e.changedTouches[0];
                    endDragging(touch.clientX, touch.clientY);
                }
            });

            document.addEventListener('touchcancel', () => {
                if (draggedElement) {
                    cleanup();
                }
            });
        }

        // Initialize
        function init() {
            initTheme();
            const grid = document.getElementById('widgetGrid');
            grid.appendChild(createAddWidgetTile());
            loadWidgets();
            // Perform a one-time sweep to remove orphaned audio blobs left from prior versions
            // (safely checks for references before deleting)
            setTimeout(() => {
                scanAndCleanupOrphanedAudio();
            }, 2000);
            initDragAndDrop();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>

    <script src="parental.js" defer></script>
    <script src="assets/js/pwa.js" defer></script>
</body>
</html>
