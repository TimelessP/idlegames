<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a1a">
    <title>Density</title>
    <link rel="icon" type="image/png" sizes="512x512" href="assets/appicons/idle-games-512x512px.png">
    <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512px.png">
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        :root {
            --tile-bg: #ffffff;
            --tile-bg-rgb: 255, 255, 255;
            --text-color: #1a1a1a;
            --text-muted: #666666;
            --shadow-color: rgba(0, 0, 0, 0.25);
            --inset-shadow: rgba(0, 0, 0, 0.15);
            --button-hover: rgba(0, 0, 0, 0.06);
            --button-active: rgba(0, 0, 0, 0.1);
            --accent-spin: #5a8a6e;
            --accent-add: #5a7a9a;
            --accent-delete: #9a6a6a;
            --accent-reset: #8a7a5a;
            --accent-up: #6a7a8a;
            --accent-down: #7a6a8a;
            --noise-opacity: 0.03;
            --grid-gap: 16px;
            --tile-radius: 8px;
            --button-radius: 6px;
            --base-unit: min(calc((100vw - 48px) / 2), 180px);
        }

        [data-theme="dark"] {
            --tile-bg: #1a1a1a;
            --tile-bg-rgb: 26, 26, 26;
            --text-color: #e8e8e8;
            --text-muted: #888888;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --inset-shadow: rgba(0, 0, 0, 0.4);
            --button-hover: rgba(255, 255, 255, 0.08);
            --button-active: rgba(255, 255, 255, 0.12);
            --accent-spin: #6a9a7e;
            --accent-add: #6a8aaa;
            --accent-delete: #aa7a7a;
            --accent-reset: #9a8a6a;
            --accent-up: #7a8a9a;
            --accent-down: #8a7a9a;
            --noise-opacity: 0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            min-height: 100vh;
            padding: var(--grid-gap);
            color: var(--text-color);
            transition: background 0.3s ease;
        }

        [data-theme="light"] body {
            background: linear-gradient(135deg, #e8e8f0 0%, #d8d8e0 100%);
        }

        [data-theme="dark"] body {
            background: linear-gradient(135deg, #0a0a0f 0%, #151520 100%);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, var(--base-unit));
            gap: var(--grid-gap);
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .tile {
            background-color: var(--tile-bg);
            border-radius: var(--tile-radius);
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: 12px;
            gap: 8px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .tile::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: var(--noise-opacity);
            pointer-events: none;
        }

        .tile.size-1x1 {
            width: var(--base-unit);
            height: var(--base-unit);
        }

        .tile.size-2x2 {
            width: calc(var(--base-unit) * 2 + var(--grid-gap));
            height: calc(var(--base-unit) * 2 + var(--grid-gap));
            grid-column: span 2;
            grid-row: span 2;
        }

        .tile.size-1x2 {
            width: calc(var(--base-unit) * 2 + var(--grid-gap));
            height: var(--base-unit);
            grid-column: span 2;
        }

        /* Buttons */
        .btn {
            background: var(--tile-bg);
            border: 2px solid currentColor;
            border-radius: var(--button-radius);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
            transition: background 0.15s ease, color 0.15s ease, transform 0.1s ease;
            position: relative;
            flex-shrink: 0;
        }

        .btn:hover {
            background: var(--button-hover);
        }

        .btn:active {
            background: var(--button-active);
            transform: scale(0.96);
        }

        .btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .btn.accent-spin { color: var(--accent-spin); }
        .btn.accent-add { color: var(--accent-add); }
        .btn.accent-delete { color: var(--accent-delete); }
        .btn.accent-reset { color: var(--accent-reset); }
        .btn.accent-up { color: var(--accent-up); }
        .btn.accent-down { color: var(--accent-down); }

        .btn-small {
            width: 32px;
            height: 32px;
        }

        .btn-small svg {
            width: 16px;
            height: 16px;
        }

        /* Input boxes */
        .input-inset {
            background: var(--tile-bg);
            border: none;
            border-radius: var(--button-radius);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            color: var(--text-color);
            font-size: 14px;
            padding: 8px 10px;
            width: 100%;
            outline: none;
            transition: box-shadow 0.2s ease;
        }

        .input-inset:focus {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .input-inset::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        select.input-inset {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23666'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 18px;
            padding-right: 30px;
        }

        [data-theme="dark"] select.input-inset {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23888'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
        }

        /* Widget specific styles */
        .widget-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .widget-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .widget-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
        }

        /* Add Widget Tile */
        .add-widget-tile .widget-content {
            justify-content: center;
        }

        .add-widget-row {
            display: flex;
            gap: 8px;
        }

        .add-widget-row select {
            flex: 1;
        }

        /* Spinner Widget */
        .spinner-input-row {
            display: flex;
            gap: 4px;
        }

        .spinner-input-row .input-inset {
            flex: 1;
            min-width: 0;
            font-size: 13px;
            padding: 6px 8px;
        }

        .spinner-input-row .input-inset.spinning {
            animation: pulse 0.1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .spinner-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Audio Widget */
        .audio-display {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            font-size: 12px;
            text-align: left;
            padding: 4px 8px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            overflow: hidden;
            white-space: nowrap;
            color: var(--text-color);
            position: relative;
        }

        .audio-display .track-name {
            display: inline-block;
            white-space: nowrap;
        }

        .audio-display .track-name.scrolling {
            animation: marquee-ping-pong var(--scroll-duration, 6s) ease-in-out infinite;
        }

        @keyframes marquee-ping-pong {
            0%, 10% { transform: translateX(0); }
            45%, 55% { transform: translateX(var(--scroll-distance, 0px)); }
            90%, 100% { transform: translateX(0); }
        }

        .audio-display.empty {
            justify-content: center;
            color: var(--text-muted);
            opacity: 0.6;
        }

        .audio-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tile.drop-active {
            outline: 2px dashed var(--accent-add);
            outline-offset: -4px;
        }

        .tile.drop-active::after {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--accent-add);
            opacity: 0.1;
            pointer-events: none;
            z-index: 5;
        }

        .audio-file-input {
            display: none;
        }

        /* Tasks Widget */
        .task-input-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            padding: 4px 8px;
            background: var(--tile-bg);
        }

        .task-input-wrapper:focus-within {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .task-check-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: color 0.15s ease;
        }

        .task-check-btn:hover {
            color: var(--accent-spin);
        }

        .task-check-btn.checked {
            color: var(--accent-spin);
        }

        .task-check-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .task-input {
            flex: 1;
            min-width: 0;
            border: none;
            background: transparent;
            color: var(--text-color);
            font-size: 13px;
            outline: none;
            padding: 2px 0;
        }

        .task-input::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        .task-input.checked {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .task-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Timer Widget */
        .timer-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .timer-segment {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .timer-value {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 28px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            background: var(--tile-bg);
            font-variant-numeric: tabular-nums;
            user-select: none;
            cursor: pointer;
            transition: box-shadow 0.15s ease;
        }

        .timer-value:focus {
            outline: none;
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .timer-value.editing {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-spin);
        }

        .timer-colon {
            font-size: 16px;
            color: var(--text-muted);
            padding: 0 1px;
        }

        .timer-adjust {
            display: flex;
            gap: 2px;
        }

        .timer-adjust-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0;
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s ease;
        }

        .timer-adjust-btn:hover {
            color: var(--text-color);
        }

        .timer-adjust-btn svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        .timer-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .timer-display.alarming .timer-value {
            animation: alarm-pulse 0.5s ease-in-out infinite;
        }

        @keyframes alarm-pulse {
            0%, 100% { background: var(--tile-bg); }
            50% { background: var(--accent-delete); color: white; }
        }

        /* Notepad Widget */
        .notepad-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .notepad-textarea {
            flex: 1;
            width: 100%;
            resize: none;
            border: none;
            background: var(--tile-bg);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            line-height: 1.5;
            padding: 10px;
            outline: none;
            overflow-x: hidden;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .notepad-textarea:focus {
            box-shadow: inset 0 2px 8px var(--inset-shadow), 0 0 0 2px var(--accent-add);
        }

        .notepad-textarea::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        /* Themed scrollbars for notepad */
        .notepad-textarea,
        .notepad-preview {
            scrollbar-width: thin;
            scrollbar-color: var(--text-muted) transparent;
        }

        .notepad-textarea::-webkit-scrollbar,
        .notepad-preview::-webkit-scrollbar {
            width: 8px;
        }

        .notepad-textarea::-webkit-scrollbar-track,
        .notepad-preview::-webkit-scrollbar-track {
            background: transparent;
            border-radius: 4px;
        }

        .notepad-textarea::-webkit-scrollbar-thumb,
        .notepad-preview::-webkit-scrollbar-thumb {
            background: var(--text-muted);
            border-radius: 4px;
            opacity: 0.5;
        }

        .notepad-textarea::-webkit-scrollbar-thumb:hover,
        .notepad-preview::-webkit-scrollbar-thumb:hover {
            background: var(--text-color);
        }

        .notepad-preview {
            flex: 1;
            overflow-x: hidden;
            overflow-y: auto;
            padding: 10px;
            box-shadow: inset 0 2px 6px var(--inset-shadow);
            border-radius: var(--button-radius);
            background: var(--tile-bg);
            font-size: 13px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .notepad-preview h1,
        .notepad-preview h2,
        .notepad-preview h3 {
            margin: 0.5em 0 0.3em;
            line-height: 1.3;
        }

        .notepad-preview h1 { font-size: 1.4em; }
        .notepad-preview h2 { font-size: 1.2em; }
        .notepad-preview h3 { font-size: 1.1em; }

        .notepad-preview p {
            margin: 0.4em 0;
        }

        .notepad-preview ul, .notepad-preview ol {
            margin: 0.4em 0;
            padding-left: 1.5em;
        }

        .notepad-preview ul ul,
        .notepad-preview ul ol,
        .notepad-preview ol ul,
        .notepad-preview ol ol {
            margin: 0.2em 0;
        }

        .notepad-preview li {
            margin: 0.1em 0;
        }

        .notepad-preview li:has(.checkbox) {
            list-style: none;
            margin-left: -1.5em;
        }

        .notepad-preview .checkbox {
            cursor: pointer;
            user-select: none;
            display: inline-flex;
            align-items: center;
            gap: 0.4em;
            vertical-align: middle;
            line-height: 1;
        }

        .notepad-preview .checkbox-box {
            width: 14px;
            height: 14px;
            border: 2px solid var(--text-muted);
            border-radius: 3px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.15s ease, border-color 0.15s ease;
            position: relative;
        }

        .notepad-preview .checkbox:hover .checkbox-box {
            border-color: var(--accent-spin);
        }

        .notepad-preview .checkbox.checked .checkbox-box {
            background: var(--accent-spin);
            border-color: var(--accent-spin);
        }

        .notepad-preview .checkbox.checked .checkbox-box::after {
            content: '';
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
            position: absolute;
            top: 0px;
            left: 3px;
        }

        .notepad-preview .checkbox.checked .checkbox-text {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .notepad-preview code {
            background: var(--button-hover);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }

        .notepad-preview pre {
            background: var(--button-hover);
            padding: 0.6em;
            border-radius: var(--button-radius);
            overflow-x: auto;
            margin: 0.4em 0;
        }

        .notepad-preview pre code {
            background: none;
            padding: 0;
        }

        .notepad-preview blockquote {
            border-left: 3px solid var(--accent-add);
            margin: 0.4em 0;
            padding-left: 0.8em;
            color: var(--text-muted);
        }

        .notepad-preview a {
            color: var(--accent-add);
            text-decoration: none;
        }

        .notepad-preview a:hover {
            text-decoration: underline;
        }

        .notepad-controls {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .notepad-btn.active {
            background: var(--button-active);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
        }

        /* Data Widget */
        .data-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            justify-content: center;
        }

        .data-row {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .data-btn {
            flex: 1;
            height: 32px;
        }

        .data-btn.armed {
            background: var(--accent-delete);
            color: white;
            border-color: var(--accent-delete);
        }

        .data-btn.armed:hover {
            background: var(--accent-delete);
            filter: brightness(1.1);
        }

        .data-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .data-file-input {
            display: none;
        }

        /* Draggable Widgets */
        .tile.draggable {
            cursor: grab;
        }

        .tile.draggable:active {
            cursor: grabbing;
        }

        .tile.dragging {
            opacity: 0.6;
            z-index: 1000;
            box-shadow: 0 8px 24px var(--shadow-color);
        }

        .tile.drag-over {
            outline: 2px dashed var(--accent-add);
            outline-offset: -4px;
        }

        .tile.drag-over::after {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--accent-add);
            opacity: 0.1;
            pointer-events: none;
            z-index: 5;
        }

        .drag-handle {
            cursor: grab;
            color: var(--text-muted);
            opacity: 0.5;
            transition: opacity 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
        }

        .drag-handle:hover {
            opacity: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        /* Theme Widget */
        .theme-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex: 1;
            align-items: center;
        }

        .theme-btn {
            width: 44px;
            height: 44px;
            border-width: 2px;
        }

        .theme-btn.active {
            background: var(--button-active);
            box-shadow: inset 0 2px 6px var(--inset-shadow);
        }

        .theme-btn svg {
            width: 22px;
            height: 22px;
        }

        /* Toggle buttons for theme */
        .toggle-group {
            display: flex;
            gap: 6px;
        }

        /* Responsive adjustments */
        @media (max-width: 400px) {
            :root {
                --base-unit: calc((100vw - 48px) / 2);
                --grid-gap: 12px;
            }
            
            .tile {
                padding: 10px;
            }
            
            .btn-small {
                width: 28px;
                height: 28px;
            }
        }

        @media (min-width: 600px) {
            :root {
                --base-unit: 160px;
            }
        }

        @media (min-width: 900px) {
            :root {
                --base-unit: 180px;
            }
        }
    </style>
</head>
<body>
    <div class="grid" id="widgetGrid">
        <!-- Add Widget tile is always first, rendered by JS -->
    </div>

    <script>
        // SVG Icons
        const icons = {
            plus: `<svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>`,
            close: `<svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`,
            up: `<svg viewBox="0 0 24 24"><path d="M7 14l5-5 5 5z"/></svg>`,
            down: `<svg viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>`,
            spin: `<svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>`,
            spinRemove: `<svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/><line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2"/></svg>`,
            reset: `<svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>`,
            delete: `<svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`,
            sun: `<svg viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37a.996.996 0 00-1.41 0 .996.996 0 000 1.41l1.06 1.06c.39.39 1.03.39 1.41 0a.996.996 0 000-1.41l-1.06-1.06zm1.06-10.96a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36a.996.996 0 000-1.41.996.996 0 00-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/></svg>`,
            moon: `<svg viewBox="0 0 24 24"><path d="M12 3a9 9 0 109 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 01-4.4 2.26 5.403 5.403 0 01-3.14-9.8c-.44-.06-.9-.1-1.36-.1z"/></svg>`,
            system: `<svg viewBox="0 0 24 24"><path d="M20 3H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h3l-1 1v2h12v-2l-1-1h3c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 13H4V5h16v11z"/></svg>`,
            check: `<svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>`,
            checkBox: `<svg viewBox="0 0 24 24"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/></svg>`,
            checkBoxChecked: `<svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`,
            play: `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`,
            pause: `<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`,
            stop: `<svg viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>`,
            prev: `<svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>`,
            next: `<svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>`,
            shuffle: `<svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>`,
            volumeOn: `<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>`,
            volumeOff: `<svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>`,
            edit: `<svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`,
            eye: `<svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`,
            drag: `<svg viewBox="0 0 24 24"><path d="M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>`,
            download: `<svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>`,
            upload: `<svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"/></svg>`,
            warning: `<svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>`,
            lock: `<svg viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>`,
            unlock: `<svg viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"/></svg>`
        };

        // Widget Types Registry
        const widgetTypes = {
            spinner: {
                name: 'Spinner',
                size: '1x1',
                create: createSpinnerWidget
            },
            tasks: {
                name: 'Tasks',
                size: '1x1',
                create: createTasksWidget
            },
            audio: {
                name: 'Audio',
                size: '1x1',
                create: createAudioWidget
            },
            theme: {
                name: 'Theme',
                size: '1x1',
                create: createThemeWidget
            },
            timer: {
                name: 'Timer',
                size: '1x1',
                create: createTimerWidget
            },
            notepad: {
                name: 'Notepad',
                size: '2x2',
                create: createNotepadWidget
            },
            data: {
                name: 'Data',
                size: '1x1',
                create: createDataWidget
            }
        };

        // Audio IndexedDB Storage
        const AUDIO_DB_NAME = 'density-audio';
        const AUDIO_DB_VERSION = 1;
        const AUDIO_STORE_NAME = 'tracks';

        // IndexedDB helper functions
        function openAudioDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(AUDIO_DB_NAME, AUDIO_DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(AUDIO_STORE_NAME)) {
                        db.createObjectStore(AUDIO_STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveAudioBlob(id, blob, type) {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readwrite');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                store.put({ id, blob, type });
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = () => { db.close(); reject(tx.error); };
            });
        }

        async function getAudioBlob(id) {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readonly');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => { db.close(); resolve(request.result); };
                request.onerror = () => { db.close(); reject(request.error); };
            });
        }

        async function deleteAudioBlob(id) {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readwrite');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                store.delete(id);
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = () => { db.close(); reject(tx.error); };
            });
        }

        async function clearAllAudio() {
            const db = await openAudioDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(AUDIO_STORE_NAME, 'readwrite');
                const store = tx.objectStore(AUDIO_STORE_NAME);
                store.clear();
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = () => { db.close(); reject(tx.error); };
            });
        }

        // State
        let widgets = [];
        let widgetIdCounter = 0;

        // Theme Management
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function applyTheme(theme) {
            const effectiveTheme = theme === 'system' ? getSystemTheme() : theme;
            document.documentElement.setAttribute('data-theme', effectiveTheme);
            localStorage.setItem('density-theme', theme);
            updateThemeWidgets(theme);
        }

        function updateThemeWidgets(theme) {
            document.querySelectorAll('.theme-widget').forEach(widget => {
                widget.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === theme);
                });
            });
        }

        function initTheme() {
            const saved = localStorage.getItem('density-theme') || 'system';
            applyTheme(saved);
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                const current = localStorage.getItem('density-theme') || 'system';
                if (current === 'system') applyTheme('system');
            });
        }

        // Widget Management
        function saveWidgets() {
            const data = widgets.map(w => ({
                id: w.id,
                type: w.type,
                data: w.data
            }));
            localStorage.setItem('density-widgets', JSON.stringify(data));
        }

        function loadWidgets() {
            try {
                const saved = localStorage.getItem('density-widgets');
                if (saved) {
                    const data = JSON.parse(saved);
                    data.forEach(w => {
                        addWidget(w.type, w.data, w.id);
                    });
                }
            } catch (e) {
                console.error('Failed to load widgets:', e);
            }
        }

        function addWidget(type, data = {}, existingId = null) {
            const widgetType = widgetTypes[type];
            if (!widgetType) return;

            const id = existingId || ++widgetIdCounter;
            if (id > widgetIdCounter) widgetIdCounter = id;

            const widget = {
                id,
                type,
                data: { ...data }
            };
            widgets.push(widget);

            const element = widgetType.create(widget);
            document.getElementById('widgetGrid').appendChild(element);
            
            if (!existingId) saveWidgets();
            return widget;
        }

        function removeWidget(id) {
            const index = widgets.findIndex(w => w.id === id);
            if (index > -1) {
                widgets.splice(index, 1);
                const element = document.querySelector(`[data-widget-id="${id}"]`);
                if (element) {
                    element.style.transform = 'scale(0.9)';
                    element.style.opacity = '0';
                    setTimeout(() => element.remove(), 200);
                }
                saveWidgets();
            }
        }

        function updateWidgetData(id, data) {
            const widget = widgets.find(w => w.id === id);
            if (widget) {
                Object.assign(widget.data, data);
                saveWidgets();
            }
        }

        // Add Widget Tile
        function createAddWidgetTile() {
            const tile = document.createElement('div');
            tile.className = 'tile size-1x1 add-widget-tile';
            tile.innerHTML = `
                <div class="widget-header">
                    <span class="widget-title">Add Widget</span>
                </div>
                <div class="widget-content">
                    <div class="add-widget-row">
                        <select class="input-inset" id="widgetTypeSelect">
                            ${Object.entries(widgetTypes).map(([key, val]) => 
                                `<option value="${key}">${val.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="add-widget-row">
                        <button class="btn accent-add" style="flex:1; height: 36px;" id="addWidgetBtn" title="Add widget">
                            ${icons.plus}
                        </button>
                    </div>
                </div>
            `;

            tile.querySelector('#addWidgetBtn').addEventListener('click', () => {
                const type = tile.querySelector('#widgetTypeSelect').value;
                addWidget(type);
            });

            return tile;
        }

        // Spinner Widget
        function createSpinnerWidget(widget) {
            const data = widget.data;
            if (!data.allItems) data.allItems = [];
            if (!data.items) data.items = [];
            if (data.currentIndex === undefined) data.currentIndex = 0;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.spinner.size}`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Spinner</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="spinner-input-row">
                    <input type="text" class="input-inset spinner-input" placeholder="—">
                </div>
                <div class="spinner-controls">
                    <button class="btn btn-small accent-up" title="Previous">${icons.up}</button>
                    <button class="btn btn-small accent-down" title="Next">${icons.down}</button>
                    <button class="btn btn-small accent-add" title="Add new">${icons.plus}</button>
                    <button class="btn btn-small accent-delete spinner-delete" title="Delete">${icons.delete}</button>
                    <button class="btn btn-small accent-spin spinner-spin" title="Spin">${icons.spin}</button>
                    <button class="btn btn-small accent-spin spinner-remove-spin" title="Remove and spin">${icons.spinRemove}</button>
                    <button class="btn btn-small accent-reset spinner-reset" title="Reset">${icons.reset}</button>
                </div>
            `;

            const input = tile.querySelector('.spinner-input');
            let isSpinning = false;

            function updateDisplay() {
                if (data.allItems.length === 0) {
                    input.value = '';
                    input.placeholder = '—';
                } else {
                    input.value = data.allItems[data.currentIndex] || '';
                }
            }

            function saveCurrentInput() {
                const val = input.value;
                if (data.allItems.length === 0) {
                    // Create first item in both lists
                    data.items.push(val);
                    data.allItems.push(val);
                    data.currentIndex = 0;
                } else {
                    // Update current item in allItems
                    const oldVal = data.allItems[data.currentIndex];
                    data.allItems[data.currentIndex] = val;
                    // Also update in visible items if present
                    const visIdx = data.items.indexOf(oldVal);
                    if (visIdx !== -1) {
                        data.items[visIdx] = val;
                    }
                }
                updateWidgetData(widget.id, { items: data.items, allItems: data.allItems, currentIndex: data.currentIndex });
            }

            function addNewItem() {
                // Save current first if we have content
                if (data.allItems.length > 0) {
                    const oldVal = data.allItems[data.currentIndex];
                    const newVal = input.value;
                    data.allItems[data.currentIndex] = newVal;
                    const visIdx = data.items.indexOf(oldVal);
                    if (visIdx !== -1) {
                        data.items[visIdx] = newVal;
                    }
                }
                // Add new empty item to both lists
                data.items.push('');
                data.allItems.push('');
                data.currentIndex = data.allItems.length - 1;
                updateDisplay();
                input.focus();
                updateWidgetData(widget.id, { items: data.items, allItems: data.allItems, currentIndex: data.currentIndex });
            }

            function navigate(dir) {
                if (data.allItems.length === 0) return;
                // Re-align currentIndex to allItems based on current displayed value
                const currentVal = input.value;
                const alignedIndex = data.allItems.indexOf(currentVal);
                if (alignedIndex !== -1) {
                    data.currentIndex = alignedIndex;
                }
                // Now navigate
                data.currentIndex = (data.currentIndex + dir + data.allItems.length) % data.allItems.length;
                const currentItem = data.allItems[data.currentIndex];
                // Add back to visible list if not present
                if (!data.items.includes(currentItem)) {
                    data.items.push(currentItem);
                }
                updateDisplay();
                updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
            }

            function deleteCurrent() {
                if (data.allItems.length === 0) return;
                const removed = data.allItems.splice(data.currentIndex, 1)[0];
                // Also remove from visible items
                const visIdx = data.items.indexOf(removed);
                if (visIdx !== -1) {
                    data.items.splice(visIdx, 1);
                }
                if (data.allItems.length === 0) {
                    data.currentIndex = 0;
                } else if (data.currentIndex >= data.allItems.length) {
                    data.currentIndex = data.allItems.length - 1;
                }
                updateDisplay();
                updateWidgetData(widget.id, { items: data.items, allItems: data.allItems, currentIndex: data.currentIndex });
            }

            function spin() {
                if (isSpinning || data.items.length === 0) return;
                isSpinning = true;
                input.classList.add('spinning');

                const duration = 3000;
                const interval = 100;
                const steps = duration / interval;
                let step = 0;

                const finalIndex = Math.floor(Math.random() * data.items.length);

                const spinInterval = setInterval(() => {
                    const randomIdx = Math.floor(Math.random() * data.items.length);
                    input.value = data.items[randomIdx];
                    step++;

                    if (step >= steps) {
                        clearInterval(spinInterval);
                        data.currentIndex = finalIndex;
                        input.value = data.items[finalIndex];
                        input.classList.remove('spinning');
                        isSpinning = false;
                        updateWidgetData(widget.id, { currentIndex: data.currentIndex });
                    }
                }, interval);
            }

            function removeAndSpin() {
                if (isSpinning || data.items.length === 0) return;
                // Remove current item from visible list only (stays in allItems)
                data.items.splice(data.currentIndex, 1);
                if (data.items.length === 0) {
                    data.currentIndex = 0;
                    updateDisplay();
                    updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
                    return;
                }
                if (data.currentIndex >= data.items.length) {
                    data.currentIndex = data.items.length - 1;
                }
                // Then spin remaining items
                isSpinning = true;
                input.classList.add('spinning');

                const duration = 3000;
                const interval = 100;
                const steps = duration / interval;
                let step = 0;

                const finalIndex = Math.floor(Math.random() * data.items.length);

                const spinInterval = setInterval(() => {
                    const randomIdx = Math.floor(Math.random() * data.items.length);
                    input.value = data.items[randomIdx];
                    step++;

                    if (step >= steps) {
                        clearInterval(spinInterval);
                        data.currentIndex = finalIndex;
                        input.value = data.items[finalIndex];
                        input.classList.remove('spinning');
                        isSpinning = false;
                        updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
                    }
                }, interval);
            }

            function reset() {
                // Restore visible list from full list
                data.items = [...data.allItems];
                data.currentIndex = data.items.length > 0 ? 0 : 0;
                updateDisplay();
                updateWidgetData(widget.id, { items: data.items, currentIndex: data.currentIndex });
            }

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));
            tile.querySelector('.btn.accent-add').addEventListener('click', addNewItem);
            tile.querySelector('.btn.accent-up').addEventListener('click', () => navigate(-1));
            tile.querySelector('.btn.accent-down').addEventListener('click', () => navigate(1));
            tile.querySelector('.spinner-delete').addEventListener('click', deleteCurrent);
            tile.querySelector('.spinner-spin').addEventListener('click', spin);
            tile.querySelector('.spinner-remove-spin').addEventListener('click', removeAndSpin);
            tile.querySelector('.spinner-reset').addEventListener('click', reset);
            input.addEventListener('input', saveCurrentInput);

            updateDisplay();
            return tile;
        }

        // Tasks Widget
        function createTasksWidget(widget) {
            const data = widget.data;
            if (!data.tasks) data.tasks = [];
            if (data.currentIndex === undefined) data.currentIndex = 0;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.tasks.size} tasks-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Tasks</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="task-input-wrapper">
                    <button class="task-check-btn" title="Toggle complete">${icons.checkBox}</button>
                    <input type="text" class="task-input" placeholder="—">
                </div>
                <div class="task-controls">
                    <button class="btn btn-small accent-up task-prev" title="Previous">${icons.up}</button>
                    <button class="btn btn-small accent-down task-next" title="Next">${icons.down}</button>
                    <button class="btn btn-small accent-add task-add" title="Add task">${icons.plus}</button>
                    <button class="btn btn-small accent-delete task-delete" title="Delete task">${icons.delete}</button>
                </div>
            `;

            const input = tile.querySelector('.task-input');
            const checkBtn = tile.querySelector('.task-check-btn');

            function updateDisplay() {
                if (data.tasks.length === 0) {
                    input.value = '';
                    input.placeholder = '—';
                    input.classList.remove('checked');
                    checkBtn.innerHTML = icons.checkBox;
                    checkBtn.classList.remove('checked');
                } else {
                    const task = data.tasks[data.currentIndex];
                    input.value = task ? task.text : '';
                    input.classList.toggle('checked', task && task.done);
                    checkBtn.innerHTML = task && task.done ? icons.checkBoxChecked : icons.checkBox;
                    checkBtn.classList.toggle('checked', task && task.done);
                }
            }

            function saveCurrentInput() {
                const val = input.value;
                if (data.tasks.length === 0) {
                    data.tasks.push({ text: val, done: false });
                    data.currentIndex = 0;
                } else {
                    data.tasks[data.currentIndex].text = val;
                }
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            function addNewTask() {
                if (data.tasks.length > 0) {
                    data.tasks[data.currentIndex].text = input.value;
                }
                data.tasks.push({ text: '', done: false });
                data.currentIndex = data.tasks.length - 1;
                updateDisplay();
                input.focus();
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            function navigate(dir) {
                if (data.tasks.length === 0) return;
                data.currentIndex = (data.currentIndex + dir + data.tasks.length) % data.tasks.length;
                updateDisplay();
                updateWidgetData(widget.id, { currentIndex: data.currentIndex });
            }

            function deleteCurrent() {
                if (data.tasks.length === 0) return;
                data.tasks.splice(data.currentIndex, 1);
                if (data.tasks.length === 0) {
                    data.currentIndex = 0;
                } else if (data.currentIndex >= data.tasks.length) {
                    data.currentIndex = data.tasks.length - 1;
                }
                updateDisplay();
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            function toggleCheck() {
                if (data.tasks.length === 0) {
                    // Create first task if none exists
                    const val = input.value.trim();
                    if (val) {
                        data.tasks.push({ text: val, done: true });
                        data.currentIndex = 0;
                    } else {
                        return;
                    }
                } else {
                    data.tasks[data.currentIndex].done = !data.tasks[data.currentIndex].done;
                }
                updateDisplay();
                updateWidgetData(widget.id, { tasks: data.tasks, currentIndex: data.currentIndex });
            }

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));
            tile.querySelector('.task-add').addEventListener('click', addNewTask);
            tile.querySelector('.task-prev').addEventListener('click', () => navigate(-1));
            tile.querySelector('.task-next').addEventListener('click', () => navigate(1));
            tile.querySelector('.task-delete').addEventListener('click', deleteCurrent);
            checkBtn.addEventListener('click', toggleCheck);
            input.addEventListener('input', saveCurrentInput);

            updateDisplay();
            return tile;
        }

        // Audio Widget
        function createAudioWidget(widget) {
            const data = widget.data;
            if (!data.tracks) data.tracks = [];
            if (data.currentIndex === undefined) data.currentIndex = 0;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.audio.size} audio-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Audio</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="audio-display empty">—</div>
                <div class="audio-controls">
                    <button class="btn btn-small accent-up audio-prev" title="Previous">${icons.prev}</button>
                    <button class="btn btn-small accent-down audio-next" title="Next">${icons.next}</button>
                    <button class="btn btn-small accent-add audio-add" title="Add track">${icons.plus}</button>
                    <button class="btn btn-small accent-delete audio-delete" title="Delete track">${icons.delete}</button>
                    <button class="btn btn-small accent-spin audio-play" title="Play">${icons.play}</button>
                    <button class="btn btn-small accent-spin audio-pause" title="Pause">${icons.pause}</button>
                    <button class="btn btn-small accent-reset audio-stop" title="Stop">${icons.stop}</button>
                    <button class="btn btn-small accent-reset audio-shuffle" title="Shuffle">${icons.shuffle}</button>
                </div>
                <input type="file" class="audio-file-input" accept="audio/mpeg,audio/ogg,audio/wav,.mp3,.ogg,.wav" multiple>
            `;

            const display = tile.querySelector('.audio-display');
            const fileInput = tile.querySelector('.audio-file-input');
            const pauseBtn = tile.querySelector('.audio-pause');
            let audio = new Audio();
            let isPlaying = false;
            let isPaused = false;

            // Validate tracks against IndexedDB on load
            async function validateTracks() {
                if (data.tracks.length === 0) return;
                try {
                    const validTracks = [];
                    for (const track of data.tracks) {
                        const stored = await getAudioBlob(track.cacheKey);
                        if (stored) {
                            validTracks.push(track);
                        }
                    }
                    if (validTracks.length !== data.tracks.length) {
                        data.tracks = validTracks;
                        if (data.currentIndex >= data.tracks.length) {
                            data.currentIndex = Math.max(0, data.tracks.length - 1);
                        }
                        updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                    }
                } catch (e) {
                    console.error('Failed to validate audio storage:', e);
                }
                updateDisplay();
            }

            function updateDisplay() {
                if (data.tracks.length === 0) {
                    display.innerHTML = '<span class="track-name">—</span>';
                    display.classList.add('empty');
                } else {
                    const track = data.tracks[data.currentIndex];
                    const name = track ? track.name : '—';
                    display.innerHTML = `<span class="track-name">${name.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>`;
                    display.classList.remove('empty');
                    // Check for overflow and add scrolling animation
                    requestAnimationFrame(() => {
                        const span = display.querySelector('.track-name');
                        if (span) {
                            span.classList.remove('scrolling');
                            span.style.removeProperty('--scroll-distance');
                            span.style.removeProperty('--scroll-duration');
                            // Account for container padding (8px on each side)
                            const style = getComputedStyle(display);
                            const paddingLeft = parseFloat(style.paddingLeft) || 0;
                            const paddingRight = parseFloat(style.paddingRight) || 0;
                            const availableWidth = display.clientWidth - paddingLeft - paddingRight;
                            const overflow = span.scrollWidth - availableWidth;
                            if (overflow > 0) {
                                const distance = -overflow - 4; // Small extra buffer
                                const duration = Math.max(4, Math.min(12, overflow / 30)); // 4-12s based on length
                                span.style.setProperty('--scroll-distance', `${distance}px`);
                                span.style.setProperty('--scroll-duration', `${duration}s`);
                                span.classList.add('scrolling');
                            }
                        }
                    });
                }
            }

            async function addFiles(files) {
                try {
                    for (const file of files) {
                        if (!file.type.match(/^audio\/(mpeg|ogg|wav)$/)) continue;
                        const cacheKey = `audio-${widget.id}-${Date.now()}-${file.name}`;
                        await saveAudioBlob(cacheKey, file, file.type);
                        data.tracks.push({
                            name: file.name.replace(/\.[^.]+$/, ''),
                            cacheKey: cacheKey
                        });
                    }
                    data.currentIndex = data.tracks.length - 1;
                    updateDisplay();
                    updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                    // Load and optionally play new track
                    await loadTrack();
                    if (!isPaused) {
                        audio.play();
                        isPlaying = true;
                    }
                } catch (e) {
                    console.error('Failed to store audio:', e);
                }
            }

            function navigate(dir) {
                if (data.tracks.length === 0) return;
                const wasPlaying = isPlaying && !isPaused;
                data.currentIndex = (data.currentIndex + dir + data.tracks.length) % data.tracks.length;
                updateDisplay();
                updateWidgetData(widget.id, { currentIndex: data.currentIndex });
                if (isPlaying || isPaused) {
                    // Load new track from start
                    loadTrack().then(() => {
                        if (wasPlaying) {
                            audio.play();
                        }
                    });
                }
            }

            async function loadTrack() {
                if (data.tracks.length === 0) return;
                try {
                    const track = data.tracks[data.currentIndex];
                    const stored = await getAudioBlob(track.cacheKey);
                    if (!stored) {
                        data.tracks.splice(data.currentIndex, 1);
                        if (data.currentIndex >= data.tracks.length) {
                            data.currentIndex = Math.max(0, data.tracks.length - 1);
                        }
                        updateDisplay();
                        updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                        return;
                    }
                    const url = URL.createObjectURL(stored.blob);
                    audio.src = url;
                    audio.currentTime = 0;
                } catch (e) {
                    console.error('Failed to load audio:', e);
                }
            }

            async function playTrack() {
                if (data.tracks.length === 0) return;
                // If paused, just resume
                if (isPaused) {
                    audio.play();
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                    return;
                }
                try {
                    const track = data.tracks[data.currentIndex];
                    const stored = await getAudioBlob(track.cacheKey);
                    if (!stored) {
                        // Track no longer in storage, remove it
                        data.tracks.splice(data.currentIndex, 1);
                        if (data.currentIndex >= data.tracks.length) {
                            data.currentIndex = Math.max(0, data.tracks.length - 1);
                        }
                        updateDisplay();
                        updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                        return;
                    }
                    const url = URL.createObjectURL(stored.blob);
                    audio.src = url;
                    audio.play();
                    isPlaying = true;
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                } catch (e) {
                    console.error('Failed to play audio:', e);
                }
            }

            function stopTrack() {
                audio.pause();
                audio.currentTime = 0;
                isPlaying = false;
                isPaused = false;
                pauseBtn.classList.remove('active');
            }

            function togglePause() {
                if (data.tracks.length === 0) return;
                if (isPaused) {
                    audio.play();
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                } else if (isPlaying) {
                    audio.pause();
                    isPaused = true;
                    pauseBtn.classList.add('active');
                }
            }

            async function deleteCurrent() {
                if (data.tracks.length === 0) return;
                const track = data.tracks[data.currentIndex];
                try {
                    await deleteAudioBlob(track.cacheKey);
                } catch (e) {
                    console.error('Failed to delete from storage:', e);
                }
                data.tracks.splice(data.currentIndex, 1);
                if (data.currentIndex >= data.tracks.length) {
                    data.currentIndex = Math.max(0, data.tracks.length - 1);
                }
                stopTrack();
                updateDisplay();
                updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
            }

            async function shuffle() {
                if (data.tracks.length < 2) return;
                for (let i = data.tracks.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [data.tracks[i], data.tracks[j]] = [data.tracks[j], data.tracks[i]];
                }
                data.currentIndex = 0;
                updateDisplay();
                updateWidgetData(widget.id, { tracks: data.tracks, currentIndex: data.currentIndex });
                // Load and optionally play shuffled track
                await loadTrack();
                if (!isPaused) {
                    audio.play();
                    isPlaying = true;
                }
            }

            // Auto-play next track when current ends
            audio.addEventListener('ended', () => {
                if (data.tracks.length > 1) {
                    data.currentIndex = (data.currentIndex + 1) % data.tracks.length;
                    updateDisplay();
                    updateWidgetData(widget.id, { currentIndex: data.currentIndex });
                    playTrack();
                } else {
                    isPlaying = false;
                }
            });

            // Drag and drop
            tile.addEventListener('dragover', (e) => {
                e.preventDefault();
                tile.classList.add('drop-active');
            });

            tile.addEventListener('dragleave', (e) => {
                e.preventDefault();
                tile.classList.remove('drop-active');
            });

            tile.addEventListener('drop', (e) => {
                e.preventDefault();
                tile.classList.remove('drop-active');
                const files = Array.from(e.dataTransfer.files).filter(f => 
                    f.type === 'audio/mpeg' || f.type === 'audio/ogg' || f.type === 'audio/wav'
                );
                if (files.length > 0) addFiles(files);
            });

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', () => {
                stopTrack();
                removeWidget(widget.id);
            });
            tile.querySelector('.audio-add').addEventListener('click', () => fileInput.click());
            tile.querySelector('.audio-prev').addEventListener('click', () => navigate(-1));
            tile.querySelector('.audio-next').addEventListener('click', () => navigate(1));
            tile.querySelector('.audio-play').addEventListener('click', playTrack);
            tile.querySelector('.audio-pause').addEventListener('click', togglePause);
            tile.querySelector('.audio-stop').addEventListener('click', stopTrack);
            tile.querySelector('.audio-delete').addEventListener('click', deleteCurrent);
            tile.querySelector('.audio-shuffle').addEventListener('click', shuffle);
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    addFiles(Array.from(e.target.files));
                    e.target.value = '';
                }
            });

            // Validate cache on load
            validateTracks();

            return tile;
        }

        // Timer Widget
        function createTimerWidget(widget) {
            const data = widget.data;
            if (data.hours === undefined) data.hours = 0;
            if (data.minutes === undefined) data.minutes = 5;
            if (data.seconds === undefined) data.seconds = 0;
            if (data.soundEnabled === undefined) data.soundEnabled = true;

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.timer.size} timer-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Timer</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="timer-display">
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="hours" tabindex="0">00</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="hours" data-dir="1" title="Increase hours">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="hours" data-dir="-1" title="Decrease hours">${icons.down}</button>
                        </div>
                    </div>
                    <span class="timer-colon">:</span>
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="minutes" tabindex="0">05</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="minutes" data-dir="1" title="Increase minutes">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="minutes" data-dir="-1" title="Decrease minutes">${icons.down}</button>
                        </div>
                    </div>
                    <span class="timer-colon">:</span>
                    <div class="timer-segment">
                        <div class="timer-value" data-unit="seconds" tabindex="0">00</div>
                        <div class="timer-adjust">
                            <button class="timer-adjust-btn" data-unit="seconds" data-dir="1" title="Increase seconds">${icons.up}</button>
                            <button class="timer-adjust-btn" data-unit="seconds" data-dir="-1" title="Decrease seconds">${icons.down}</button>
                        </div>
                    </div>
                </div>
                <div class="timer-controls">
                    <button class="btn btn-small accent-spin timer-start" title="Start">${icons.play}</button>
                    <button class="btn btn-small accent-spin timer-pause" title="Pause">${icons.pause}</button>
                    <button class="btn btn-small accent-reset timer-reset" title="Reset">${icons.reset}</button>
                    <button class="btn btn-small accent-add timer-sound" title="Toggle sound">${data.soundEnabled ? icons.volumeOn : icons.volumeOff}</button>
                </div>
            `;

            const timerDisplay = tile.querySelector('.timer-display');
            const hoursEl = tile.querySelector('[data-unit="hours"].timer-value');
            const minutesEl = tile.querySelector('[data-unit="minutes"].timer-value');
            const secondsEl = tile.querySelector('[data-unit="seconds"].timer-value');
            const startBtn = tile.querySelector('.timer-start');
            const pauseBtn = tile.querySelector('.timer-pause');
            const soundBtn = tile.querySelector('.timer-sound');

            let remainingMs = 0;
            let intervalId = null;
            let isRunning = false;
            let isPaused = false;
            let isAlarming = false;
            let audioCtx = null;
            let oscillator = null;
            let gainNode = null;

            function pad(n) {
                return String(n).padStart(2, '0');
            }

            function updateDisplay() {
                const totalSec = Math.ceil(remainingMs / 1000);
                const h = Math.floor(totalSec / 3600);
                const m = Math.floor((totalSec % 3600) / 60);
                const s = totalSec % 60;
                hoursEl.textContent = pad(h);
                minutesEl.textContent = pad(m);
                secondsEl.textContent = pad(s);
            }

            function updateFromData() {
                remainingMs = (data.hours * 3600 + data.minutes * 60 + data.seconds) * 1000;
                updateDisplay();
            }

            function adjustUnit(unit, dir) {
                if (isRunning && !isPaused) return;
                stopAlarm();
                const limits = { hours: 99, minutes: 59, seconds: 59 };
                data[unit] = Math.max(0, Math.min(limits[unit], data[unit] + dir));
                updateFromData();
                updateWidgetData(widget.id, { hours: data.hours, minutes: data.minutes, seconds: data.seconds });
            }

            function startTimer() {
                if (isAlarming) {
                    stopAlarm();
                    return;
                }
                if (isRunning && !isPaused) return;
                if (isPaused) {
                    // Resume
                    isPaused = false;
                    pauseBtn.classList.remove('active');
                } else {
                    // Fresh start
                    updateFromData();
                    if (remainingMs <= 0) return;
                }
                isRunning = true;
                const startTime = Date.now();
                const startRemaining = remainingMs;

                intervalId = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    remainingMs = Math.max(0, startRemaining - elapsed);
                    updateDisplay();
                    if (remainingMs <= 0) {
                        clearInterval(intervalId);
                        intervalId = null;
                        isRunning = false;
                        triggerAlarm();
                    }
                }, 100);
            }

            function pauseTimer() {
                if (!isRunning || isPaused) return;
                if (isAlarming) {
                    stopAlarm();
                    return;
                }
                clearInterval(intervalId);
                intervalId = null;
                isPaused = true;
                pauseBtn.classList.add('active');
            }

            function resetTimer() {
                stopAlarm();
                clearInterval(intervalId);
                intervalId = null;
                isRunning = false;
                isPaused = false;
                pauseBtn.classList.remove('active');
                updateFromData();
            }

            function triggerAlarm() {
                isAlarming = true;
                timerDisplay.classList.add('alarming');
                if (data.soundEnabled) {
                    playAlarmSound();
                }
            }

            function stopAlarm() {
                if (!isAlarming) return;
                isAlarming = false;
                timerDisplay.classList.remove('alarming');
                stopAlarmSound();
            }

            function playAlarmSound() {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    gainNode = audioCtx.createGain();
                    gainNode.connect(audioCtx.destination);
                    gainNode.gain.value = 0.3;

                    // Soft pulsing sine wave
                    oscillator = audioCtx.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440;
                    oscillator.connect(gainNode);
                    oscillator.start();

                    // Gentle pulse effect
                    const pulseGain = () => {
                        if (!isAlarming || !gainNode) return;
                        const now = audioCtx.currentTime;
                        gainNode.gain.setValueAtTime(0.3, now);
                        gainNode.gain.linearRampToValueAtTime(0.1, now + 0.25);
                        gainNode.gain.linearRampToValueAtTime(0.3, now + 0.5);
                        setTimeout(pulseGain, 500);
                    };
                    pulseGain();
                } catch (e) {
                    console.error('Failed to play alarm:', e);
                }
            }

            function stopAlarmSound() {
                if (oscillator) {
                    oscillator.stop();
                    oscillator = null;
                }
                if (audioCtx) {
                    audioCtx.close();
                    audioCtx = null;
                }
                gainNode = null;
            }

            function toggleSound() {
                data.soundEnabled = !data.soundEnabled;
                soundBtn.innerHTML = data.soundEnabled ? icons.volumeOn : icons.volumeOff;
                updateWidgetData(widget.id, { soundEnabled: data.soundEnabled });
                if (!data.soundEnabled && isAlarming) {
                    stopAlarmSound();
                } else if (data.soundEnabled && isAlarming) {
                    playAlarmSound();
                }
            }

            // Handle direct value editing
            function handleValueClick(el, unit) {
                if (isRunning && !isPaused) return;
                stopAlarm();
                el.classList.add('editing');
                const currentVal = data[unit];
                el.textContent = '';
                el.contentEditable = true;
                el.focus();

                const finishEdit = () => {
                    el.contentEditable = false;
                    el.classList.remove('editing');
                    const val = parseInt(el.textContent) || 0;
                    const limits = { hours: 99, minutes: 59, seconds: 59 };
                    data[unit] = Math.max(0, Math.min(limits[unit], val));
                    updateFromData();
                    updateWidgetData(widget.id, { hours: data.hours, minutes: data.minutes, seconds: data.seconds });
                };

                el.addEventListener('blur', finishEdit, { once: true });
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        el.blur();
                    } else if (e.key === 'Escape') {
                        el.textContent = pad(currentVal);
                        el.blur();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        adjustUnit(unit, 1);
                        el.blur();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        adjustUnit(unit, -1);
                        el.blur();
                    }
                });
            }

            // Keyboard navigation on timer values
            [hoursEl, minutesEl, secondsEl].forEach(el => {
                const unit = el.dataset.unit;
                el.addEventListener('click', () => handleValueClick(el, unit));
                el.addEventListener('keydown', (e) => {
                    if (el.contentEditable === 'true') return;
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        adjustUnit(unit, 1);
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        adjustUnit(unit, -1);
                    } else if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleValueClick(el, unit);
                    }
                });
            });

            // Adjust buttons (touch/mouse)
            tile.querySelectorAll('.timer-adjust-btn').forEach(btn => {
                const unit = btn.dataset.unit;
                const dir = parseInt(btn.dataset.dir);
                
                let intervalId = null;
                let timeoutId = null;

                const startAdjust = (e) => {
                    e.preventDefault();
                    adjustUnit(unit, dir);
                    timeoutId = setTimeout(() => {
                        intervalId = setInterval(() => adjustUnit(unit, dir), 100);
                    }, 400);
                };

                const stopAdjust = () => {
                    clearTimeout(timeoutId);
                    clearInterval(intervalId);
                };

                btn.addEventListener('mousedown', startAdjust);
                btn.addEventListener('mouseup', stopAdjust);
                btn.addEventListener('mouseleave', stopAdjust);
                btn.addEventListener('touchstart', startAdjust, { passive: false });
                btn.addEventListener('touchend', stopAdjust);
                btn.addEventListener('touchcancel', stopAdjust);
            });

            // Control buttons
            tile.querySelector('.widget-header .btn').addEventListener('click', () => {
                stopAlarm();
                clearInterval(intervalId);
                removeWidget(widget.id);
            });
            startBtn.addEventListener('click', startTimer);
            pauseBtn.addEventListener('click', pauseTimer);
            tile.querySelector('.timer-reset').addEventListener('click', resetTimer);
            soundBtn.addEventListener('click', toggleSound);

            updateFromData();
            return tile;
        }

        // Notepad Widget
        function createNotepadWidget(widget) {
            const data = widget.data;
            if (data.content === undefined) data.content = '';
            if (data.mode === undefined) data.mode = 'edit';

            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.notepad.size} notepad-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Notepad</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="notepad-content">
                    <textarea class="notepad-textarea" placeholder="Write something..."></textarea>
                    <div class="notepad-preview" style="display: none;"></div>
                </div>
                <div class="notepad-controls">
                    <button class="btn btn-small accent-add notepad-btn notepad-edit active" title="Edit">${icons.edit}</button>
                    <button class="btn btn-small accent-add notepad-btn notepad-preview-btn" title="Preview">${icons.eye}</button>
                </div>
            `;

            const textarea = tile.querySelector('.notepad-textarea');
            const preview = tile.querySelector('.notepad-preview');
            const editBtn = tile.querySelector('.notepad-edit');
            const previewBtn = tile.querySelector('.notepad-preview-btn');

            textarea.value = data.content;

            function parseMarkdown(text) {
                const lines = text.split('\n');
                let html = '';
                let inCodeBlock = false;
                let codeBlockContent = '';
                let listStack = []; // Stack of { type: 'ul'|'ol', indent: number }
                
                function escapeHtml(str) {
                    return str
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                }
                
                function processInline(str) {
                    // Inline code (before other processing)
                    str = str.replace(/`([^`]+)`/g, '<code>$1</code>');
                    
                    // Bold and italic
                    str = str.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
                    str = str.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                    str = str.replace(/\*(.+?)\*/g, '<em>$1</em>');
                    str = str.replace(/___(.+?)___/g, '<strong><em>$1</em></strong>');
                    str = str.replace(/__(.+?)__/g, '<strong>$1</strong>');
                    str = str.replace(/_(.+?)_/g, '<em>$1</em>');
                    
                    // Links
                    str = str.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
                    
                    return str;
                }
                
                function closeListsToIndent(targetIndent) {
                    while (listStack.length > 0 && listStack[listStack.length - 1].indent >= targetIndent) {
                        const list = listStack.pop();
                        html += `</${list.type}>`;
                    }
                }
                
                function closeAllLists() {
                    while (listStack.length > 0) {
                        const list = listStack.pop();
                        html += `</${list.type}>`;
                    }
                }
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    
                    // Code blocks
                    if (line.trim().startsWith('```')) {
                        if (inCodeBlock) {
                            html += '<pre><code>' + escapeHtml(codeBlockContent.slice(0, -1)) + '</code></pre>';
                            codeBlockContent = '';
                            inCodeBlock = false;
                        } else {
                            closeAllLists();
                            inCodeBlock = true;
                        }
                        continue;
                    }
                    
                    if (inCodeBlock) {
                        codeBlockContent += line + '\n';
                        continue;
                    }
                    
                    // Count leading spaces/tabs for indentation
                    const indentMatch = line.match(/^([ \t]*)/);
                    const indent = indentMatch ? indentMatch[1].replace(/\t/g, '    ').length : 0;
                    const trimmedLine = line.trim();
                    
                    // Empty line
                    if (trimmedLine === '') {
                        closeAllLists();
                        html += '<br>';
                        continue;
                    }
                    
                    // Headers
                    const headerMatch = trimmedLine.match(/^(#{1,3}) (.+)$/);
                    if (headerMatch) {
                        closeAllLists();
                        const level = headerMatch[1].length;
                        html += `<h${level}>${processInline(escapeHtml(headerMatch[2]))}</h${level}>`;
                        continue;
                    }
                    
                    // Blockquotes
                    if (trimmedLine.startsWith('> ')) {
                        closeAllLists();
                        html += `<blockquote>${processInline(escapeHtml(trimmedLine.slice(2)))}</blockquote>`;
                        continue;
                    }
                    
                    // Checkbox items - [ ] or [x]
                    const checkboxMatch = trimmedLine.match(/^[\*\-] \[([ xX])\] (.*)$/);
                    if (checkboxMatch) {
                        const isChecked = checkboxMatch[1].toLowerCase() === 'x';
                        const checkboxText = checkboxMatch[2];
                        const lineIndex = i;
                        
                        // Close lists that are deeper than current indent
                        closeListsToIndent(indent + 1);
                        
                        // Open new list if needed
                        if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                            html += '<ul>';
                            listStack.push({ type: 'ul', indent: indent });
                        }
                        
                        html += `<li><span class="checkbox ${isChecked ? 'checked' : ''}" data-line="${lineIndex}"><span class="checkbox-box"></span><span class="checkbox-text">${processInline(escapeHtml(checkboxText))}</span></span></li>`;
                        continue;
                    }
                    
                    // Unordered list items
                    const ulMatch = trimmedLine.match(/^[\*\-] (.*)$/);
                    if (ulMatch) {
                        // Close lists that are deeper than current indent
                        closeListsToIndent(indent + 1);
                        
                        // Open new list if needed
                        if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                            html += '<ul>';
                            listStack.push({ type: 'ul', indent: indent });
                        }
                        
                        html += `<li>${processInline(escapeHtml(ulMatch[1]))}</li>`;
                        continue;
                    }
                    
                    // Ordered list items
                    const olMatch = trimmedLine.match(/^\d+\. (.*)$/);
                    if (olMatch) {
                        // Close lists that are deeper than current indent
                        closeListsToIndent(indent + 1);
                        
                        // Open new list if needed
                        if (listStack.length === 0 || listStack[listStack.length - 1].indent < indent) {
                            html += '<ol>';
                            listStack.push({ type: 'ol', indent: indent });
                        }
                        
                        html += `<li>${processInline(escapeHtml(olMatch[1]))}</li>`;
                        continue;
                    }
                    
                    // Regular paragraph text
                    closeAllLists();
                    html += `<p>${processInline(escapeHtml(trimmedLine))}</p>`;
                }
                
                // Close any remaining open lists
                closeAllLists();
                
                // Clean up consecutive <br> tags
                html = html.replace(/(<br>)+/g, '<br>');
                html = html.replace(/^<br>/, '');
                html = html.replace(/<br>$/, '');
                
                return html;
            }

            function setMode(mode) {
                data.mode = mode;
                if (mode === 'edit') {
                    textarea.style.display = '';
                    preview.style.display = 'none';
                    editBtn.classList.add('active');
                    previewBtn.classList.remove('active');
                } else {
                    preview.innerHTML = parseMarkdown(data.content);
                    textarea.style.display = 'none';
                    preview.style.display = '';
                    editBtn.classList.remove('active');
                    previewBtn.classList.add('active');
                    
                    // Add click handlers for checkboxes
                    preview.querySelectorAll('.checkbox').forEach(cb => {
                        cb.addEventListener('click', () => {
                            const lineIndex = parseInt(cb.dataset.line);
                            const lines = data.content.split('\n');
                            if (lineIndex >= 0 && lineIndex < lines.length) {
                                const line = lines[lineIndex];
                                // Toggle checkbox state
                                if (line.match(/^([ \t]*)[\*\-] \[ \]/)) {
                                    lines[lineIndex] = line.replace(/^([ \t]*[\*\-]) \[ \]/, '$1 [x]');
                                } else if (line.match(/^([ \t]*)[\*\-] \[[xX]\]/)) {
                                    lines[lineIndex] = line.replace(/^([ \t]*[\*\-]) \[[xX]\]/, '$1 [ ]');
                                }
                                data.content = lines.join('\n');
                                textarea.value = data.content;
                                updateWidgetData(widget.id, { content: data.content });
                                // Re-render preview
                                preview.innerHTML = parseMarkdown(data.content);
                                // Re-attach click handlers
                                setMode('preview');
                            }
                        });
                    });
                }
                updateWidgetData(widget.id, { mode: data.mode });
            }

            textarea.addEventListener('input', () => {
                data.content = textarea.value;
                updateWidgetData(widget.id, { content: data.content });
            });

            editBtn.addEventListener('click', () => setMode('edit'));
            previewBtn.addEventListener('click', () => setMode('preview'));

            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));

            // Initialize mode
            setMode(data.mode);

            return tile;
        }

        // Data Widget
        function createDataWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.data.size} data-widget`;
            tile.dataset.widgetId = widget.id;

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Data</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="data-controls">
                    <div class="data-row">
                        <button class="btn btn-small accent-add data-btn data-export" title="Export data">${icons.download}</button>
                        <button class="btn btn-small accent-add data-btn data-import" title="Import data">${icons.upload}</button>
                    </div>
                    <div class="data-row">
                        <button class="btn btn-small accent-reset data-btn data-arm" title="Arm delete">${icons.lock}</button>
                        <button class="btn btn-small accent-delete data-btn data-delete" title="Delete all" disabled>${icons.delete}</button>
                    </div>
                </div>
                <input type="file" class="data-file-input" accept=".json,application/json">
            `;

            const exportBtn = tile.querySelector('.data-export');
            const importBtn = tile.querySelector('.data-import');
            const armBtn = tile.querySelector('.data-arm');
            const deleteBtn = tile.querySelector('.data-delete');
            const fileInput = tile.querySelector('.data-file-input');
            let isArmed = false;

            // Export all data
            async function exportData() {
                // Save current state first to ensure we capture latest
                saveWidgets();
                
                const data = {
                    version: 1,
                    exportDate: new Date().toISOString(),
                    theme: localStorage.getItem('density-theme'),
                    // Exclude audio widgets - audio files are too large to export
                    widgets: widgets
                        .filter(w => w.type !== 'audio')
                        .map(w => ({
                            id: w.id,
                            type: w.type,
                            data: JSON.parse(JSON.stringify(w.data)) // Deep copy
                        }))
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `density-backup-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            // Import and merge data
            async function importData(file) {
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    if (!data.version) {
                        return;
                    }

                    // Merge theme (only if not set)
                    if (data.theme && !localStorage.getItem('density-theme')) {
                        localStorage.setItem('density-theme', data.theme);
                        applyTheme(data.theme);
                    }

                    // Merge widgets - preserve order from import
                    if (data.widgets && Array.isArray(data.widgets)) {
                        // Find max ID to avoid conflicts
                        let maxId = Math.max(0, ...widgets.map(w => w.id), widgetIdCounter);
                        const existingIds = new Set(widgets.map(w => w.id));
                        const hasDataWidget = widgets.some(w => w.type === 'data');
                        
                        // Add imported widgets in order, assigning new IDs only for conflicts
                        for (const importedWidget of data.widgets) {
                            // Skip data widget if we already have one
                            if (importedWidget.type === 'data' && hasDataWidget) {
                                continue;
                            }
                            
                            let newId = importedWidget.id;
                            if (existingIds.has(newId)) {
                                newId = ++maxId;
                            }
                            existingIds.add(newId);
                            // Deep copy the data to preserve all values
                            const widgetData = JSON.parse(JSON.stringify(importedWidget.data || {}));
                            addWidget(importedWidget.type, widgetData, newId);
                        }
                    }
                } catch (e) {
                    console.error('Import failed:', e);
                }
            }

            // Delete all data
            async function deleteAllData() {
                if (!isArmed) return;

                // Clear localStorage
                localStorage.removeItem('density-widgets');
                localStorage.removeItem('density-theme');

                // Clear audio IndexedDB
                try {
                    await clearAllAudio();
                } catch (e) {
                    console.error('Failed to delete audio storage:', e);
                }

                // Reset state and reload
                widgets = [];
                widgetIdCounter = 0;
                
                // Reload the page to reset everything
                location.reload();
            }

            // Toggle arm state
            function toggleArm() {
                isArmed = !isArmed;
                if (isArmed) {
                    armBtn.innerHTML = icons.unlock;
                    armBtn.classList.add('armed');
                    deleteBtn.disabled = false;
                    // Auto-disarm after 5 seconds
                    setTimeout(() => {
                        if (isArmed) {
                            isArmed = false;
                            armBtn.innerHTML = icons.lock;
                            armBtn.classList.remove('armed');
                            deleteBtn.disabled = true;
                        }
                    }, 5000);
                } else {
                    armBtn.innerHTML = icons.lock;
                    armBtn.classList.remove('armed');
                    deleteBtn.disabled = true;
                }
            }

            // Event listeners
            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));
            exportBtn.addEventListener('click', exportData);
            importBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    importData(e.target.files[0]);
                    e.target.value = '';
                }
            });
            armBtn.addEventListener('click', toggleArm);
            deleteBtn.addEventListener('click', deleteAllData);

            return tile;
        }

        // Theme Widget
        function createThemeWidget(widget) {
            const tile = document.createElement('div');
            tile.className = `tile size-${widgetTypes.theme.size} theme-widget`;
            tile.dataset.widgetId = widget.id;

            const currentTheme = localStorage.getItem('density-theme') || 'system';

            tile.innerHTML = `
                <div class="widget-header">
                    <span class="drag-handle" title="Drag to reorder">${icons.drag}</span>
                    <span class="widget-title">Theme</span>
                    <button class="btn btn-small accent-delete" title="Remove widget">${icons.close}</button>
                </div>
                <div class="theme-buttons">
                    <button class="btn theme-btn ${currentTheme === 'system' ? 'active' : ''}" data-theme="system" title="System">${icons.system}</button>
                    <button class="btn theme-btn ${currentTheme === 'light' ? 'active' : ''}" data-theme="light" title="Light">${icons.sun}</button>
                    <button class="btn theme-btn ${currentTheme === 'dark' ? 'active' : ''}" data-theme="dark" title="Dark">${icons.moon}</button>
                </div>
            `;

            tile.querySelector('.widget-header .btn').addEventListener('click', () => removeWidget(widget.id));
            tile.querySelectorAll('.theme-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyTheme(btn.dataset.theme);
                });
            });

            return tile;
        }

        // Drag and Drop for Widget Reordering
        function initDragAndDrop() {
            const grid = document.getElementById('widgetGrid');
            let draggedWidget = null;
            let draggedElement = null;
            let placeholder = null;
            let touchStartX = 0;
            let touchStartY = 0;
            let touchOffsetX = 0;
            let touchOffsetY = 0;
            let isDragging = false;

            function getWidgetElements() {
                return Array.from(grid.querySelectorAll('.tile[data-widget-id]'));
            }

            function createPlaceholder(element) {
                const ph = document.createElement('div');
                ph.className = element.className + ' drag-placeholder';
                ph.style.opacity = '0.4';
                ph.style.pointerEvents = 'none';
                ph.style.border = '2px dashed var(--accent-add)';
                ph.style.background = 'var(--button-hover)';
                return ph;
            }

            function getInsertPosition(x, y, exclude) {
                const elements = getWidgetElements().filter(el => el !== exclude);
                const addTile = grid.querySelector('.add-widget-tile');
                
                // Check each widget to find insertion point
                for (let i = 0; i < elements.length; i++) {
                    const el = elements[i];
                    const rect = el.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    // If cursor is in the left half or top half of element, insert before
                    if (y < rect.bottom && y >= rect.top) {
                        if (x < centerX) {
                            return { element: el, position: 'before' };
                        }
                    }
                    // If cursor is above this row
                    if (y < rect.top) {
                        return { element: el, position: 'before' };
                    }
                }
                
                // If we're past all elements, insert at end
                if (elements.length > 0) {
                    return { element: null, position: 'end' };
                }
                
                // Insert after add tile
                return { element: addTile, position: 'after' };
            }

            function handleDragStart(e, element) {
                // Don't drag the add-widget tile
                if (element.classList.contains('add-widget-tile')) return false;
                
                // Check if we clicked on an interactive element
                const target = e.target;
                if (target.closest('input, textarea, button, select, .timer-value, .audio-display')) {
                    return false;
                }

                // Only allow drag from header or drag handle
                if (!target.closest('.widget-header, .drag-handle')) {
                    return false;
                }

                draggedElement = element;
                draggedWidget = widgets.find(w => w.id === parseInt(element.dataset.widgetId));
                
                return true;
            }

            function startDragging(element, clientX, clientY) {
                isDragging = true;
                element.classList.add('dragging');
                
                const rect = element.getBoundingClientRect();
                touchOffsetX = clientX - rect.left;
                touchOffsetY = clientY - rect.top;
                
                // Create placeholder and insert where the element was
                placeholder = createPlaceholder(element);
                element.parentNode.insertBefore(placeholder, element);
                
                // Make element fixed for dragging
                element.style.position = 'fixed';
                element.style.left = rect.left + 'px';
                element.style.top = rect.top + 'px';
                element.style.width = rect.width + 'px';
                element.style.zIndex = '1000';
                element.style.pointerEvents = 'none';
            }

            function moveDragging(clientX, clientY) {
                if (!draggedElement || !isDragging) return;
                
                // Move the dragged element
                draggedElement.style.left = (clientX - touchOffsetX) + 'px';
                draggedElement.style.top = (clientY - touchOffsetY) + 'px';
                
                // Find where to show the placeholder
                const insertPos = getInsertPosition(clientX, clientY, draggedElement);
                
                if (insertPos.position === 'end') {
                    // Append to end of grid
                    grid.appendChild(placeholder);
                } else if (insertPos.element && insertPos.element !== placeholder) {
                    if (insertPos.position === 'before') {
                        insertPos.element.parentNode.insertBefore(placeholder, insertPos.element);
                    } else {
                        insertPos.element.parentNode.insertBefore(placeholder, insertPos.element.nextSibling);
                    }
                }
            }

            function endDragging(clientX, clientY) {
                if (!draggedElement || !isDragging) {
                    cleanup();
                    return;
                }
                
                // Reset styles
                draggedElement.classList.remove('dragging');
                draggedElement.style.position = '';
                draggedElement.style.left = '';
                draggedElement.style.top = '';
                draggedElement.style.width = '';
                draggedElement.style.zIndex = '';
                draggedElement.style.pointerEvents = '';
                
                // Insert the dragged element where the placeholder is
                if (placeholder && placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(draggedElement, placeholder);
                    
                    // Rebuild widgets array based on new DOM order
                    const newOrder = [];
                    getWidgetElements().forEach(el => {
                        const w = widgets.find(w => w.id === parseInt(el.dataset.widgetId));
                        if (w) newOrder.push(w);
                    });
                    widgets = newOrder;
                    saveWidgets();
                }
                
                cleanup();
            }

            function cleanup() {
                if (placeholder && placeholder.parentNode) {
                    placeholder.remove();
                }
                placeholder = null;
                draggedWidget = null;
                draggedElement = null;
                isDragging = false;
            }

            // Mouse events
            grid.addEventListener('mousedown', (e) => {
                const tile = e.target.closest('.tile[data-widget-id]');
                if (tile && handleDragStart(e, tile)) {
                    e.preventDefault();
                    touchStartX = e.clientX;
                    touchStartY = e.clientY;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!draggedElement) return;
                
                if (!isDragging) {
                    const dx = Math.abs(e.clientX - touchStartX);
                    const dy = Math.abs(e.clientY - touchStartY);
                    if (dx > 5 || dy > 5) {
                        startDragging(draggedElement, touchStartX, touchStartY);
                    }
                }
                
                if (isDragging) {
                    e.preventDefault();
                    moveDragging(e.clientX, e.clientY);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (draggedElement) {
                    endDragging(e.clientX, e.clientY);
                }
            });

            // Touch events
            grid.addEventListener('touchstart', (e) => {
                const tile = e.target.closest('.tile[data-widget-id]');
                if (tile && handleDragStart(e, tile)) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!draggedElement) return;
                
                const touch = e.touches[0];
                
                if (!isDragging) {
                    const dx = Math.abs(touch.clientX - touchStartX);
                    const dy = Math.abs(touch.clientY - touchStartY);
                    if (dx > 10 || dy > 10) {
                        startDragging(draggedElement, touchStartX, touchStartY);
                    }
                }
                
                if (isDragging) {
                    e.preventDefault();
                    moveDragging(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (draggedElement) {
                    const touch = e.changedTouches[0];
                    endDragging(touch.clientX, touch.clientY);
                }
            });

            document.addEventListener('touchcancel', () => {
                if (draggedElement) {
                    cleanup();
                }
            });
        }

        // Initialize
        function init() {
            initTheme();
            const grid = document.getElementById('widgetGrid');
            grid.appendChild(createAddWidgetTile());
            loadWidgets();
            initDragAndDrop();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>

    <script src="parental.js" defer></script>
    <script src="assets/js/pwa.js" defer></script>
</body>
</html>
