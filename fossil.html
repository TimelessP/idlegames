<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fossil Hunter - Archaeological Discovery Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #8B4513, #D2691E, #F4A460);
            color: white;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        .game-header {
            background: rgba(0,0,0,0.4);
            box-shadow: 0 1px 5px rgba(0,0,0,0.3);
            padding: 8px 12px;
            position: relative;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 100%;
            gap: 15px;
        }

        .game-title {
            font-size: 1.3em;
            color: #ffd700;
            font-weight: bold;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .header-stats {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 4px 8px;
            min-width: 0;
        }

        .stat-label {
            font-size: 0.75em;
            color: #ccc;
            white-space: nowrap;
        }

        .stat-value {
            font-size: 0.9em;
            font-weight: bold;
            color: #ffd700;
            white-space: nowrap;
        }

        .header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .header-btn {
            background: linear-gradient(145deg, #8B4513, #A0522D);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: bold;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .header-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }

        .game-area {
            flex: 1;
            position: relative;
            background: linear-gradient(145deg, #8B4513, #A0522D);
            border: 4px solid #654321;
            border-radius: 15px;
            margin: 8px;
            padding: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Responsive layout - auto-fit to viewport */
        .game-header {
            flex-shrink: 0;
        }
        
        .game-area {
            flex: 1;
            min-height: 0; /* Allow flexbox to shrink */
        }
        
        /* Mobile landscape adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            .game-area {
                margin: 4px;
            }
            .header-content {
                gap: 8px;
            }
        }
        
        /* Responsive fossil sizing */
        #fossilCanvas {
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: calc(100vh - 80px);
            object-fit: contain;
        }

        #fossilCanvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            cursor: crosshair;
            background: #D2B48C;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        }

        .tool-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 50;
        }

        .tool-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .tool-label {
            font-size: 0.8em;
            color: #ffd700;
            font-weight: bold;
        }

        .brush-controls {
            display: flex;
            gap: 5px;
        }

        .brush-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            border: 2px solid #ffd700;
            background: linear-gradient(145deg, #8B4513, #A0522D);
            color: white;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .brush-btn.active {
            background: linear-gradient(145deg, #ffd700, #ffed4e);
            color: #654321;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .brush-btn:hover {
            transform: scale(1.1);
        }

        .size-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 5px;
            border-radius: 5px;
            background: #654321;
            outline: none;
        }

        .size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }

        .size-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            border: none;
        }

        .progress-panel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            z-index: 50;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #654321;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.9em;
            text-align: center;
            color: #ffd700;
        }

        .fossil-info {
            margin-top: 10px;
            font-size: 0.8em;
            color: #ccc;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .fossil-info.visible {
            opacity: 1;
        }

        /* Particle effects */
        .sand-particle {
            position: absolute;
            background: #C19A6B; /* Slightly darker sand color for better visibility */
            border-radius: 50%;
            pointer-events: none;
            z-index: 30;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3); /* Add subtle shadow */
        }

        /* Discovery celebration overlay */
        .discovery-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            animation: fadeIn 0.5s ease-out;
        }

        .discovery-overlay.show {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .discovery-panel {
            background: linear-gradient(145deg, #1a5c3a, #0d4f3c);
            border: 4px solid #ffd700;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            max-width: 80%;
            min-width: 300px;
            box-shadow: 
                0 0 0 3px rgba(255, 215, 0, 0.3),
                0 10px 40px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: celebrationBounce 0.6s ease-out;
        }

        @keyframes celebrationBounce {
            0% { 
                transform: scale(0.3) rotate(-5deg);
                opacity: 0;
            }
            50% { 
                transform: scale(1.05) rotate(2deg);
            }
            100% { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .discovery-title {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .discovery-fossil {
            font-size: 4em;
            margin: 20px 0;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
        }

        .discovery-name {
            font-size: 1.5em;
            color: #4CAF50;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .discovery-description {
            color: #ccc;
            margin-bottom: 25px;
            line-height: 1.4;
        }

        .discovery-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .discovery-btn {
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .discovery-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .discovery-btn.secondary {
            background: linear-gradient(145deg, #8B4513, #A0522D);
        }

        .discovery-btn.secondary:hover {
            box-shadow: 0 4px 12px rgba(139, 69, 19, 0.4);
        }

        /* Dig Collapse Overlay */
        .collapse-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(139, 69, 19, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
            animation: fadeIn 0.5s ease-out;
        }

        .collapse-overlay.show {
            display: flex;
        }

        .collapse-panel {
            background: linear-gradient(145deg, #654321, #8B4513);
            border: 4px solid #D2691E;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            max-width: 80%;
            min-width: 300px;
            box-shadow: 
                0 0 0 3px rgba(210, 105, 30, 0.3),
                0 10px 40px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: emergencyShake 0.6s ease-out;
        }

        @keyframes emergencyShake {
            0% { 
                transform: scale(0.3) rotate(-5deg);
                opacity: 0;
            }
            20% { 
                transform: scale(1.05) rotate(2deg);
            }
            40% { 
                transform: scale(0.95) rotate(-1deg);
            }
            60% { 
                transform: scale(1.02) rotate(1deg);
            }
            80% { 
                transform: scale(0.98) rotate(-0.5deg);
            }
            100% { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .collapse-title {
            font-size: 1.8em;
            color: #ff6b35;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .collapse-icon {
            font-size: 3em;
            margin: 15px 0;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .collapse-message {
            color: #ffd700;
            margin-bottom: 25px;
            line-height: 1.4;
            font-size: 1.1em;
        }

        .collapse-submessage {
            color: #ccc;
            margin-bottom: 25px;
            line-height: 1.4;
            font-size: 0.9em;
        }

        .collapse-btn {
            background: linear-gradient(145deg, #D2691E, #B8860B);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .collapse-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(210, 105, 30, 0.4);
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .tool-panel {
                top: 10px;
                right: 10px;
                padding: 10px;
            }

            .brush-btn {
                width: 30px;
                height: 30px;
                font-size: 0.7em;
            }

            .size-slider {
                width: 80px;
            }

            .progress-panel {
                bottom: 10px;
                left: 10px;
                min-width: 150px;
                padding: 10px;
            }

            #fossilCanvas {
                cursor: pointer;
            }
        }

        /* Touch optimization */
        .brush-btn, .header-btn {
            min-height: 44px;
            -webkit-tap-highlight-color: rgba(255, 215, 0, 0.3);
        }

        .brush-btn:disabled, .header-btn:disabled {
            cursor: not-allowed;
            background: #666 !important;
            color: #999 !important;
            border-color: #555 !important;
            transform: none !important;
            box-shadow: none !important;
        }

        @media (max-width: 480px) {
            .brush-btn, .header-btn {
                min-height: 48px;
            }
            
            .collapse-panel {
                padding: 20px;
                min-width: 250px;
            }
            
            .collapse-title {
                font-size: 1.5em;
            }
            
            .collapse-icon {
                font-size: 2.5em;
            }
        }
    </style>
</head>
<body>
    <header class="game-header">
        <div class="header-content">
            <div class="game-title">🦴 Fossil Hunter ⛏️</div>
            <div class="header-controls">
                <button class="header-btn" onclick="newFossil()">New Dig</button>
                <button class="header-btn" onclick="resetProgress()">Reset</button>
            </div>
        </div>
    </header>

    <main class="game-area">
        <canvas id="fossilCanvas"></canvas>
        
        <!-- Discovery Celebration Overlay -->
        <div class="discovery-overlay" id="discovery-overlay">
            <div class="discovery-panel">
                <div class="discovery-title">🎉 Discovery Complete! 🎉</div>
                <div class="discovery-fossil" id="discovery-emoji"></div>
                <div class="discovery-name" id="discovery-name"></div>
                <div class="discovery-description" id="discovery-description"></div>
                <div class="discovery-buttons">
                    <button class="discovery-btn" onclick="continueDigging()">New Dig Site</button>
                    <button class="discovery-btn secondary" onclick="admireDiscovery()">Admire Find</button>
                </div>
            </div>
        </div>
        
        <!-- Dig Site Collapse Overlay -->
        <div class="collapse-overlay" id="collapse-overlay">
            <div class="collapse-panel">
                <div class="collapse-title">⚠️ Dig Site Collapse! ⚠️</div>
                <div class="collapse-icon">🏗️</div>
                <div class="collapse-message">
                    The excavation site has collapsed due to shifting ground conditions!
                </div>
                <div class="collapse-submessage">
                    Environmental changes have destabilized the dig area. We need to establish a new site with proper measurements.
                </div>
                <button class="collapse-btn" onclick="restartDigSite()">🔧 Establish New Site</button>
            </div>
        </div>
        
        <div class="tool-panel">
            <div class="tool-section">
                <div class="tool-label">Brush Type</div>
                <div class="brush-controls">
                    <button class="brush-btn active" data-brush="soft" title="Soft Brush">🖌️</button>
                    <button class="brush-btn" data-brush="medium" title="Medium Brush">🖍️</button>
                    <button class="brush-btn" data-brush="fine" title="Fine Brush">✏️</button>
                </div>
            </div>
            
            <div class="tool-section">
                <div class="tool-label">Brush Size</div>
                <input type="range" class="size-slider" id="brushSize" min="5" max="50" value="20">
            </div>
        </div>

        <div class="progress-panel">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">0% Revealed</div>
            <div class="fossil-info" id="fossilInfo">
                Carefully brush away the sand to reveal the ancient fossil beneath...
            </div>
        </div>
    </main>

    <script>
        // Game state
    let canvas, ctx;
    let currentFossilData = null;
    let currentFossilSeed = null;
        let fossilsDiscovered = 0;
        let revealProgress = 0;
        let isDrawing = false;
        let currentBrushType = 'soft';
    let brushSize = 20;
    let fossilGenerator;

        // Canvas layers
        let fossilCanvas, sandCanvas;
        let fossilCtx, sandCtx;

        // Touch handling
        let lastTouchX = 0;
        let lastTouchY = 0;
        
        // Performance throttling
        let lastBrushTime = 0;
        let lastProgressUpdate = 0;
        const BRUSH_THROTTLE_MS = 16; // ~60fps limit
        const PROGRESS_UPDATE_MS = 100; // Update progress less frequently

        // Resize handling
        let resizeTimeout;
        let gameActive = true;
        let lastWindowWidth = window.innerWidth;
        let lastWindowHeight = window.innerHeight;

        // Funny dig site failure reasons
        const digFailureReasons = [
            {
                title: "⚠️ Underground Gopher Convention! ⚠️",
                message: "A massive gopher gathering has destabilized the dig site!",
                submessage: "The local gopher union has called an emergency meeting directly beneath your excavation. We must respect their territorial rights.",
                icon: "🐹"
            },
            {
                title: "⚠️ Dinosaur Sneeze Detected! ⚠️", 
                message: "Seismic readings indicate a prehistoric sneeze!",
                submessage: "Our equipment has detected what can only be described as a T-Rex sized achoo from deep underground. Safety protocols require immediate evacuation.",
                icon: "🤧"
            },
            {
                title: "⚠️ Time Portal Malfunction! ⚠️",
                message: "Temporal interference has compromised the dig site!",
                submessage: "A small time vortex has opened up, causing the soil layers to shift between geological periods. We need to recalibrate our chronometers.",
                icon: "🌀"
            },
            {
                title: "⚠️ Underground Wi-Fi Outage! ⚠️",
                message: "The mole internet has gone down!",
                submessage: "Critical infrastructure failure in the subterranean communication network. Even our most sophisticated digging equipment requires a stable connection.",
                icon: "📶"
            },
            {
                title: "⚠️ Fossil Union Strike! ⚠️",
                message: "The ancient specimens have organized!",
                submessage: "Local fossils are demanding better working conditions and dental coverage. Negotiations are ongoing with their prehistoric representatives.",
                icon: "🪧"
            },
            {
                title: "⚠️ Unexpected Tea Break! ⚠️",
                message: "The dig site has declared mandatory teatime!",
                submessage: "British archaeological protocols require a proper tea break every 4 hours. The soil itself has become too civilized to continue without refreshments.",
                icon: "☕"
            },
            {
                title: "⚠️ Meteor Shower Alert! ⚠️",
                message: "Space rocks are incoming!",
                submessage: "A small meteor shower is predicted to impact the area. While exciting for future paleontologists, it's rather inconvenient for current ones.",
                icon: "☄️"
            },
            {
                title: "⚠️ Dragon Territorial Dispute! ⚠️",
                message: "An ancient dragon has filed a property claim!",
                submessage: "Legal documents from the Cretaceous period have surfaced, indicating this land belongs to a very old and very grumpy dragon. Best not to argue.",
                icon: "🐲"
            },
            {
                title: "⚠️ Caffeine Shortage Crisis! ⚠️",
                message: "The archaeological team has run out of coffee!",
                submessage: "No serious excavation can proceed without adequate caffeine levels. The dig site has been declared unsafe until a coffee supply run is completed.",
                icon: "☕"
            },
            {
                title: "⚠️ Spontaneous Quicksand! ⚠️",
                message: "The ground has become unexpectedly wiggly!",
                submessage: "Geological surveys indicate the soil has developed a mind of its own and is now doing the archaeological equivalent of the cha-cha. Safety first!",
                icon: "🌊"
            }
        ];

        // Procedural fossil generator responsible for seeded bone layouts
        class ProceduralFossilGenerator {
            constructor() {
                this.dinosaurNames = [
                    'Tyrannosaurus', 'Triceratops', 'Velociraptor', 'Stegosaurus', 'Brachiosaurus',
                    'Allosaurus', 'Ankylosaurus', 'Spinosaurus', 'Pachycephalosaurus', 'Parasaurolophus',
                    'Iguanodon', 'Giganotosaurus', 'Dilophosaurus', 'Carnotaurus', 'Compsognathus',
                    'Megaraptor', 'Utahraptor', 'Therizinosaurus', 'Gallimimus', 'Hadrosaurus',
                    'Corythosaurus', 'Albertosaurus', 'Deinonychus', 'Troodon', 'Plateosaurus',
                    'Sauropelta', 'Microraptor', 'Maiasaura', 'Stygimoloch', 'Camarasaurus'
                ];
                this.templates = this.createTemplates();
                this.boneIdCounter = 0;
                this.baseScale = 1;
                this.activeBones = [];
                this.boneMap = new Map();
            }

            generate(seed, ctx, width, height) {
                this.boneIdCounter = 0;
                this.baseScale = this.computeBaseScale(width, height);
                this.activeBones = [];
                this.boneMap = new Map();

                const rng = this.createRng(seed);
                const dinosaurName = this.pickDinosaurName(rng);
                const plan = this.buildSkeleton(rng, width, height);

                // Scale and center the fossil to fit the canvas before rendering
                this.scaleFossilToFit(plan.bones, width, height);

                this.renderBackground(ctx, width, height);
                this.renderBones(ctx, plan.bones);
                this.applyWeathering(ctx, rng, width, height);

                const description = this.describeFind(dinosaurName, plan);

                return {
                    name: dinosaurName,
                    description,
                    completeness: plan.completeness,
                    hint: plan.hint,
                    features: plan.featureSummary
                };
            }

            createRng(seed) {
                let state = seed >>> 0;
                return {
                    next() {
                        state = (state + 0x6D2B79F5) | 0;
                        let t = Math.imul(state ^ state >>> 15, 1 | state);
                        t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
                        return ((t ^ t >>> 14) >>> 0) / 4294967296;
                    },
                    range(min, max) {
                        return min + (max - min) * this.next();
                    },
                    int(min, max) {
                        return Math.floor(this.range(min, max + 1));
                    },
                    pick(collection) {
                        return collection[Math.floor(this.next() * collection.length)];
                    },
                    chance(probability) {
                        return this.next() < probability;
                    }
                };
            }

            computeBaseScale(width, height) {
                return Math.min(width, height) / 520;
            }

            pickDinosaurName(rng) {
                return rng.pick(this.dinosaurNames);
            }

            createTemplates() {
                const baseStroke = 'rgba(108, 82, 54, 0.9)';
                return {
                    skull: [
                        {
                            variant: 'standard',
                            weight: 1,
                            origin: { x: 60, y: 50 },
                            path: 'M12,58 C12,36 18,20 32,12 C46,4 64,6 82,14 C96,20 108,32 112,46 C116,62 114,76 104,86 C94,96 76,98 60,94 C44,90 28,82 20,68 C14,58 12,48 12,58 Z',
                            holes: [
                                { path: 'M46,42 C46,36 50,32 56,32 C62,32 66,36 66,42 C66,48 62,52 56,52 C50,52 46,48 46,42 Z', alpha: 1 }
                            ],
                            details: [
                                { path: 'M52,72 C58,70 66,68 74,70 C78,71 82,74 84,78', stroke: 'rgba(255, 240, 210, 0.5)', lineWidth: 3 },
                                { path: 'M32,34 C36,28 42,24 48,22', stroke: 'rgba(180, 150, 110, 0.4)', lineWidth: 2 }
                            ],
                            connectors: [
                                { name: 'neck', position: { x: 118, y: 54 }, angle: 2, angleVariance: 10 }
                            ],
                            gradient: {
                                from: { x: 28, y: 20 },
                                to: { x: 88, y: 90 },
                                stops: [
                                    { offset: 0, color: 'rgba(250, 240, 214, 0.95)' },
                                    { offset: 0.5, color: 'rgba(232, 210, 172, 0.95)' },
                                    { offset: 1, color: 'rgba(192, 160, 120, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 5,
                            scaleRange: { min: 2.0, max: 2.4 },
                            layer: 4
                        }
                    ],
                    cervical: [
                        {
                            variant: 'compact',
                            weight: 1,
                            origin: { x: 50, y: 32 },
                            path: 'M8,30 L12,24 C16,20 22,16 30,16 L70,16 C78,16 84,20 88,24 L92,30 C94,34 94,38 92,42 L88,48 C84,52 78,56 70,56 L30,56 C22,56 16,52 12,48 L8,42 C6,38 6,34 8,30 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 0, y: 36 }, angle: 180, angleVariance: 9 },
                                { name: 'distal', position: { x: 100, y: 36 }, angle: 0, angleVariance: 9 }
                            ],
                            gradient: {
                                from: { x: 20, y: 20 },
                                to: { x: 80, y: 52 },
                                stops: [
                                    { offset: 0, color: 'rgba(244, 229, 198, 0.95)' },
                                    { offset: 0.5, color: 'rgba(218, 194, 158, 0.95)' },
                                    { offset: 1, color: 'rgba(176, 142, 104, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.5, max: 0.7 },
                            layer: 3
                        },
                        {
                            variant: 'elongated',
                            weight: 0.75,
                            origin: { x: 70, y: 36 },
                            path: 'M6,32 L12,24 C18,18 28,14 40,14 L100,14 C112,14 122,18 128,24 L134,32 C138,38 138,44 136,50 L130,58 C124,64 114,68 102,68 L38,68 C26,68 16,64 10,58 L4,50 C2,44 2,38 6,32 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 0, y: 41 }, angle: 180, angleVariance: 10 },
                                { name: 'distal', position: { x: 140, y: 41 }, angle: 0, angleVariance: 10 }
                            ],
                            gradient: {
                                from: { x: 24, y: 18 },
                                to: { x: 116, y: 64 },
                                stops: [
                                    { offset: 0, color: 'rgba(246, 230, 198, 0.95)' },
                                    { offset: 0.5, color: 'rgba(218, 194, 156, 0.94)' },
                                    { offset: 1, color: 'rgba(174, 138, 102, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.55, max: 0.75 },
                            layer: 3
                        }
                    ],
                    thoracic: [
                        {
                            variant: 'compact',
                            weight: 1,
                            origin: { x: 54, y: 40 },
                            path: 'M6,36 L10,28 C14,22 22,18 32,16 L76,16 C86,18 94,22 98,28 L102,36 C106,42 106,48 104,54 L100,62 C96,68 88,72 78,74 L30,74 C20,72 12,68 8,62 L4,54 C2,48 2,42 6,36 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 0, y: 45 }, angle: 180, angleVariance: 8 },
                                { name: 'distal', position: { x: 108, y: 45 }, angle: 0, angleVariance: 8 },
                                { name: 'ribLeft', position: { x: 28, y: 10 }, angle: 90, angleVariance: 12 },
                                { name: 'ribRight', position: { x: 80, y: 10 }, angle: 90, angleVariance: 12 },
                                { name: 'limbLeft', position: { x: 24, y: 80 }, angle: 90, angleVariance: 15 },
                                { name: 'limbRight', position: { x: 84, y: 80 }, angle: 90, angleVariance: 15 }
                            ],
                            gradient: {
                                from: { x: 18, y: 20 },
                                to: { x: 90, y: 70 },
                                stops: [
                                    { offset: 0, color: 'rgba(243, 225, 194, 0.9)' },
                                    { offset: 0.55, color: 'rgba(212, 186, 148, 0.92)' },
                                    { offset: 1, color: 'rgba(170, 136, 102, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.52, max: 0.72 },
                            layer: 2
                        },
                        {
                            variant: 'arching',
                            weight: 0.8,
                            origin: { x: 78, y: 50 },
                            path: 'M4,46 L10,34 C16,26 28,20 42,18 L114,18 C128,20 140,26 146,34 L152,46 C156,54 156,62 154,70 L148,82 C142,90 130,96 116,98 L40,98 C26,96 14,90 8,82 L2,70 C0,62 0,54 4,46 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 0, y: 58 }, angle: 180, angleVariance: 9 },
                                { name: 'distal', position: { x: 156, y: 58 }, angle: 0, angleVariance: 10 },
                                { name: 'ribLeft', position: { x: 36, y: 12 }, angle: 90, angleVariance: 14 },
                                { name: 'ribRight', position: { x: 120, y: 12 }, angle: 90, angleVariance: 14 },
                                { name: 'limbLeft', position: { x: 30, y: 104 }, angle: 90, angleVariance: 18 },
                                { name: 'limbRight', position: { x: 126, y: 104 }, angle: 90, angleVariance: 18 }
                            ],
                            gradient: {
                                from: { x: 22, y: 22 },
                                to: { x: 134, y: 94 },
                                stops: [
                                    { offset: 0, color: 'rgba(240, 221, 192, 0.9)' },
                                    { offset: 0.55, color: 'rgba(208, 180, 142, 0.92)' },
                                    { offset: 1, color: 'rgba(168, 134, 102, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.58, max: 0.78 },
                            layer: 2
                        }
                    ],
                    tail: [
                        {
                            variant: 'compact',
                            weight: 1,
                            origin: { x: 42, y: 30 },
                            path: 'M8,26 L12,20 C16,16 22,12 30,10 L54,10 C62,12 68,16 72,20 L76,26 C80,32 80,38 78,44 L74,50 C70,56 64,60 56,62 L28,62 C20,60 14,56 10,50 L6,44 C4,38 4,32 8,26 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 0, y: 36 }, angle: 180, angleVariance: 10 },
                                { name: 'distal', position: { x: 84, y: 36 }, angle: 0, angleVariance: 14 }
                            ],
                            gradient: {
                                from: { x: 14, y: 14 },
                                to: { x: 70, y: 58 },
                                stops: [
                                    { offset: 0, color: 'rgba(238, 219, 186, 0.9)' },
                                    { offset: 0.6, color: 'rgba(206, 178, 140, 0.92)' },
                                    { offset: 1, color: 'rgba(164, 130, 98, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.45, max: 0.65 },
                            layer: 2
                        },
                        {
                            variant: 'tapered',
                            weight: 0.85,
                            origin: { x: 56, y: 36 },
                            path: 'M6,32 L12,22 C18,16 28,10 40,8 L72,8 C84,10 94,16 100,22 L106,32 C112,42 112,52 108,62 L102,72 C96,80 86,86 74,88 L38,88 C26,86 16,80 10,72 L4,62 C0,52 0,42 6,32 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 0, y: 48 }, angle: 184, angleVariance: 12 },
                                { name: 'distal', position: { x: 112, y: 48 }, angle: -4, angleVariance: 16 }
                            ],
                            gradient: {
                                from: { x: 24, y: 12 },
                                to: { x: 88, y: 84 },
                                stops: [
                                    { offset: 0, color: 'rgba(238, 220, 192, 0.9)' },
                                    { offset: 0.55, color: 'rgba(206, 178, 142, 0.92)' },
                                    { offset: 1, color: 'rgba(162, 124, 96, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.5, max: 0.7 },
                            layer: 2
                        }
                    ],
                    rib: [
                        {
                            variant: 'broad',
                            weight: 1,
                            origin: { x: 32, y: 40 },
                            path: 'M20,28 C26,18 40,12 58,10 C78,8 98,12 114,22 C126,30 134,42 136,56 C138,70 132,84 118,94 C102,106 80,110 60,106 C42,102 28,90 20,74 C14,62 14,42 20,28 Z',
                            holes: [
                                { path: 'M34,38 C38,30 50,26 64,26 C78,26 92,30 102,38 C110,44 114,52 114,62 C114,72 108,82 96,88 C84,94 68,96 54,92 C42,88 34,78 32,66 C30,56 30,46 34,38 Z', alpha: 1 }
                            ],
                            connectors: [
                                { name: 'spine', position: { x: 18, y: 44 }, angle: 140, angleVariance: 18 }
                            ],
                            gradient: {
                                from: { x: 18, y: 14 },
                                to: { x: 70, y: 86 },
                                stops: [
                                    { offset: 0, color: 'rgba(240, 222, 194, 0.85)' },
                                    { offset: 0.5, color: 'rgba(204, 170, 132, 0.88)' },
                                    { offset: 1, color: 'rgba(156, 120, 90, 0.92)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.38, max: 0.55 },
                            layer: 1
                        },
                        {
                            variant: 'sweep',
                            weight: 0.6,
                            origin: { x: 52, y: 44 },
                            path: 'M18,24 C24,12 42,4 64,2 C88,0 112,4 134,14 C154,24 168,40 174,58 C180,76 176,96 162,112 C146,130 124,140 100,142 C76,144 52,136 34,120 C20,108 12,90 10,70 C8,52 10,36 18,24 Z',
                            holes: [
                                { path: 'M36,40 C40,30 54,22 72,20 C90,18 108,22 122,32 C134,40 142,52 144,66 C146,80 140,94 128,104 C114,116 96,122 78,120 C62,118 48,108 40,94 C34,84 32,70 32,58 C32,48 34,44 36,40 Z', alpha: 1 }
                            ],
                            connectors: [
                                { name: 'spine', position: { x: 16, y: 46 }, angle: 145, angleVariance: 16 }
                            ],
                            gradient: {
                                from: { x: 26, y: 12 },
                                to: { x: 108, y: 96 },
                                stops: [
                                    { offset: 0, color: 'rgba(240, 224, 196, 0.82)' },
                                    { offset: 0.55, color: 'rgba(204, 172, 138, 0.86)' },
                                    { offset: 1, color: 'rgba(158, 124, 96, 0.9)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.38, max: 0.52 },
                            layer: 1
                        }
                    ],
                    shoulder: [
                        {
                            variant: 'standard',
                            weight: 1,
                            origin: { x: 36, y: 40 },
                            path: 'M12,36 C12,24 18,14 28,8 C38,2 50,2 60,8 C68,14 74,22 76,32 C78,44 74,56 66,64 C58,72 46,78 34,76 C24,74 16,68 14,58 C12,50 12,44 12,36 Z',
                            connectors: [
                                { name: 'spine', position: { x: 6, y: 40 }, angle: 180, angleVariance: 15 },
                                { name: 'limb', position: { x: 80, y: 48 }, angle: 0, angleVariance: 20 }
                            ],
                            gradient: {
                                from: { x: 18, y: 10 },
                                to: { x: 66, y: 72 },
                                stops: [
                                    { offset: 0, color: 'rgba(244, 226, 198, 0.9)' },
                                    { offset: 0.6, color: 'rgba(210, 180, 144, 0.92)' },
                                    { offset: 1, color: 'rgba(170, 134, 102, 0.94)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.7, max: 0.9 },
                            layer: 3
                        }
                    ],
                    hip: [
                        {
                            variant: 'standard',
                            weight: 1,
                            origin: { x: 38, y: 44 },
                            path: 'M10,40 C10,28 16,16 28,10 C40,4 54,4 66,10 C76,16 84,26 86,38 C88,52 84,66 74,76 C64,86 50,92 36,90 C24,88 14,80 12,68 C10,58 10,48 10,40 Z',
                            connectors: [
                                { name: 'spine', position: { x: 4, y: 44 }, angle: 180, angleVariance: 14 },
                                { name: 'limb', position: { x: 90, y: 58 }, angle: 0, angleVariance: 22 }
                            ],
                            gradient: {
                                from: { x: 16, y: 12 },
                                to: { x: 72, y: 82 },
                                stops: [
                                    { offset: 0, color: 'rgba(242, 224, 194, 0.9)' },
                                    { offset: 0.55, color: 'rgba(205, 174, 138, 0.92)' },
                                    { offset: 1, color: 'rgba(166, 128, 98, 0.95)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.8, max: 1.0 },
                            layer: 3
                        }
                    ],
                    limbUpper: [
                        {
                            variant: 'compact',
                            weight: 1,
                            origin: { x: 28, y: 48 },
                            path: 'M22,8 L30,6 C36,6 40,8 42,12 L46,16 C48,20 48,24 48,28 L48,68 C48,72 48,76 46,80 L42,84 C40,88 36,90 30,90 L22,88 C16,88 12,86 10,82 L6,78 C4,74 4,70 4,66 L4,30 C4,26 4,22 6,18 L10,14 C12,10 16,8 22,8 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 26, y: -2 }, angle: -90, angleVariance: 18 },
                                { name: 'distal', position: { x: 26, y: 96 }, angle: 90, angleVariance: 20 }
                            ],
                            gradient: {
                                from: { x: 18, y: 16 },
                                to: { x: 54, y: 86 },
                                stops: [
                                    { offset: 0, color: 'rgba(246, 228, 198, 0.88)' },
                                    { offset: 0.55, color: 'rgba(210, 178, 142, 0.9)' },
                                    { offset: 1, color: 'rgba(172, 134, 102, 0.92)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.7, max: 0.9 },
                            layer: 3
                        },
                        {
                            variant: 'extended',
                            weight: 0.7,
                            origin: { x: 46, y: 66 },
                            path: 'M28,10 L38,8 C46,8 52,10 54,14 L60,20 C62,24 62,28 62,32 L62,100 C62,104 62,108 60,112 L54,118 C52,122 46,124 38,124 L28,122 C20,122 14,120 12,116 L6,110 C4,106 4,102 4,98 L4,34 C4,30 4,26 6,22 L12,16 C14,12 20,10 28,10 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 33, y: 2 }, angle: -90, angleVariance: 18 },
                                { name: 'distal', position: { x: 33, y: 132 }, angle: 90, angleVariance: 22 }
                            ],
                            gradient: {
                                from: { x: 24, y: 20 },
                                to: { x: 88, y: 112 },
                                stops: [
                                    { offset: 0, color: 'rgba(244, 226, 198, 0.88)' },
                                    { offset: 0.55, color: 'rgba(212, 180, 144, 0.9)' },
                                    { offset: 1, color: 'rgba(172, 136, 104, 0.92)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.75, max: 0.95 },
                            layer: 3
                        }
                    ],
                    limbLower: [
                        {
                            variant: 'compact',
                            weight: 1,
                            origin: { x: 28, y: 52 },
                            path: 'M22,6 L30,4 C36,4 40,6 42,10 L46,14 C48,18 48,22 48,26 L48,78 C48,82 48,86 46,90 L42,94 C40,98 36,100 30,100 L22,98 C16,98 12,96 10,92 L6,88 C4,84 4,80 4,76 L4,28 C4,24 4,20 6,16 L10,12 C12,8 16,6 22,6 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 26, y: -2 }, angle: -90, angleVariance: 16 },
                                { name: 'distal', position: { x: 26, y: 106 }, angle: 90, angleVariance: 22 }
                            ],
                            gradient: {
                                from: { x: 18, y: 18 },
                                to: { x: 56, y: 92 },
                                stops: [
                                    { offset: 0, color: 'rgba(244, 224, 196, 0.88)' },
                                    { offset: 0.5, color: 'rgba(206, 172, 138, 0.9)' },
                                    { offset: 1, color: 'rgba(164, 126, 94, 0.92)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.7, max: 0.9 },
                            layer: 3
                        },
                        {
                            variant: 'extended',
                            weight: 0.7,
                            origin: { x: 46, y: 74 },
                            path: 'M28,8 L38,6 C46,6 52,8 54,12 L60,18 C62,22 62,26 62,30 L62,118 C62,122 62,126 60,130 L54,136 C52,140 46,142 38,142 L28,140 C20,140 14,138 12,134 L6,128 C4,124 4,120 4,116 L4,32 C4,28 4,24 6,20 L12,14 C14,10 20,8 28,8 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 33, y: 0 }, angle: -90, angleVariance: 18 },
                                { name: 'distal', position: { x: 33, y: 148 }, angle: 90, angleVariance: 24 }
                            ],
                            gradient: {
                                from: { x: 26, y: 24 },
                                to: { x: 88, y: 126 },
                                stops: [
                                    { offset: 0, color: 'rgba(244, 224, 198, 0.88)' },
                                    { offset: 0.55, color: 'rgba(206, 176, 144, 0.9)' },
                                    { offset: 1, color: 'rgba(166, 130, 98, 0.92)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 3,
                            scaleRange: { min: 0.75, max: 0.95 },
                            layer: 3
                        }
                    ],
                    claw: [
                        {
                            variant: 'curved',
                            weight: 0.7,
                            origin: { x: 16, y: 56 },
                            path: 'M18,58 L24,50 L28,44 L30,38 C32,30 34,20 32,12 C30,6 26,4 22,6 C18,8 16,14 16,20 L14,32 L12,44 L10,54 C9,58 12,60 16,60 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 16, y: 62 }, angle: 90, angleVariance: 18 }
                            ],
                            gradient: {
                                from: { x: 22, y: 8 },
                                to: { x: 12, y: 58 },
                                stops: [
                                    { offset: 0, color: 'rgba(255, 245, 225, 0.88)' },
                                    { offset: 0.5, color: 'rgba(220, 192, 160, 0.9)' },
                                    { offset: 1, color: 'rgba(180, 148, 118, 0.93)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 2.5,
                            scaleRange: { min: 0.7, max: 1.0 },
                            layer: 5
                        },
                        {
                            variant: 'straight',
                            weight: 0.3,
                            origin: { x: 18, y: 56 },
                            path: 'M20,58 L26,48 L30,38 L32,28 L34,18 C35,12 34,6 30,4 C26,2 22,4 20,8 L18,18 L16,30 L14,42 L12,52 C11,56 14,60 18,60 Z',
                            connectors: [
                                { name: 'proximal', position: { x: 18, y: 62 }, angle: 90, angleVariance: 16 }
                            ],
                            gradient: {
                                from: { x: 28, y: 6 },
                                to: { x: 14, y: 56 },
                                stops: [
                                    { offset: 0, color: 'rgba(252, 242, 220, 0.87)' },
                                    { offset: 0.5, color: 'rgba(218, 188, 156, 0.9)' },
                                    { offset: 1, color: 'rgba(176, 144, 114, 0.92)' }
                                ]
                            },
                            stroke: baseStroke,
                            strokeWidth: 2.5,
                            scaleRange: { min: 0.7, max: 1.0 },
                            layer: 5
                        }
                    ]
                };
            }

            pickTemplate(type, rng, variantHint) {
                const variants = this.templates[type];
                if (!variants || !variants.length) {
                    return null;
                }

                if (variantHint) {
                    const hinted = variants.find(v => v.variant === variantHint);
                    if (hinted) {
                        return hinted;
                    }
                }

                if (variants.length === 1) {
                    return variants[0];
                }

                const totalWeight = variants.reduce((sum, variant) => sum + (variant.weight || 1), 0);
                let roll = rng.next() * totalWeight;
                for (const variant of variants) {
                    roll -= (variant.weight || 1);
                    if (roll <= 0) {
                        return variant;
                    }
                }

                return variants[variants.length - 1];
            }

            buildSkeleton(rng, width, height) {
                const centerY = rng.range(height * 0.42, height * 0.58);
                const startX = rng.range(width * 0.22, width * 0.32);

                const skull = this.createInitialBone('skull', {
                    position: { x: startX, y: centerY - rng.range(-26, 26) },
                    rotation: rng.range(-12, 12),
                    features: ['skull']
                }, rng);

                let previous = skull;
                let connectorName = 'neck';

                const cervicalCount = rng.int(2, 4);
                const thoracicCount = rng.int(3, 6);
                const tailCount = rng.int(3, 6);

                const spineBones = [];
                for (let i = 0; i < cervicalCount; i++) {
                    const cervicalOptions = { angleVariance: 10, features: ['spine'] };
                    if (i === cervicalCount - 1 || rng.chance(0.35 + i * 0.15)) {
                        cervicalOptions.variant = 'elongated';
                    }
                    const cervical = this.attachBone(previous, connectorName, 'cervical', 'proximal', rng, cervicalOptions);
                    if (!cervical) break;
                    spineBones.push(cervical);
                    previous = cervical;
                    connectorName = 'distal';
                }

                const thoracicBones = [];
                for (let i = 0; i < thoracicCount; i++) {
                    const thoracicOptions = { angleVariance: 9, features: ['spine'] };
                    if (i >= 1 && i <= thoracicCount - 2 && rng.chance(0.6)) {
                        thoracicOptions.variant = 'arching';
                    }
                    const thoracic = this.attachBone(previous, connectorName, 'thoracic', 'proximal', rng, thoracicOptions);
                    if (!thoracic) break;
                    thoracicBones.push(thoracic);
                    spineBones.push(thoracic);
                    previous = thoracic;
                    connectorName = 'distal';

                    if (rng.chance(0.92)) {
                        const ribOptionsLeft = { mirror: -1, angleVariance: 14, features: ['rib'] };
                        if (rng.chance(0.45)) ribOptionsLeft.variant = 'sweep';
                        this.attachBone(thoracic, 'ribLeft', 'rib', 'spine', rng, ribOptionsLeft);
                    }
                    if (rng.chance(0.92)) {
                        const ribOptionsRight = { mirror: 1, angleVariance: 14, features: ['rib'] };
                        if (rng.chance(0.45)) ribOptionsRight.variant = 'sweep';
                        this.attachBone(thoracic, 'ribRight', 'rib', 'spine', rng, ribOptionsRight);
                    }

                    if (i < 2 && rng.chance(0.7)) {
                        this.buildForeLimb(thoracic, 'left', rng);
                    }
                    if (i < 2 && rng.chance(0.7)) {
                        this.buildForeLimb(thoracic, 'right', rng);
                    }

                    if (i >= thoracicCount - 2 && rng.chance(0.75)) {
                        this.buildHindLimb(thoracic, 'left', rng);
                    }
                    if (i >= thoracicCount - 2 && rng.chance(0.75)) {
                        this.buildHindLimb(thoracic, 'right', rng);
                    }
                }

                for (let i = 0; i < tailCount; i++) {
                    const tailOptions = {
                        angleVariance: 12,
                        scaleMultiplier: 0.9 + (i / Math.max(1, tailCount - 1)) * 0.2,
                        features: ['tail']
                    };
                    if (i === 0 || (i < tailCount - 1 && rng.chance(0.5))) {
                        tailOptions.variant = 'tapered';
                    }
                    const tailSegment = this.attachBone(previous, connectorName, 'tail', 'proximal', rng, tailOptions);
                    if (!tailSegment) break;
                    spineBones.push(tailSegment);
                    previous = tailSegment;
                    connectorName = 'distal';
                }

                const totalBones = this.activeBones.length;
                const integrity = rng.range(0.55, 1.0);
                const targetVisible = Math.max(3, Math.round(totalBones * integrity));
                let visibleCount = totalBones;

                const removable = this.activeBones.filter(bone => bone.parentId !== null);
                while (visibleCount > targetVisible && removable.length) {
                    const index = Math.floor(rng.next() * removable.length);
                    const candidate = removable[index];
                    if (!candidate || !candidate.visible || candidate.type === 'skull') {
                        removable.splice(index, 1);
                        continue;
                    }
                    const removed = this.removeBranch(candidate);
                    visibleCount -= removed;
                    removable.splice(index, 1);
                }

                const visibleBones = this.activeBones.filter(bone => bone.visible);
                const completeness = visibleBones.length / totalBones;
                const featureCounts = this.collectFeatureCounts(visibleBones);
                const featureSummary = this.buildFeatureSummary(featureCounts);
                const hint = this.buildHint(featureSummary);

                return {
                    bones: this.activeBones.slice(),
                    completeness,
                    featureSummary,
                    hint
                };
            }

            scaleFossilToFit(bones, canvasWidth, canvasHeight) {
                // Filter to only visible bones
                const visibleBones = bones.filter(bone => bone.visible);
                if (!visibleBones.length) return;

                // Calculate bounding box of all visible bones
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                visibleBones.forEach(bone => {
                    const template = bone.template;
                    const bounds = this.getBoneBounds(bone, template);
                    
                    minX = Math.min(minX, bounds.minX);
                    minY = Math.min(minY, bounds.minY);
                    maxX = Math.max(maxX, bounds.maxX);
                    maxY = Math.max(maxY, bounds.maxY);
                });

                // Calculate current fossil dimensions
                const fossilWidth = maxX - minX;
                const fossilHeight = maxY - minY;

                // Define margins (percentage of canvas)
                const marginX = canvasWidth * 0.08;
                const marginY = canvasHeight * 0.08;
                const targetWidth = canvasWidth - (marginX * 2);
                const targetHeight = canvasHeight - (marginY * 2);

                // Calculate scale to fit within margins (maintain aspect ratio)
                const scaleX = targetWidth / fossilWidth;
                const scaleY = targetHeight / fossilHeight;
                const fitScale = Math.min(scaleX, scaleY, 1.2); // Cap at 1.2x to avoid over-scaling small fossils

                // Calculate centering offset
                const scaledWidth = fossilWidth * fitScale;
                const scaledHeight = fossilHeight * fitScale;
                const centerX = marginX + (targetWidth - scaledWidth) / 2;
                const centerY = marginY + (targetHeight - scaledHeight) / 2;
                const offsetX = centerX - (minX * fitScale);
                const offsetY = centerY - (minY * fitScale);

                // Apply scale and translation to all bones
                bones.forEach(bone => {
                    bone.position.x = bone.position.x * fitScale + offsetX;
                    bone.position.y = bone.position.y * fitScale + offsetY;
                    bone.scale *= fitScale;
                });
            }

            getBoneBounds(bone, template) {
                // Use explicit bounds if provided, otherwise estimate from path or use defaults
                let width, height;
                
                if (template.bounds) {
                    width = template.bounds.width;
                    height = template.bounds.height;
                } else {
                    // Estimate bounds based on bone type and origin
                    // Most bones have origins roughly centered, so we double the origin as an estimate
                    const originX = template.origin.x;
                    const originY = template.origin.y;
                    
                    // Heuristic: assume bone extends roughly equally in all directions from origin
                    // This works well for symmetrical bones
                    width = originX * 2.2;
                    height = originY * 2.2;
                }

                const originX = template.origin.x;
                const originY = template.origin.y;

                // Define corners relative to origin
                const corners = [
                    { x: -originX, y: -originY },
                    { x: width - originX, y: -originY },
                    { x: width - originX, y: height - originY },
                    { x: -originX, y: height - originY }
                ];

                // Transform corners by bone's scale, rotation, and position
                const rad = this.degToRad(bone.rotation);
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);

                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                corners.forEach(corner => {
                    // Scale
                    let x = corner.x * bone.scale * bone.mirror;
                    let y = corner.y * bone.scale;
                    
                    // Rotate
                    const rotatedX = x * cos - y * sin;
                    const rotatedY = x * sin + y * cos;
                    
                    // Translate
                    const finalX = rotatedX + bone.position.x;
                    const finalY = rotatedY + bone.position.y;
                    
                    minX = Math.min(minX, finalX);
                    minY = Math.min(minY, finalY);
                    maxX = Math.max(maxX, finalX);
                    maxY = Math.max(maxY, finalY);
                });

                return { minX, minY, maxX, maxY };
            }

            createInitialBone(type, config, rng) {
                const template = this.pickTemplate(type, rng, config.variant);
                if (!template) return null;
                const scale = this.sampleScale(template, rng, config.scaleMultiplier, config.scaleOverride);
                const bone = {
                    id: this.boneIdCounter++,
                    type,
                    template,
                    templateVariant: template.variant || 'default',
                    position: config.position,
                    rotation: config.rotation || 0,
                    scale,
                    mirror: config.mirror || 1,
                    parentId: null,
                    children: [],
                    visible: true,
                    features: config.features ? [...config.features] : []
                };
                this.activeBones.push(bone);
                this.boneMap.set(bone.id, bone);
                return bone;
            }

            attachBone(parent, parentConnector, type, childConnector, rng, options = {}) {
                if (!parent) return null;
                const template = this.pickTemplate(type, rng, options.variant);
                if (!template) return null;
                const parentConnection = this.getConnector(parent, parentConnector);
                if (!parentConnection) return null;
                parent.usedConnectors = parent.usedConnectors || new Set();
                if (parent.usedConnectors.has(parentConnector)) return null;

                const childConnection = template.connectors.find(conn => conn.name === childConnector);
                if (!childConnection) return null;

                const mirror = options.mirror || 1;
                const scale = this.sampleScale(template, rng, options.scaleMultiplier, options.scaleOverride);
                const parentWorld = this.resolveConnector(parent, parentConnector);
                if (!parentWorld) return null;

                const angleVariance = options.angleVariance ?? (childConnection.angleVariance || 0);
                const variance = angleVariance ? rng.range(-angleVariance, angleVariance) : 0;
                const adjustedChildAngle = this.applyMirrorToAngle(childConnection.angle, mirror);
                const rotation = this.normalizeAngle(parentWorld.angle + 180 + variance - adjustedChildAngle);
                const position = this.solveChildPosition(parentWorld.position, template, childConnection, rotation, scale, mirror);

                const bone = {
                    id: this.boneIdCounter++,
                    type,
                    template,
                    templateVariant: template.variant || 'default',
                    position,
                    rotation,
                    scale,
                    mirror,
                    parentId: parent.id,
                    children: [],
                    visible: true,
                    features: options.features ? [...options.features] : []
                };

                this.activeBones.push(bone);
                this.boneMap.set(bone.id, bone);
                parent.children.push(bone.id);
                parent.usedConnectors.add(parentConnector);
                return bone;
            }

            buildForeLimb(spineBone, side, rng) {
                const connector = side === 'left' ? 'limbLeft' : 'limbRight';
                const mirror = side === 'left' ? -1 : 1;
                const shoulder = this.attachBone(spineBone, connector, 'shoulder', 'spine', rng, { mirror, angleVariance: 18, features: ['forelimb'] });
                if (!shoulder) return false;
                const upperOptions = { mirror, angleVariance: 20, features: ['forelimb'] };
                if (rng.chance(0.55)) {
                    upperOptions.variant = 'extended';
                }
                const upper = this.attachBone(shoulder, 'limb', 'limbUpper', 'proximal', rng, upperOptions);
                if (!upper) return true;
                const lowerOptions = { mirror, angleVariance: 18, features: ['forelimb'] };
                if (rng.chance(0.6)) {
                    lowerOptions.variant = 'extended';
                }
                const lower = this.attachBone(upper, 'distal', 'limbLower', 'proximal', rng, lowerOptions);
                if (!lower) return true;
                this.attachBone(lower, 'distal', 'claw', 'proximal', rng, { mirror, angleVariance: 24, features: ['forelimb', 'claw'] });
                return true;
            }

            buildHindLimb(spineBone, side, rng) {
                const connector = side === 'left' ? 'limbLeft' : 'limbRight';
                const mirror = side === 'left' ? -1 : 1;
                const hip = this.attachBone(spineBone, connector, 'hip', 'spine', rng, { mirror, angleVariance: 18, features: ['hindlimb'] });
                if (!hip) return false;
                const upperOptions = { mirror, angleVariance: 16, scaleMultiplier: 1.12, features: ['hindlimb'] };
                if (rng.chance(0.65)) {
                    upperOptions.variant = 'extended';
                }
                const upper = this.attachBone(hip, 'limb', 'limbUpper', 'proximal', rng, upperOptions);
                if (!upper) return true;
                const lowerOptions = { mirror, angleVariance: 16, scaleMultiplier: 1.08, features: ['hindlimb'] };
                if (rng.chance(0.7)) {
                    lowerOptions.variant = 'extended';
                }
                const lower = this.attachBone(upper, 'distal', 'limbLower', 'proximal', rng, lowerOptions);
                if (!lower) return true;
                this.attachBone(lower, 'distal', 'claw', 'proximal', rng, { mirror, angleVariance: 22, features: ['hindlimb', 'claw'] });
                return true;
            }

            removeBranch(bone) {
                if (!bone.visible) return 0;
                bone.visible = false;
                let removed = 1;
                bone.children.forEach(childId => {
                    const child = this.boneMap.get(childId);
                    if (child) {
                        removed += this.removeBranch(child);
                    }
                });
                return removed;
            }

            collectFeatureCounts(bones) {
                const counts = { ribs: 0, forelimbSegments: 0, hindlimbSegments: 0, tailSegments: 0, skull: false, claws: 0 };
                bones.forEach(bone => {
                    if (bone.features.includes('rib')) counts.ribs += 1;
                    if (bone.features.includes('forelimb')) counts.forelimbSegments += 1;
                    if (bone.features.includes('hindlimb')) counts.hindlimbSegments += 1;
                    if (bone.features.includes('tail')) counts.tailSegments += 1;
                    if (bone.features.includes('skull')) counts.skull = true;
                    if (bone.features.includes('claw')) counts.claws += 1;
                });
                return counts;
            }

            buildFeatureSummary(counts) {
                const summary = [];
                if (counts.skull) {
                    summary.push('a detailed skull');
                }
                if (counts.ribs >= 4) {
                    summary.push('an articulated rib cage');
                } else if (counts.ribs >= 2) {
                    summary.push('rib fragments');
                }
                if (counts.tailSegments >= 4) {
                    summary.push('a sweeping tail');
                } else if (counts.tailSegments >= 2) {
                    summary.push('tail vertebrae');
                }
                if (counts.forelimbSegments >= 3) {
                    summary.push('forelimbs with claws');
                } else if (counts.forelimbSegments >= 1) {
                    summary.push('forelimb fragments');
                }
                if (counts.hindlimbSegments >= 3) {
                    summary.push('powerful hind legs');
                } else if (counts.hindlimbSegments >= 1) {
                    summary.push('hind limb remnants');
                }
                if (counts.claws >= 2 && summary.length < 4) {
                    summary.push('sharp claw impressions');
                }
                if (!summary.length) {
                    summary.push('scattered bone impressions');
                }
                return summary.slice(0, 4);
            }

            buildHint(featureSummary) {
                const focus = featureSummary[0] || 'delicate bone impressions';
                return `Faint outlines hint at ${focus}.`;
            }

            describeFind(name, plan) {
                let descriptor;
                if (plan.completeness >= 0.85) {
                    descriptor = 'a remarkably complete skeleton';
                } else if (plan.completeness >= 0.65) {
                    descriptor = 'a well-preserved partial skeleton';
                } else if (plan.completeness >= 0.45) {
                    descriptor = 'a partial skeleton';
                } else {
                    descriptor = 'fragmentary remains';
                }
                const features = plan.featureSummary.join(', ');
                return `A discovery of ${descriptor} of ${name}, highlighting ${features}.`;
            }

            renderBackground(ctx, width, height) {
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#d9ba8b');
                gradient.addColorStop(0.6, '#c59968');
                gradient.addColorStop(1, '#b07e4d');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                ctx.save();
                ctx.globalAlpha = 0.35;
                for (let i = 0; i < 5; i++) {
                    const centerX = width * (0.15 + i * 0.18);
                    const centerY = height * 0.7;
                    const radius = Math.min(width, height) * (0.16 + i * 0.05);
                    const light = ctx.createRadialGradient(centerX, centerY, radius * 0.1, centerX, centerY, radius);
                    light.addColorStop(0, 'rgba(255, 245, 220, 0.08)');
                    light.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = light;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            renderBones(ctx, bones) {
                const drawList = bones.filter(bone => bone.visible);
                drawList.sort((a, b) => {
                    if (a.template.layer === b.template.layer) {
                        return a.id - b.id;
                    }
                    return a.template.layer - b.template.layer;
                });
                drawList.forEach(bone => this.drawBone(ctx, bone));
            }

            drawBone(ctx, bone) {
                const template = bone.template;
                const path = template.cachedPath || new Path2D(template.path);
                if (!template.cachedPath) {
                    template.cachedPath = path;
                }

                ctx.save();
                ctx.translate(bone.position.x, bone.position.y);
                ctx.rotate(this.degToRad(bone.rotation));
                ctx.scale(bone.scale * bone.mirror, bone.scale);
                ctx.translate(-template.origin.x, -template.origin.y);

                ctx.shadowColor = 'rgba(40, 25, 15, 0.25)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 6;

                const gradient = ctx.createLinearGradient(template.gradient.from.x, template.gradient.from.y, template.gradient.to.x, template.gradient.to.y);
                template.gradient.stops.forEach(stop => {
                    gradient.addColorStop(stop.offset, this.makeOpaque(stop.color));
                });
                ctx.fillStyle = gradient;
                ctx.globalAlpha = 1;
                ctx.fill(path);

                ctx.shadowColor = 'transparent';
                ctx.globalAlpha = 1;
                ctx.lineWidth = template.strokeWidth / bone.scale;
                ctx.strokeStyle = this.makeOpaque(template.stroke);
                ctx.stroke(path);

                if (template.holes) {
                    ctx.globalCompositeOperation = 'destination-out';
                    template.holes.forEach(hole => {
                        const holePath = hole.cachedPath || new Path2D(hole.path);
                        if (!hole.cachedPath) {
                            hole.cachedPath = holePath;
                        }
                        ctx.globalAlpha = hole.alpha ?? 1;
                        ctx.fill(holePath);
                    });
                    ctx.globalCompositeOperation = 'source-over';
                }

                if (template.details) {
                    template.details.forEach(detail => {
                        const detailPath = detail.cachedPath || new Path2D(detail.path);
                        if (!detail.cachedPath) {
                            detail.cachedPath = detailPath;
                        }
                        ctx.globalAlpha = detail.alpha ?? 0.5;
                        ctx.lineWidth = (detail.lineWidth ?? 2) / bone.scale;
                        ctx.strokeStyle = detail.stroke ?? 'rgba(255, 255, 255, 0.45)';
                        ctx.stroke(detailPath);
                    });
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            }

            applyWeathering(ctx, rng, width, height) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const noise = rng.range(-12, 12);
                    data[i] = this.clamp(data[i] + noise, 0, 255);
                    data[i + 1] = this.clamp(data[i + 1] + noise, 0, 255);
                    data[i + 2] = this.clamp(data[i + 2] + noise * 0.8, 0, 255);
                }
                ctx.putImageData(imageData, 0, 0);

                const patchCount = Math.floor(rng.range(6, 11));
                for (let i = 0; i < patchCount; i++) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.translate(rng.range(0, width), rng.range(0, height));
                    ctx.rotate(this.degToRad(rng.range(0, 360)));
                    const radius = rng.range(Math.min(width, height) * 0.06, Math.min(width, height) * 0.12);
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    gradient.addColorStop(0, `rgba(80, 60, 40, ${rng.range(0.10, 0.18)})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                const speckleCount = Math.floor(rng.range(70, 110));
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = 0.25;
                for (let i = 0; i < speckleCount; i++) {
                    const x = rng.range(0, width);
                    const y = rng.range(0, height);
                    const w = rng.range(1, 3);
                    const h = rng.range(1, 3);
                    ctx.beginPath();
                    ctx.ellipse(x, y, w, h, this.degToRad(rng.range(0, 180)), 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 243, 210, 0.65)';
                    ctx.fill();
                }
                ctx.restore();
            }

            getConnector(bone, connectorName) {
                return bone.template.connectors.find(connector => connector.name === connectorName) || null;
            }

            resolveConnector(bone, connectorName) {
                const connector = this.getConnector(bone, connectorName);
                if (!connector) return null;
                const offset = {
                    x: (connector.position.x - bone.template.origin.x) * bone.mirror,
                    y: connector.position.y - bone.template.origin.y
                };
                const scaled = { x: offset.x * bone.scale, y: offset.y * bone.scale };
                const rotated = this.rotatePoint(scaled, bone.rotation);
                const angle = this.normalizeAngle(bone.rotation + this.applyMirrorToAngle(connector.angle, bone.mirror));
                return {
                    position: { x: bone.position.x + rotated.x, y: bone.position.y + rotated.y },
                    angle
                };
            }

            solveChildPosition(anchor, template, connector, rotation, scale, mirror) {
                const offset = {
                    x: (connector.position.x - template.origin.x) * mirror,
                    y: connector.position.y - template.origin.y
                };
                const scaled = { x: offset.x * scale, y: offset.y * scale };
                const rotated = this.rotatePoint(scaled, rotation);
                return {
                    x: anchor.x - rotated.x,
                    y: anchor.y - rotated.y
                };
            }

            sampleScale(template, rng, scaleMultiplier = 1, override) {
                if (override) return override;
                const range = template.scaleRange || { min: 1, max: 1 };
                return this.baseScale * rng.range(range.min, range.max) * (scaleMultiplier || 1);
            }

            applyMirrorToAngle(angle, mirror) {
                if (mirror === 1) return angle;
                return 180 - angle;
            }

            normalizeAngle(angle) {
                let normalized = angle % 360;
                if (normalized > 180) normalized -= 360;
                if (normalized < -180) normalized += 360;
                return normalized;
            }

            rotatePoint(point, angleDeg) {
                const rad = this.degToRad(angleDeg);
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                return {
                    x: point.x * cos - point.y * sin,
                    y: point.x * sin + point.y * cos
                };
            }

            makeOpaque(color) {
                if (typeof color !== 'string') {
                    return color;
                }
                const match = color.match(/rgba\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)/i);
                if (!match) {
                    return color;
                }
                const [, r, g, b] = match;
                return `rgba(${parseFloat(r)}, ${parseFloat(g)}, ${parseFloat(b)}, 1)`;
            }

            degToRad(deg) {
                return (deg * Math.PI) / 180;
            }

            clamp(value, min, max) {
                return Math.min(max, Math.max(min, value));
            }
        }

        function generateFossilSeed() {
            const buffer = new Uint32Array(1);
            if (window.crypto && window.crypto.getRandomValues) {
                window.crypto.getRandomValues(buffer);
            } else {
                buffer[0] = Math.floor(Math.random() * 0xFFFFFFFF);
            }
            return buffer[0];
        }

        function renderProceduralFossil(seed) {
            if (!fossilGenerator) {
                fossilGenerator = new ProceduralFossilGenerator();
            }
            fossilCtx.clearRect(0, 0, fossilCanvas.width, fossilCanvas.height);
            return fossilGenerator.generate(seed, fossilCtx, fossilCanvas.width, fossilCanvas.height);
        }

        function resetFossilInfo() {
            const info = document.getElementById('fossilInfo');
            info.classList.remove('visible');
            info.style.color = '#ccc';
            if (currentFossilData && currentFossilData.hint) {
                info.textContent = currentFossilData.hint;
            } else {
                info.textContent = 'Carefully brush away the sand to reveal the ancient fossil beneath...';
            }
        }

        // Initialize the game
        function initGame() {
            canvas = document.getElementById('fossilCanvas');
            ctx = canvas.getContext('2d');
            fossilGenerator = new ProceduralFossilGenerator();

            // Initialize window size tracking
            lastWindowWidth = window.innerWidth;
            lastWindowHeight = window.innerHeight;

            // Set up canvas size
            resizeCanvas();

            // Set up event listeners
            setupEventListeners();

            // Initialize first fossil with a fresh seed
            const seed = generateFossilSeed();
            loadFossil(seed);

            // Update UI
            updateUI();
        }



        function resizeCanvas() {
            // Force a complete canvas refresh by resetting its CSS dimensions
            canvas.style.width = '';
            canvas.style.height = '';
            canvas.style.display = 'none';
            canvas.offsetHeight; // Force reflow
            canvas.style.display = 'block';
            
            // Wait for the browser to calculate new dimensions
            const rect = canvas.getBoundingClientRect();
            let width = rect.width;
            let height = rect.height;
            
            // Fallback: calculate dimensions from parent container if canvas rect is invalid
            if (width === 0 || height === 0) {
                const gameArea = document.querySelector('.game-area');
                const gameRect = gameArea.getBoundingClientRect();
                width = gameRect.width - 16; // Account for padding
                height = gameRect.height - 16;
            }
            
            // Ensure we have valid dimensions
            if (width <= 0) width = window.innerWidth - 32;
            if (height <= 0) height = window.innerHeight - 100;
            
            // Main canvas
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            // Create off-screen canvases for layers
            fossilCanvas = document.createElement('canvas');
            sandCanvas = document.createElement('canvas');
            
            fossilCanvas.width = width;
            fossilCanvas.height = height;
            sandCanvas.width = width;
            sandCanvas.height = height;
            
            fossilCtx = fossilCanvas.getContext('2d', { willReadFrequently: true });
            sandCtx = sandCanvas.getContext('2d', { willReadFrequently: true });
        }

        function handleResize() {
            // Check if this is a significant resize (not just minor browser chrome changes)
            const widthDiff = Math.abs(window.innerWidth - lastWindowWidth);
            const heightDiff = Math.abs(window.innerHeight - lastWindowHeight);
            const significantChange = widthDiff > 50 || heightDiff > 50;
            
            // Only trigger collapse modal for significant changes and if game is active
            if (significantChange && gameActive && revealProgress > 0 && revealProgress < 100) {
                // Pause the game and show collapse modal
                pauseGame();
                showCollapseModal();
            } else if (significantChange) {
                // Just resize without modal if no active digging
                resizeCanvas();
                const seed = currentFossilSeed ?? generateFossilSeed();
                loadFossil(seed);
            }
            
            // Update stored dimensions
            lastWindowWidth = window.innerWidth;
            lastWindowHeight = window.innerHeight;
        }

        function debouncedResize() {
            // Clear existing timeout
            clearTimeout(resizeTimeout);
            
            // Set new timeout
            resizeTimeout = setTimeout(handleResize, 200);
        }

        function setupEventListeners() {
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
            
            // Touch events
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', stopDrawing);
            
            // Prevent scrolling on touch
            canvas.addEventListener('touchstart', e => e.preventDefault());
            canvas.addEventListener('touchmove', e => e.preventDefault());
            
            // Resize and orientation events
            window.addEventListener('resize', debouncedResize);
            window.addEventListener('orientationchange', () => {
                // Give device time to complete rotation
                setTimeout(debouncedResize, 300);
            });
            
            // Brush controls
            document.querySelectorAll('.brush-btn').forEach(btn => {
                btn.addEventListener('click', () => setBrushType(btn.dataset.brush));
            });
            
            document.getElementById('brushSize').addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
            });
        }

        function startDrawing(e) {
            if (!gameActive) return;
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing || !gameActive) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            brushAway(x, y);
        }

        function stopDrawing() {
            isDrawing = false;
            // Ensure final composite after stroke ends (in case throttled operations pending)
            compositeLayers();
        }

        function handleTouchStart(e) {
            if (!gameActive) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            lastTouchX = touch.clientX - rect.left;
            lastTouchY = touch.clientY - rect.top;
            isDrawing = true;
            brushAway(lastTouchX, lastTouchY);
        }

        function handleTouchMove(e) {
            if (!isDrawing || !gameActive) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // Interpolate between last position and current for smooth strokes
            const steps = Math.max(Math.abs(x - lastTouchX), Math.abs(y - lastTouchY));
            for (let i = 0; i <= steps; i++) {
                const interpX = lastTouchX + (x - lastTouchX) * (i / steps);
                const interpY = lastTouchY + (y - lastTouchY) * (i / steps);
                brushAway(interpX, interpY);
            }
            
            lastTouchX = x;
            lastTouchY = y;
        }

        function brushAway(x, y) {
            // Throttle brush operations for performance
            const now = Date.now();
            if (now - lastBrushTime < BRUSH_THROTTLE_MS) {
                return;
            }
            lastBrushTime = now;
            
            // Clear sand in circular area
            const radius = brushSize;
            
            // Different brush effects based on type
            let intensity = 1;
            let falloff = 1;
            
            switch (currentBrushType) {
                case 'soft':
                    intensity = 0.3;
                    falloff = 2;
                    break;
                case 'medium':
                    intensity = 0.6;
                    falloff = 1.5;
                    break;
                case 'fine':
                    intensity = 0.9;
                    falloff = 1;
                    break;
            }
            
            // Apply brush effect to sand layer only
            sandCtx.globalCompositeOperation = 'destination-out';
            
            // Create gradient for soft brush effect
            const gradient = sandCtx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, `rgba(0,0,0,${intensity})`);
            gradient.addColorStop(0.7, `rgba(0,0,0,${intensity * 0.5})`);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            sandCtx.fillStyle = gradient;
            sandCtx.beginPath();
            sandCtx.arc(x, y, radius, 0, Math.PI * 2);
            sandCtx.fill();
            
            sandCtx.globalCompositeOperation = 'source-over';
            
            // Re-composite layers to show updated result
            compositeLayers();
            
            // Create sand particles (minimal for performance)
            if (Math.random() < 0.3) { // Only 30% chance to create particles
                createSandParticles(x, y, Math.min(2, Math.round(radius * 0.05)));
            }
            
            // Update progress (throttled)
            const currentTime = Date.now();
            if (currentTime - lastProgressUpdate > PROGRESS_UPDATE_MS) {
                lastProgressUpdate = currentTime;
                updateProgress();
            }
        }

        function createSandParticles(x, y, count) {
            // Ultra-light particle system for performance
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'sand-particle';
                
                const size = Math.random() * 3 + 1; // Smaller particles
                const offsetX = (Math.random() - 0.5) * 20; // Less spread
                const offsetY = (Math.random() - 0.5) * 20;
                const duration = 200; // Much shorter duration
                
                particle.style.cssText = `
                    width: ${size}px;
                    height: ${size}px;
                    left: ${x + offsetX}px;
                    top: ${y + offsetY}px;
                    opacity: 0.6;
                    transition: all ${duration}ms ease-out;
                `;
                
                document.body.appendChild(particle);
                
                // Immediate animation - no setTimeout delay
                requestAnimationFrame(() => {
                    particle.style.transform = `translate(${offsetX}px, ${offsetY + 10}px)`;
                    particle.style.opacity = '0';
                });
                
                // Quick cleanup
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, duration + 50);
            }
        }



        function updateProgress() {
            // Don't update progress if fossil is already completed
            if (revealProgress >= 100) return;
            
            // Sample the sand layer to determine how much has been cleared
            const imageData = sandCtx.getImageData(0, 0, sandCanvas.width, sandCanvas.height);
            const data = imageData.data;
            
            let clearedPixels = 0;
            let totalPixels = 0;
            
            // Count transparent pixels in sand layer
            for (let i = 3; i < data.length; i += 4) {
                totalPixels++;
                if (data[i] < 128) { // Alpha channel - considering partially transparent as cleared
                    clearedPixels++;
                }
            }
            
            revealProgress = Math.min((clearedPixels / totalPixels) * 100, 100);
            
            // Update UI
            document.getElementById('progressFill').style.width = revealProgress + '%';
            document.getElementById('progressText').textContent = Math.floor(revealProgress) + '% Revealed';
            
            // Show fossil info as progress increases
            const fossilInfo = document.getElementById('fossilInfo');
            if (revealProgress > 15 && currentFossilData) {
                fossilInfo.textContent = currentFossilData.hint || 'Intriguing bone patterns begin to surface...';
                fossilInfo.classList.add('visible');
            }
            
            // Complete fossil discovery
            if (revealProgress >= 80) {
                completeFossil();
            }
        }

        function completeFossil() {
            // Prevent multiple completions
            if (revealProgress >= 100) return;
            
            revealProgress = 100; // Mark as completed
            fossilsDiscovered++;
            updateUI();
            
            // Show completion message in progress panel
            const fossilInfo = document.getElementById('fossilInfo');
            const fossilName = currentFossilData ? currentFossilData.name : 'mysterious fossil';
            fossilInfo.textContent = `🎉 Discovery Complete! You uncovered ${fossilName}!`;
            fossilInfo.style.color = '#4CAF50';
            fossilInfo.classList.add('visible');
            
            // Show beautiful discovery overlay after a short delay
            setTimeout(() => {
                showDiscoveryOverlay();
            }, 1000);
        }

        function showDiscoveryOverlay() {
            if (!currentFossilData) return;

            // Populate overlay content
            document.getElementById('discovery-emoji').textContent = '🦴';
            document.getElementById('discovery-name').textContent = `You uncovered ${currentFossilData.name}!`;
            document.getElementById('discovery-description').textContent = currentFossilData.description;

            // Show overlay
            document.getElementById('discovery-overlay').classList.add('show');
        }

        function continueDigging() {
            // Hide overlay
            document.getElementById('discovery-overlay').classList.remove('show');
            
            // Start new dig
            setTimeout(() => {
                newFossil();
            }, 300);
        }

        function admireDiscovery() {
            // Hide overlay to admire the fossil
            document.getElementById('discovery-overlay').classList.remove('show');
        }

        function pauseGame() {
            gameActive = false;
            isDrawing = false;
            
            // Disable canvas interactions
            canvas.style.pointerEvents = 'none';
            canvas.style.opacity = '0.7';
            
            // Disable UI controls
            document.querySelectorAll('.brush-btn, .size-slider, .header-btn').forEach(element => {
                element.disabled = true;
                element.style.opacity = '0.5';
            });
        }

        function resumeGame() {
            gameActive = true;
            
            // Re-enable canvas interactions
            canvas.style.pointerEvents = 'auto';
            canvas.style.opacity = '1';
            
            // Re-enable UI controls
            document.querySelectorAll('.brush-btn, .size-slider, .header-btn').forEach(element => {
                element.disabled = false;
                element.style.opacity = '1';
            });
        }

        function showCollapseModal() {
            // Select a random failure reason
            const reason = digFailureReasons[Math.floor(Math.random() * digFailureReasons.length)];
            // Update modal content with random reason
            document.querySelector('.collapse-title').textContent = reason.title;
            document.querySelector('.collapse-icon').textContent = reason.icon;
            document.querySelector('.collapse-message').textContent = reason.message;
            document.querySelector('.collapse-submessage').textContent = reason.submessage;
            
            document.getElementById('collapse-overlay').classList.add('show');
        }

        function hideCollapseModal() {
            document.getElementById('collapse-overlay').classList.remove('show');
        }

        function restartDigSite() {
            // Hide collapse modal
            hideCollapseModal();
            
            // Force a proper resize after modal closes
            setTimeout(() => {
                // Update stored dimensions to current viewport
                lastWindowWidth = window.innerWidth;
                lastWindowHeight = window.innerHeight;
                
                // Force layout reflow to ensure game area has correct dimensions
                const gameArea = document.querySelector('.game-area');
                gameArea.style.display = 'none';
                gameArea.offsetHeight; // Force reflow
                gameArea.style.display = 'flex';
                
                // Wait for reflow then resize canvas
                requestAnimationFrame(() => {
                    // Give an extra frame for the canvas element to resize
                    requestAnimationFrame(() => {
                        resizeCanvas();
                        const newSeed = generateFossilSeed();
                        loadFossil(newSeed);
                        resumeGame();
                    });
                });
            }, 100);
        }

        function setBrushType(type) {
            currentBrushType = type;
            document.querySelectorAll('.brush-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-brush="${type}"]`).classList.add('active');
        }

        function loadFossil(seed) {
            if (!fossilCtx || !sandCtx) {
                return;
            }

            const resolvedSeed = seed !== undefined && seed !== null
                ? seed >>> 0
                : (currentFossilSeed ?? generateFossilSeed());

            currentFossilSeed = resolvedSeed;
            revealProgress = 0;

            const details = renderProceduralFossil(resolvedSeed);
            currentFossilData = {
                seed: resolvedSeed,
                ...details
            };

            createSandLayer();
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressText').textContent = '0% Revealed';
            resetFossilInfo();
            updateUI();
        }

        function createSandLayer() {
            // Clear sand layer
            sandCtx.clearRect(0, 0, sandCanvas.width, sandCanvas.height);
            
            // Create sand texture
            sandCtx.fillStyle = '#D2B48C';
            sandCtx.fillRect(0, 0, sandCanvas.width, sandCanvas.height);
            
            // Add sand texture noise
            const imageData = sandCtx.getImageData(0, 0, sandCanvas.width, sandCanvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 30;
                data[i] += noise;     // Red
                data[i + 1] += noise; // Green  
                data[i + 2] += noise; // Blue
            }
            
            sandCtx.putImageData(imageData, 0, 0);
            
            // Composite the layers on main canvas
            compositeLayers();
        }

        function compositeLayers() {
            // Clear main canvas
            ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
            
            // Draw fossil layer first (background)
            ctx.drawImage(fossilCanvas, 0, 0);
            
            // Draw sand layer on top
            ctx.drawImage(sandCanvas, 0, 0);
        }

        function newFossil() {
            if (!gameActive) return;
            const seed = generateFossilSeed();
            loadFossil(seed);
        }

        function resetProgress() {
            if (!gameActive) return;
            fossilsDiscovered = 0;
            loadFossil(currentFossilSeed);
        }

        function updateUI() {
            // UI elements for fossil count and current fossil were removed for header compacting
            // Progress is now shown in the progress panel instead
        }

        // Initialize game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
<script src="parental.js"></script>
</html>