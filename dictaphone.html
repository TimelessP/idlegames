<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dictaphone</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --button-bg: #007bff;
            --button-text: #ffffff;
            --button-hover: #0056b3;
            --button-active: #004085;
            --button-danger: #dc3545;
            --button-danger-hover: #c82333;
            --button-success: #28a745;
            --button-success-hover: #218838;
            --panel-bg: #f8f9fa;
            --border-color: #dee2e6;
            --slider-track: #ddd;
            --slider-thumb: #007bff;
            --meter-bg: #e9ecef;
            --meter-needle: #dc3545;
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --button-bg: #0d6efd;
            --button-text: #ffffff;
            --button-hover: #0b5ed7;
            --button-active: #0a58ca;
            --button-danger: #dc3545;
            --button-danger-hover: #bb2d3b;
            --button-success: #198754;
            --button-success-hover: #157347;
            --panel-bg: #2d2d2d;
            --border-color: #495057;
            --slider-track: #495057;
            --slider-thumb: #0d6efd;
            --meter-bg: #495057;
            --meter-needle: #dc3545;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            font-size: 18px;
            line-height: 1.5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 0;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .button {
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--button-bg);
            color: var(--button-text);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 60px;
            touch-action: manipulation;
        }

        .button:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
        }

        .button:active {
            background: var(--button-active);
            transform: translateY(0);
        }

        .button.danger {
            background: var(--button-danger);
        }

        .button.danger:hover {
            background: var(--button-danger-hover);
        }

        .button.success {
            background: var(--button-success);
        }

        .button.success:hover {
            background: var(--button-success-hover);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .button.recording {
            background: var(--button-danger);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .slider-container {
            margin: 30px 0;
        }

        .slider-wrapper {
            position: relative;
            padding: 0 30px;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--slider-track);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
            border: 2px solid var(--bg-color);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
            border: 2px solid var(--bg-color);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .time-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.8;
            padding: 0 30px;
        }

        .meter-container {
            margin: 20px 0;
            text-align: center;
        }

        .meter {
            width: 200px;
            height: 100px;
            margin: 0 auto;
            position: relative;
            background: var(--meter-bg);
            border-radius: 100px 100px 0 0;
            overflow: hidden;
            border: 3px solid var(--border-color);
        }

        .meter-needle {
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 2px;
            height: 80px;
            background: var(--meter-needle);
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(-90deg);
            transition: transform 0.1s ease;
        }

        .meter-labels {
            display: flex;
            justify-content: space-between;
            width: 200px;
            margin: 5px auto 0;
            font-size: 12px;
            opacity: 0.7;
        }

        .volume-container {
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .volume-label {
            font-weight: 600;
            min-width: 80px;
        }

        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            background: var(--panel-bg);
            transition: transform 0.2s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .status {
            text-align: center;
            margin: 20px 0;
            font-size: 18px;
            font-weight: 600;
            min-height: 25px;
        }

        .status.recording {
            color: var(--button-danger);
        }

        .status.playing {
            color: var(--button-success);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            .controls {
                grid-template-columns: repeat(2, 1fr);
            }

            .button {
                font-size: 14px;
                padding: 12px 15px;
            }

            h1 {
                font-size: 2em;
            }

            .slider-wrapper {
                padding: 0 20px;
            }

            .time-labels {
                padding: 0 20px;
            }
        }

        .keyboard-shortcuts {
            margin-top: 30px;
            padding: 20px;
            background: var(--panel-bg);
            border-radius: 10px;
            font-size: 14px;
            border: 1px solid var(--border-color);
        }

        .keyboard-shortcuts h3 {
            margin-top: 0;
            margin-bottom: 15px;
        }

        .shortcut-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
        }

        .key {
            background: var(--panel-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="themeToggle" title="Toggle theme">üåë</button>
    
    <div class="container">
        <h1>üéôÔ∏è Dictaphone</h1>
        
        <div class="status" id="status">Ready</div>
        
        <div class="meter-container">
            <div class="meter">
                <div class="meter-needle" id="meterNeedle"></div>
            </div>
            <div class="meter-labels">
                <span>Quiet</span>
                <span>Loud</span>
            </div>
        </div>
        
        <div class="controls">
            <button class="button" id="recordBtn" title="Record (R)">
                <span>üî¥</span> Record
            </button>
            <button class="button" id="pttBtn" title="Push-to-Talk (T)">
                <span>üìª</span> PTT
            </button>
            <button class="button" id="stopBtn" title="Stop (Space)">
                <span>‚èπÔ∏è</span> Stop
            </button>
            <button class="button success" id="playBtn" title="Play (P)">
                <span>‚ñ∂Ô∏è</span> Play
            </button>
        </div>
        
        <div class="slider-container">
            <div class="slider-wrapper">
                <input type="range" class="slider" id="positionSlider" min="0" max="100" value="0" title="Audio position">
            </div>
            <div class="time-labels">
                <span id="currentTime">0:00</span>
                <span id="totalTime">0:00</span>
            </div>
        </div>
        
        <div class="volume-container">
            <label class="volume-label" for="volumeSlider">Volume:</label>
            <input type="range" class="slider" id="volumeSlider" min="0" max="100" value="75" title="Playback volume">
            <span id="volumeValue">75%</span>
        </div>
        
        <div class="controls">
            <div class="file-input-wrapper">
                <input type="file" class="file-input" id="importFile" accept="audio/*">
                <button class="button" onclick="document.getElementById('importFile').click()" title="Import audio (I)">
                    <span>üìÇ</span> Import
                </button>
            </div>
            <button class="button success" id="exportBtn" title="Export (E)">
                <span>üíæ</span> Export
            </button>
            <button class="button danger" id="eraseBtn" title="Erase All (Delete)">
                <span>üóëÔ∏è</span> Erase All
            </button>
        </div>
        
        <div class="keyboard-shortcuts">
            <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
            <div class="shortcut-list">
                <div class="shortcut">
                    <span>Record</span>
                    <span class="key">R</span>
                </div>
                <div class="shortcut">
                    <span>Push-to-Talk</span>
                    <span class="key">T</span>
                </div>
                <div class="shortcut">
                    <span>Stop</span>
                    <span class="key">Space</span>
                </div>
                <div class="shortcut">
                    <span>Play</span>
                    <span class="key">P</span>
                </div>
                <div class="shortcut">
                    <span>Import</span>
                    <span class="key">I</span>
                </div>
                <div class="shortcut">
                    <span>Export</span>
                    <span class="key">E</span>
                </div>
                <div class="shortcut">
                    <span>Erase All</span>
                    <span class="key">Del</span>
                </div>
                <div class="shortcut">
                    <span>Theme</span>
                    <span class="key">M</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Dictaphone {
            constructor() {
                this.audioContext = null;
                this.mediaRecorder = null;
                this.stream = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.isPlaying = false;
                this.isPTT = false;
                this.audioBuffer = null;
                this.audioSource = null;
                this.startTime = 0;
                this.pauseTime = 0;
                this.currentPosition = 0;
                this.analyser = null;
                this.dataArray = null;
                this.animationFrame = null;
                this.recordingAnimationFrame = null;
                this.recordingStartTime = 0;
                this.recordingStartPosition = 0;
                this.isDragging = false;
                this.currentThemeMode = 'system'; // Track the current theme mode (system/light/dark)
                
                this.initializeElements();
                this.initializeAudio();
                this.setupEventListeners();
                this.loadFromCache();
                this.initializeTheme();
                this.updateUI();
            }

            initializeElements() {
                this.elements = {
                    recordBtn: document.getElementById('recordBtn'),
                    pttBtn: document.getElementById('pttBtn'),
                    stopBtn: document.getElementById('stopBtn'),
                    playBtn: document.getElementById('playBtn'),
                    positionSlider: document.getElementById('positionSlider'),
                    volumeSlider: document.getElementById('volumeSlider'),
                    volumeValue: document.getElementById('volumeValue'),
                    exportBtn: document.getElementById('exportBtn'),
                    eraseBtn: document.getElementById('eraseBtn'),
                    importFile: document.getElementById('importFile'),
                    status: document.getElementById('status'),
                    meterNeedle: document.getElementById('meterNeedle'),
                    currentTime: document.getElementById('currentTime'),
                    totalTime: document.getElementById('totalTime'),
                    themeToggle: document.getElementById('themeToggle')
                };
            }

            async initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.connect(this.audioContext.destination);
                    
                    // Load saved volume level
                    this.loadVolumeFromStorage();
                    
                    // Request microphone access
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: false
                        } 
                    });
                    
                    // Set up audio analysis for meter
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    // Connect microphone to analyser by default
                    this.microphoneSource = this.audioContext.createMediaStreamSource(this.stream);
                    this.microphoneSource.connect(this.analyser);
                    
                    this.startMeterAnimation();
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.updateStatus('Microphone access denied');
                }
            }

            setupEventListeners() {
                // Button events
                this.elements.recordBtn.addEventListener('click', () => this.toggleRecord());
                this.elements.stopBtn.addEventListener('click', () => this.stop());
                this.elements.playBtn.addEventListener('click', () => this.togglePlay());
                this.elements.exportBtn.addEventListener('click', () => this.export());
                this.elements.eraseBtn.addEventListener('click', () => this.eraseAll());
                this.elements.importFile.addEventListener('change', (e) => this.import(e));

                // PTT events
                this.elements.pttBtn.addEventListener('mousedown', () => this.startPTT());
                this.elements.pttBtn.addEventListener('mouseup', () => this.stopPTT());
                this.elements.pttBtn.addEventListener('mouseleave', () => this.stopPTT());
                this.elements.pttBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startPTT();
                });
                this.elements.pttBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.stopPTT();
                });

                // Slider events
                this.elements.positionSlider.addEventListener('input', (e) => this.onSliderInput(e));
                this.elements.positionSlider.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    // Capture current playback position when starting to interact with slider
                    if (this.isPlaying) {
                        this.currentPosition = this.getCurrentPosition();
                    }
                });
                this.elements.positionSlider.addEventListener('mouseup', (e) => {
                    this.isDragging = false;
                    // Slider position updates can now resume
                });
                this.elements.positionSlider.addEventListener('touchstart', (e) => {
                    this.isDragging = true;
                    // Capture current playback position when starting to interact with slider
                    if (this.isPlaying) {
                        this.currentPosition = this.getCurrentPosition();
                    }
                });
                this.elements.positionSlider.addEventListener('touchend', (e) => {
                    this.isDragging = false;
                    // Slider position updates can now resume
                });

                this.elements.volumeSlider.addEventListener('input', (e) => this.updateVolume(e));

                // Theme toggle
                this.elements.themeToggle.addEventListener('click', () => this.toggleTheme());

                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                document.addEventListener('keyup', (e) => this.handleKeyboardUp(e));

                // Media keys
                navigator.mediaSession.setActionHandler('play', () => this.togglePlay());
                navigator.mediaSession.setActionHandler('pause', () => this.stop());
                navigator.mediaSession.setActionHandler('stop', () => this.stop());

                // Prevent context menu on PTT for better mobile experience
                this.elements.pttBtn.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            handleKeyboard(e) {
                // Don't trigger shortcuts when typing in inputs
                if (e.target.tagName === 'INPUT') return;

                switch(e.key.toLowerCase()) {
                    case 'r':
                        e.preventDefault();
                        this.toggleRecord();
                        break;
                    case 't':
                        e.preventDefault();
                        if (!this.isPTT) this.startPTT();
                        break;
                    case ' ':
                        e.preventDefault();
                        this.stop();
                        break;
                    case 'p':
                        e.preventDefault();
                        this.togglePlay();
                        break;
                    case 'i':
                        e.preventDefault();
                        this.elements.importFile.click();
                        break;
                    case 'e':
                        e.preventDefault();
                        this.export();
                        break;
                    case 'delete':
                        e.preventDefault();
                        this.eraseAll();
                        break;
                    case 'm':
                        e.preventDefault();
                        this.toggleTheme();
                        break;
                }
            }

            handleKeyboardUp(e) {
                if (e.key.toLowerCase() === 't' && this.isPTT) {
                    e.preventDefault();
                    this.stopPTT();
                }
            }

            async toggleRecord() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                if (this.isPlaying) {
                    this.stop();
                }

                // Move position to the end of existing audio before starting recording
                if (this.audioBuffer) {
                    this.currentPosition = this.audioBuffer.duration;
                    this.updatePositionSlider();
                    this.updateTimeLabels();
                }

                try {
                    this.mediaRecorder = new MediaRecorder(this.stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });

                    this.audioChunks = [];
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        this.processRecording();
                    };

                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.recordingStartTime = this.audioContext.currentTime;
                    this.recordingStartPosition = this.currentPosition;
                    this.updateStatus('Recording...');
                    this.updateUI();
                    this.startRecordingUpdate();
                } catch (error) {
                    console.error('Error starting recording:', error);
                    this.updateStatus('Recording failed');
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    this.stopRecordingUpdate();
                    this.updateStatus('Processing...');
                    this.updateUI(); // Update UI immediately when stopping
                }
            }

            startPTT() {
                if (!this.isPTT && !this.isRecording) {
                    // Stop playback if it's currently playing
                    if (this.isPlaying) {
                        this.pausePlayback();
                    }
                    
                    this.isPTT = true;
                    this.startRecording();
                    this.elements.pttBtn.classList.add('recording');
                }
            }

            stopPTT() {
                if (this.isPTT) {
                    this.isPTT = false;
                    this.stopRecording();
                    this.elements.pttBtn.classList.remove('recording');
                    // UI will be updated when processRecording completes
                }
            }

            async processRecording() {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                
                try {
                    // Convert to AudioBuffer
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const newAudioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    
                    // Append to existing audio
                    if (this.audioBuffer) {
                        this.audioBuffer = this.concatenateBuffers(this.audioBuffer, newAudioBuffer);
                    } else {
                        this.audioBuffer = newAudioBuffer;
                    }
                    
                    this.saveToCache();
                    this.updateStatus('Ready');
                    this.updateTimeLabels();
                    this.updateUI(); // Ensure UI updates after processing
                } catch (error) {
                    console.error('Error processing recording:', error);
                    this.updateStatus('Processing failed');
                    this.updateUI(); // Update UI even if processing fails
                }
            }

            concatenateBuffers(buffer1, buffer2) {
                const numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);
                const length = buffer1.length + buffer2.length;
                const sampleRate = buffer1.sampleRate;
                
                const result = this.audioContext.createBuffer(numberOfChannels, length, sampleRate);
                
                for (let channel = 0; channel < numberOfChannels; channel++) {
                    const output = result.getChannelData(channel);
                    const input1 = buffer1.getChannelData(channel);
                    const input2 = buffer2.getChannelData(channel);
                    
                    output.set(input1, 0);
                    output.set(input2, buffer1.length);
                }
                
                return result;
            }

            togglePlay() {
                if (this.isPlaying) {
                    this.pausePlayback();
                } else {
                    this.startPlayback();
                }
            }

            async startPlayback() {
                if (!this.audioBuffer || this.isRecording) return;

                try {
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    this.audioSource = this.audioContext.createBufferSource();
                    this.audioSource.buffer = this.audioBuffer;
                    
                    // Connect audio source to both gain node and analyser for meter display
                    this.audioSource.connect(this.gainNode);
                    
                    // Disconnect microphone from analyser and connect playback source
                    try {
                        this.microphoneSource.disconnect(this.analyser);
                    } catch (e) {
                        // Microphone might already be disconnected
                    }
                    this.audioSource.connect(this.analyser);

                    const startOffset = this.currentPosition;
                    this.audioSource.start(0, startOffset);
                    this.startTime = this.audioContext.currentTime - startOffset;
                    
                    this.audioSource.onended = () => {
                        if (this.isPlaying) {
                            this.stop();
                        }
                    };

                    this.isPlaying = true;
                    this.updateStatus('Playing');
                    this.updateUI();
                    this.startPositionUpdate();
                } catch (error) {
                    console.error('Error starting playback:', error);
                    this.updateStatus('Playback failed');
                }
            }

            async seekToPosition(position) {
                if (!this.audioBuffer || this.isRecording) return;

                const wasPlaying = this.isPlaying;
                this.currentPosition = position;

                if (wasPlaying) {
                    // Keep isPlaying true throughout the seeking process
                    // to prevent UI from flickering to pause state
                    
                    // Temporarily disable the onended callback to prevent automatic stop
                    if (this.audioSource && this.audioSource.onended) {
                        this.audioSource.onended = null;
                    }
                    
                    // Stop current playback
                    if (this.audioSource) {
                        try {
                            this.audioSource.stop();
                        } catch (e) {
                            // Source might already be stopped
                        }
                        this.audioSource = null;
                    }

                    try {
                        if (this.audioContext.state === 'suspended') {
                            await this.audioContext.resume();
                        }

                        this.audioSource = this.audioContext.createBufferSource();
                        this.audioSource.buffer = this.audioBuffer;
                        
                        // Connect audio source to both gain node and analyser for meter display
                        this.audioSource.connect(this.gainNode);
                        
                        // Disconnect microphone from analyser and connect playback source
                        try {
                            this.microphoneSource.disconnect(this.analyser);
                        } catch (e) {
                            // Microphone might already be disconnected
                        }
                        this.audioSource.connect(this.analyser);

                        const startOffset = this.currentPosition;
                        this.audioSource.start(0, startOffset);
                        this.startTime = this.audioContext.currentTime - startOffset;
                        
                        // Set the onended callback AFTER starting
                        this.audioSource.onended = () => {
                            if (this.isPlaying) {
                                this.stop();
                            }
                        };
                        
                        // Ensure we maintain playing state
                        this.isPlaying = true;
                        
                        // Make sure position updates continue
                        if (!this.animationFrame) {
                            this.startPositionUpdate();
                        }
                        
                    } catch (error) {
                        console.error('Error seeking during playback:', error);
                        this.updateStatus('Seek failed');
                        // If seeking fails, maintain the playing state
                        this.isPlaying = wasPlaying;
                    }
                }
                
                this.updateTimeLabels();
            }

            pausePlayback() {
                if (this.audioSource) {
                    // Disconnect playback source from analyser and reconnect microphone
                    try {
                        this.audioSource.disconnect(this.analyser);
                    } catch (e) {
                        // Source might already be disconnected
                    }
                    try {
                        this.microphoneSource.connect(this.analyser);
                    } catch (e) {
                        // Microphone might already be connected
                    }
                    
                    this.audioSource.stop();
                    this.audioSource = null;
                }
                this.currentPosition = this.getCurrentPosition();
                this.isPlaying = false;
                this.updateStatus('Paused');
                this.updateUI();
                this.stopPositionUpdate();
            }

            stop() {
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                if (this.isPlaying) {
                    this.pausePlayback();
                }
                
                if (this.isPTT) {
                    this.stopPTT();
                }
                
                // Ensure microphone is connected to analyser when stopped
                if (this.audioSource && this.microphoneSource) {
                    try {
                        this.audioSource.disconnect(this.analyser);
                    } catch (e) {
                        // Source might already be disconnected
                    }
                    try {
                        this.microphoneSource.connect(this.analyser);
                    } catch (e) {
                        // Microphone might already be connected
                    }
                }
                
                this.currentPosition = 0;
                this.updatePositionSlider();
                this.updateTimeLabels();
                this.updateStatus('Ready');
                this.updateUI();
            }

            onSliderInput(e) {
                if (this.audioBuffer) {
                    const position = (e.target.value / 100) * this.audioBuffer.duration;
                    
                    if (this.isPlaying) {
                        // Use seekToPosition to maintain playback state
                        this.seekToPosition(position);
                    } else {
                        // Just update position when not playing
                        this.currentPosition = position;
                        this.updateTimeLabels();
                    }
                }
            }

            updateVolume(e) {
                const volume = e.target.value / 100;
                this.gainNode.gain.value = volume;
                this.elements.volumeValue.textContent = `${e.target.value}%`;
                
                // Save volume to localStorage
                localStorage.setItem('dictaphone-volume', e.target.value);
            }

            getCurrentPosition() {
                if (this.isPlaying && this.audioContext && this.audioSource) {
                    return this.audioContext.currentTime - this.startTime;
                }
                return this.currentPosition;
            }

            startPositionUpdate() {
                const updatePosition = () => {
                    if (this.isPlaying) {
                        const position = this.getCurrentPosition();
                        if (!this.isDragging) {
                            this.updatePositionSlider();
                        }
                        this.updateTimeLabels();
                        this.animationFrame = requestAnimationFrame(updatePosition);
                    }
                };
                updatePosition();
            }

            startRecordingUpdate() {
                const updateRecording = () => {
                    if (this.isRecording) {
                        // Update the slider max to show growing audio length
                        const recordingDuration = this.audioContext.currentTime - this.recordingStartTime;
                        const newTotalDuration = this.recordingStartPosition + recordingDuration;
                        
                        // Update time labels to show the growing total duration
                        this.elements.currentTime.textContent = this.formatTime(this.currentPosition);
                        this.elements.totalTime.textContent = this.formatTime(newTotalDuration);
                        
                        // Update the slider max value but keep position at the recording start point
                        const percentage = this.audioBuffer ? 
                            (this.currentPosition / newTotalDuration) * 100 : 0;
                        this.elements.positionSlider.value = Math.min(percentage, 100);
                        
                        this.recordingAnimationFrame = requestAnimationFrame(updateRecording);
                    }
                };
                updateRecording();
            }

            stopRecordingUpdate() {
                if (this.recordingAnimationFrame) {
                    cancelAnimationFrame(this.recordingAnimationFrame);
                    this.recordingAnimationFrame = null;
                }
            }

            stopPositionUpdate() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
            }

            updatePositionSlider() {
                if (this.audioBuffer && !this.isDragging) {
                    const position = this.getCurrentPosition();
                    const percentage = (position / this.audioBuffer.duration) * 100;
                    this.elements.positionSlider.value = Math.min(percentage, 100);
                }
            }

            updateTimeLabels() {
                if (this.audioBuffer) {
                    const current = this.getCurrentPosition();
                    const total = this.audioBuffer.duration;
                    
                    this.elements.currentTime.textContent = this.formatTime(current);
                    this.elements.totalTime.textContent = this.formatTime(total);
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            startMeterAnimation() {
                const updateMeter = () => {
                    if (this.analyser && this.dataArray) {
                        this.analyser.getByteFrequencyData(this.dataArray);
                        
                        // Calculate average volume
                        let sum = 0;
                        for (let i = 0; i < this.dataArray.length; i++) {
                            sum += this.dataArray[i];
                        }
                        const average = sum / this.dataArray.length;
                        
                        // Convert to rotation (-90 to 90 degrees)
                        const rotation = (average / 255) * 180 - 90;
                        this.elements.meterNeedle.style.transform = `translateX(-50%) rotate(${rotation}deg)`;
                    }
                    requestAnimationFrame(updateMeter);
                };
                updateMeter();
            }

            async export() {
                if (!this.audioBuffer) {
                    this.updateStatus('No audio to export');
                    return;
                }

                try {
                    this.updateStatus('Exporting...');
                    
                    // Convert AudioBuffer to WAV
                    const wavBuffer = this.audioBufferToWav(this.audioBuffer);
                    const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                    
                    // Create download
                    const now = new Date();
                    const filename = `audio_${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}.wav`;
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.updateStatus('Exported successfully');
                } catch (error) {
                    console.error('Export error:', error);
                    this.updateStatus('Export failed');
                }
            }

            audioBufferToWav(buffer) {
                const length = buffer.length;
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * numberOfChannels * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numberOfChannels * 2, true);
                view.setUint16(32, numberOfChannels * 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * numberOfChannels * 2, true);
                
                // Convert audio data
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return arrayBuffer;
            }

            async import(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    this.updateStatus('Importing...');
                    
                    // Clear cached audio when importing - user expects fresh start
                    await this.clearCache();
                    
                    const arrayBuffer = await file.arrayBuffer();
                    this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.currentPosition = 0;
                    await this.saveToCache(); // Save to cache
                    this.updateStatus('Imported successfully');
                    this.updateTimeLabels();
                    this.updatePositionSlider();
                    this.updateUI(); // Ensure UI updates after import to enable buttons
                } catch (error) {
                    console.error('Import error:', error);
                    this.updateStatus('Import failed');
                }
                
                // Clear the file input
                event.target.value = '';
            }

            async eraseAll() {
                if (confirm('Are you sure you want to erase all audio? This cannot be undone.')) {
                    this.stop();
                    this.audioBuffer = null;
                    this.currentPosition = 0;
                    await this.clearCache();
                    this.updateStatus('Audio erased');
                    this.updateTimeLabels();
                    this.updatePositionSlider();
                    this.updateUI();
                }
            }

            async saveToCache() {
                if (this.audioBuffer) {
                    try {
                        // Convert AudioBuffer to WAV blob for caching
                        const wavBuffer = this.audioBufferToWav(this.audioBuffer);
                        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                        
                        // Create a response object to store in cache
                        const response = new Response(blob, {
                            headers: {
                                'Content-Type': 'audio/wav',
                                'Content-Length': blob.size.toString()
                            }
                        });
                        
                        // Open cache and store the audio
                        const cache = await caches.open('dictaphone-cache');
                        await cache.put('dictaphone-audio', response);
                        
                    } catch (error) {
                        console.warn('Error saving to cache:', error);
                        // Continue working normally, just without persistence
                    }
                }
            }

            async loadFromCache() {
                try {
                    const cache = await caches.open('dictaphone-cache');
                    const response = await cache.match('dictaphone-audio');
                    
                    if (response) {
                        this.updateStatus('Loading saved audio...');
                        const arrayBuffer = await response.arrayBuffer();
                        this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                        
                        this.updateTimeLabels();
                        this.updateStatus('Audio loaded from previous session');
                        this.updateUI();
                    }
                } catch (error) {
                    console.error('Error loading from cache:', error);
                    // Clear corrupted cache
                    await this.clearCache();
                }
            }

            loadVolumeFromStorage() {
                try {
                    const savedVolume = localStorage.getItem('dictaphone-volume');
                    if (savedVolume !== null) {
                        const volumeValue = parseInt(savedVolume, 10);
                        if (volumeValue >= 0 && volumeValue <= 100) {
                            this.elements.volumeSlider.value = volumeValue;
                            this.elements.volumeValue.textContent = `${volumeValue}%`;
                            this.gainNode.gain.value = volumeValue / 100;
                        }
                    }
                } catch (error) {
                    console.error('Error loading volume from storage:', error);
                    // Use default volume if loading fails
                }
            }

            async clearCache() {
                try {
                    const cache = await caches.open('dictaphone-cache');
                    await cache.delete('dictaphone-audio');
                } catch (error) {
                    console.error('Error clearing cache:', error);
                }
            }

            initializeTheme() {
                const savedTheme = localStorage.getItem('dictaphone-theme');
                if (savedTheme && ['light', 'dark'].includes(savedTheme)) {
                    // Explicit theme was saved
                    this.currentThemeMode = savedTheme;
                    document.body.setAttribute('data-theme', savedTheme);
                    this.updateThemeIcon(savedTheme);
                } else {
                    // Default to system preference
                    this.currentThemeMode = 'system';
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const theme = prefersDark ? 'dark' : 'light';
                    document.body.setAttribute('data-theme', theme);
                    this.updateThemeIcon('system');
                }
                
                // Listen for system theme changes
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                mediaQuery.addEventListener('change', (e) => {
                    if (this.currentThemeMode === 'system') {
                        document.body.setAttribute('data-theme', e.matches ? 'dark' : 'light');
                    }
                });
            }

            toggleTheme() {
                // Cycle through: system -> light -> dark -> system
                if (this.currentThemeMode === 'system') {
                    this.currentThemeMode = 'light';
                    document.body.setAttribute('data-theme', 'light');
                    this.updateThemeIcon('light');
                    localStorage.setItem('dictaphone-theme', 'light');
                } else if (this.currentThemeMode === 'light') {
                    this.currentThemeMode = 'dark';
                    document.body.setAttribute('data-theme', 'dark');
                    this.updateThemeIcon('dark');
                    localStorage.setItem('dictaphone-theme', 'dark');
                } else {
                    this.currentThemeMode = 'system';
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    document.body.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
                    this.updateThemeIcon('system');
                    localStorage.removeItem('dictaphone-theme'); // Remove explicit theme to use system
                }
            }

            updateThemeIcon(mode) {
                const icons = {
                    'system': 'üåì', // Half moon for system (auto)
                    'light': '‚òÄÔ∏è',  // Sun for light mode
                    'dark': 'üåô'    // Crescent moon for dark mode
                };
                this.elements.themeToggle.textContent = icons[mode] || icons.system;
                
                // Update title to show current mode
                const titles = {
                    'system': 'Theme: System (Auto)',
                    'light': 'Theme: Light', 
                    'dark': 'Theme: Dark'
                };
                this.elements.themeToggle.title = titles[mode] || titles.system;
            }

            updateStatus(message) {
                this.elements.status.textContent = message;
                this.elements.status.className = 'status';
                
                if (message === 'Recording...') {
                    this.elements.status.classList.add('recording');
                } else if (message === 'Playing') {
                    this.elements.status.classList.add('playing');
                }
            }

            updateUI() {
                // Update button states - Record button should only show as recording for regular recording, not PTT
                this.elements.recordBtn.classList.toggle('recording', this.isRecording && !this.isPTT);
                this.elements.playBtn.textContent = this.isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
                
                // Disable slider only during recording, not during playback
                this.elements.positionSlider.disabled = this.isRecording;
                
                // Update button availability
                const hasAudio = !!this.audioBuffer;
                this.elements.playBtn.disabled = !hasAudio || this.isRecording;
                this.elements.exportBtn.disabled = !hasAudio;
                this.elements.eraseBtn.disabled = !hasAudio;
                
                // PTT visual feedback
                if (this.isPTT && this.isRecording) {
                    this.elements.pttBtn.classList.add('recording');
                } else {
                    this.elements.pttBtn.classList.remove('recording');
                }
            }
        }

        // Initialize the dictaphone when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new Dictaphone();
        });
    </script>
</body>
</html>
