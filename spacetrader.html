<!DOCTYPE html>
<html lang="en" data-theme="system">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Space Trader - Retro Space Trading Adventure</title>
  <meta name="description" content="Pilot your ship through an infinite procedural universe of trade and adventure" />
  <meta name="color-scheme" content="light dark" />
  <link rel="icon" href="favicon.ico" />
  <style>
    * { box-sizing: border-box; }
    
    body {
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
      background: #000;
      color: #00ff00;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      user-select: none;
      -webkit-user-select: none;
    }
    body.modal-open { overflow: hidden; }
    
    .container {
      position: relative;
      width: 100vw;
      min-height: 100vh;
      height: auto;
      background: radial-gradient(circle at center, #001122 0%, #000000 70%);
    }
    
    .back-button {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
    }
    
    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(0, 255, 0, 0.1);
      color: #00ff00;
      text-decoration: none;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      transition: all 0.2s ease;
      border: 1px solid rgba(0, 255, 0, 0.3);
    }
    
    .back-link:hover {
      background: rgba(0, 255, 0, 0.2);
      transform: translateX(-2px);
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
    }
    
    /* Cockpit Layout */
    .cockpit-grid {
      position: relative;
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-areas:
        "topbar"
        "viewport"
        "deck";
      grid-template-rows: auto 1fr auto;
      grid-template-columns: 1fr;
    }

    .topbar {
      grid-area: topbar;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      gap: 20px;
      padding: 10px 16px 0 16px;
      color: #00ff99;
      font-size: 12px;
      text-transform: uppercase;
    }
    .topbar .stat { display: inline-flex; gap: 6px; align-items: center; }
    .topbar .value { color: #ffff66; font-weight: bold; }
    .topbar-actions { margin-left: auto; display: flex; gap: 8px; flex-wrap: wrap; }
    
    .viewport {
      grid-area: viewport;
      position: relative;
      background: #000011;
      border: 3px solid #00ff00;
      border-radius: 10px;
      margin: 20px;
      min-height: clamp(240px, 45vh, 640px);
      overflow: hidden;
      box-shadow: inset 0 0 50px rgba(0, 255, 0, 0.2);
    }
    
    .viewport-content {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      perspective: 800px;
    }
    
    .planet-view {
      width: min(45vmin, 360px);
      height: min(45vmin, 360px);
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #4488cc, #1155aa, #002244);
      box-shadow: 
        inset -20px -20px 40px rgba(0, 0, 0, 0.5),
        0 0 50px rgba(68, 136, 204, 0.3);
      position: relative;
      animation: planetRotate 20s linear infinite;
    }

    .planet-view.turning {
      animation: turnAway 4s ease forwards;
    }

    @keyframes turnAway {
      0% { transform: rotateY(0deg) scale(1); opacity: 1; }
      100% { transform: rotateY(90deg) scale(0.85); opacity: 0.6; }
    }
    
    .planet-surface {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: 
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.1) 5%, transparent 15%),
        radial-gradient(circle at 60% 40%, rgba(0, 100, 200, 0.3) 8%, transparent 20%),
        radial-gradient(circle at 80% 70%, rgba(100, 200, 100, 0.2) 6%, transparent 18%);
    }
    
    @keyframes planetRotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .space-view {
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(2px 2px at 20px 30px, #fff, transparent),
        radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.5), transparent),
        radial-gradient(1px 1px at 90px 40px, #fff, transparent),
        radial-gradient(1px 1px at 130px 80px, rgba(255,255,255,0.5), transparent),
        radial-gradient(2px 2px at 160px 30px, #fff, transparent);
      background-repeat: repeat;
      background-size: 200px 100px;
      animation: starsMove 30s linear infinite;
    }
    
    @keyframes starsMove {
      from { background-position: 0 0; }
      to { background-position: 200px 100px; }
    }
    
    .warp-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
      animation: warpLines 0.5s ease-in-out infinite;
      opacity: 0;
    }
    
    .warp-effect.active {
      opacity: 1;
    }
    
    @keyframes warpLines {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    /* Bottom Control Deck */
    .deck { grid-area: deck; padding: 10px 16px 16px; }
  .deck-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .deck-section { background: linear-gradient(145deg, #002200, #001100); border: 2px solid #00aa00; border-radius: 10px; padding: 10px; }
    .deck-title { color: #00ff00; font-size: 12px; font-weight: bold; text-align: center; margin-bottom: 8px; text-transform: uppercase; }
    
    .button {
      width: 100%;
      padding: 8px;
      margin: 3px 0;
      background: linear-gradient(145deg, #003300, #001a00);
      border: 2px solid #00aa00;
      border-radius: 5px;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
    }
    
    .button:hover {
      background: linear-gradient(145deg, #004400, #002200);
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
      transform: translateY(-1px);
    }
    
    .button:active {
      transform: translateY(0);
      box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
    }
    
    .button.danger {
      border-color: #aa0000;
      color: #ff0000;
    }
    
    .button.danger:hover {
      background: linear-gradient(145deg, #440000, #220000);
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
    }
    
    .switch {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 5px 0;
      font-size: 10px;
    }
    
    .switch-toggle {
      width: 40px;
      height: 20px;
      background: #002200;
      border: 1px solid #00aa00;
      border-radius: 10px;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .switch-toggle.on {
      background: #004400;
    }
    
    .switch-knob {
      width: 16px;
      height: 16px;
      background: #00ff00;
      border-radius: 50%;
      position: absolute;
      top: 1px;
      left: 2px;
      transition: all 0.3s ease;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    }
    
    .switch-toggle.on .switch-knob {
      left: 20px;
    }
    
    .credits-display {
      color: #ffff00;
      font-weight: bold;
      text-align: center;
      margin: 5px 0;
    }
    
    .cargo-display {
      background: #001100;
      border: 1px solid #00aa00;
      border-radius: 5px;
      padding: 5px;
      margin: 5px 0;
      min-height: 80px;
      font-size: 9px;
    }
    
    .cargo-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 2px;
      margin-top: 5px;
    }
    
    .cargo-slot {
      width: 20px;
      height: 20px;
      border: 1px solid #004400;
      border-radius: 2px;
      background: #000800;
      transition: all 0.2s ease;
    }
    
    .cargo-slot.filled {
      background: #00aa00;
      box-shadow: 0 0 5px rgba(0, 170, 0, 0.5);
      position: relative;
    }

    .cargo-slot.filled::after {
      content: '';
      position: absolute;
      inset: 2px;
      border-radius: 1px;
      border: 1px solid rgba(0,0,0,0.4);
    }
    
    .system-map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: flex-start;
      flex-direction: column;
      padding-top: 16px;
    }
    
    .system-map.active { display: flex; }
    
    .map-container {
      width: 80%;
      height: 70%;
      border: 2px solid #00ff00;
      border-radius: 10px;
      background: rgba(0, 20, 0, 0.5);
      position: relative;
      overflow: hidden;
      margin: 0 auto;
    }
    /* System map primitives */
    .system-center {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 40%, #ffffaa, #ffaa00, #552200);
      border: 2px solid #00ff00;
      box-shadow: 0 0 20px rgba(255, 255, 100, 0.5);
      pointer-events: none;
    }
    .orbit-ring {
      position: absolute;
      border: 1px dashed rgba(0, 255, 0, 0.35);
      border-radius: 50%;
      pointer-events: none;
    }
    .planet-icon {
      position: absolute;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      border: 2px solid #004400;
      box-shadow: 0 0 6px rgba(0, 255, 0, 0.4);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .planet-icon:hover { transform: scale(1.3); box-shadow: 0 0 10px rgba(0,255,0,0.6); }
    
    .planet-icon.current {
      border-color: #ffff00;
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
    }

    /* You-are-here reticule */
    .here-reticule {
      position: absolute;
      width: 42px;
      height: 42px;
      border: 2px solid #ffff66;
      border-radius: 50%;
      box-shadow: 0 0 16px rgba(255, 255, 120, 0.9);
      pointer-events: none;
      z-index: 20;
      animation: herePulse 1.6s ease-out infinite;
    }
    .here-reticule::after {
      content: '';
      position: absolute;
      inset: 6px;
      border: 1px dashed rgba(255, 255, 120, 0.9);
      border-radius: 50%;
    }
    @keyframes herePulse {
      0% { transform: scale(0.95); opacity: 0.9; }
      60% { transform: scale(1.05); opacity: 0.6; }
      100% { transform: scale(1.0); opacity: 0.9; }
    }
    
    .trade-interface {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      align-items: flex-start;
      justify-content: center;
      padding: 24px 12px;
      overflow-y: auto;
      z-index: 2000;
    }
    
    .trade-interface.active {
      display: flex;
    }
    
    .trade-panel {
      width: min(900px, 92vw);
      background: linear-gradient(145deg, #002200, #001100);
      border: 3px solid #00aa00;
      border-radius: 15px;
      padding: 16px;
      overflow: visible;
    }
    
    .trader-info {
      text-align: center;
      margin-bottom: 20px;
      color: #00ff00;
    }
    
    .trade-items {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .trade-section {
      border: 1px solid #004400;
      border-radius: 8px;
      padding: 10px;
    }
    
    .trade-item {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
      padding: 6px 8px;
      margin: 4px 0;
      background: rgba(0, 20, 0, 0.5);
      border-radius: 3px;
      font-size: 11px;
    }
    
    .item-name { color: #00ff00; }
    .item-price { color: #ffff00; }
    .item-quantity { color: #00aaaa; }
  .trade-item .item-name { flex: 1 1 160px; min-width: 120px; }
  .trade-item .item-quantity, .trade-item .item-price, .trade-item .item-meta { flex: 0 0 auto; }
  .trade-item .button { width: auto; padding: 4px 8px; }
  .trade-item .trade-action { flex: 0 0 72px; margin-left: auto; text-align: center; }
    .item-meta { color: #00ff99; font-size: 10px; margin-left: 8px; }
    .price-up { color: #66ff66; font-weight: bold; }
    .price-down { color: #ff6666; font-weight: bold; }
    .profit { color: #aaffaa; font-weight: bold; margin-left: 8px; }
    .loss { color: #ff8888; font-weight: bold; margin-left: 8px; }
    .trade-log { border: 1px solid #004400; border-radius: 8px; padding: 8px; background: rgba(0, 20, 0, 0.4); max-height: 160px; overflow-y: auto; font-size: 11px; color: #aaffaa; }
    .trade-log .entry { margin: 4px 0; }
    .trade-log .sys { color: #66ffcc; }

    @media (max-width: 760px) {
      .trade-items { grid-template-columns: 1fr; }
      .trade-log { max-height: 140px; }
      .trade-interface { padding: 16px 8px; }
      .trade-item .trade-action { flex-basis: 64px; }
    }
    
    .haggle-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
    }
    
    .travel-animation {
      position: fixed;
      inset: 0;
      background: #000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: 24px 12px;
      z-index: 2500;
      overflow: hidden;
    }
    
    .travel-animation.active {
      display: flex;
    }
    .travel-hud { 
      display: flex; 
      flex-wrap: wrap; 
      align-items: center; 
      justify-content: center; 
      gap: 12px 16px; 
      width: min(92vw, 1000px);
      margin: 0 auto;
    }
    
    .travel-text {
      color: #00ff00;
      font-size: clamp(16px, 4vw, 28px);
      text-align: center;
      margin: 0 8px 8px 8px;
      padding: 0 8px;
      flex: 1 1 300px;
      animation: pulse 2s ease-in-out infinite;
    }
    
    .travel-progress {
      width: min(520px, 90vw);
      height: clamp(14px, 2.5vh, 20px);
      border: 2px solid #00ff00;
      border-radius: 10px;
      overflow: hidden;
      background: rgba(0, 50, 0, 0.3);
      margin: 0 8px;
      flex: 1 1 320px;
    }
    
    .travel-bar {
      height: 100%;
      background: linear-gradient(90deg, #00ff00, #00aa00);
      width: 0%;
      transition: width 0.5s ease;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .hidden { display: none !important; }

    /* Planet Details (with moons) */
    .planet-details {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      display: none; align-items: center; justify-content: center; flex-direction: column;
    }
    .planet-details.active { display: flex; }
    .planet-card { width: 520px; max-width: 90vw; background: #001700; border: 2px solid #00aa00; border-radius: 12px; padding: 16px; }
    .moons-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
    .moon-chip { padding: 6px 10px; border: 1px solid #00aa00; border-radius: 999px; cursor: pointer; background: #002200; color: #00ff00; font-size: 12px; }
    .moon-chip:hover { background: #003300; }

    /* Galaxy Map */
  .galaxy-map { position: absolute; inset: 0; background: rgba(0,0,0,0.95); display: none; align-items: center; justify-content: flex-start; flex-direction: column; padding-top: 16px; }
  .galaxy-map.active { display: flex; }
  .galaxy-container { width: 85%; height: 70%; border: 2px solid #00ff00; border-radius: 10px; background: #000; position: relative; overflow: hidden; touch-action: none; }
  .galaxy-stage { position: absolute; inset: 0; transform-origin: 0 0; }
  .galaxy-canvas { position: absolute; inset: 0; }
    .system-node { position: absolute; width: 14px; height: 14px; border-radius: 50%; background: #00ff00; border: 2px solid #004400; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; }
    .system-node:hover { transform: scale(1.4); box-shadow: 0 0 12px rgba(0,255,0,0.7); }
    .system-node.current { background: #ffff00; box-shadow: 0 0 14px rgba(255,255,0,0.8); }
    .node-label { position: absolute; transform: translate(-50%, 14px); color: #00ff99; font-size: 10px; white-space: nowrap; }

    /* Mobile-friendly galaxy map sizing and targets */
    @media (max-width: 760px) {
      .galaxy-container { width: 96vw; height: 70vh; }
      .system-node { width: 20px; height: 20px; }
      .node-label { font-size: 11px; }
    }

    /* Cargo beam effect */
    .beam-overlay { position: absolute; inset: 0; pointer-events: none; display: none; }
    .beam-overlay.active { display: block; }
    .beam { position: absolute; left: 50%; top: 0; width: 6px; height: 100%; background: linear-gradient(180deg, rgba(0,255,200,0.0), rgba(0,255,200,0.6), rgba(0,255,200,0.0)); transform: translateX(-50%); animation: beamPulse 0.5s ease-in-out infinite; box-shadow: 0 0 12px rgba(0,255,200,0.6); }
    @keyframes beamPulse { 0%,100% { opacity: 0.3 } 50% { opacity: 1 } }
    
    @media (max-width: 900px) {
      .deck-grid { grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 600px) {
      .deck-grid { grid-template-columns: 1fr; }
      .system-map { padding-top: 8px; }
      .map-container { width: 96vw; height: 70vh; }
      .galaxy-map { padding-top: 8px; }
      .button { font-size: 10px; padding: 6px; }
      .viewport { margin: 10px; }
      .topbar { gap: 10px; }
      .topbar .stat { flex: 1 1 45%; justify-content: center; }
      .topbar-actions { margin-left: 0; width: 100%; justify-content: center; }
    }
  </style>
</head>
<body>
  <div class="container">
    

    <div class="cockpit-grid">
      <div class="topbar">
        <div class="stat">System: <span id="currentSystem" class="value">Sol</span></div>
        <div class="stat">Body: <span id="currentPlanet" class="value">Earth</span></div>
        <div class="stat">Credits: <span id="creditsAmount" class="value">10000</span></div>
        <div class="stat">Fuel: <span id="fuelLevel" class="value">85%</span></div>
        <div class="topbar-actions">
          <button class="button danger" style="padding:4px 8px; width:auto;" onclick="game.newGame()">New Game</button>
        </div>
      </div>

      <!-- Main Viewport -->
      <div class="viewport">
        <div class="viewport-content">
          <div class="planet-view" id="planetView">
            <div class="planet-surface"></div>
          </div>
          <div class="space-view hidden" id="spaceView"></div>
          <div class="warp-effect" id="warpEffect"></div>
          <div class="beam-overlay" id="beamOverlay"><div class="beam"></div></div>
        </div>
      </div>
      <div class="deck">
        <div class="deck-grid">
          <div class="deck-section">
            <div class="deck-title">Navigation</div>
            <button class="button" onclick="game.showSystemMap()">System Map</button>
            <button class="button" onclick="game.showGalaxyMap()">Galaxy Map</button>
          </div>
          <div class="deck-section">
            <div class="deck-title">Communications</div>
            <button class="button" onclick="game.openTradeInterface()">Open Trade Comm</button>
            <button class="button" onclick="game.downloadTradeData()">Download Trade Data</button>
            <button class="button" onclick="game.refuel()">Refuel</button>
          </div>
          <div class="deck-section">
            <div class="deck-title">Systems & Cargo</div>
            <div class="switch" style="margin-bottom:6px;">
              <span>A-Grav</span>
              <div class="switch-toggle on" onclick="game.toggleSystem('agrav', event)">
                <div class="switch-knob"></div>
              </div>
            </div>
            <div class="cargo-display">
              <div id="cargoSummary">Cargo Bay (0/50)</div>
              <div class="cargo-grid" id="cargoGrid"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- System Map Overlay -->
    <div class="system-map" id="systemMap">
      <div class="map-container">
        <div class="system-center"></div>
        <!-- Orbit rings and planets will be generated here -->
      </div>
      <button class="button" onclick="game.closeSystemMap()" style="margin-top: 20px;">Close Map</button>
    </div>

    <!-- Planet Details (with moons) -->
    <div class="planet-details" id="planetDetails">
      <div class="planet-card">
        <div class="panel-title" id="planetDetailsTitle">Planet Details</div>
        <div id="planetDetailsInfo" style="font-size:12px; color:#00ff99;"></div>
        <div style="margin-top:10px; color:#00ff00; font-weight:bold;">Moons</div>
        <div class="moons-list" id="moonsList"></div>
        <div style="text-align:center; margin-top: 12px;">
          <button class="button" onclick="game.closePlanetDetails()">Close</button>
        </div>
      </div>
    </div>

    <!-- Galaxy Map Overlay -->
    <div class="galaxy-map" id="galaxyMap">
      <div class="galaxy-container">
        <div id="galaxyStage" class="galaxy-stage">
          <canvas id="galaxyCanvas" class="galaxy-canvas"></canvas>
          <!-- Nodes will be added dynamically into the stage -->
        </div>
      </div>
      <div id="routeInfo" style="margin-top:10px; color:#00ff99; font-size:12px; text-align:center;"></div>
      <button class="button" onclick="game.closeGalaxyMap()" style="margin-top: 20px;">Close Galaxy Map</button>
    </div>

    <!-- Trade Interface Overlay -->
    <div class="trade-interface" id="tradeInterface">
      <div class="trade-panel">
        <div class="trader-info">
          <h3 id="traderName">Captain Zylox Veridian</h3>
          <p id="traderShip">"Stellar Wanderer" - Independent Trader</p>
          <div id="playerCreditsInTrade" style="margin-top:6px; color:#ffff66; font-weight:bold;">Credits: 0₵</div>
        </div>
        
        <div class="trade-items">
          <div class="trade-section">
            <h4 style="color: #00ff00;">Buying From Trader</h4>
            <div id="buyingItems"></div>
          </div>
          
          <div class="trade-section">
            <h4 style="color: #00ff00;">Selling To Trader</h4>
            <div id="sellingItems"></div>
          </div>
        </div>

        <div class="trade-section" style="margin-bottom: 12px;">
          <h4 style="color:#00ff00;">Comm Log</h4>
          <div id="tradeLog" class="trade-log"></div>
        </div>
        
        <div class="haggle-controls">
          <button class="button" onclick="game.haggle('charm')">Charm</button>
          <button class="button" onclick="game.haggle('intimidate')">Intimidate</button>
          <button class="button" onclick="game.haggle('logic')">Logic</button>
          <button class="button" onclick="game.haggle('desperate')">Desperate Plea</button>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
          <button class="button" onclick="game.closeTradeInterface()">End Transmission</button>
        </div>
      </div>
    </div>

    <!-- Travel Animation Overlay -->
    <div class="travel-animation" id="travelAnimation">
      <div class="travel-hud">
        <div class="travel-text" id="travelText">Engaging Warp Drive...</div>
        <div class="travel-progress">
          <div class="travel-bar" id="travelBar"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Seeded Random Number Generator
    class SeededRNG {
      constructor(seed = 12345) {
        this.seed = seed;
      }
      
      next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
      }
      
      nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
      }
      
      choice(array) {
        return array[Math.floor(this.next() * array.length)];
      }
    }

    // Game Engine
    class SpaceTraderGame {
      constructor() {
        this.rng = new SeededRNG(42); // Same seed every time
        this.credits = 10000;
        this.fuel = 85;
        this.cargoCapacity = 50;
        this.currentCargo = 0;
        this.cargo = []; // aggregated counts per item
        this.cargoSlots = new Array(this.cargoCapacity).fill(null); // physical crates
        this.itemVolumes = {
          'Water': 2,
          'Electronics': 1,
          'Rare Metals': 3,
          'Food': 1,
          'Fuel Cells': 2,
          'Medical Supplies': 1,
          'Textiles': 1,
          'Machinery': 4,
          'Gems': 1,
          'Spices': 1,
          'Art Objects': 2,
          'Weapons': 3,
          'Tools': 1,
          'Computers': 2,
          'Biomatter': 2
        };
        
    // Galaxy: deterministic coordinate-based without caching
    this.galaxySeed = 4242; // controls galaxy naming randomness
    this.currentCoords = { x: 0, y: 0 }; // Sol at (0,0)
    this.currentSystem = this.getSystemAt(0, 0);
    this.currentPlanetIndex = 0;
    this.currentMoonIndex = null; // null means at planet, number for moon
        
        // Game state
        this.systems = new Map();
        this.isTrading = false;
        this.currentTrader = null;
        // Transaction history: { [itemName]: { buys: number[], avgCost: number } }
        this.txHistory = {};
        
        // Load save or initialize new game
        if (!this.loadGame()) {
          this.initializeGame();
        }
        this.generateCargoGrid();
        this.updateUI();

        // Keyboard controls
        document.addEventListener('keydown', (e) => this.handleKey(e));
        // Resize galaxy canvas if open
        window.addEventListener('resize', () => this.resizeGalaxyCanvas());
        // Safety autosave when tab is hidden or page is being unloaded
        document.addEventListener('visibilitychange', () => { if (document.hidden) this.saveGame(); });
        window.addEventListener('pagehide', () => this.saveGame());
      }
      
      initializeGame() {
        // Generate some initial nearby systems around (0,0)
        const coordsList = [
          {x:0,y:0},{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
        ];
        coordsList.forEach(c => {
          const sys = this.getSystemAt(c.x, c.y);
          this.systems.set(sys.name, sys);
        });
        
        // Add some initial cargo
        const initialCargo = [
          { name: 'Water', quantity: 5 },
          { name: 'Electronics', quantity: 4 },
          { name: 'Rare Metals', quantity: 2 }
        ];
        initialCargo.forEach(({name, quantity}) => {
          for (let i = 0; i < quantity; i++) this.addCrate(name);
        });
      }
      
      generateSystem(name, seedOffset) {
        const systemRng = new SeededRNG(42 + seedOffset * 1000);
        const planetCount = systemRng.nextInt(3, 8);
        const planets = [];
        
        for (let i = 0; i < planetCount; i++) {
          planets.push(this.generatePlanet(systemRng, i));
        }
        
        return {
          name: name,
          planets: planets,
          discovered: name === 'Sol'
        };
      }
      
      generatePlanet(rng, index) {
        const planetTypes = ['Rocky', 'Gas Giant', 'Ice World', 'Desert', 'Ocean', 'Volcanic'];
        const type = rng.choice(planetTypes);
        const colors = {
          'Rocky': ['#8B4513', '#CD853F', '#A0522D'],
          'Gas Giant': ['#4169E1', '#6495ED', '#87CEEB'],
          'Ice World': ['#E0FFFF', '#B0E0E6', '#F0F8FF'],
          'Desert': ['#DAA520', '#F4A460', '#CD853F'],
          'Ocean': ['#008B8B', '#20B2AA', '#48D1CC'],
          'Volcanic': ['#DC143C', '#B22222', '#8B0000']
        };
        
        const planet = {
          name: `${type} ${String.fromCharCode(65 + index)}`,
          type: type,
          color: rng.choice(colors[type]),
          distance: (index + 1) * 50 + rng.nextInt(-10, 10),
          tradingPost: rng.next() > 0.3,
          population: rng.nextInt(1000, 10000000),
          resources: this.generateResources(rng),
          trader: rng.next() > 0.4 ? this.generateTrader(rng) : null,
          moons: []
        };

        const moonCount = rng.nextInt(0, 3);
        for (let i = 0; i < moonCount; i++) {
          planet.moons.push(this.generateMoon(rng, i));
        }
        return planet;
      }

      generateMoon(rng, index) {
        // Smaller body with fewer resources
        const greek = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon'];
        const name = `Moon ${greek[index % greek.length]}`;
        return {
          name,
          color: rng.choice(['#888888', '#AAAAAA', '#777777', '#999999']),
          tradingPost: rng.next() > 0.5,
          population: rng.nextInt(10, 50000),
          resources: this.generateResources(rng),
          trader: rng.next() > 0.5 ? this.generateTrader(rng) : null
        };
      }
      
      generateResources(rng) {
        const allResources = [
          'Water', 'Food', 'Electronics', 'Rare Metals', 'Fuel Cells',
          'Medical Supplies', 'Textiles', 'Machinery', 'Gems', 'Spices',
          'Art Objects', 'Weapons', 'Tools', 'Computers', 'Biomatter'
        ];
        
        const resources = {};
        const resourceCount = rng.nextInt(5, 12);
        
        for (let i = 0; i < resourceCount; i++) {
          const resource = rng.choice(allResources);
          if (!resources[resource]) {
            resources[resource] = {
              buyPrice: rng.nextInt(100, 2000),
              sellPrice: rng.nextInt(50, 1500),
              available: rng.nextInt(1, 50),
              demand: rng.nextInt(1, 30)
            };
          }
        }
        
        return resources;
      }
      
      generateTrader(rng) {
        const consonants = ['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Z'];
        const vowels = ['a', 'e', 'i', 'o', 'u', 'y'];
        
        let name = '';
        const nameLength = rng.nextInt(2, 4);
        for (let i = 0; i < nameLength; i++) {
          name += rng.choice(consonants).toLowerCase();
          name += rng.choice(vowels);
        }
        name = name.charAt(0).toUpperCase() + name.slice(1);
        
        const shipNames = ['Wanderer', 'Seeker', 'Voyager', 'Explorer', 'Drifter', 'Nomad', 'Pioneer'];
        const shipAdjectives = ['Stellar', 'Cosmic', 'Void', 'Star', 'Galactic', 'Nebula', 'Solar'];
        
        return {
          name: `Captain ${name}`,
          ship: `${rng.choice(shipAdjectives)} ${rng.choice(shipNames)}`,
          personality: rng.choice(['friendly', 'suspicious', 'greedy', 'honest', 'eccentric']),
          haggleSkill: rng.nextInt(1, 10),
          reputation: rng.nextInt(1, 100)
        };
      }
      
      generateCargoGrid() {
        const grid = document.getElementById('cargoGrid');
        grid.innerHTML = '';
        
        for (let i = 0; i < this.cargoCapacity; i++) {
          const slot = document.createElement('div');
          slot.className = 'cargo-slot';
          const s = this.cargoSlots[i];
          if (s) {
            slot.classList.add('filled');
            slot.style.background = this.colorForItem(s.name);
            slot.title = s.name;
          }
          grid.appendChild(slot);
        }
      }
      
      updateUI() {
        const sysEl = document.getElementById('currentSystem');
        if (sysEl) sysEl.textContent = this.currentSystem.name;
        const bodyLabel = this.currentMoonIndex === null
          ? this.currentSystem.planets[this.currentPlanetIndex].name
          : `${this.currentSystem.planets[this.currentPlanetIndex].name} / ${this.currentSystem.planets[this.currentPlanetIndex].moons[this.currentMoonIndex].name}`;
        const bodyEl = document.getElementById('currentPlanet');
        if (bodyEl) bodyEl.textContent = bodyLabel;
        const creditsEl = document.getElementById('creditsAmount');
        if (creditsEl) creditsEl.textContent = this.credits;
        const fuelEl = document.getElementById('fuelLevel');
        if (fuelEl) fuelEl.textContent = `${this.fuel}%`;
  const cargoSummary = document.getElementById('cargoSummary');
  if (cargoSummary) cargoSummary.textContent = `Cargo Bay (${this.currentCargo}/${this.cargoCapacity})`;
        
        // Update planet view (or moon color)
        const planet = this.currentSystem.planets[this.currentPlanetIndex];
        const bodyColor = this.currentMoonIndex === null ? planet.color : (planet.moons[this.currentMoonIndex]?.color || planet.color);
        const planetView = document.getElementById('planetView');
        if (planetView) {
          planetView.style.background = `radial-gradient(circle at 30% 30%, ${bodyColor}, ${this.darkenColor(bodyColor)}, #000022)`;
        }
        
        // Update signal strength and trader status
        const hasTrader = (this.currentMoonIndex === null ? planet.trader : planet.moons[this.currentMoonIndex]?.trader) !== null && (this.currentMoonIndex === null ? planet.trader : planet.moons[this.currentMoonIndex]?.trader) !== undefined;
        const sigEl = document.getElementById('signalStrength');
        if (sigEl) sigEl.textContent = hasTrader ? '████████░░' : '███░░░░░░░';
        const traderEl = document.getElementById('traderStatus');
        if (traderEl) traderEl.textContent = hasTrader ? 'Yes' : 'No';
        
        this.generateCargoGrid();
      }
      
      darkenColor(color) {
        // Simple color darkening
        const hex = color.replace('#', '');
        const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - 50);
        const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - 50);
        const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - 50);
        return `rgb(${r}, ${g}, ${b})`;
      }
      
      // Navigation Functions
      showSystemMap() {
        const systemMap = document.getElementById('systemMap');
        // Make overlay visible before measuring for accurate sizes
        systemMap.classList.add('active');
        const mapContainer = systemMap.querySelector('.map-container');

  // Clear existing planets, rings, and reticule
  mapContainer.querySelectorAll('.orbit-ring, .planet-icon, .here-reticule').forEach(el => el.remove());

        // Geometry and layout
        const rect = mapContainer.getBoundingClientRect();
        const W = rect.width || mapContainer.clientWidth;
        const H = rect.height || mapContainer.clientHeight;
  const padding = 24; // keep content off the edges
  const starRadius = 15; // .system-center 30px diameter
  const iconHalf = 7.5; // half of 15px

        // Sun at top-left with padding
        const sunX = padding + starRadius;
        const sunY = padding + starRadius;

  // Furthest planet should land at the bottom-right corner (icons fully visible),
  // allow orbit rings to clip outside the frame.
  const targetX = W - padding - iconHalf;
  const targetY = H - padding - iconHalf;
  const vecX = targetX - sunX;
  const vecY = targetY - sunY;
  const maxRadius = Math.hypot(vecX, vecY);

        // Reposition the star element
        const star = mapContainer.querySelector('.system-center');
        if (star) {
          star.style.left = `${sunX - starRadius}px`;
          star.style.top = `${sunY - starRadius}px`;
          star.style.transform = 'none';
        }

        // Determine scaling based on planet "distance" metadata
        const planets = this.currentSystem.planets.slice();
        if (planets.length === 0) return;
        const distances = planets.map(p => Math.max(1, p.distance || 1));
        const minD = Math.min(...distances);
        const maxD = Math.max(...distances);
        const inner = starRadius + 16; // smallest orbit gap from the star

        // Direction from sun to bottom-right corner (unit vector)
  const dirLen = maxRadius || 1;
  const ux = vecX / dirLen;
  const uy = vecY / dirLen;

        // Draw rings and place planets along the diagonal from sun to bottom-right
  let currentIconPos = null;
  planets.forEach((planet, index) => {
          const raw = Math.max(1, planet.distance || (minD + index + 1));
          const t = maxD > minD ? (raw - minD) / (maxD - minD) : (index + 1) / (planets.length + 1);
          const radius = inner + t * (maxRadius - inner);

          // Orbit ring centered on the sun
          const ring = document.createElement('div');
          ring.className = 'orbit-ring';
          ring.style.width = `${radius * 2}px`;
          ring.style.height = `${radius * 2}px`;
          ring.style.left = `${sunX - radius}px`;
          ring.style.top = `${sunY - radius}px`;
          ring.style.transform = 'none';
          mapContainer.appendChild(ring);

          // Planet position along the diagonal at this radius
          const px = sunX + ux * radius;
          const py = sunY + uy * radius;
          const icon = document.createElement('div');
          icon.className = `planet-icon ${index === this.currentPlanetIndex ? 'current' : ''}`;
          icon.style.background = planet.color;
          icon.style.left = `${px - iconHalf}px`;
          icon.style.top = `${py - iconHalf}px`;
          icon.title = `${planet.name} - ${planet.type}`;
          icon.onclick = () => this.openPlanetDetails(index);
          mapContainer.appendChild(icon);
          if (index === this.currentPlanetIndex) {
            currentIconPos = { x: px, y: py };
          }
        });
        // Draw a visible, pulsing reticule around the current planet
        if (currentIconPos) {
          const r = document.createElement('div');
          r.className = 'here-reticule';
          r.style.left = `${currentIconPos.x - 21}px`;
          r.style.top = `${currentIconPos.y - 21}px`;
          mapContainer.appendChild(r);
        }
        // Keep map responsive to window resize while open
        if (!this._systemMapResizeHandler) {
          this._systemMapResizeHandler = () => {
            const sm = document.getElementById('systemMap');
            if (sm && sm.classList.contains('active')) {
              const mc = sm.querySelector('.map-container');
              mc.querySelectorAll('.orbit-ring, .planet-icon').forEach(el => el.remove());
              // Re-render
              this.showSystemMap();
            }
          };
          window.addEventListener('resize', this._systemMapResizeHandler);
        }
      }
      
      closeSystemMap() {
        document.getElementById('systemMap').classList.remove('active');
        if (this._systemMapResizeHandler) {
          window.removeEventListener('resize', this._systemMapResizeHandler);
          this._systemMapResizeHandler = null;
        }
      }
      
      showGalaxyMap() {
        const overlay = document.getElementById('galaxyMap');
        const container = overlay.querySelector('.galaxy-container');
        const stage = document.getElementById('galaxyStage');
        const canvas = document.getElementById('galaxyCanvas');
        overlay.classList.add('active');
        // Reset zoom/pan
        this._galaxyZoom = 1;
        this._galaxyPanX = 0;
        this._galaxyPanY = 0;
        stage.style.transform = `translate(0px, 0px) scale(1)`;
        // Prepare nodes
        stage.querySelectorAll('.system-node, .node-label').forEach(n => n.remove());
        this.resizeGalaxyCanvas();

  const nodes = this.buildGalaxyNodes(this.currentSystem.name);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width, canvas.height);
        // Draw edges
        ctx.strokeStyle = 'rgba(0,255,0,0.3)';
        ctx.lineWidth = 1;
        nodes.edges.forEach(([from, to]) => {
          const a = nodes.positions[from];
          const b = nodes.positions[to];
          ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
        });
        // Draw clickable nodes
        Object.entries(nodes.positions).forEach(([name, pos]) => {
          const node = document.createElement('div');
          node.className = 'system-node' + (name === this.currentSystem.name ? ' current' : '');
          node.style.left = `${pos.x - 7}px`;
          node.style.top = `${pos.y - 7}px`;
          node.title = name;
          const c = nodes.coords[name];
          if (c) { node.dataset.x = c.x; node.dataset.y = c.y; }
          node.onclick = () => {
            const x = parseInt(node.dataset.x, 10);
            const y = parseInt(node.dataset.y, 10);
            if (!Number.isNaN(x) && !Number.isNaN(y)) this.plotHyperjumpTo(x, y, name); else this.plotHyperjump(name);
          };
          const label = document.createElement('div');
          label.className = 'node-label';
          label.style.left = `${pos.x}px`;
          label.style.top = `${pos.y}px`;
          label.textContent = name;
          stage.appendChild(node);
          stage.appendChild(label);
        });

        // Zoom and pan handlers (wheel + pointer events for touch)
        const onWheel = (e) => {
          e.preventDefault();
          const rect = container.getBoundingClientRect();
          const cx = e.clientX - rect.left;
          const cy = e.clientY - rect.top;
          const prevScale = this._galaxyZoom;
          const delta = -e.deltaY; // wheel up to zoom in
          const factor = Math.exp(delta * 0.0015);
          const newScale = Math.max(0.4, Math.min(3.0, prevScale * factor));
          // Adjust pan so zoom focuses around cursor point
          const sx = (cx - this._galaxyPanX) / prevScale;
          const sy = (cy - this._galaxyPanY) / prevScale;
          this._galaxyPanX = cx - sx * newScale;
          this._galaxyPanY = cy - sy * newScale;
          this._galaxyZoom = newScale;
          stage.style.transform = `translate(${this._galaxyPanX}px, ${this._galaxyPanY}px) scale(${this._galaxyZoom})`;
        };
        // Pointer state
        this._pointers = new Map();
        const setTransform = () => {
          stage.style.transform = `translate(${this._galaxyPanX}px, ${this._galaxyPanY}px) scale(${this._galaxyZoom})`;
        };
        const onPointerDown = (e) => {
          container.setPointerCapture(e.pointerId);
          this._pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
          if (this._pointers.size === 1) {
            this._panning = true;
            this._panStartX = e.clientX - this._galaxyPanX;
            this._panStartY = e.clientY - this._galaxyPanY;
          } else if (this._pointers.size === 2) {
            // Initialize pinch
            const pts = Array.from(this._pointers.values());
            this._pinchStartDist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);
            this._pinchStartScale = this._galaxyZoom;
            const rect = container.getBoundingClientRect();
            this._pinchCenter = {
              x: (pts[0].x + pts[1].x) / 2 - rect.left,
              y: (pts[0].y + pts[1].y) / 2 - rect.top
            };
          }
        };
        const onPointerMove = (e) => {
          if (!this._pointers.has(e.pointerId)) return;
          this._pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
          if (this._pointers.size === 1 && this._panning) {
            this._galaxyPanX = e.clientX - this._panStartX;
            this._galaxyPanY = e.clientY - this._panStartY;
            setTransform();
          } else if (this._pointers.size === 2) {
            const pts = Array.from(this._pointers.values());
            const dist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);
            const scale = Math.max(0.4, Math.min(3.0, this._pinchStartScale * (dist / this._pinchStartDist)));
            // Zoom around pinch center
            const sx = (this._pinchCenter.x - this._galaxyPanX) / this._galaxyZoom;
            const sy = (this._pinchCenter.y - this._galaxyPanY) / this._galaxyZoom;
            this._galaxyPanX = this._pinchCenter.x - sx * scale;
            this._galaxyPanY = this._pinchCenter.y - sy * scale;
            this._galaxyZoom = scale;
            setTransform();
          }
        };
        const onPointerUp = (e) => {
          if (container.hasPointerCapture?.(e.pointerId)) container.releasePointerCapture(e.pointerId);
          this._pointers.delete(e.pointerId);
          if (this._pointers.size === 0) this._panning = false;
        };
        // Bind
        container.addEventListener('wheel', onWheel, { passive: false });
        container.addEventListener('pointerdown', onPointerDown);
        container.addEventListener('pointermove', onPointerMove);
        container.addEventListener('pointerup', onPointerUp);
        container.addEventListener('pointercancel', onPointerUp);
        // Store handlers for cleanup
        this._galaxyHandlers = { onWheel, onPointerDown, onPointerMove, onPointerUp };

        // Show route info: current -> neighbors (1 hop) -> their neighbors (2 hops)
        const oneHop = this.getNeighbors(this.currentSystem.name);
        const twoHop = new Set();
        oneHop.forEach(n => this.getNeighbors(n).forEach(m => { if (m !== this.currentSystem.name) twoHop.add(m); }));
        const info = document.getElementById('routeInfo');
        if (info) {
          info.innerHTML = `<div>Current: <strong>${this.currentSystem.name}</strong></div>
                            <div>Next hop: ${oneHop.join(', ') || 'None'}</div>
                            <div>Two hops: ${Array.from(twoHop).join(', ') || 'None'}</div>`;
        }
      }

      closeGalaxyMap() { 
        const overlay = document.getElementById('galaxyMap');
        overlay.classList.remove('active');
        // Cleanup event handlers
        const container = overlay.querySelector('.galaxy-container');
        if (this._galaxyHandlers && container) {
          container.removeEventListener('wheel', this._galaxyHandlers.onWheel);
          container.removeEventListener('pointerdown', this._galaxyHandlers.onPointerDown);
          container.removeEventListener('pointermove', this._galaxyHandlers.onPointerMove);
          container.removeEventListener('pointerup', this._galaxyHandlers.onPointerUp);
          container.removeEventListener('pointercancel', this._galaxyHandlers.onPointerUp);
          this._galaxyHandlers = null;
          this._pointers = null;
        }
      }

      resizeGalaxyCanvas() {
        const canvas = document.getElementById('galaxyCanvas');
        if (!canvas) return;
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }

      buildGalaxyNodes(centerName) {
        // Deterministic layout and neighbor generation with 2-hop context
        const centerCoords = { x: this.currentCoords.x, y: this.currentCoords.y };
        const nCoords = this.getNeighborCoords(centerCoords.x, centerCoords.y);
        const neighbors = nCoords.map(c => this.systemNameAt(c.x, c.y));
        const positions = {};
        const rect = document.getElementById('galaxyCanvas').getBoundingClientRect();
        const cx = rect.width / 2, cy = rect.height / 2;
        positions[centerName] = { x: cx, y: cy };
        const edges = [];
        const rng = this.rngFromString(centerName);
        const radius = Math.min(cx, cy) - 40;
        neighbors.forEach((n, i) => {
          const angle = (i / neighbors.length) * Math.PI * 2 + rng.next() * 0.3;
          const r = radius * (0.6 + 0.3 * rng.next());
          positions[n] = { x: cx + Math.cos(angle) * r, y: cy + Math.sin(angle) * r };
          edges.push([centerName, n]);
          // Ensure system exists
          if (!this.systems.has(n)) {
            // Use exact coordinates for determinism
            const cc = nCoords[i];
            const sys = this.getSystemAt(cc.x, cc.y);
            this.systems.set(n, sys);
          }
        });
        // include edges among first and second hop to give better context
        neighbors.forEach((n, idx) => {
          const baseCoord = nCoords[idx];
          const nnCoords = this.getNeighborCoords(baseCoord.x, baseCoord.y);
          const nn = nnCoords.map(c => this.systemNameAt(c.x, c.y));
          nn.forEach(m => {
            if (!positions[m]) {
              // place second-hop nodes near their parent neighbor
              const base = positions[n];
              const rr = 60 + 40 * this.rngFromString(n + m).next();
              const aa = 2 * Math.PI * this.rngFromString(m + n).next();
              positions[m] = { x: base.x + Math.cos(aa) * rr, y: base.y + Math.sin(aa) * rr };
            }
            edges.push([n, m]);
          });
        });
        // map names to their coords
        const coordsMap = { [centerName]: centerCoords };
        neighbors.forEach((n,i) => { coordsMap[n] = nCoords[i]; });
        // Include second-hop nodes in coords map
        neighbors.forEach((n, idx) => {
          const baseCoord = nCoords[idx];
          const nnCoords = this.getNeighborCoords(baseCoord.x, baseCoord.y);
          const nn = nnCoords.map(c => this.systemNameAt(c.x, c.y));
          nn.forEach((m, j) => { if (!coordsMap[m]) coordsMap[m] = nnCoords[j]; });
        });
        return { positions, edges, coords: coordsMap };
      }

      // Deterministic neighbor coordinates (4 cardinals + 2 diagonals picked deterministically)
      getNeighborCoords(x, y) {
        const base = [
          {x:x+1,y:y},{x:x-1,y:y},{x:x,y:y+1},{x:x,y:y-1}
        ];
        const r = this.rngFromString(`${x},${y}`);
        const diag = [
          {x:x+1,y:y+1},{x:x-1,y:y-1},{x:x+1,y:y-1},{x:x-1,y:y+1}
        ];
        // pick 2 unique diagonals deterministically
        const used = new Set();
        const chosen = [];
        while (chosen.length < 2 && used.size < diag.length) {
          const idx = r.nextInt(0, diag.length-1);
          if (!used.has(idx)) { used.add(idx); chosen.push(diag[idx]); }
        }
        return base.concat(chosen);
      }
      
      scanSystem() {
        const planet = this.currentSystem.planets[this.currentPlanetIndex];
        const moon = this.currentMoonIndex !== null ? planet.moons[this.currentMoonIndex] : null;
        let scanResult = `Scanning ${moon ? moon.name : planet.name}...\n`;
        if (!moon) {
          scanResult += `Type: ${planet.type}\n`;
        }
        const pop = (moon ? moon.population : planet.population).toLocaleString();
        const tp = (moon ? moon.tradingPost : planet.tradingPost) ? 'Yes' : 'No';
        scanResult += `Population: ${pop}\n`;
        scanResult += `Trading Post: ${tp}\n`;
        const trader = moon ? moon.trader : planet.trader;
        if (trader) { scanResult += `Trader Present: ${trader.name}`; }
        this.showStatus(scanResult);
      }
      
      // Travel Functions
      travelToPlanet(planetIndex) {
        if (planetIndex === this.currentPlanetIndex) return;
        // Require fuel for intra-system travel
        if (this.fuel < 5) { this.showStatus('Insufficient fuel to travel to planet.'); return; }
        // Close any open overlays related to selection
        this.closePlanetDetails();
        this.closeSystemMap();
        this.currentMoonIndex = null;
        this.startTravelAnimation('Warp Drive', () => {
          this.currentPlanetIndex = planetIndex;
          this.fuel = Math.max(0, this.fuel - 5);
          this.updateUI();
          this.downloadTradeData();
          this.saveGame();
        });
      }

      travelToMoon(planetIndex, moonIndex) {
        if (this.fuel < 3) { this.showStatus('Insufficient fuel to travel to moon.'); return; }
        this.closePlanetDetails();
        this.closeSystemMap();
        const same = (planetIndex === this.currentPlanetIndex && moonIndex === this.currentMoonIndex);
        if (same) return;
        this.startTravelAnimation('Warp Drive', () => {
          this.currentPlanetIndex = planetIndex;
          this.currentMoonIndex = moonIndex;
          this.fuel = Math.max(0, this.fuel - 3);
          this.updateUI();
          this.downloadTradeData();
          this.saveGame();
        });
      }
      
      engageImpulse() {
        if (this.fuel < 10) {
          this.showStatus('Insufficient fuel for impulse drive!');
          return;
        }
        this.showStatus('Impulse drive engaged. Short-range movement only.');
      }
      
      engageWarp() {
        if (this.fuel < 20) {
          this.showStatus('Insufficient fuel for warp drive!');
          return;
        }
        this.showSystemMap();
      }
      
      engageHyper() {
        if (this.fuel < 50) {
          this.showStatus('Insufficient fuel for hyperdrive!');
          return;
        }
        this.showStatus('Hyperdrive ready. Select destination system from galaxy map.');
        this.showGalaxyMap();
      }
      
      startTravelAnimation(driveType, callback) {
        const animation = document.getElementById('travelAnimation');
        const text = document.getElementById('travelText');
        const bar = document.getElementById('travelBar');
        
        text.textContent = `Engaging ${driveType}...`;
        bar.style.width = '0%';
        animation.classList.add('active');
        document.body.classList.add('modal-open');
        
        // Warp effect
        const warpEffect = document.getElementById('warpEffect');
        const planetView = document.getElementById('planetView');
        const spaceView = document.getElementById('spaceView');

        let phase = 0; // 0 warm, 1 travel, 2 cool
        let elapsed = 0;
        let total = 15000; // 15s
        let start = performance.now();

        planetView.classList.add('turning');

        const step = (now) => {
          elapsed = now - start;
          const p = Math.min(1, elapsed / total);
          bar.style.width = `${Math.floor(p * 100)}%`;

          if (elapsed < 4000 && phase === 0) { // warm-up 0-4s
            text.textContent = `Engaging ${driveType}... Warming up`;
            warpEffect.classList.remove('active');
          } else if (elapsed < 11000 && phase <= 1) { // travel 4-11s
            phase = 1;
            text.textContent = `${driveType} in transit...`;
            spaceView.classList.remove('hidden');
            warpEffect.classList.add('active');
          } else if (elapsed < 15000 && phase <= 2) { // cool-down 11-15s
            phase = 2;
            text.textContent = `Braking and cool-down...`;
            warpEffect.classList.remove('active');
          }

          if (elapsed >= total) {
            planetView.classList.remove('turning');
            animation.classList.remove('active');
            warpEffect.classList.remove('active');
            spaceView.classList.add('hidden');
            document.body.classList.remove('modal-open');
            callback();
          } else {
            requestAnimationFrame(step);
          }
        };
        requestAnimationFrame(step);
      }
      
      // Trading Functions
      openTradeInterface() {
        const planet = this.currentSystem.planets[this.currentPlanetIndex];
        const moon = this.currentMoonIndex !== null ? planet.moons[this.currentMoonIndex] : null;
        const hasOutpost = moon ? moon.tradingPost : planet.tradingPost;
        const npcTrader = moon ? moon.trader : planet.trader;
        if (!hasOutpost && !npcTrader) {
          this.showStatus('No trading outpost here.');
          return;
        }
        // If there's no NPC trader but an outpost exists, synthesize a deterministic station market contact
        if (!npcTrader && hasOutpost) {
          const key = `${this.currentSystem.name}-${moon ? moon.name : planet.name}-station`;
          const r = this.rngFromString(key);
          this.currentTrader = {
            name: 'Station Quartermaster',
            ship: 'Orbital Market',
            personality: 'formal',
            haggleSkill: r.nextInt(4, 7),
            reputation: r.nextInt(40, 80)
          };
        } else {
          this.currentTrader = npcTrader;
        }
        this.traderPriceMod = 1;
        this.populateTradeInterface(planet);
        document.getElementById('tradeInterface').classList.add('active');
        document.body.classList.add('modal-open');
      }
      
      closeTradeInterface() {
        document.getElementById('tradeInterface').classList.remove('active');
        document.body.classList.remove('modal-open');
        this.currentTrader = null;
      }
      
      populateTradeInterface(planet) {
        const trader = this.currentTrader || (this.currentMoonIndex === null ? planet.trader : planet.moons[this.currentMoonIndex]?.trader) || { name: 'Outpost Clerk', ship: 'Station' };
        document.getElementById('traderName').textContent = trader.name;
        document.getElementById('traderShip').textContent = `"${trader.ship}" - Independent Trader`;
        const cEl = document.getElementById('playerCreditsInTrade');
        if (cEl) cEl.textContent = `Credits: ${this.credits}₵`;
        
        const buyingItems = document.getElementById('buyingItems');
        const sellingItems = document.getElementById('sellingItems');
        
        buyingItems.innerHTML = '';
        sellingItems.innerHTML = '';
        
        // Show items trader is selling
  const resources = this.currentMoonIndex === null ? planet.resources : planet.moons[this.currentMoonIndex].resources;
        Object.entries(resources).forEach(([name, resource]) => {
          const price = this.applyTraderMods(resource.buyPrice);
          if (resource.available > 0) {
            const item = document.createElement('div');
            item.className = 'trade-item';
            const priceClass = this.lastHaggleDelta ? (this.lastHaggleDelta < 0 ? 'price-up' : 'price-down') : '';
            item.innerHTML = `
              <span class="item-name">${name}</span>
              <span class="item-quantity">${resource.available}</span>
              <span class="item-price ${priceClass}">${price}₵</span>
              <span class="trade-action"><button class="button" onclick="game.buyItem('${name}')">Buy</button></span>
            `;
            buyingItems.appendChild(item);
          }
        });
        
        // Show items we can sell, sorted by highest profit first
        const cargoCopy = this.cargo.filter(c => c.quantity > 0).map(c => ({...c}));
        cargoCopy.forEach(ci => {
          const hist = this.txHistory[ci.name];
          const avgCost = hist?.avgCost ?? null;
          const res = resources[ci.name];
          const sellPrice = this.applyTraderMods(res ? res.sellPrice : 50);
          const unitProfit = avgCost !== null ? (sellPrice - avgCost) : 0;
          ci._avgCost = avgCost;
          ci._unitProfit = unitProfit;
        });
        cargoCopy.sort((a,b) => (b._unitProfit||-Infinity) - (a._unitProfit||-Infinity));
        cargoCopy.forEach(item => {
          const res = resources[item.name];
          const sellPrice = this.applyTraderMods(res ? res.sellPrice : 50);
          const avgCost = item._avgCost;
          const unitProfit = item._unitProfit;
          const profitClass = unitProfit >= 0 ? 'profit' : 'loss';
          const demandLeft = res?.demand ?? this.defaultDemandFor(item.name, resources);
          const meta = avgCost !== null ? `<span class=\"item-meta\">avg cost ${Math.round(avgCost)}₵</span><span class=\"${profitClass}\">Δ ${Math.round(unitProfit)}₵</span>` : '<span class=\"item-meta\">no history</span>';
          const priceClass = this.lastHaggleDelta ? (this.lastHaggleDelta > 0 ? 'price-down' : 'price-up') : '';
          const tradeItem = document.createElement('div');
          tradeItem.className = 'trade-item';
          tradeItem.innerHTML = `
            <span class="item-name">${item.name}</span>
            <span class="item-quantity">${item.quantity}</span>
            <span class="item-price ${priceClass}">${sellPrice}₵</span>
            ${meta}
            <span class="item-meta">demand ${demandLeft}</span>
            <span class="trade-action"><button class="button" onclick="game.sellItem('${item.name}')">Sell</button></span>
          `;
          sellingItems.appendChild(tradeItem);
        });
        // clear last haggle delta after render so highlight is transient
        this.lastHaggleDelta = 0;
      }
      
      buyItem(itemName) {
        const planet = this.currentSystem.planets[this.currentPlanetIndex];
        const resources = this.currentMoonIndex === null ? planet.resources : planet.moons[this.currentMoonIndex].resources;
        const resource = resources[itemName];
        
        if (!resource || resource.available <= 0) {
          this.showStatus('Item not available!');
          this.tradeLog(`System: Item ${itemName} not available.`, 'sys');
          return;
        }
        
        const price = this.applyTraderMods(resource.buyPrice);
        if (this.credits < price) {
          this.showStatus('Insufficient credits!');
          this.tradeLog(`System: Insufficient credits for ${itemName} (${price}₵).`, 'sys');
          return;
        }
        
        const vol = this.getItemVolume(itemName);
        if (this.getFreeSlots() < vol) {
          this.showStatus('Cargo hold full!');
          this.tradeLog(`System: Cargo hold full, cannot take ${itemName}.`, 'sys');
          return;
        }
        
        // Complete the purchase
  this.credits -= price;
        resource.available--;
        this.addCrate(itemName);
        this.flashBeam();

  // record transaction history for average cost
  if (!this.txHistory[itemName]) this.txHistory[itemName] = { buys: [], avgCost: null };
  const hist = this.txHistory[itemName];
  hist.buys.push(price);
  const sum = hist.buys.reduce((a,b)=>a+b,0);
  hist.avgCost = sum / hist.buys.length;

        this.updateUI();
        this.populateTradeInterface(planet);
        this.saveGame();
        this.showStatus(`Purchased ${itemName} for ${price}₵`);
        this.tradeLog(`You: Purchased ${itemName} for ${price}₵.`);
      }
      
      sellItem(itemName) {
        const planet = this.currentSystem.planets[this.currentPlanetIndex];
        const resources = this.currentMoonIndex === null ? planet.resources : planet.moons[this.currentMoonIndex].resources;
        const resource = resources[itemName];
        const cargoItem = this.cargo.find(item => item.name === itemName);
        
        if (!cargoItem || cargoItem.quantity <= 0) {
          this.showStatus('Item not in cargo!');
          this.tradeLog(`System: Item ${itemName} not in cargo.`, 'sys');
          return;
        }
        
        const sellPrice = this.applyTraderMods(resource ? resource.sellPrice : 50);

        // Enforce finite demand available for sale
        let demand = resource?.demand;
        if (demand === undefined || demand === null) {
          demand = this.defaultDemandFor(itemName, resources);
        }
  if (demand <= 0) { this.showStatus('No demand for this item right now.'); this.tradeLog(`Trader: No demand for ${itemName} right now.`, 'sys'); return; }
        
        // Complete the sale
        this.credits += sellPrice;
        cargoItem.quantity--;
        this.removeCrate(itemName);
        // reduce demand if resource is present (or virtual demand)
        if (resource) resource.demand = Math.max(0, (resource.demand||0) - 1);
        else {
          // adjust a virtual demand cache on the fly by attaching to resources
          resources[itemName] = { sellPrice: 50, buyPrice: 100, available: 0, demand: Math.max(0, demand - 1) };
        }
        
        if (cargoItem.quantity === 0) {
          const index = this.cargo.indexOf(cargoItem);
          this.cargo.splice(index, 1);
          // clear tx history when out of stock
          delete this.txHistory[itemName];
        }
        
        this.updateUI();
        this.populateTradeInterface(planet);
  this.saveGame();
        // report profit if available
        const hist = this.txHistory[itemName];
        if (hist?.avgCost != null) {
          const delta = Math.round(sellPrice - hist.avgCost);
          const tag = delta >= 0 ? 'profit' : 'loss';
          this.showStatus(`Sold ${itemName} for ${sellPrice}₵ (${tag} ${delta}₵)`);
          this.tradeLog(`You: Sold ${itemName} for ${sellPrice}₵ (${tag} ${delta}₵).`);
        } else {
          this.showStatus(`Sold ${itemName} for ${sellPrice}₵`);
          this.tradeLog(`You: Sold ${itemName} for ${sellPrice}₵.`);
        }
      }
      
      haggle(technique) {
        if (!this.currentTrader) return;
        
        const outcomes = {
          charm: ['The trader smiles warmly', 'Your charm works perfectly', 'They seem unimpressed'],
          intimidate: ['The trader looks nervous', 'They stand their ground', 'Security is called!'],
          logic: ['Your argument is sound', 'They see the logic', 'They counter with facts'],
          desperate: ['They take pity on you', 'They sense weakness', 'They offer a small discount']
        };
        
  const result = this.rng.choice(outcomes[technique]);
  this.showStatus(`Haggle attempt: ${result}`);
  this.tradeLog(`You (${technique}): ${result}`);
        
        // Simple haggle success chance
        if (this.rng.next() > 0.6) {
          this.showStatus('Success! Prices improved slightly.');
          // Improve temp price modifier for current trader interaction
          this.traderPriceMod = (this.traderPriceMod || 1) * 0.97; // 3% better
          // Visual cue for price change next render
          this.lastHaggleDelta = -0.03;
          this.populateTradeInterface(this.currentSystem.planets[this.currentPlanetIndex]);
          this.tradeLog('Trader: Very well, a better price for you.');
        } else if (this.rng.next() < 0.2) {
          this.showStatus('That backfired. Prices worsened slightly.');
          this.traderPriceMod = Math.min(1.2, (this.traderPriceMod || 1) * 1.03);
          this.lastHaggleDelta = +0.03;
          this.populateTradeInterface(this.currentSystem.planets[this.currentPlanetIndex]);
          this.tradeLog('Trader: Nice try. Prices are going up.');
        }
      }

      tradeLog(message, cls) {
        const log = document.getElementById('tradeLog');
        if (!log) return;
        const div = document.createElement('div');
        div.className = 'entry' + (cls ? ' ' + cls : '');
        div.textContent = message;
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;
      }

      // compute default demand if not present, deterministic per system and item
      defaultDemandFor(itemName, resources) {
        const key = `${this.currentSystem.name}-${itemName}`;
        const r = this.rngFromString(key);
        // if first time, synthesize demand and memoize in resources to keep consistent during visit
        if (!resources[itemName]) resources[itemName] = { buyPrice: 100, sellPrice: 50, available: 0, demand: r.nextInt(3, 20) };
        if (resources[itemName].demand == null) resources[itemName].demand = r.nextInt(3, 20);
        return resources[itemName].demand;
      }
      
      // System Functions
      toggleSystem(systemName, ev) {
        const e = ev || window.event;
        const toggle = e.target.closest('.switch-toggle');
        toggle.classList.toggle('on');
        
        const isOn = toggle.classList.contains('on');
        this.showStatus(`${systemName.toUpperCase()}: ${isOn ? 'ON' : 'OFF'}`);
      }
      
      // Removed non-requested features: docking, launch, emergency stop
      
      downloadTradeData() {
        // Slightly adjust market prices deterministically per visit
        const planet = this.currentSystem.planets[this.currentPlanetIndex];
        const resources = this.currentMoonIndex === null ? planet.resources : planet.moons[this.currentMoonIndex].resources;
        const rng = this.rngFromString(`${this.currentSystem.name}-${planet.name}-${this.currentMoonIndex ?? 'P'}`);
        Object.values(resources).forEach(r => {
          const delta = Math.floor((rng.next() - 0.5) * 50);
          r.buyPrice = Math.max(10, r.buyPrice + delta);
          r.sellPrice = Math.max(5, r.sellPrice + Math.floor(delta * 0.8));
        });
        this.showStatus('Downloading latest trade data... Complete. Market prices updated.');
      }
      
      showStatus(message) {
        // Simple status display - in full implementation would be more sophisticated
        console.log('STATUS:', message);
        
        // Flash the viewport briefly to indicate message
        const viewport = document.querySelector('.viewport');
        viewport.style.borderColor = '#ffff00';
        setTimeout(() => {
          viewport.style.borderColor = '#00ff00';
        }, 500);
      }

      // Planet details with moons
      openPlanetDetails(planetIndex) {
        const overlay = document.getElementById('planetDetails');
        const planet = this.currentSystem.planets[planetIndex];
        document.getElementById('planetDetailsTitle').textContent = planet.name;
        document.getElementById('planetDetailsInfo').textContent = `${planet.type} • Pop ${planet.population.toLocaleString()} • Trading Post: ${planet.tradingPost ? 'Yes' : 'No'}`;
        const list = document.getElementById('moonsList');
        list.innerHTML = '';
        if (planet.moons.length === 0) {
          const none = document.createElement('div');
          none.style.color = '#00aa66';
          none.style.fontSize = '12px';
          none.textContent = 'No moons';
          list.appendChild(none);
        } else {
          planet.moons.forEach((m, i) => {
            const chip = document.createElement('div');
            chip.className = 'moon-chip';
            chip.textContent = `${m.name} • TP: ${m.tradingPost ? 'Yes' : 'No'}`;
            chip.onclick = () => this.travelToMoon(planetIndex, i);
            list.appendChild(chip);
          });
        }
        // also button to travel to planet body itself
        const chip = document.createElement('div');
        chip.className = 'moon-chip';
        chip.textContent = `Go to ${planet.name}`;
        chip.onclick = () => this.travelToPlanet(planetIndex);
        list.appendChild(chip);

        overlay.classList.add('active');
      }
      closePlanetDetails() { document.getElementById('planetDetails').classList.remove('active'); }

      // Hyperjump plotting to another system via galaxy map
      plotHyperjump(systemName) {
        if (this.fuel < 30) { this.showStatus('Insufficient fuel for hyperjump!'); return; }
        if (systemName === this.currentSystem.name) return;
        this.closeGalaxyMap();
        this.startTravelAnimation('Hyperdrive', () => {
          // Move to new system
          const coords = this.coordsFromName(systemName);
          const sys = this.getSystemAt(coords.x, coords.y);
          this.currentSystem = sys;
          this.currentCoords = coords;
          this.currentPlanetIndex = 0;
          this.currentMoonIndex = null;
          this.fuel = Math.max(0, this.fuel - 30);
          // Reset any previous planetView state and update visuals for the new system
          const pv = document.getElementById('planetView');
          if (pv) pv.classList.remove('turning');
          this.updateUI();
          this.downloadTradeData();
          this.saveGame();
        });
      }

      // Deterministic hyperjump to exact coordinates (preferred)
      plotHyperjumpTo(x, y, nameHint) {
        if (this.fuel < 30) { this.showStatus('Insufficient fuel for hyperjump!'); return; }
        const targetName = nameHint || this.systemNameAt(x, y);
        if (targetName === this.currentSystem.name && this.currentCoords.x === x && this.currentCoords.y === y) return;
        this.closeGalaxyMap();
        this.startTravelAnimation('Hyperdrive', () => {
          const sys = this.getSystemAt(x, y);
          this.currentSystem = sys;
          this.currentCoords = { x, y };
          this.currentPlanetIndex = 0;
          this.currentMoonIndex = null;
          this.fuel = Math.max(0, this.fuel - 30);
          const pv = document.getElementById('planetView');
          if (pv) pv.classList.remove('turning');
          this.updateUI();
          this.downloadTradeData();
          this.saveGame();
        });
      }

      getOrCreateSystem(name) {
        if (this.systems.has(name)) return this.systems.get(name);
        const c = this.coordsFromName(name);
        const sys = this.generateSystem(name, this.seedOffsetAt(c.x, c.y));
        this.systems.set(name, sys);
        return sys;
      }

      // Deterministic neighbors from grid without caching
      getNeighbors(systemName) {
        const c = this.coordsFromName(systemName);
        const base = [
          {x:c.x+1,y:c.y},{x:c.x-1,y:c.y},{x:c.x,y:c.y+1},{x:c.x,y:c.y-1}
        ];
        const r = this.rngFromString(`${c.x},${c.y}`);
        const diag = [
          {x:c.x+1,y:c.y+1},{x:c.x-1,y:c.y-1},{x:c.x+1,y:c.y-1},{x:c.x-1,y:c.y+1}
        ];
        const pick = (arr, k) => {
          const chosen = [];
          const used = new Set();
          while (chosen.length < k && chosen.length < arr.length) {
            const idx = r.nextInt(0, arr.length-1);
            if (!used.has(idx)) { used.add(idx); chosen.push(arr[idx]); }
          }
          return chosen;
        };
        const all = base.concat(pick(diag, 2));
        return all.map(cc => this.systemNameAt(cc.x, cc.y));
      }

      // Coordinate-based helpers
      getSystemAt(x,y) {
        const name = this.systemNameAt(x,y);
        const sys = this.generateSystem(name, this.seedOffsetAt(x,y));
        return sys;
      }
      systemNameAt(x,y) {
        const rng = this.rngFromString(`${this.galaxySeed}:${x}:${y}`);
        return this.generateSystemName(rng);
      }
      seedOffsetAt(x,y) {
        return (Math.abs(this.hash(`${this.galaxySeed}:${x}:${y}`)) % 100000);
      }
      coordsFromName(name) {
        // Try to find coords around current position for locality
        for (let dx=-4; dx<=4; dx++) {
          for (let dy=-4; dy<=4; dy++) {
            const nx = this.currentCoords.x + dx;
            const ny = this.currentCoords.y + dy;
            if (this.systemNameAt(nx,ny) === name) return {x:nx,y:ny};
          }
        }
        // Fallback to hashing
        const h = this.hash(name + ':' + this.galaxySeed);
        const x = ((h >> 8) % 10000) | 0;
        const y = (h % 10000) | 0;
        return { x, y };
      }

      // Save/Load/New Game under key 'spacetrader'
      saveGame() {
        const data = {
          version: 1,
          galaxySeed: this.galaxySeed,
          coords: this.currentCoords,
          systemName: this.currentSystem.name,
          planetIndex: this.currentPlanetIndex,
          moonIndex: this.currentMoonIndex,
          credits: this.credits,
          fuel: this.fuel,
          cargoSlots: this.cargoSlots,
          cargo: this.cargo,
          txHistory: this.txHistory
        };
        try { localStorage.setItem('spacetrader', JSON.stringify(data)); } catch(e) { /* ignore */ }
      }
      loadGame() {
        try {
          const raw = localStorage.getItem('spacetrader');
          if (!raw) return false;
          const data = JSON.parse(raw);
          if (!data || data.version !== 1) return false;
          this.galaxySeed = data.galaxySeed ?? this.galaxySeed;
          this.currentCoords = data.coords ?? {x:0,y:0};
          const name = data.systemName ?? this.systemNameAt(this.currentCoords.x, this.currentCoords.y);
          // Rebuild the system deterministically from saved coordinates
          this.currentSystem = this.getSystemAt(this.currentCoords.x, this.currentCoords.y);
          this.currentPlanetIndex = data.planetIndex ?? 0;
          this.currentMoonIndex = data.moonIndex ?? null;
          this.credits = data.credits ?? this.credits;
          this.fuel = data.fuel ?? this.fuel;
          this.cargoSlots = Array.isArray(data.cargoSlots) ? data.cargoSlots : this.cargoSlots;
          this.cargo = Array.isArray(data.cargo) ? data.cargo : this.cargo;
          this.txHistory = data.txHistory ?? {};
          this.showStatus('Save loaded.');
          return true;
        } catch(e) { return false; }
      }
      newGame() {
        this.rng = new SeededRNG(42);
        this.credits = 10000;
        this.fuel = 85;
        this.cargoCapacity = 50;
        this.currentCargo = 0;
        this.cargo = [];
        this.cargoSlots = new Array(this.cargoCapacity).fill(null);
        this.txHistory = {};
        this.galaxySeed = 4242;
        this.currentCoords = { x: 0, y: 0 };
        this.currentSystem = this.getSystemAt(0,0);
        this.currentPlanetIndex = 0;
        this.currentMoonIndex = null;
        this.updateUI();
        this.saveGame();
        this.showStatus('New game started.');
      }

      rngFromString(str) {
        let h = this.hash(str);
        return new SeededRNG((h % 2147483647) || 42);
      }

      hash(str) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return Math.abs(h);
      }

      generateSystemName(rng) {
        const C = 'bcdfghjklmnpqrstvwxyz'.split('');
        const V = 'aeiouy'.split('');
        const len = rng.nextInt(2, 3);
        let s = '';
        for (let i = 0; i < len; i++) { s += rng.choice(C).toUpperCase() + rng.choice(V); }
        const suffix = ['-I', '-II', '', '', '', ' Prime'][rng.nextInt(0,5)];
        return s.charAt(0).toUpperCase() + s.slice(1) + suffix;
      }

      // Cargo helpers
      getItemVolume(name) { return this.itemVolumes[name] || 1; }
      getFreeSlots() { return this.cargoSlots.filter(s => !s).length; }
      addCrate(name) {
        const vol = this.getItemVolume(name);
        let remaining = vol;
        for (let i = 0; i < this.cargoCapacity && remaining > 0; i++) {
          if (!this.cargoSlots[i]) { this.cargoSlots[i] = { name }; remaining--; this.currentCargo++; }
        }
        const existing = this.cargo.find(c => c.name === name);
        if (existing) existing.quantity++; else this.cargo.push({ name, quantity: 1 });
      }
      removeCrate(name) {
        const vol = this.getItemVolume(name);
        let removed = 0;
        for (let i = 0; i < this.cargoCapacity && removed < vol; i++) {
          if (this.cargoSlots[i]?.name === name) { this.cargoSlots[i] = null; removed++; this.currentCargo--; }
        }
      }
      colorForItem(name) {
        // Deterministic HSL color from name
        const h = (this.hash(name) % 360);
        return `hsl(${h} 70% 35%)`;
      }

      flashBeam() {
        const overlay = document.getElementById('beamOverlay');
        overlay.classList.add('active');
        setTimeout(() => overlay.classList.remove('active'), 800);
      }

      applyTraderMods(price) { return Math.max(1, Math.round(price * (this.traderPriceMod || 1))); }

      // Refueling: pay credits to increase fuel when trading post exists
      refuel() {
        const planet = this.currentSystem.planets[this.currentPlanetIndex];
        const hasTP = this.currentMoonIndex === null ? planet.tradingPost : planet.moons[this.currentMoonIndex]?.tradingPost;
        if (!hasTP) { this.showStatus('No refueling available here.'); return; }
        if (this.fuel >= 100) { this.showStatus('Fuel tanks already full.'); return; }
        const needed = 100 - this.fuel;
        const unitPrice = 50; // 50 credits per 1%
        const affordable = Math.min(needed, Math.floor(this.credits / unitPrice));
        if (affordable <= 0) { this.showStatus('Insufficient credits to refuel.'); return; }
        this.credits -= affordable * unitPrice;
        this.fuel += affordable;
        this.updateUI();
        this.saveGame();
        this.showStatus(`Refueled ${affordable}% for ${affordable * unitPrice}₵`);
      }

      // Keyboard controls
      handleKey(e) {
        const k = e.key.toLowerCase();
        if (k === 'm') this.showSystemMap();
        else if (k === 'g') this.engageHyper();
        else if (k === 'w') this.engageWarp();
        else if (k === 'i') this.engageImpulse();
        else if (k === 't') this.openTradeInterface();
        else if (k === 's') this.scanSystem();
        // d, l, e unassigned (removed docking/launch/emergency)
        else if (k === 'escape') { this.closeSystemMap(); this.closeGalaxyMap(); this.closePlanetDetails(); this.closeTradeInterface(); }
      }
    }

    // Initialize game
    let game;
    document.addEventListener('DOMContentLoaded', () => {
      game = new SpaceTraderGame();
    });
  </script>
</body>
<script src="parental.js"></script>
</html>