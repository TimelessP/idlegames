<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Personal Organiser</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;600;700;900&display=swap" rel="stylesheet">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        :root {
            /* UI scaling unit – set by JS to min(clientWidth, clientHeight)/100 * userScale */
            --u: 8px;
            /* base length unit, updated by JS */
            --bw-thick: calc(0.8 * var(--u));
            /* thick comic outline */
            --bw: calc(0.45 * var(--u));
            /* inner comic lines */
            --radius: calc(2.0 * var(--u));
            --radius-sm: calc(1.0 * var(--u));
            --fs: calc(2.4 * var(--u));
            /* base font size (1.5x increase) */
            --fs-sm: calc(1.95 * var(--u));
            --fs-lg: calc(3.0 * var(--u));

            /* Palette – bright pastel yet earthy/cute */
            --peach: #ffc9a9;
            --peach-2: #ffb88f;
            --mint: #b9f5c6;
            --mint-2: #a8e6cf;
            --teal: #9ee7e5;
            --leaf: #a0d468;
            --sun: #ffd86b;
            --berry: #ff6fa7;
            --lav: #cdb4ff;

            --page: #ffffff;
            /* page white inside */
            --ink: #000000;
            /* black outline */
            --ink-80: rgba(0, 0, 0, 0.8);
            --ink-60: rgba(0, 0, 0, 0.6);
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        /* Ensure form controls inherit the global font for uniform sizing */
        button,
        input,
        select,
        textarea {
            font: inherit;
        }

        option {
            font: inherit;
        }

        input::file-selector-button {
            font: inherit;
        }

        code,
        pre,
        kbd,
        samp {
            font-family: inherit;
            font-size: inherit;
        }

        /* Placeholders should match the same font and size */
        ::placeholder {
            font: inherit;
            color: var(--ink-60);
            opacity: 1;
            /* avoid extra dimming on some browsers */
        }

        body {
            margin: 0;
            font-family: 'Noto Sans', 'Noto Color Emoji', 'Segoe UI Emoji', 'Apple Color Emoji', 'Segoe UI', system-ui, sans-serif;
            font-size: var(--fs);
            line-height: 1.2;
            background:
                radial-gradient(120% 120% at 10% 20%, rgba(255, 216, 107, 0.55), transparent 55%),
                radial-gradient(120% 120% at 90% 10%, rgba(158, 231, 229, 0.6), transparent 50%),
                radial-gradient(120% 120% at 20% 90%, rgba(185, 245, 198, 0.6), transparent 45%),
                linear-gradient(135deg, #ffe3d5 0%, #e0ffd8 100%);
            /* slightly-more-saturated-than pastel peach and greens */
            display: grid;
            place-items: center;
            touch-action: manipulation;
        }

        /* Organiser outer shell */
        .organiser {
            width: min(94vw, 1200px);
            height: min(100svh, 900px);
            /* better on mobile vertical; avoids browser UI cutting content */
            background: var(--page);
            border: var(--bw-thick) solid var(--ink);
            border-radius: var(--radius);
            box-shadow:
                calc(0.6 * var(--u)) calc(0.6 * var(--u)) 0 0 var(--ink),
                0 0 0 calc(0.25 * var(--u)) var(--ink);
            display: grid;
            grid-template-rows: auto auto 1fr;
            /* titlebar, tabbar, content, footer */
            overflow: hidden;
            position: relative;
        }

        .titlebar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: calc(1.0 * var(--u));
            padding: calc(1.0 * var(--u)) calc(1.4 * var(--u));
            background: linear-gradient(90deg, var(--peach) 0%, var(--sun) 50%, var(--mint) 100%);
            border-bottom: var(--bw) solid var(--ink);
        }

        .titlebar .title {
            display: flex;
            align-items: center;
            gap: calc(1.0 * var(--u));
            font-weight: 900;
            letter-spacing: 0.02em;
            color: var(--ink);
            text-shadow: 0 calc(0.15 * var(--u)) 0 var(--page);
        }

        .titlebar .controls {
            display: flex;
            align-items: center;
            gap: calc(0.8 * var(--u));
        }

        .btn {
            appearance: none;
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            background: var(--sun);
            color: var(--ink);
            padding: calc(0.5 * var(--u)) calc(1.0 * var(--u));
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 calc(0.25 * var(--u)) 0 0 var(--ink);
            transform: translateY(0);
            transition: transform 80ms ease, box-shadow 80ms ease, filter 120ms ease;
            user-select: none;
            touch-action: manipulation;
        }

        .btn:hover {
            filter: brightness(1.05);
        }

        .btn:active {
            transform: translateY(calc(0.25 * var(--u)));
            box-shadow: 0 0 0 0 var(--ink);
        }

        .btn.peach {
            background: var(--peach-2);
        }

        .btn.mint {
            background: var(--mint-2);
        }

        .btn.teal {
            background: var(--teal);
        }

        .btn.berry {
            background: var(--berry);
            color: #000;
        }

        .btn.lav {
            background: var(--lav);
        }

        .tabbar {
            display: flex;
            gap: calc(0.6 * var(--u));
            padding: calc(0.6 * var(--u)) calc(1.0 * var(--u));
            background: var(--page);
            border-bottom: var(--bw) solid var(--ink);
            align-items: center;
            /* prevent tabs from stretching vertically */
            flex-wrap: wrap;
            /* allow tabs to wrap to new lines on small screens */
        }

        .tabbar::-webkit-scrollbar {
            display: none;
        }

        .tab {
            border: var(--bw) solid var(--ink);
            border-bottom-width: calc(0.5 * var(--bw));
            border-radius: var(--radius-sm);
            padding: calc(0.5 * var(--u)) calc(1.0 * var(--u));
            background: var(--mint);
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 calc(0.25 * var(--u)) 0 0 var(--ink);
            user-select: none;
            flex: 0 1 auto;
            /* allow wrapping and shrinking if needed */
        }

        .tab[aria-selected="true"] {
            background: var(--sun);
            transform: translateY(calc(0.15 * var(--u)));
        }

        .content {
            display: grid;
            grid-template-rows: 1fr;
            overflow: hidden;
            min-height: 0;
            /* allow inner panels to shrink without forcing scrollbars */
            background: var(--page);
        }

        .panel {
            display: none;
            height: 100%;
            overflow: hidden;
        }

        .panel.active {
            display: grid;
            grid-template-rows: auto 1fr;
            min-height: 0;
            /* allow content to shrink within container */
        }
        /* Calculator panel has no header tips; let its body fill the panel */
        #panel-calc.panel.active {
            grid-template-rows: 1fr;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: calc(0.8 * var(--u));
            padding: calc(0.8 * var(--u)) calc(1.2 * var(--u));
            border-bottom: var(--bw) solid var(--ink);
            background: #fff;
        }

        .panel-body {
            padding: calc(1.0 * var(--u));
            overflow: auto;
            /* allow panel content (calendar, calculator, data) to scroll when needed */
        }

        /* Notes */

        .notes .panel-body {
            display: grid;
            grid-template-columns: 26% 74%;
            gap: calc(1.0 * var(--u));
            min-height: 0;
            /* allow children to shrink within grid to prevent overflow */
            overflow: hidden;
            /* localize scrolling to inner note list/content */
        }

        .note-list {
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            overflow: auto;
            /* scroll only the list if it overflows */
            background: #fff;
            min-height: 0;
        }

        .note-item {
            display: flex;
            align-items: center;
            gap: calc(0.6 * var(--u));
            padding: calc(0.6 * var(--u));
            border-bottom: var(--bw) solid var(--ink);
            cursor: pointer;
            font-weight: 700;
        }

        .note-item:hover {
            background: var(--mint);
        }

        .note-item.active {
            background: var(--sun);
        }

        /* Title area inside note list item */
        .note-title {
            flex: 1 1 auto;
            min-width: 0;
        }

        /* Drag handle for touch/mouse reordering */
        .drag-handle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: calc(2.2 * var(--u));
            height: calc(2.2 * var(--u));
            padding: 0;
            background: transparent;
            border: none;
            color: var(--ink-80);
            font-weight: 900;
            cursor: grab;
            user-select: none;
            touch-action: none;
            /* grabbing the handle should not scroll */
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Visuals for custom touch-drag */
        .drag-ghost {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.9;
            box-shadow: 0 calc(0.25 * var(--u)) 0 0 var(--ink);
        }

        .drag-placeholder {
            border: calc(0.2 * var(--u)) dashed var(--ink);
            border-radius: var(--radius-sm);
            margin: calc(0.2 * var(--u)) 0;
        }

        /* Dragging cues for sortable lists */
        .note-item.dragging,
        .task-item.dragging {
            opacity: 0.6;
        }

        .note-editor {
            display: grid;
            grid-template-rows: auto auto auto;
            /* title, textarea (resizable), buttons follow textarea */
            gap: calc(0.6 * var(--u));
            overflow: auto;
            /* allow the editor column to scroll if textarea is enlarged */
            min-height: 0;
            padding-bottom: calc(0.8 * var(--u));
            /* leave room so button shadows aren't clipped */
            padding-right: calc(1.0 * var(--u));
            /* add breathing room on the right edge so controls don't touch border */
            align-content: start;
            /* don't stretch rows to fill free space */
            align-items: start;
            /* don't stretch individual controls vertically */
        }

        /* Let note textarea take available space and be the only scroller in the editor column */
        #note-content {
            /* Let the textarea's own min-height control initial size; allow manual resize */
            overflow: auto;
        }

        .input,
        textarea {
            width: 100%;
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            padding: calc(0.6 * var(--u));
            font-size: var(--fs);
            background: #fff;
        }

        /* Extra inner space so the caret doesn't hug the border */
        .input,
        input[type="text"],
        input[type="search"],
        input[type="email"],
        input[type="url"],
        input[type="password"],
        input[type="number"],
        input[type="date"],
        input[type="time"],
        textarea {
            padding: calc(0.8 * var(--u));
        }

        textarea {
            resize: vertical;
            min-height: calc(20 * var(--u));
        }

        /* Tasks */
        .task-input {
            display: flex;
            gap: calc(0.6 * var(--u));
        }

        .tasks-list {
            margin-top: calc(0.8 * var(--u));
        }

        .task-item {
            display: flex;
            align-items: center;
            gap: calc(0.6 * var(--u));
            padding: calc(0.5 * var(--u));
            border-bottom: var(--bw) solid var(--ink);
        }

        .task-item input[type="checkbox"] {
            width: calc(2.0 * var(--u));
            height: calc(2.0 * var(--u));
            border: var(--bw) solid var(--ink);
        }

        .task-item .txt {
            flex: 1;
            /* Preserve user-entered line breaks and wrap long words safely */
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* While a task is being edited, give a subtle background and prevent accidental drag cursor */
        .task-item.editing {
            background: rgba(0, 0, 0, 0.03);
            cursor: default;
        }

        .task-item.done .txt {
            text-decoration: line-through;
            opacity: 0.7;
        }

        /* Calendar */
        .calendar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: calc(0.6 * var(--u));
        }

        .calendar-grid {
            margin-top: calc(0.8 * var(--u));
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: calc(0.5 * var(--u));
        }

        .day-name {
            text-align: center;
            font-weight: 900;
        }

        .day {
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            min-height: calc(10.5 * var(--u));
            padding: calc(0.5 * var(--u));
            background: #fff;
            position: relative;
            cursor: pointer;
        }

        .day .date {
            font-weight: 900;
        }

        .dots {
            position: absolute;
            right: calc(0.5 * var(--u));
            bottom: calc(0.5 * var(--u));
            display: flex;
            gap: calc(0.3 * var(--u));
        }

        .dot {
            width: calc(0.8 * var(--u));
            height: calc(0.8 * var(--u));
            border-radius: 50%;
            border: var(--bw) solid var(--ink);
            background: var(--berry);
        }

        .event-editor {
            margin-top: calc(1.0 * var(--u));
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            padding: calc(0.8 * var(--u));
            background: #fff;
        }

        /* Flip cards */
        .cards-wrap {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: calc(1.0 * var(--u));
        }

        .cards-wrap.practice .card-viewer {
            grid-column: 1 / -1;
        }

        /* In Manage mode, stack the viewer above the editor/list */
        .cards-wrap.manage {
            grid-template-columns: 1fr;
            grid-auto-rows: auto;
        }
        .cards-wrap.manage .card-viewer {
            grid-column: 1;
            grid-row: 1;
        }
        .cards-wrap.manage .card-editor {
            grid-column: 1;
            grid-row: 2;
        }

        .card-editor,
        .card-viewer {
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            padding: calc(0.8 * var(--u));
            background: #fff;
        }

        /* Flip Cards: highlight active mode button and mute inactive */
        #cards-mode-practice[aria-pressed="true"],
        #cards-mode-manage[aria-pressed="true"] {
            background: var(--sun);
            filter: brightness(1.03);
        }

        #cards-mode-practice[aria-pressed="false"],
        #cards-mode-manage[aria-pressed="false"] {
            background: var(--mint-2);
        }

        #card-front,
        #card-back {
            flex: 1 1 20ch;
            min-height: calc(12 * var(--u));
        }

        .flashcard {
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius);
            min-height: calc(18 * var(--u));
            display: grid;
            place-items: center;
            padding: calc(1.0 * var(--u));
            text-align: center;
            background: var(--mint);
            cursor: pointer;
            user-select: none;
            white-space: pre-wrap;
            overflow: auto;
            word-break: break-word;
            align-content: center;
        }

        .hidden {
            display: none !important;
        }

        /* Wheel */
        .wheel-body {
            display: grid;
            grid-template-columns: 60% 40%;
            gap: calc(1.0 * var(--u));
            align-items: stretch;
            min-height: 0;
        }
        .wheel-editor textarea {
            width: 100%;
            height: 100%;
            min-height: calc(22 * var(--u));
        }
        .wheel-canvas-wrap {
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            background: #fff;
            display: grid;
            place-items: center;
            overflow: hidden;
            min-height: calc(22 * var(--u));
        }
        #wheel-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Calculator */
        /* Make the calculator content scalable to fit its panel */
        #panel-calc .panel-body {
            display: grid;
            place-items: center;
            overflow: hidden;
        }

        .calc-fit {
            width: 100%;
            height: 100%;
            display: grid;
            place-items: center;
            overflow: hidden;
        }

        /* Remove legacy width cap inside the calculator panel, allow measuring natural size */
        #panel-calc .calc {
            max-width: none;
            display: grid;
            grid-template-rows: auto 1fr;
            gap: calc(0.8 * var(--u));
            transform-origin: center center;
            will-change: transform;
        }

        .calc-display {
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            padding: calc(0.8 * var(--u));
            background: #fff;
            font-weight: 900;
            letter-spacing: 0.04em;
        }

        .calc-keys {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: calc(0.6 * var(--u));
        }

        .key {
            text-align: center;
            padding: calc(0.8 * var(--u));
            border: var(--bw) solid var(--ink);
            border-radius: var(--radius-sm);
            background: var(--peach);
            font-weight: 900;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 calc(0.25 * var(--u)) 0 0 var(--ink);
        }

        .key.op {
            background: var(--lav);
        }

        .key.wide {
            grid-column: span 2;
        }

        .key:active {
            transform: translateY(calc(0.25 * var(--u)));
            box-shadow: 0 0 0 0 var(--ink);
        }

        /* Data */
        .data-actions {
            display: flex;
            flex-wrap: wrap;
            gap: calc(0.6 * var(--u));
            margin-bottom: calc(0.8 * var(--u));
        }

        .mono {
            font-family: inherit;
            /* unify font across the app */
            font-size: inherit;
            /* standardize to base size everywhere */
        }

        .textarea-json {
            width: 100%;
            min-height: calc(22 * var(--u));
        }

        /* Visual cue for invalid JSON */
        .textarea-json.invalid {
            border-color: #d33 !important;
            box-shadow: 0 0 0 calc(0.2 * var(--u)) rgba(221, 51, 51, 0.15);
        }

        .notice {
            border: var(--bw) dashed var(--ink);
            border-radius: var(--radius-sm);
            padding: calc(0.8 * var(--u));
            margin-bottom: calc(0.8 * var(--u));
            background: #fff;
        }

        /* Footer */
        .footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: calc(1.0 * var(--u));
            padding: calc(0.8 * var(--u)) calc(1.2 * var(--u));
            border-top: var(--bw) solid var(--ink);
            background: var(--page);
        }

        /* Floating scale controls */
        .scale-controls {
            position: absolute;
            top: calc(env(safe-area-inset-top, 0px) + 0.8 * var(--u));
            right: calc(env(safe-area-inset-right, 0px) + 0.8 * var(--u));
            display: flex;
            gap: calc(0.4 * var(--u));
            z-index: 5;
        }

        /* When scale controls are placed inside the title bar, make them flow inline
           so they remain anchored to the bar (prevents overlap with the tab bar in fullscreen). */
        .titlebar .scale-controls {
            position: static;
            top: auto;
            right: auto;
            z-index: auto;
        }

        .round {
            border-radius: 50%;
            width: calc(3.8 * var(--u));
            height: calc(3.8 * var(--u));
            display: grid;
            place-items: center;
            line-height: 1;
            /* tighter baseline for symbols like ⤢, ⟳, −, + */
            padding: 0;
        }

        /* Ensure SVG icons inside round buttons match the visual weight and alignment of +/- */
        .round svg {
            width: 70%;
            height: 70%;
            display: block;
            fill: none;
        }

        .round svg path,
        .round svg polyline,
        .round svg line {
            stroke: var(--ink);
            stroke-width: 2.4;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 780px) {
            .organiser {
                width: 100vw;
            }

            .titlebar {
                padding: calc(0.8 * var(--u)) calc(1.0 * var(--u));
            }

            .tabbar {
                padding: calc(0.5 * var(--u)) calc(0.8 * var(--u));
            }

            .footer {
                padding: calc(0.6 * var(--u)) calc(0.8 * var(--u));
            }

            .notes .panel-body {
                grid-template-columns: 1fr;
            }

            .cards-wrap {
                grid-template-columns: 1fr;
            }

            #card-front,
            #card-back {
                min-height: calc(10 * var(--u));
            }

            /* Wheel: stack vertically on small screens; wheel first, textarea follows */
            .wheel-body {
                grid-template-columns: 1fr;
            }
            .wheel-editor textarea {
                height: auto;
                min-height: calc(16 * var(--u));
            }
        }

        @media (max-height: 640px) {
            .titlebar {
                padding: calc(0.6 * var(--u)) calc(0.8 * var(--u));
            }

            .tabbar {
                padding: calc(0.4 * var(--u)) calc(0.6 * var(--u));
            }

            .panel-body {
                padding: calc(0.6 * var(--u));
            }

            .scale-controls {
                top: calc(env(safe-area-inset-top, 0px) + 0.5 * var(--u));
            }
        }
    </style>
</head>

<body>
    <div class="organiser" id="organiser" role="application" aria-label="Personal Organiser">
        <div class="scale-controls" aria-hidden="false">
            <button class="btn round teal" id="fullscreen-btn" title="Toggle Fullscreen" aria-pressed="false"
                aria-label="Toggle Fullscreen">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <polyline points="3 9 3 3 9 3" />
                    <line x1="3" y1="3" x2="10" y2="10" />
                    <polyline points="15 3 21 3 21 9" />
                    <line x1="14" y1="10" x2="21" y2="3" />
                    <polyline points="21 15 21 21 15 21" />
                    <line x1="21" y1="21" x2="14" y2="14" />
                    <polyline points="9 21 3 21 3 15" />
                    <line x1="10" y1="14" x2="3" y2="21" />
                </svg>
            </button>
            <button class="btn round peach" id="scale-down" title="Scale down" aria-label="Scale down">−</button>
            <button class="btn round lav" id="scale-reset" title="Reset scale" aria-label="Reset scale">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <polyline points="3 6 3 3 6 3" />
                    <path d="M21 12a9 9 0 1 1-9-9" />
                </svg>
            </button>
            <button class="btn round mint" id="scale-up" title="Scale up" aria-label="Scale up">+</button>
        </div>

        <div class="titlebar">
            <div class="title">
                <span style="font-size: var(--fs-lg)">📔</span>
                <span>Personal Organiser</span>
            </div>
            <div class="controls"></div>
        </div>

        <div class="tabbar" role="tablist" aria-label="Organiser sections">
            <button class="tab" role="tab" aria-selected="true" aria-controls="panel-notes"
                id="tab-notes">Notes</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="panel-calendar"
                id="tab-calendar">Calendar</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="panel-tasks"
                id="tab-tasks">Tasks</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="panel-cards" id="tab-cards">Flip
                Cards</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="panel-calc"
                id="tab-calc">Calculator</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="panel-wheel" id="tab-wheel">Wheel</button>
            <button class="tab" role="tab" aria-selected="false" aria-controls="panel-data" id="tab-data">Data</button>
        </div>

        <div class="content">
            <!-- Notes Panel -->
            <section class="panel notes active" role="tabpanel" id="panel-notes" aria-labelledby="tab-notes">
                <div class="panel-header">
                    <div>
                        <button class="btn berry" id="add-note">+ New Note</button>
                    </div>
                    <div class="mono" id="notes-count">0 notes</div>
                </div>
                <div class="panel-body">
                    <div class="note-list" id="note-list" tabindex="0" aria-label="Notes list"></div>
                    <div class="note-editor">
                        <input class="input" id="note-title" placeholder="Note title" />
                        <textarea id="note-content" placeholder="Write your note here..."></textarea>
                        <div style="display:flex; gap: calc(0.6 * var(--u)); justify-content:flex-end;">
                            <button class="btn" id="delete-note">Delete</button>
                            <button class="btn mint" id="save-note">Save</button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Wheel Panel -->
            <section class="panel" role="tabpanel" id="panel-wheel" aria-labelledby="tab-wheel">
                <div class="panel-header">
                    <div style="display:flex; gap: calc(0.6 * var(--u)); align-items:center; flex-wrap:wrap;">
                        <button class="btn mint" id="wheel-spin">Spin</button>
                        <button class="btn peach" id="wheel-remove-spin">Remove &amp; Spin</button>
                        <div class="mono" id="wheel-result" aria-live="polite"></div>
                    </div>
                </div>
                <div class="panel-body wheel-body">
                    <div class="wheel-canvas-wrap">
                        <canvas id="wheel-canvas"></canvas>
                    </div>
                    <div class="wheel-editor">
                        <textarea id="wheel-input" class="mono" placeholder="Enter one option per line..."></textarea>
                        <div style="display:flex; gap: calc(0.6 * var(--u)); margin-top: calc(0.6 * var(--u)); justify-content:flex-end;">
                            <button class="btn" id="wheel-clear">Clear</button>
                            <button class="btn peach" id="wheel-sample">Sample</button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Calendar Panel -->
            <section class="panel" role="tabpanel" id="panel-calendar" aria-labelledby="tab-calendar">
                <div class="panel-header calendar-header">
                    <div style="display:flex; gap: calc(0.6 * var(--u)); align-items:center;">
                        <button class="btn" id="cal-prev">◀</button>
                        <div class="mono" id="cal-label">Month YYYY</div>
                        <button class="btn" id="cal-next">▶</button>
                    </div>
                    <button class="btn mint" id="cal-today">Today</button>
                </div>
                <div class="panel-body">
                    <div class="calendar-grid" id="calendar"></div>
                    <div class="event-editor" id="event-editor" hidden>
                        <div
                            style="display:flex; align-items:center; justify-content:space-between; gap: calc(0.6 * var(--u));">
                            <div class="mono" id="event-date-label"></div>
                            <div style="display:flex; gap: calc(0.6 * var(--u));">
                                <input class="input" id="event-text" placeholder="Add event" />
                                <button class="btn berry" id="add-event">Add</button>
                            </div>
                        </div>
                        <div id="event-list" class="tasks-list" style="margin-top: calc(0.8 * var(--u));"></div>
                    </div>
                </div>
            </section>

            <!-- Tasks Panel -->
            <section class="panel" role="tabpanel" id="panel-tasks" aria-labelledby="tab-tasks">
                <div class="panel-header">
                    <div class="task-input" style="flex:1;">
                        <input class="input" id="task-text" placeholder="New task" />
                        <button class="btn berry" id="add-task">Add</button>
                    </div>
                    <div class="mono" id="tasks-count">0 tasks</div>
                </div>
                <div class="panel-body">
                    <div id="tasks-list" class="tasks-list"></div>
                </div>
            </section>

            <!-- Flip Cards Panel -->
            <section class="panel" role="tabpanel" id="panel-cards" aria-labelledby="tab-cards">
                <div class="panel-header">
                    <div style="display:flex; flex-wrap:wrap; gap: calc(0.6 * var(--u)); align-items:center;">
                        <button class="btn mint" id="cards-mode-practice" aria-pressed="true" title="Practice mode">Practice</button>
                        <button class="btn" id="cards-mode-manage" aria-pressed="false" title="Manage cards">Manage</button>
                        <button class="btn mint" id="shuffle-cards" title="Shuffle deck">Shuffle</button>
                        <button class="btn" id="unshuffle-cards" title="Use list order">Unshuffle</button>
                    </div>
                </div>
                <div class="panel-body">
                    <div class="cards-wrap">
                        <div class="card-editor">
                            <div
                                style="display:flex; flex-wrap:wrap; gap: calc(0.6 * var(--u)); align-items:flex-start;">
                                <textarea id="card-front" placeholder="Front (multi-line)..."></textarea>
                                <textarea id="card-back" placeholder="Back (multi-line)..."></textarea>
                                <div style="display:flex; gap: calc(0.6 * var(--u));">
                                    <button class="btn berry" id="add-card">+ New</button>
                                    <button class="btn mint" id="save-card">Save</button>
                                    <button class="btn" id="delete-card">Delete</button>
                                </div>
                            </div>
                            <div id="cards-list" class="tasks-list" style="margin-top: calc(0.8 * var(--u));"></div>
                        </div>
                        <div class="card-viewer">
                            <div class="flashcard" id="flashcard" title="Click to flip">Click to flip</div>
                            <div
                                style="display:flex; gap: calc(0.6 * var(--u)); justify-content:center; margin-top: calc(0.8 * var(--u));">
                                <button class="btn" id="prev-card">◀ Prev</button>
                                <button class="btn" id="next-card">Next ▶</button>
                            </div>
                            <div class="mono" id="cards-progress" style="text-align:center; margin-top: calc(0.4 * var(--u));"></div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Calculator Panel -->
            <section class="panel" role="tabpanel" id="panel-calc" aria-labelledby="tab-calc">
                <div class="panel-body">
                    <div class="calc">
                        <div class="calc-display mono" id="calc-display">0</div>
                        <div class="calc-keys" id="calc-keys">
                            <div class="key" data-k="7">7</div>
                            <div class="key" data-k="8">8</div>
                            <div class="key" data-k="9">9</div>
                            <div class="key op" data-k="/">÷</div>
                            <div class="key" data-k="4">4</div>
                            <div class="key" data-k="5">5</div>
                            <div class="key" data-k="6">6</div>
                            <div class="key op" data-k="*">×</div>
                            <div class="key" data-k="1">1</div>
                            <div class="key" data-k="2">2</div>
                            <div class="key" data-k="3">3</div>
                            <div class="key op" data-k="-">−</div>
                            <div class="key wide" data-k="0">0</div>
                            <div class="key" data-k=".">.</div>
                            <div class="key op" data-k="+">+</div>
                            <div class="key" data-k="C">C</div>
                            <div class="key wide" data-k="=">=</div>
                            <div class="key" data-k="(">(</div>
                            <div class="key" data-k=")">)</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Data Panel -->
            <section class="panel" role="tabpanel" id="panel-data" aria-labelledby="tab-data">
                <div class="panel-header">
                    <div class="data-actions">
                        <button class="btn mint" id="export-json">Export JSON</button>
                        <button class="btn lav" id="export-schema" title="Download JSON schema">Export Schema</button>
                        <button class="btn" id="import-json">Import JSON</button>
                        <input type="file" id="file-input" accept="application/json" style="display:none" />
                        <button class="btn" id="to-text-json">To Text</button>
                        <button class="btn" id="apply-json" disabled>Apply Text</button>
                        <button class="btn berry" id="erase-all">Erase All</button>
                    </div>
                    <div class="mono">Local only • No accounts • No uploads</div>
                </div>
                <div class="panel-body">
                    <div class="notice">
                        <strong>Privacy Notice:</strong> Your organiser data is stored only in your browser's local
                        storage and never uploaded anywhere. You can export or erase it at any time.
                    </div>
                    <textarea id="json-area" class="textarea-json mono"
                        placeholder="Exported JSON appears here... Paste JSON here, then click Apply Text."></textarea>
                    <div class="mono" id="json-hint" style="margin-top: calc(0.5 * var(--u)); opacity: 0.8;">Paste JSON
                        and click Apply Text. Invalid JSON will not be imported.</div>
                </div>
            </section>
        </div>


    </div>

    <script>
        (function () {
            'use strict';

            const STORAGE_KEY = 'organiser-data-v1';
            const SCALE_KEY = 'organiser-ui-scale';

            // Choose a sensible default scale: bump size on mobile/coarse pointers, keep 1.0 on desktop
            function getDefaultScale() {
                try {
                    const coarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
                    const smallViewport = Math.min(window.innerWidth, window.innerHeight) <= 780;
                    return (coarse || smallViewport) ? 1.6 : 1.0;
                } catch {
                    return 1.0;
                }
            }

            const savedScaleStr = localStorage.getItem(SCALE_KEY);
            let userScale = savedScaleStr !== null ? Number(savedScaleStr) : getDefaultScale(); // persistent UI scale multiplier
            if (!isFinite(userScale) || userScale <= 0) userScale = getDefaultScale();

            const state = loadState() || {
                ui: { tab: 'notes', cardsMode: 'practice' },
                notes: [],
                tasks: [],
                events: {}, // { 'YYYY-MM-DD': [ {id, text} ] }
                cards: [],
                // Shuffled order cache for flip cards: { cards: [ids...], index: number }
                shuffledCache: { cards: [], index: 0 },
                wheel: { itemsText: '' },
            };

            // Ensure the floating controls are anchored inside the title bar so they move with it
            // (fixes Android fullscreen where absolute-positioned controls could overlap the tab bar).
            const titlebarControlsHost = document.querySelector('.titlebar .controls');
            const floatingScaleControls = document.querySelector('.scale-controls');
            if (titlebarControlsHost && floatingScaleControls && floatingScaleControls.parentElement !== titlebarControlsHost) {
                titlebarControlsHost.appendChild(floatingScaleControls);
            }

            // UTILITIES
            function gid(id) { return document.getElementById(id); }
            function fmtDate(d) {
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${y}-${m}-${day}`;
            }
            function uid() { return Math.random().toString(36).slice(2, 10); }
            function saveState() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                    setStatus('Saved');
                } catch (e) { console.warn('Save failed', e); setStatus('Save failed'); }
            }
            let saveTimer;
            function scheduleSave() { clearTimeout(saveTimer); saveTimer = setTimeout(saveState, 300); }
            function loadState() {
                try {
                    const s = localStorage.getItem(STORAGE_KEY);
                    return s ? JSON.parse(s) : null;
                } catch (e) { console.warn('Load failed', e); return null; }
            }
            function setStatus(msg) { /* status UI removed; keep as no-op to avoid breaking callers */ }

            // SCALING
            function updateScaleVars() {
                const minDim = Math.max(320, Math.min(window.innerWidth, window.innerHeight));
                const unit = (minDim / 100) * userScale;
                document.documentElement.style.setProperty('--u', unit + 'px');
            }
            function adjustScale(delta) {
                userScale = Math.max(0.6, Math.min(1.8, +(userScale + delta).toFixed(2)));
                localStorage.setItem(SCALE_KEY, String(userScale));
                updateScaleVars();
                fitCalc();
                if (state.ui.tab === 'wheel') resizeWheelCanvas();
            }

            window.addEventListener('resize', updateScaleVars);
            gid('scale-up').addEventListener('click', () => adjustScale(0.05));
            gid('scale-down').addEventListener('click', () => adjustScale(-0.05));
            gid('scale-reset').addEventListener('click', () => {
                userScale = getDefaultScale();
                localStorage.setItem(SCALE_KEY, String(userScale));
                updateScaleVars();
                setStatus('Scale reset');
                fitCalc();
                if (state.ui.tab === 'wheel') resizeWheelCanvas();
            });

            // FULLSCREEN
            const fsBtn = gid('fullscreen-btn');
            fsBtn.addEventListener('click', async () => {
                try {
                    if (!document.fullscreenElement) {
                        await gid('organiser').requestFullscreen();
                        fsBtn.setAttribute('aria-pressed', 'true');
                    } else {
                        await document.exitFullscreen();
                        fsBtn.setAttribute('aria-pressed', 'false');
                    }
                } catch (e) { console.warn(e); }
            });

            // TABS
            const tabs = [
                { id: 'notes', btn: gid('tab-notes'), panel: gid('panel-notes') },
                { id: 'calendar', btn: gid('tab-calendar'), panel: gid('panel-calendar') },
                { id: 'tasks', btn: gid('tab-tasks'), panel: gid('panel-tasks') },
                { id: 'cards', btn: gid('tab-cards'), panel: gid('panel-cards') },
                { id: 'calc', btn: gid('tab-calc'), panel: gid('panel-calc') },
                { id: 'wheel', btn: gid('tab-wheel'), panel: gid('panel-wheel') },
                { id: 'data', btn: gid('tab-data'), panel: gid('panel-data') },
            ];
            function showTab(id) {
                tabs.forEach(t => {
                    const sel = (t.id === id);
                    t.btn.setAttribute('aria-selected', sel ? 'true' : 'false');
                    if (sel) t.panel.classList.add('active'); else t.panel.classList.remove('active');
                });
                state.ui.tab = id; scheduleSave();
                if (id === 'calc') {
                    // Defer to after layout so sizes are measurable
                    setTimeout(fitCalc, 0);
                } else if (id === 'wheel') {
                    setTimeout(resizeWheelCanvas, 0);
                }
            }
            tabs.forEach(t => t.btn.addEventListener('click', () => showTab(t.id)));
            window.addEventListener('keydown', (e) => {
                if (e.key === '[' || (e.altKey && e.key === 'ArrowLeft')) {
                    const idx = tabs.findIndex(t => t.id === state.ui.tab); showTab(tabs[(idx - 1 + tabs.length) % tabs.length].id);
                }
                if (e.key === ']' || (e.altKey && e.key === 'ArrowRight')) {
                    const idx = tabs.findIndex(t => t.id === state.ui.tab); showTab(tabs[(idx + 1) % tabs.length].id);
                }
            });

            // NOTES
            let currentNoteId = null;
            const noteList = gid('note-list');
            const noteTitle = gid('note-title');
            const noteContent = gid('note-content');
            let sortableNotesEnabled = false;
            function renderNotes() {
                noteList.innerHTML = '';
                state.notes.forEach(n => {
                    const div = document.createElement('div');
                    div.className = 'note-item' + (n.id === currentNoteId ? ' active' : '');
                    div.dataset.id = n.id;
                    div.setAttribute('draggable', 'true');
                    div.tabIndex = 0;

                    const title = document.createElement('div');
                    title.className = 'note-title';
                    title.textContent = (typeof n.title === 'string' && n.title.trim() !== '') ? n.title : '(untitled)';

                    const handle = document.createElement('button');
                    handle.type = 'button';
                    handle.className = 'drag-handle';
                    handle.title = 'Drag to reorder';
                    handle.setAttribute('aria-label', 'Drag to reorder');
                    handle.textContent = '⠿';
                    // Prevent row click when tapping the handle, but allow pointerdown to bubble for drag
                    handle.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });

                    div.onclick = () => { currentNoteId = n.id; fillEditor(); renderNotes(); };
                    div.onkeydown = (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); div.click(); } };

                    div.append(title, handle);
                    noteList.appendChild(div);
                });
                gid('notes-count').textContent = `${state.notes.length} note${state.notes.length !== 1 ? 's' : ''}`;
            }
            function fillEditor() {
                const n = state.notes.find(x => x.id === currentNoteId);
                noteTitle.value = n ? n.title : '';
                noteContent.value = n ? n.content : '';
            }
            function saveCurrentNote(createIfMissing = false) {
                const rawTitle = noteTitle.value; // preserve spaces while typing
                const content = noteContent.value;
                if (!currentNoteId) {
                    if (!createIfMissing) { return; }
                    // For creation, consider trimmed emptiness to decide whether to create
                    if (rawTitle.trim() === '' && content.trim() === '') { return; }
                    const n = { id: uid(), title: (rawTitle.trim() || 'New note'), content, updated: Date.now() };
                    state.notes.unshift(n);
                    currentNoteId = n.id;
                } else {
                    const n = state.notes.find(x => x.id === currentNoteId);
                    if (!n) return;
                    // During updates, keep the exact title as typed (including spaces)
                    n.title = rawTitle;
                    n.content = content;
                    n.updated = Date.now();
                }
                scheduleSave();
                renderNotes();
                fillEditor();
            }
            gid('add-note').addEventListener('click', () => {
                const n = { id: uid(), title: 'New note', content: '', updated: Date.now() };
                state.notes.unshift(n);
                currentNoteId = n.id;
                scheduleSave();
                renderNotes();
                fillEditor();
                noteTitle.focus();
            });
            gid('save-note').addEventListener('click', () => saveCurrentNote(true));
            gid('delete-note').addEventListener('click', () => {
                if (!currentNoteId) return;
                const idx = state.notes.findIndex(x => x.id === currentNoteId);
                if (idx >= 0) { state.notes.splice(idx, 1); currentNoteId = null; scheduleSave(); renderNotes(); fillEditor(); }
            });
            noteTitle.addEventListener('input', () => saveCurrentNote(false));
            noteContent.addEventListener('input', () => saveCurrentNote(false));

            // TASKS
            const taskText = gid('task-text');
            const tasksList = gid('tasks-list');
            let sortableTasksEnabled = false;
            function renderTasks() {
                tasksList.innerHTML = '';
                state.tasks.forEach(t => {
                    const row = document.createElement('div');
                    row.className = 'task-item' + (t.done ? ' done' : '');
                    row.dataset.id = t.id;
                    row.setAttribute('draggable', 'true');

                    const handle = document.createElement('button');
                    handle.type = 'button';
                    handle.className = 'drag-handle';
                    handle.title = 'Drag to reorder';
                    handle.setAttribute('aria-label', 'Drag to reorder');
                    handle.textContent = '⠿';
                    handle.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });

                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.checked = !!t.done;
                    cb.onchange = () => { t.done = cb.checked; scheduleSave(); renderTasks(); };

                    const txt = document.createElement('div');
                    txt.className = 'txt';
                    txt.textContent = t.text;

                    const editBtn = document.createElement('button');
                    editBtn.className = 'btn';
                    editBtn.textContent = 'Edit';

                    const del = document.createElement('button');
                    del.className = 'btn';
                    del.textContent = 'Delete';
                    del.onclick = () => { state.tasks = state.tasks.filter(x => x.id !== t.id); scheduleSave(); renderTasks(); };

                    // Inline edit flow with Save/Cancel
                    editBtn.onclick = () => {
                        if (row.classList.contains('editing')) return;
                        row.classList.add('editing');
                        // rebuild row for editing
                        row.innerHTML = '';
                        const cb2 = document.createElement('input'); cb2.type = 'checkbox'; cb2.checked = !!t.done; cb2.onchange = () => { t.done = cb2.checked; scheduleSave(); };
                        const editor = document.createElement('textarea'); editor.className = 'input mono'; editor.style.minHeight = 'calc(8 * var(--u))'; editor.value = t.text || '';
                        const saveBtn = document.createElement('button'); saveBtn.className = 'btn mint'; saveBtn.textContent = 'Save';
                        const cancelBtn = document.createElement('button'); cancelBtn.className = 'btn peach'; cancelBtn.textContent = 'Cancel';
                        const del2 = document.createElement('button'); del2.className = 'btn'; del2.textContent = 'Delete'; del2.onclick = () => { state.tasks = state.tasks.filter(x => x.id !== t.id); scheduleSave(); renderTasks(); };
                        saveBtn.onclick = () => { t.text = editor.value; scheduleSave(); renderTasks(); };
                        cancelBtn.onclick = () => { renderTasks(); };
                        row.append(cb2, editor, saveBtn, cancelBtn, del2);
                        editor.focus();
                    };

                    // Restrict native drag to only start from the handle and when not editing
                    row.addEventListener('dragstart', (e) => {
                        if (row.classList.contains('editing') || !e.target.closest('.drag-handle')) {
                            e.preventDefault();
                            return false;
                        }
                    });

                    row.append(handle, cb, txt, editBtn, del);
                    tasksList.appendChild(row);
                });
                gid('tasks-count').textContent = `${state.tasks.length} task${state.tasks.length !== 1 ? 's' : ''}`;
            }

            // SORTABLE (drag & drop) for notes and tasks
            function reorderArrayById(arr, ids) {
                const index = new Map();
                ids.forEach((id, i) => index.set(id, i));
                // Items with known ids ordered first, others keep their relative order at the end
                return arr.slice().sort((a, b) => {
                    const ai = index.has(a.id) ? index.get(a.id) : Number.MAX_SAFE_INTEGER;
                    const bi = index.has(b.id) ? index.get(b.id) : Number.MAX_SAFE_INTEGER;
                    if (ai !== bi) return ai - bi;
                    return 0;
                });
            }

            function enableSortable(container, itemSelector, onOrderChange) {
                function getAfterElement(y) {
                    const els = Array.from(container.querySelectorAll(itemSelector + ':not(.dragging)'));
                    return els.reduce((closest, child) => {
                        const box = child.getBoundingClientRect();
                        const offset = y - (box.top + box.height / 2);
                        if (offset < 0 && offset > closest.offset) { return { offset, element: child }; }
                        else { return closest; }
                    }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
                }

                // Desktop: native drag & drop, only from handle
                container.addEventListener('dragstart', (e) => {
                    const item = e.target.closest(itemSelector);
                    if (!item) return;
                    if (!e.target.closest('.drag-handle') || item.classList.contains('editing')) { e.preventDefault(); return; }
                    item.classList.add('dragging');
                    if (e.dataTransfer) { try { e.dataTransfer.effectAllowed = 'move'; } catch { } }
                });
                container.addEventListener('dragend', (e) => {
                    const item = e.target.closest(itemSelector);
                    if (item) item.classList.remove('dragging');
                });
                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const dragging = container.querySelector('.dragging');
                    if (!dragging) return;
                    const after = getAfterElement(e.clientY);
                    if (after == null) container.appendChild(dragging); else container.insertBefore(dragging, after);
                });
                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const orderedIds = Array.from(container.querySelectorAll(itemSelector)).map(el => el.dataset.id).filter(Boolean);
                    onOrderChange(orderedIds);
                });

                // Touch: pointer-based custom drag from handle only
                let draggingEl = null;
                let ghostEl = null;
                let placeholderEl = null;
                let startOffsetY = 0;
                let scrollTimer = null;
                function stopAutoScroll() { if (scrollTimer) { cancelAnimationFrame(scrollTimer); scrollTimer = null; } }
                function autoScrollIfNeeded(y) {
                    const rect = container.getBoundingClientRect();
                    const threshold = Math.min(40, rect.height * 0.1);
                    const topZone = rect.top + threshold;
                    const bottomZone = rect.bottom - threshold;
                    let delta = 0;
                    if (y < topZone) delta = -6; else if (y > bottomZone) delta = 6;
                    if (delta !== 0) { scrollTimer = requestAnimationFrame(() => { container.scrollTop += delta; }); }
                    else { stopAutoScroll(); }
                }

                container.addEventListener('pointerdown', (e) => {
                    const handle = e.target.closest('.drag-handle');
                    if (!handle) return;
                    const item = handle.closest(itemSelector);
                    if (!item || item.classList.contains('editing')) return;
                    e.preventDefault();
                    draggingEl = item;
                    const rect = draggingEl.getBoundingClientRect();
                    startOffsetY = e.clientY - rect.top;
                    placeholderEl = document.createElement('div');
                    placeholderEl.className = 'drag-placeholder';
                    placeholderEl.style.height = rect.height + 'px';
                    container.insertBefore(placeholderEl, draggingEl.nextSibling);
                    ghostEl = draggingEl.cloneNode(true);
                    ghostEl.classList.add('drag-ghost');
                    ghostEl.style.width = rect.width + 'px';
                    ghostEl.style.left = rect.left + 'px';
                    ghostEl.style.top = (e.clientY - startOffsetY) + 'px';
                    document.body.appendChild(ghostEl);
                    draggingEl.classList.add('dragging');
                    draggingEl.style.display = 'none';
                    handle.setPointerCapture?.(e.pointerId);

                    function onMove(ev) {
                        if (!ghostEl) return;
                        ghostEl.style.top = (ev.clientY - startOffsetY) + 'px';
                        const after = getAfterElement(ev.clientY);
                        if (after == null) container.appendChild(placeholderEl); else container.insertBefore(placeholderEl, after);
                        autoScrollIfNeeded(ev.clientY);
                    }
                    function onUp(ev) {
                        stopAutoScroll();
                        handle.releasePointerCapture?.(e.pointerId);
                        window.removeEventListener('pointermove', onMove);
                        window.removeEventListener('pointerup', onUp);
                        window.removeEventListener('pointercancel', onUp);
                        if (!draggingEl) return;
                        draggingEl.style.display = '';
                        draggingEl.classList.remove('dragging');
                        container.insertBefore(draggingEl, placeholderEl);
                        ghostEl?.remove(); ghostEl = null;
                        placeholderEl?.remove(); placeholderEl = null;
                        draggingEl = null;
                        const orderedIds = Array.from(container.querySelectorAll(itemSelector)).map(el => el.dataset.id).filter(Boolean);
                        onOrderChange(orderedIds);
                    }
                    window.addEventListener('pointermove', onMove, { passive: false });
                    window.addEventListener('pointerup', onUp, { passive: false });
                    window.addEventListener('pointercancel', onUp, { passive: false });
                }, { passive: false });
            }
            function addTask() {
                const v = taskText.value.trim(); if (!v) return;
                state.tasks.push({ id: uid(), text: v, done: false });
                taskText.value = '';
                scheduleSave(); renderTasks();
            }
            gid('add-task').addEventListener('click', addTask);
            taskText.addEventListener('keydown', (e) => { if (e.key === 'Enter') { addTask(); } });

            // Flush pending save before closing/navigating away
            window.addEventListener('beforeunload', () => { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch { } });

            // CALENDAR
            const cal = gid('calendar');
            const calLabel = gid('cal-label');
            const eventEditor = gid('event-editor');
            const eventDateLabel = gid('event-date-label');
            const eventText = gid('event-text');
            const eventList = gid('event-list');
            let calYear, calMonth; // month 0-11
            let selectedDateStr = null;

            function setMonth(y, m) { calYear = y; calMonth = m; renderCalendar(); }
            function renderCalendar() {
                const names = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                calLabel.textContent = `${names[calMonth]} ${calYear}`;
                cal.innerHTML = '';
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                dayNames.forEach(n => { const d = document.createElement('div'); d.className = 'day-name'; d.textContent = n; cal.appendChild(d); });
                const first = new Date(calYear, calMonth, 1);
                const start = first.getDay();
                const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                for (let i = 0; i < start; i++) { const empty = document.createElement('div'); cal.appendChild(empty); }
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateStr = `${calYear}-${String(calMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    const cell = document.createElement('div');
                    cell.className = 'day';
                    const label = document.createElement('div'); label.className = 'date'; label.textContent = String(day);
                    cell.appendChild(label);
                    const dots = document.createElement('div'); dots.className = 'dots';
                    const evs = state.events[dateStr] || [];
                    evs.slice(0, 4).forEach(() => { const dot = document.createElement('div'); dot.className = 'dot'; dots.appendChild(dot); });
                    cell.appendChild(dots);
                    cell.onclick = () => { selectedDateStr = dateStr; openEventEditor(dateStr); };
                    cal.appendChild(cell);
                }
            }
            function openEventEditor(dateStr) {
                eventEditor.hidden = false;
                eventDateLabel.textContent = dateStr;
                eventText.value = '';
                renderEventsFor(dateStr);
            }
            function renderEventsFor(dateStr) {
                eventList.innerHTML = '';
                const evs = state.events[dateStr] || [];
                evs.forEach(ev => {
                    const row = document.createElement('div'); row.className = 'task-item';
                    const dot = document.createElement('div'); dot.className = 'dot'; dot.style.marginRight = 'calc(0.4 * var(--u))';
                    const txt = document.createElement('div'); txt.className = 'txt'; txt.contentEditable = 'true'; txt.textContent = ev.text; txt.oninput = () => { ev.text = txt.textContent; scheduleSave(); };
                    const del = document.createElement('button'); del.className = 'btn'; del.textContent = 'Delete'; del.onclick = () => { state.events[dateStr] = (state.events[dateStr] || []).filter(x => x.id !== ev.id); if (state.events[dateStr].length === 0) delete state.events[dateStr]; scheduleSave(); renderCalendar(); renderEventsFor(dateStr); };
                    row.append(dot, txt, del);
                    eventList.appendChild(row);
                });
            }
            gid('add-event').addEventListener('click', () => {
                if (!selectedDateStr) return; const v = eventText.value.trim(); if (!v) return;
                const list = state.events[selectedDateStr] = state.events[selectedDateStr] || [];
                list.push({ id: uid(), text: v });
                eventText.value = '';
                scheduleSave(); renderCalendar(); renderEventsFor(selectedDateStr);
            });
            gid('cal-prev').addEventListener('click', () => { let m = calMonth - 1, y = calYear; if (m < 0) { m = 11; y--; } setMonth(y, m); });
            gid('cal-next').addEventListener('click', () => { let m = calMonth + 1, y = calYear; if (m > 11) { m = 0; y++; } setMonth(y, m); });
            gid('cal-today').addEventListener('click', () => { const d = new Date(); setMonth(d.getFullYear(), d.getMonth()); });

            // INDEX CARDS (Practice / Manage)
            const cardsList = gid('cards-list');
            const cardFront = gid('card-front');
            const cardBack = gid('card-back');
            const flashcard = gid('flashcard');
            const cardsModePracticeBtn = gid('cards-mode-practice');
            const cardsModeManageBtn = gid('cards-mode-manage');
            const cardsWrap = document.querySelector('.cards-wrap');
            const cardsProgress = gid('cards-progress');
            let currentCardId = null;
            let viewerIndex = 0;
            let viewerFront = true;

            // --- Flip Cards: Shuffled cache helpers ---
            function ensureShuffledCache() {
                if (!state.shuffledCache || typeof state.shuffledCache !== 'object') {
                    state.shuffledCache = { cards: [], index: 0 };
                } else {
                    if (!Array.isArray(state.shuffledCache.cards)) state.shuffledCache.cards = [];
                    if (!Number.isInteger(state.shuffledCache.index)) state.shuffledCache.index = 0;
                }
            }

            function listOrderIds() { return state.cards.map(c => c.id); }

            function reconcileShuffledWithCards() {
                ensureShuffledCache();
                const existing = state.shuffledCache.cards || [];
                const idsSet = new Set(state.cards.map(c => c.id));
                // Keep only ids that still exist
                let order = existing.filter(id => idsSet.has(id));
                // Append any new ids not already in order
                state.cards.forEach(c => { if (!order.includes(c.id)) order.push(c.id); });
                state.shuffledCache.cards = order;
                // Clamp index
                if (order.length === 0) state.shuffledCache.index = 0; else state.shuffledCache.index = Math.max(0, Math.min(state.shuffledCache.index || 0, order.length - 1));
                viewerIndex = state.shuffledCache.index;
            }

            function setCardsOrder(orderIds) {
                ensureShuffledCache();
                state.shuffledCache.cards = Array.isArray(orderIds) ? orderIds.slice() : [];
                state.shuffledCache.index = 0;
                viewerIndex = 0;
            }

            function getCardsOrder() {
                ensureShuffledCache();
                if (!state.shuffledCache.cards || state.shuffledCache.cards.length === 0) {
                    // initialize to list order
                    state.shuffledCache.cards = listOrderIds();
                    state.shuffledCache.index = 0;
                }
                return state.shuffledCache.cards;
            }

            function getCurrentViewerCardId() {
                const order = getCardsOrder();
                if (order.length === 0) return null;
                const idx = ((viewerIndex % order.length) + order.length) % order.length;
                return order[idx] || null;
            }

            function setViewerIndex(newIdx) {
                const order = getCardsOrder();
                if (order.length === 0) { viewerIndex = 0; state.shuffledCache.index = 0; return; }
                const len = order.length;
                viewerIndex = ((newIdx % len) + len) % len;
                state.shuffledCache.index = viewerIndex;
            }

            function setCardsMode(mode) {
                state.ui.cardsMode = mode;
                const isPractice = mode === 'practice';
                cardsModePracticeBtn.setAttribute('aria-pressed', String(isPractice));
                cardsModeManageBtn.setAttribute('aria-pressed', String(!isPractice));
                // Hide editor when practicing
                const editor = document.querySelector('.card-editor');
                if (isPractice) {
                    editor.classList.add('hidden');
                    cardsWrap.classList.add('practice');
                    cardsWrap.classList.remove('manage');
                    // ensure we show the front side when practicing, keep position
                    viewerFront = true; updateViewer();
                } else {
                    editor.classList.remove('hidden');
                    cardsWrap.classList.remove('practice');
                    cardsWrap.classList.add('manage');
                    // Auto-load the current viewer card into the editor for quick edits
                    const id = getCurrentViewerCardId();
                    if (id) {
                        const c = state.cards.find(x => x.id === id);
                        currentCardId = id;
                        cardFront.value = c ? c.front : '';
                        cardBack.value = c ? c.back : '';
                    } else {
                        // No cards: clear the editor and selection
                        currentCardId = null;
                        cardFront.value = '';
                        cardBack.value = '';
                    }
                }
                scheduleSave();
            }

            function renderCards() {
                cardsList.innerHTML = '';
                state.cards.forEach(c => {
                    const row = document.createElement('div'); row.className = 'task-item';
                    row.dataset.id = c.id; row.setAttribute('draggable', 'true');
                    // Drag handle for manual reordering in Manage
                    const handle = document.createElement('button'); handle.type = 'button'; handle.className = 'drag-handle'; handle.title = 'Drag to reorder'; handle.setAttribute('aria-label', 'Drag to reorder'); handle.textContent = '⠿';
                    handle.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
                    const preview = document.createElement('div'); preview.className = 'txt mono';
                    const firstLine = (c.front || '').split(/\r?\n/)[0] || '(front)';
                    preview.textContent = firstLine;
                    const sel = document.createElement('button'); sel.className = 'btn'; sel.textContent = 'Edit'; sel.onclick = () => {
                        currentCardId = c.id; cardFront.value = c.front; cardBack.value = c.back;
                        // Keep viewer and editor in sync when selecting from the list
                        const idx = getCardsOrder().indexOf(c.id);
                        if (idx >= 0) { setViewerIndex(idx); viewerFront = true; updateViewer(); }
                    };
                    const del = document.createElement('button'); del.className = 'btn'; del.textContent = 'Delete'; del.onclick = () => { deleteCardAndAdjust(c.id); };
                    // Restrict native drag to only start from the handle
                    row.addEventListener('dragstart', (e) => { if (!e.target.closest('.drag-handle')) { e.preventDefault(); return false; } });
                    row.append(handle, preview, sel, del);
                    cardsList.appendChild(row);
                });
            }

            function updateViewer() {
                const order = getCardsOrder();
                if (order.length === 0) {
                    flashcard.textContent = 'No flip cards yet';
                    // In Manage mode with no cards, clear editor and selection
                    if (state.ui.cardsMode === 'manage') {
                        currentCardId = null;
                        cardFront.value = '';
                        cardBack.value = '';
                    }
                    updateCardsProgress();
                    return;
                }
                const idx = ((viewerIndex % order.length) + order.length) % order.length;
                const id = order[idx];
                const c = state.cards.find(x => x.id === id) || state.cards[0];
                flashcard.textContent = viewerFront ? (c.front || '(front)') : (c.back || '(back)');
                // In Manage mode, keep the editor synced to the current viewer card
                if (state.ui.cardsMode === 'manage') {
                    currentCardId = id;
                    cardFront.value = c ? c.front : '';
                    cardBack.value = c ? c.back : '';
                }
                updateCardsProgress();
            }

            function updateCardsProgress() {
                if (!cardsProgress) return;
                const order = getCardsOrder();
                const total = order.length;
                if (!total) { cardsProgress.textContent = ''; return; }
                const idx = ((viewerIndex % total) + total) % total;
                cardsProgress.textContent = `${idx + 1} of ${total}`;
            }

            // Manage actions
            // Add creates a blank card and selects it for editing
            gid('add-card')?.addEventListener('click', () => {
                const c = { id: uid(), front: '', back: '' };
                state.cards.push(c);
                currentCardId = c.id;
                cardFront.value = '';
                cardBack.value = '';
                reconcileShuffledWithCards();
                // Move the viewer to the new card to keep preview and editor aligned
                const idx = getCardsOrder().indexOf(c.id);
                if (idx >= 0) setViewerIndex(idx);
                viewerFront = true;
                scheduleSave(); renderCards(); updateViewer();
            });

            gid('save-card').addEventListener('click', () => {
                if (!currentCardId) { // create new if none selected
                    const c = { id: uid(), front: cardFront.value, back: cardBack.value };
                    state.cards.push(c);
                    currentCardId = c.id;
                    reconcileShuffledWithCards();
                    const idx = getCardsOrder().indexOf(c.id);
                    if (idx >= 0) setViewerIndex(idx);
                } else {
                    const c = state.cards.find(x => x.id === currentCardId);
                    if (c) { c.front = cardFront.value; c.back = cardBack.value; }
                    reconcileShuffledWithCards();
                }
                scheduleSave(); renderCards(); updateViewer();
            });

            gid('delete-card').addEventListener('click', () => {
                if (!currentCardId) return; const id = currentCardId; currentCardId = null; cardFront.value = ''; cardBack.value = ''; deleteCardAndAdjust(id);
            });

            function deleteCardAndAdjust(id) {
                const order = getCardsOrder();
                const currentId = getCurrentViewerCardId();
                // Remove from main list
                state.cards = state.cards.filter(x => x.id !== id);
                // Remove from cache order
                ensureShuffledCache();
                state.shuffledCache.cards = (state.shuffledCache.cards || []).filter(cid => cid !== id);
                // Adjust viewer index if we deleted the current one or shifted past end
                if (currentId === id) {
                    // keep same numeric index if possible; if index now equals length, move to previous
                    const len = state.shuffledCache.cards.length;
                    if (len === 0) { setViewerIndex(0); }
                    else if (viewerIndex >= len) { setViewerIndex(len - 1); }
                } else {
                    // If deletion changed length and index is out of bounds, clamp
                    const len = state.shuffledCache.cards.length;
                    if (len === 0) setViewerIndex(0); else if (viewerIndex >= len) setViewerIndex(len - 1);
                }
                scheduleSave(); renderCards(); updateViewer();
            }

            // Practice actions
            gid('shuffle-cards').addEventListener('click', () => {
                // Build a shuffled order of IDs from the current list, without changing list order
                const ids = listOrderIds();
                for (let i = ids.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [ids[i], ids[j]] = [ids[j], ids[i]]; }
                setCardsOrder(ids);
                viewerFront = true; updateViewer(); scheduleSave();
            });
            gid('unshuffle-cards').addEventListener('click', () => {
                // Reset cached order to current list order
                setCardsOrder(listOrderIds());
                viewerFront = true; updateViewer(); scheduleSave();
            });
            gid('prev-card').addEventListener('click', () => { setViewerIndex(viewerIndex - 1); viewerFront = true; updateViewer(); scheduleSave(); });
            gid('next-card').addEventListener('click', () => { setViewerIndex(viewerIndex + 1); viewerFront = true; updateViewer(); scheduleSave(); });
            flashcard.addEventListener('click', () => { viewerFront = !viewerFront; updateViewer(); });

            // Mode toggle
            cardsModePracticeBtn.addEventListener('click', () => setCardsMode('practice'));
            cardsModeManageBtn.addEventListener('click', () => setCardsMode('manage'));

            // CALCULATOR
            const calcDisplay = gid('calc-display');
            const calcKeys = gid('calc-keys');
            let expr = '';
            function setDisplay(v) { calcDisplay.textContent = v; }
            function sanitize(s) { return s.replace(/[^0-9+\-*/().]/g, ''); }
            function press(k) {
                if (k === 'C') { expr = ''; setDisplay('0'); return; }
                if (k === '=') { try { const res = Function('return (' + sanitize(expr || '0') + ')')(); expr = String(res); setDisplay(expr); } catch { setDisplay('Err'); } return; }
                if (k === 'Backspace') { expr = expr.slice(0, -1); setDisplay(expr || '0'); return; }
                expr += k; setDisplay(expr);
            }
            calcKeys.addEventListener('click', (e) => { const t = e.target.closest('.key'); if (!t) return; press(t.dataset.k); });
            window.addEventListener('keydown', (e) => {
                if (['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '+', '-', '*', '/', '(', ')'].includes(e.key)) press(e.key);
                else if (e.key === 'Enter' || e.key === '=') press('=');
                else if (e.key === 'Backspace') press('Backspace');
            });

            // DATA PANEL
            const exportBtn = gid('export-json');
            const exportSchemaBtn = gid('export-schema');
            const importBtn = gid('import-json');
            const fileInput = gid('file-input');
            const jsonArea = gid('json-area');
            const toTextBtn = gid('to-text-json');
            exportBtn.addEventListener('click', () => {
                const data = JSON.stringify(state, null, 2);
                jsonArea.value = data;
                try {
                    const blob = new Blob([data], { type: 'application/json' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'organiser-export.json';
                    a.click();
                    URL.revokeObjectURL(a.href);
                } catch { }
            });
            exportSchemaBtn?.addEventListener('click', () => {
                // JSON Schema for organiser state used for external generation
                const schema = {
                    $schema: 'https://json-schema.org/draft/2020-12/schema',
                    $id: 'https://example.com/organiser.schema.json',
                    title: 'Personal Organiser Schema',
                    description: 'Schema for exporting/importing Personal Organiser data.',
                    type: 'object',
                    additionalProperties: false,
                    properties: {
                        ui: {
                            type: 'object',
                            description: 'Optional UI hints; not required when generating data.',
                            additionalProperties: true,
                            properties: {
                                tab: { type: 'string', enum: ['notes','calendar','tasks','cards','calc','wheel','data'] },
                                cardsMode: { type: 'string', enum: ['practice','manage'] }
                            },
                            required: []
                        },
                        notes: {
                            type: 'array',
                            description: 'List of notes. Omit id to auto-generate.',
                            items: {
                                type: 'object',
                                additionalProperties: false,
                                properties: {
                                    id: { type: 'string', description: 'Optional. If missing, an id will be generated.' },
                                    title: { type: 'string', default: '' },
                                    content: { type: 'string', default: '' },
                                    updated: { type: 'number', description: 'Unix ms timestamp', default: 0 }
                                },
                                required: ['title','content']
                            },
                            default: []
                        },
                        tasks: {
                            type: 'array',
                            description: 'Task list with completion flags.',
                            items: {
                                type: 'object',
                                additionalProperties: false,
                                properties: {
                                    id: { type: 'string', description: 'Optional. If missing, an id will be generated.' },
                                    text: { type: 'string' },
                                    done: { type: 'boolean', default: false }
                                },
                                required: ['text']
                            },
                            default: []
                        },
                        events: {
                            type: 'object',
                            description: 'Calendar events keyed by YYYY-MM-DD.',
                            patternProperties: {
                                '^[0-9]{4}-[0-9]{2}-[0-9]{2}$': {
                                    type: 'array',
                                    items: {
                                        type: 'object',
                                        additionalProperties: false,
                                        properties: {
                                            id: { type: 'string', description: 'Optional. If missing, an id will be generated.' },
                                            text: { type: 'string' }
                                        },
                                        required: ['text']
                                    }
                                }
                            },
                            additionalProperties: false,
                            default: {}
                        },
                        cards: {
                            type: 'array',
                            description: 'Flip cards for learning. Omit id to auto-generate.',
                            items: {
                                type: 'object',
                                additionalProperties: false,
                                properties: {
                                    id: { type: 'string', description: 'Optional. If missing, an id will be generated.' },
                                    front: { type: 'string', default: '' },
                                    back: { type: 'string', default: '' }
                                },
                                required: ['front','back']
                            },
                            default: []
                        },
                        shuffledCache: {
                            type: 'object',
                            description: 'Optional shuffle cache for practice mode; safe to omit.',
                            additionalProperties: false,
                            properties: {
                                cards: { type: 'array', items: { type: 'string' }, default: [] },
                                index: { type: 'number', default: 0 }
                            },
                            required: []
                        },
                        wheel: {
                            type: 'object',
                            description: 'Spinner wheel content.',
                            additionalProperties: false,
                            properties: {
                                itemsText: { type: 'string', description: 'One option per line for the spinner wheel.', default: '' }
                            },
                            required: []
                        }
                    },
                    required: [],
                    examples: [
                        {
                            notes: [ { title: 'Welcome', content: 'This is your organiser.' } ],
                            tasks: [ { text: 'Set goals', done: false } ],
                            events: { '2025-09-14': [ { text: 'Daily run 20 min' } ] },
                            cards: [ { front: 'What is VO2 max?', back: 'Maximal oxygen uptake during intense exercise.' } ],
                            wheel: { itemsText: 'Read a book\nStretching\nShort walk' }
                        }
                    ]
                };
                try {
                    const data = JSON.stringify(schema, null, 2);
                    const blob = new Blob([data], { type: 'application/schema+json' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'organiser.schema.json';
                    a.click();
                    URL.revokeObjectURL(a.href);
                } catch {}
            });
            importBtn.addEventListener('click', () => fileInput.click());
            toTextBtn.addEventListener('click', () => {
                const data = JSON.stringify(state, null, 2);
                jsonArea.value = data;
                // Re-run validator to enable Apply if valid
                try { validateJsonInput(); } catch {}
            });
            fileInput.addEventListener('change', () => {
                const f = fileInput.files && fileInput.files[0]; if (!f) return;
                const r = new FileReader();
                r.onload = () => {
                    try {
                        let obj = JSON.parse(String(r.result));
                        if (!isValidStateImport(obj)) { alert('Invalid JSON'); return; }
                        if (Array.isArray(obj)) obj = { cards: obj };
                        if (Array.isArray(obj.cards)) {
                            obj.cards = obj.cards.map(c => ({ id: typeof c.id === 'string' ? c.id : uid(), front: c.front || '', back: c.back || '' }));
                        }
                        if (obj && typeof obj === 'object') { Object.assign(state, obj); ensureShuffledCache(); reconcileShuffledWithCards(); scheduleSave(); initRenderAll(); setStatus('Imported'); }
                    }
                    catch (e) { alert('Invalid JSON'); }
                };
                r.readAsText(f);
            });
            // Validate JSON as user types/pastes; do not import until Apply is pressed
            const applyBtn = gid('apply-json');
            // Lightweight shape validator: allows partials; validates optional shuffledCache
            function isPlainObject(v) { return !!v && typeof v === 'object' && !Array.isArray(v); }
            function isStringArray(v) { return Array.isArray(v) && v.every(x => typeof x === 'string'); }
            function isCard(v) { return isPlainObject(v) && (typeof v.id === 'string' || !('id' in v)); }
            function isCardArray(v) { return Array.isArray(v) && v.every(isCard); }
            function isValidStateImport(obj) {
                // Accept top-level array of cards as a shorthand
                if (Array.isArray(obj)) return isCardArray(obj);
                if (!isPlainObject(obj)) return false;
                if ('ui' in obj && !isPlainObject(obj.ui)) return false;
                if ('notes' in obj && !Array.isArray(obj.notes)) return false;
                if ('tasks' in obj && !Array.isArray(obj.tasks)) return false;
                if ('events' in obj && !isPlainObject(obj.events)) return false;
                if ('cards' in obj && !isCardArray(obj.cards)) return false;
                if ('shuffledCache' in obj) {
                    const sc = obj.shuffledCache;
                    if (!isPlainObject(sc)) return false;
                    if ('cards' in sc && !isStringArray(sc.cards)) return false;
                    if ('index' in sc && !(typeof sc.index === 'number' && Number.isFinite(sc.index))) return false;
                }
                return true;
            }
            function validateJsonInput() {
                const txt = jsonArea.value.trim();
                if (!txt) { jsonArea.classList.remove('invalid'); applyBtn.disabled = true; return; }
                try {
                    const obj = JSON.parse(txt);
                    const ok = isValidStateImport(obj);
                    if (ok) { jsonArea.classList.remove('invalid'); applyBtn.disabled = false; }
                    else { jsonArea.classList.add('invalid'); applyBtn.disabled = true; }
                }
                catch { jsonArea.classList.add('invalid'); applyBtn.disabled = true; }
            }
            jsonArea.addEventListener('input', validateJsonInput);
            jsonArea.addEventListener('paste', () => setTimeout(validateJsonInput, 0));
            applyBtn.addEventListener('click', () => {
                const txt = jsonArea.value.trim();
                try {
                    let obj = JSON.parse(txt);
                    if (!isValidStateImport(obj)) { alert('Invalid JSON shape'); return; }
                    // Support top-level cards array shorthand
                    if (Array.isArray(obj)) {
                        obj = { cards: obj };
                    }
                    if (obj && typeof obj === 'object') {
                        // Ensure cards have ids
                        if (Array.isArray(obj.cards)) {
                            obj.cards = obj.cards.map(c => ({ id: typeof c.id === 'string' ? c.id : uid(), front: c.front || '', back: c.back || '' }));
                        }
                        Object.assign(state, obj);
                        ensureShuffledCache();
                        reconcileShuffledWithCards();
                        scheduleSave();
                        initRenderAll();
                        setStatus('Imported');
                        applyBtn.disabled = true;
                    }
                } catch {
                    alert('Invalid JSON');
                }
            });
            gid('erase-all').addEventListener('click', () => {
                if (!confirm('Erase ALL organiser data? This cannot be undone.')) return;
                // Preserve current UI (tab/mode), wipe user data
                const currentUI = { tab: state.ui?.tab || 'notes', cardsMode: state.ui?.cardsMode || 'practice' };
                localStorage.removeItem(STORAGE_KEY);
                state.ui = currentUI;
                state.notes = [];
                state.tasks = [];
                state.events = {};
                state.cards = [];
                state.shuffledCache = { cards: [], index: 0 };
                state.wheel = { itemsText: '' };
                // Clear the JSON textarea and reset validation state
                if (jsonArea) {
                    jsonArea.value = '';
                    jsonArea.classList.remove('invalid');
                }
                if (applyBtn) applyBtn.disabled = true;
                initRenderAll();
                setStatus('Erased');
            });

            // WHEEL
            const wheelInput = gid('wheel-input');
            const wheelSpinBtn = gid('wheel-spin');
            const wheelRemoveSpinBtn = gid('wheel-remove-spin');
            const wheelCanvas = gid('wheel-canvas');
            const wheelResult = gid('wheel-result');
            const wheelClearBtn = gid('wheel-clear');
            const wheelSampleBtn = gid('wheel-sample');
            // Initialize wheel state lazily
            if (!state.wheel) state.wheel = { itemsText: '' };

            let wheelAngle = 0; // current rotation in radians
            let wheelSpinning = false;
            let spinStart = 0;
            let spinDuration = 0;
            let startAngle = 0;
            let targetAngle = 0; // absolute angle to end at

            function getWheelItems() {
                const text = (wheelInput?.value ?? state.wheel.itemsText ?? '').replace(/\r\n?/g, '\n');
                return text.split(/\n/).map(s => s.trim()).filter(Boolean);
            }

            function resizeWheelCanvas() {
                if (!wheelCanvas) return;
                const wrap = wheelCanvas.parentElement;
                if (!wrap) return;
                const s = Math.max(50, Math.min(wrap.clientWidth, wrap.clientHeight));
                const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
                wheelCanvas.width = Math.floor(s * dpr);
                wheelCanvas.height = Math.floor(s * dpr);
                wheelCanvas.style.width = s + 'px';
                wheelCanvas.style.height = s + 'px';
                drawWheel();
            }

            function wheelColors(i) {
                const palette = [
                    getComputedStyle(document.documentElement).getPropertyValue('--peach').trim() || '#ffc9a9',
                    getComputedStyle(document.documentElement).getPropertyValue('--mint').trim() || '#b9f5c6',
                    getComputedStyle(document.documentElement).getPropertyValue('--teal').trim() || '#9ee7e5',
                    getComputedStyle(document.documentElement).getPropertyValue('--lav').trim() || '#cdb4ff',
                    getComputedStyle(document.documentElement).getPropertyValue('--berry').trim() || '#ff6fa7'
                ];
                return palette[i % palette.length];
            }

            function drawRoundedTriangle(ctx, x, y, w, h, r) {
                const rw = Math.min(r, w / 2), rh = Math.min(r, h / 2);
                ctx.beginPath();
                // Triangle pointing left: base centered at right, tip at left
                // Points: A (x, y), B (x + w, y - h/2), C (x + w, y + h/2)
                const A = { x: x, y: y };
                const B = { x: x + w, y: y - h / 2 };
                const C = { x: x + w, y: y + h / 2 };
                // Move slightly inwards for rounded corners
                ctx.moveTo(A.x + rw, A.y);
                // Arc at B
                ctx.lineTo(B.x - rw, B.y + rh);
                ctx.quadraticCurveTo(B.x, B.y, B.x - rw, B.y - rh);
                // Arc at C
                ctx.lineTo(C.x - rw, C.y - rh);
                ctx.quadraticCurveTo(C.x, C.y, C.x - rw, C.y + rh);
                // Back to A with arc
                ctx.lineTo(A.x + rw, A.y);
                ctx.quadraticCurveTo(A.x, A.y, A.x + rw, A.y);
                ctx.closePath();
            }

            function computeHitIndexByAngle(angle, n) {
                // Determine which slice center is closest to pointer at +X for a given wheel angle
                const a = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                for (let i = 0; i < n; i++) {
                    const a0 = (i / n) * Math.PI * 2;
                    const a1 = ((i + 1) / n) * Math.PI * 2;
                    const aMid = (a0 + a1) / 2;
                    const rel = (aMid + a + Math.PI * 2) % (Math.PI * 2);
                    if (rel < Math.PI / n || rel > (Math.PI * 2 - Math.PI / n)) return i;
                }
                return 0;
            }

            function drawWheel() {
                if (!wheelCanvas) return;
                const ctx = wheelCanvas.getContext('2d');
                const { width: W, height: H } = wheelCanvas;
                ctx.clearRect(0, 0, W, H);
                const items = getWheelItems();
                const n = items.length || 1;
                const highlightIdx = (!wheelSpinning && items.length) ? computeHitIndexByAngle(wheelAngle, n) : -1;
                const cx = W / 2, cy = H / 2;
                // Leave enough clearance for thick stroke so it isn't clipped by the canvas edge
                const rawR = Math.min(cx, cy);
                // Estimate stroke and ensure at least half the stroke width plus a small buffer fits
                let r = rawR - 4;
                let estStroke = Math.max(1.5, r * 0.045);
                const minClear = Math.max(4, estStroke / 2 + 2);
                r = rawR - minClear;
                // Outer circle background
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(wheelAngle);
                for (let i = 0; i < n; i++) {
                    const a0 = (i / n) * Math.PI * 2;
                    const a1 = ((i + 1) / n) * Math.PI * 2;
                    // Slice
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, r, a0, a1);
                    ctx.closePath();
                    if (i === highlightIdx) {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--leaf').trim() || '#a0d468';
                    } else {
                        ctx.fillStyle = wheelColors(i);
                    }
                    ctx.fill();
                    // Outline
                    ctx.lineWidth = Math.max(1.5, r * 0.045);
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink').trim() || '#000';
                    ctx.stroke();

                    // Label: Angle the text along the slice bisector towards the wheel center.
                    // Start of text should be closest to the center, flowing outward along the bisector.
                    const aMid = (a0 + a1) / 2;
                    ctx.save();
                    // Rotate to bisector; draw text along +X in this local frame
                    ctx.rotate(aMid);
                    const inner = r * 0.32; // where text starts
                    ctx.translate(inner, 0);
                    // Text settings
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink').trim() || '#000';
                    ctx.font = `${Math.max(10, Math.floor(r * 0.16))}px Noto Sans, sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    const label = items[i] || '';
                    const maxWidth = r - inner - 4;
                    ctx.save();
                    // Slight white halo for readability
                    ctx.shadowColor = 'rgba(255,255,255,0.9)';
                    ctx.shadowBlur = Math.max(0, Math.floor(r * 0.03));
                    ctx.fillText(label, 0, 0, maxWidth);
                    ctx.restore();
                    ctx.restore();
                }
                ctx.restore();

                // Draw pointer on the right (east). Triangle with rounded outline.
                ctx.save();
                const outline = getComputedStyle(document.documentElement).getPropertyValue('--ink').trim() || '#000';
                const yellow = getComputedStyle(document.documentElement).getPropertyValue('--sun').trim() || '#ffd86b';
                const pointerW = Math.min(W, H) * 0.14;
                const pointerH = Math.min(W, H) * 0.18;
                const pointerStroke = Math.max(2, Math.min(W, H) * 0.03);
                const pad = Math.max(Math.min(W, H) * 0.02, pointerStroke / 2 + 2);
                const px = W - pad - pointerW; // leftmost x of pointer body
                const py = H / 2;
                // Simple triangle: tip at (px, py), base on the right
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + pointerW, py - pointerH / 2);
                ctx.lineTo(px + pointerW, py + pointerH / 2);
                ctx.closePath();
                ctx.fillStyle = yellow;
                ctx.fill();
                ctx.lineWidth = pointerStroke;
                ctx.strokeStyle = outline;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
                ctx.restore();
            }

            function angleForIndex(i, n) { return (i / n) * Math.PI * 2; }

            function spinWheel(onDone) {
                const items = getWheelItems();
                const n = items.length;
                if (!n) { wheelResult.textContent = 'Add options to spin'; return; }
                if (wheelSpinning) return;
                // Choose a target slice randomly
                const idx = Math.floor(Math.random() * n);
                // Align slice center to pointer at +X.
                const TAU = Math.PI * 2;
                const aMid = (angleForIndex(idx, n) + angleForIndex(idx + 1, n)) / 2;
                startAngle = wheelAngle;
                const spins = 4 + Math.floor(Math.random() * 3); // 4-6 extra spins for fun
                const norm = (a) => ((a % TAU) + TAU) % TAU;
                const aStartMod = norm(startAngle);
                const needed = norm(-aMid - aStartMod); // delta to bring aMid to 0 (pointer)
                const delta = needed + spins * TAU;
                targetAngle = startAngle + delta;
                spinDuration = 1800 + Math.random() * 1200; // ms
                spinStart = performance.now();
                wheelSpinning = true;
                if (wheelSpinBtn) wheelSpinBtn.disabled = true;
                if (wheelRemoveSpinBtn) wheelRemoveSpinBtn.disabled = true;

                function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
                const animate = (now) => {
                    if (!wheelSpinning) return;
                    const t = Math.min(1, (now - spinStart) / spinDuration);
                    const eased = easeOutCubic(t);
                    wheelAngle = startAngle + (targetAngle - startAngle) * eased;
                    drawWheel();
                    if (t < 1) { requestAnimationFrame(animate); }
                    else {
                        // Snap to exact target to avoid endless micro-rotation
                        wheelAngle = targetAngle % (Math.PI * 2);
                        wheelSpinning = false;
                        if (wheelSpinBtn) wheelSpinBtn.disabled = false;
                        if (wheelRemoveSpinBtn) wheelRemoveSpinBtn.disabled = false;
                        drawWheel();
                        // Announce result: which slice at +X
                        const finalAngle = wheelAngle % (Math.PI * 2);
                        const hit = computeHitIndexByAngle(finalAngle, n);
                        const winner = items[hit] || '';
                        wheelResult.textContent = winner;
                        if (typeof onDone === 'function') onDone({ index: hit, text: winner, items });
                    }
                };
                requestAnimationFrame(animate);
            }

            function wheelInputChanged() {
                state.wheel.itemsText = wheelInput.value;
                scheduleSave();
                drawWheel();
            }

            wheelInput?.addEventListener('input', wheelInputChanged);
            wheelSpinBtn?.addEventListener('click', () => spinWheel());
            wheelRemoveSpinBtn?.addEventListener('click', () => {
                if (wheelSpinning) return;
                const items = getWheelItems();
                const n = items.length;
                if (!n) { wheelResult.textContent = 'Add options to spin'; return; }
                // Remove the currently highlighted item (under the pointer at +X)
                const idx = computeHitIndexByAngle(wheelAngle, n);
                const updated = items.filter((_, i) => i !== idx);
                wheelInput.value = updated.join('\n');
                wheelInputChanged(); // persists + redraws wheel immediately
                wheelResult.textContent = '';
                // If any items remain, spin the updated wheel
                if (updated.length > 0) {
                    spinWheel();
                }
            });
            wheelClearBtn?.addEventListener('click', () => { wheelInput.value = ''; wheelInputChanged(); wheelResult.textContent = ''; });
            wheelSampleBtn?.addEventListener('click', () => {
                if (!wheelInput) return;
                const samples = ['Pizza', 'Sushi', 'Burgers', 'Salad', 'Pasta', 'Curry', 'Tacos'];
                wheelInput.value = samples.join('\n');
                wheelInputChanged();
            });


            // INIT
            function initRenderAll() {
                // Notes
                if (state.notes.length) { currentNoteId = state.notes[0].id; } else { currentNoteId = null; }
                renderNotes(); fillEditor();
                if (!sortableNotesEnabled) {
                    enableSortable(noteList, '.note-item', (ids) => {
                        state.notes = reorderArrayById(state.notes, ids);
                        scheduleSave();
                        renderNotes();
                        fillEditor();
                    });
                    sortableNotesEnabled = true;
                }
                // Tasks
                renderTasks();
                if (!sortableTasksEnabled) {
                    enableSortable(tasksList, '.task-item', (ids) => {
                        state.tasks = reorderArrayById(state.tasks, ids);
                        scheduleSave();
                        renderTasks();
                    });
                    sortableTasksEnabled = true;
                }
                // Calendar
                const d = new Date(); setMonth(d.getFullYear(), d.getMonth()); selectedDateStr = null; eventEditor.hidden = true;
                // Cards
                ensureShuffledCache();
                reconcileShuffledWithCards();
                renderCards();
                updateViewer();
                setCardsMode(state.ui.cardsMode || 'practice');
                // Enable sortable for cards manage list once
                if (!window.__sortableCardsEnabled) {
                    enableSortable(cardsList, '.task-item', (ids) => {
                        state.cards = reorderArrayById(state.cards, ids);
                        // Keep cache, but make sure any new/missing ids are reconciled
                        reconcileShuffledWithCards();
                        // After reordering, keep viewer on the currently edited card if possible
                        if (currentCardId) {
                            const idx = getCardsOrder().indexOf(currentCardId);
                            if (idx >= 0) setViewerIndex(idx);
                        }
                        scheduleSave();
                        renderCards();
                        updateViewer();
                    });
                    window.__sortableCardsEnabled = true;
                }
                // Tabs
                showTab(state.ui.tab || 'notes');
                // Wheel
                if (wheelInput) {
                    wheelInput.value = state.wheel?.itemsText || '';
                }
                setTimeout(() => { resizeWheelCanvas(); }, 0);
            }

            // Start
            updateScaleVars();
            initRenderAll();

            // Calculator autosize: wrap and scale to fit available space
            function ensureCalcWrapper() {
                const calcPanelBody = document.querySelector('#panel-calc .panel-body');
                if (!calcPanelBody) return null;
                let wrap = document.getElementById('calc-fit');
                const calcEl = calcPanelBody.querySelector('.calc');
                if (!calcEl) return null;
                if (!wrap) {
                    wrap = document.createElement('div');
                    wrap.id = 'calc-fit';
                    wrap.className = 'calc-fit';
                    calcEl.parentElement.insertBefore(wrap, calcEl);
                    wrap.appendChild(calcEl);
                }
                return wrap;
            }

            function fitCalc() {
                const wrap = ensureCalcWrapper();
                if (!wrap) return;
                const calcEl = wrap.querySelector('.calc');
                if (!calcEl) return;
                // Reset transform to measure natural size
                calcEl.style.transform = 'none';
                // If not visible (e.g., different tab), skip
                const aw = wrap.clientWidth;
                const ah = wrap.clientHeight;
                const nw = calcEl.offsetWidth;
                const nh = calcEl.offsetHeight;
                if (!aw || !ah || !nw || !nh) return;
                const scale = Math.min(aw / nw, ah / nh);
                calcEl.style.transform = `scale(${scale})`;
            }

            // Refit on resize and fullscreen changes
            window.addEventListener('resize', () => fitCalc());
            document.addEventListener('fullscreenchange', () => fitCalc());
            // If currently on calculator, fit immediately; else it will fit on tab switch
            if (state.ui.tab === 'calc') setTimeout(fitCalc, 0);

            // Resize wheel on container changes
            window.addEventListener('resize', () => { if (state.ui.tab === 'wheel') resizeWheelCanvas(); });
            document.addEventListener('fullscreenchange', () => { if (state.ui.tab === 'wheel') resizeWheelCanvas(); });
            // If starting on wheel, size it
            if (state.ui.tab === 'wheel') setTimeout(resizeWheelCanvas, 0);
        })();
    </script>
    <script src="parental.js"></script>
</body>

</html>