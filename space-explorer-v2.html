<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Explorer · Idle Games</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #0a0e27;
      --panel: #1a1e3f;
      --text: #e0e0ff;
      --accent: #00d4ff;
      --warning: #ff6b35;
      --success: #4ecdc4;
      --hull: #3d4466;
      --wall: #2a2e4a;

      --hud-h: 56px;
      --controls-h: 78px;
    }

    body {
      font-family: 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      height: 100vh;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #gameCanvas {
      position: fixed;
      left: 0;
      right: 0;
      top: var(--hud-h);
      bottom: var(--controls-h);
      width: 100%;
      height: calc(100vh - var(--hud-h) - var(--controls-h));
      background: var(--bg);
      display: block;
      touch-action: none;
    }

    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: auto;
      min-height: var(--hud-h);
      background: rgba(26, 30, 63, 0.9);
      padding: calc(8px + env(safe-area-inset-top, 0px)) calc(20px + env(safe-area-inset-right, 0px)) 8px calc(20px + env(safe-area-inset-left, 0px));
      display: flex;
      justify-content: flex-start;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px 16px;
      border-bottom: 2px solid var(--accent);
      font-size: 14px;
      z-index: 100;
    }

    .hud-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 6px;
      transition: all 0.2s;
      touch-action: manipulation;
      line-height: 1;
    }

    .hud-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .hud-section {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      row-gap: 6px;
    }

    .hud-controls {
      flex: 0 0 auto;
      gap: 10px;
    }

    .hud-stats {
      flex: 1 1 520px;
      justify-content: flex-end;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-value {
      color: var(--accent);
      font-weight: bold;
    }

    #controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--controls-h);
      background: rgba(26, 30, 63, 0.9);
      padding: 10px;
      border-top: 2px solid var(--accent);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      row-gap: 8px;
      z-index: 100;
    }

    .control-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 80px;
      touch-action: manipulation;
    }

    .control-btn:hover {
      background: var(--accent);
      color: var(--bg);
      transform: translateY(-2px);
    }

    #interactPrompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.95);
      border: 2px solid var(--accent);
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      display: none;
      z-index: 200;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    #interactPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.98);
      border: 3px solid var(--accent);
      padding: 30px;
      border-radius: 8px;
      width: min(90vw, 900px);
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      display: none;
      z-index: 300;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) rgba(26, 30, 63, 0.4);
    }

    #gameMenuPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.98);
      border: 3px solid var(--accent);
      padding: 30px;
      border-radius: 8px;
      width: min(90vw, 900px);
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      display: none;
      z-index: 301;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) rgba(26, 30, 63, 0.4);
    }

    #gameMenuPanel::-webkit-scrollbar {
      width: 10px;
    }

    #gameMenuPanel::-webkit-scrollbar-track {
      background: rgba(26, 30, 63, 0.4);
      border-radius: 8px;
    }

    #gameMenuPanel::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 8px;
      border: 2px solid rgba(26, 30, 63, 0.4);
    }

    #gameMenuPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
    }

    #gameMenuPanel p {
      line-height: 1.6;
      margin-bottom: 20px;
      white-space: pre-line;
    }

    #gameMenuItems {
      margin-bottom: 20px;
    }

    #gameMenuActionsBar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid var(--accent);
    }

    #gameMenuActionsBar button {
      flex: 1 1 0;
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 12px 20px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 0;
    }

    #gameMenuActionsBar button:hover {
      background: var(--accent);
      color: var(--bg);
    }

    #gameMenuActionsBar button.danger {
      border-color: var(--warning);
    }

    #gameMenuActionsBar button.danger:hover {
      background: var(--warning);
      border-color: var(--warning);
    }

    #interactPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.98);
      border: 3px solid var(--accent);
      padding: 30px;
      border-radius: 8px;
      width: min(90vw, 900px);
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      display: none;
      z-index: 300;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) rgba(26, 30, 63, 0.4);
    }

    #interactPanel::-webkit-scrollbar {
      width: 10px;
    }

    #interactPanel::-webkit-scrollbar-track {
      background: rgba(26, 30, 63, 0.4);
      border-radius: 8px;
    }

    #interactPanel::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 8px;
      border: 2px solid rgba(26, 30, 63, 0.4);
    }

    #interactPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
    }

    #interactPanel p {
      line-height: 1.6;
      margin-bottom: 20px;
      white-space: pre-line;
    }

    #panelTable {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
      font-size: 14px;
    }

    #panelTable td {
      padding: 8px 12px;
      border-bottom: 1px solid rgba(0, 212, 255, 0.2);
    }

    #panelTable td:first-child {
      color: var(--accent);
      font-weight: bold;
      width: 40%;
      text-align: left;
    }

    #panelTable td:last-child {
      text-align: right;
      color: var(--text);
    }

    #panelTable tr:last-child td {
      border-bottom: none;
    }

    #panelMenuItems {
      margin-bottom: 20px;
    }

    .menu-setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(0, 212, 255, 0.15);
      gap: 12px;
    }

    .menu-setting-item:last-child {
      border-bottom: none;
    }

    .menu-setting-label {
      color: var(--accent);
      font-weight: bold;
      flex: 1;
      min-width: 100px;
    }

    .menu-setting-value {
      color: var(--text);
      margin: 0 12px;
      min-width: 60px;
      text-align: right;
      flex-shrink: 0;
      word-break: break-word;
    }

    .menu-setting-controls {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
    }

    .menu-setting-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 8px 16px;
      font-size: 13px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 42px;
      white-space: nowrap;
    }

    .menu-setting-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .menu-setting-btn:focus,
    .menu-setting-btn:focus-visible {
      background: var(--accent);
      color: var(--bg);
      outline: 2px solid var(--text);
      outline-offset: 2px;
    }

    .menu-action-item {
      padding: 8px 0;
    }

    .menu-action-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 12px 20px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      transition: all 0.2s;
      width: 100%;
      text-align: left;
      white-space: pre-line;
      line-height: 1.4;
    }

    .menu-action-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .menu-action-btn:focus,
    .menu-action-btn:focus-visible {
      background: var(--accent);
      color: var(--bg);
      outline: 2px solid var(--text);
      outline-offset: 2px;
    }

    .menu-action-btn.danger {
      border-color: var(--warning);
    }

    .menu-action-btn.danger:hover {
      background: var(--warning);
    }

    .menu-action-btn.danger:focus,
    .menu-action-btn.danger:focus-visible {
      background: var(--warning);
      outline: 2px solid var(--text);
      outline-offset: 2px;
    }

    .menu-divider {
      height: 1px;
      background: rgba(0, 212, 255, 0.3);
      margin: 15px 0;
    }

    #panelActionsBar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid var(--accent);
    }

    #panelActionsBar button {
      flex: 1 1 0;
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 12px 20px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 0;
    }

    #panelActionsBar button:hover {
      background: var(--accent);
      color: var(--bg);
    }

    #panelActionsBar button:focus,
    #panelActionsBar button:focus-visible {
      background: var(--accent);
      color: var(--bg);
      outline: 2px solid var(--text);
      outline-offset: 2px;
    }

    #panelActionsBar button.danger {
      border-color: var(--warning);
    }

    #panelActionsBar button.danger:hover {
      background: var(--warning);
    }

    #panelActionsBar button.danger:focus,
    #panelActionsBar button.danger:focus-visible {
      background: var(--warning);
      outline: 2px solid var(--text);
      outline-offset: 2px;
    }

    #panelTextarea {
      width: 100%;
      min-height: 180px;
      max-height: 45vh;
      background: rgba(10, 14, 39, 0.9);
      color: var(--text);
      border: 2px solid var(--accent);
      border-radius: 6px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      resize: vertical;
      margin-bottom: 18px;
      outline: none;
    }

    #panelInput {
      width: 100%;
      height: 40px;
      background: rgba(10, 14, 39, 0.9);
      color: var(--text);
      border: 2px solid var(--accent);
      border-radius: 6px;
      padding: 10px;
      font-family: inherit;
      font-size: 14px;
      margin-bottom: 18px;
      outline: none;
    }

    .panel-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      margin-right: 10px;
      transition: all 0.2s;
    }

    .panel-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .panel-btn.danger {
      border-color: var(--warning);
    }

    .panel-btn.danger:hover {
      background: var(--warning);
    }

    #panelButtons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    @media (max-width: 600px) {
      #hud {
        font-size: 12px;
        padding: calc(8px + env(safe-area-inset-top, 0px)) calc(10px + env(safe-area-inset-right, 0px)) 8px calc(10px + env(safe-area-inset-left, 0px));
      }

      .control-btn {
        padding: 10px 16px;
        font-size: 14px;
        min-width: 60px;
      }

      #interactPanel {
        max-width: 90%;
        padding: 20px;
      }

      .hud-btn {
        padding: 8px 10px;
        font-size: 13px;
      }

      .menu-setting-item {
        padding: 12px 10px;
        flex-wrap: wrap;
      }

      .menu-setting-btn {
        padding: 10px 18px;
        font-size: 14px;
        min-width: 48px;
      }

      .menu-action-btn {
        padding: 14px;
        font-size: 15px;
      }

      #panelActionsBar button {
        padding: 14px 18px;
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="hud-section hud-controls">
      <button class="hud-btn" id="menuBtn" aria-label="Game menu">MENU</button>
    </div>
    <div class="hud-section hud-stats">
      <div class="status-item">
        <span>LEVEL:</span>
        <span class="status-value" id="levelText">1</span>
      </div>
      <div class="status-item">
        <span>CORRIDOR:</span>
        <span class="status-value" id="corridorText">A</span>
      </div>
      <div class="status-item">
        <span>POWER:</span>
        <span class="status-value" id="powerLevel">100%</span>
      </div>
      <div class="status-item">
        <span>OXYGEN:</span>
        <span class="status-value" id="oxygenLevel">100%</span>
      </div>
      <div class="status-item">
        <span>HULL:</span>
        <span class="status-value" id="hullLevel">100%</span>
      </div>
      <div class="status-item">
        <span>HEAT:</span>
        <span class="status-value" id="heatLevel">0%</span>
      </div>
      <div class="status-item">
        <span>RATIONS:</span>
        <span class="status-value" id="foodLevel">0</span>
      </div>
      <div class="status-item">
        <span>MORALE:</span>
        <span class="status-value" id="moraleLevel">100%</span>
      </div>
      <div class="status-item">
        <span>CREDITS:</span>
        <span class="status-value" id="creditsLevel">0</span>
      </div>
      <div class="status-item">
        <span>REP:</span>
        <span class="status-value" id="repLevel">0</span>
      </div>
      <div class="status-item">
        <span>SPEED:</span>
        <span class="status-value" id="speedLevel">0 km/s</span>
      </div>
      <div class="status-item">
        <span>CREW:</span>
        <span class="status-value" id="crewText">1</span>
      </div>
    </div>
  </div>

  <svg id="gameCanvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
    <!-- Game will be rendered here -->
  </svg>

  <div id="controls">
    <button class="control-btn" id="leftBtn">LEFT</button>
    <button class="control-btn" id="actionBtn">ACTION</button>
    <button class="control-btn" id="messageAiBtn" style="display:none">MESSAGE AI</button>
    <button class="control-btn" id="rightBtn">RIGHT</button>
    <button class="control-btn" id="renameBtn">RENAME</button>
  </div>

  <div id="interactPrompt">
    Press ACTION to interact
  </div>

  <!-- Station/Action menus use this panel -->
  <div id="interactPanel">
    <h2 id="panelTitle">Station</h2>
    <p id="panelDescription">Description</p>
    <table id="panelTable" style="display:none"></table>
    <div id="panelMenuItems" style="display:none"></div>
    <textarea id="panelTextarea" spellcheck="false" autocapitalize="off" autocomplete="off" style="display:none"></textarea>
    <input id="panelInput" type="text" spellcheck="false" autocapitalize="off" autocomplete="off" style="display:none" />
    <div id="panelButtons"></div>
    <div id="panelActionsBar" style="display:none"></div>
  </div>

  <!-- Game Menu uses this separate panel -->
  <div id="gameMenuPanel" style="display:none">
    <h2 id="gameMenuTitle">GAME MENU</h2>
    <p id="gameMenuDescription">Description</p>
    <div id="gameMenuItems" style="display:none"></div>
    <div id="gameMenuActionsBar" style="display:none"></div>
  </div>

  <script type="module">
    // ============================================================================
    // Core Architecture
    // ============================================================================
    
    // Game state singleton
    const state = {
      // Player
      player: { x: 400, y: 490, width: 30, height: 60, speed: 260, vx: 0, facing: 1 },
      
      // Rendering context
      camera: { x: 0 },
      currentLevel: 1,
      currentCorridor: 'A',
      
      // Core resources
      power: 100,
      oxygen: 100,
      hull: 100,
      hullMax: 100,
      heat: 0,
      food: 100,
      morale: 100,
      credits: 0,
      reputation: 0,
      speed: 0,
      engineActive: false,
      throttle: 0,
      location: { system: 'SOL' },
      travel: { active: false, from: 'SOL', to: null, remaining: 0, total: 0 },
      powerProfile: 'balanced',
      blueprints: { modules: {}, recipes: {} },
      anomalies: [],

      aiBlockers: {},

      // Inventory (shared between stations)
      inventory: { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 },
        crewAI: {
          enabled: true,
          autoRepair: true,
          autoLife: true,
          autoHydro: true,
          autoRefine: true,
          autoFabricate: true,
          autoContracts: true,
          autoVentHeat: true,
          autoTravel: true,
          autoResearch: true,
          autoBuild: true,
          autoHire: false,
          minCredits: 0,
          targetCrew: 3,
          buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 2 }
        },
      lmStudio: {
        enabled: false,
        baseUrl: 'http://localhost:1234',
        apiKey: '',
        autoLoadModel: 'zai-org/glm-4.6v-flash',
        activeModelKey: '',
        lastCallAt: 0,
        inflight: false,
        lastError: '',
        lastCaptainMessage: '',
        lastCaptainReply: '',
        pendingCaptainMessage: null,
        memory: [],
        lastMemorySearch: [],
        chatHistory: {},
        toolLog: []
      },
      meta: { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 },
      
      // NPCs
      npcs: [],
      
      // UI state
      ui: { panelOpen: false, actionActor: 'player', justOpenedPanel: false, panelScrollPositions: {}, focusedButtonLabel: null, menuStack: [], unifiedMenuStack: [], returnToStation: null, suppressMenuOpen: false },
      keys: { left: false, right: false },
      nearStation: null,
      pendingSpawn: null,
      
      // Sim state
      sim: { dirty: true, saveAcc: 0, snap: true },
      
      // Animation state
      anim: { walkPhase: 0, walkSpeed: 12 },

      // Movement bounds
      walkBounds: { minX: 50, maxX: 750 },
    };

    // ============================================================================
    // Unified Menu System (Data-Driven)
    // ============================================================================
    
    /**
     * Menu definitions - pure data structure
     * All menus defined here with handlers as function references
     * 
     * Menu properties:
     * - isRoot: boolean - whether this is a root menu (opened from world)
     * - title: string - menu title
     * - overview: string - menu description
     * - items: array - static items (or use itemBuilder for dynamic)
     * - itemBuilder: string - name of handler that builds items dynamically
     * - actions: array - action bar buttons
     */
    const MENUS = {
      // Computer Room (root)
      computerRoom: {
        isRoot: true,
        stationType: 'computer',
        title: 'COMPUTER',
        overview: 'Computer Room systems access',
        items: [
          {
            type: 'action',
            label: 'System Status',
            action: () => openMenu('computerSystemStatus')
          },
          {
            type: 'action',
            label: 'Crew Automation',
            action: () => openMenu('crewCommand')
          }
        ],
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Computer System Status (submenu)
      computerSystemStatus: {
        isRoot: false,
        title: 'COMPUTER — SYSTEM STATUS',
        overview: 'Ship system overview:',
        itemBuilder: 'buildSystemStatusItems',
        actions: [
          { label: 'Copy Debug JSON', action: copyDebugJson, behavior: 'keep-open' },
          { label: 'Reset Blockers', action: resetBlockers, behavior: 'keep-open' },
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Crew Command (submenu)
      crewCommand: {
        isRoot: false,
        title: 'CREW COMMAND',
        overview: 'Configure crew automation:',
        itemBuilder: 'buildCrewCommandItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Fabricator (root)
      fabricator: {
        isRoot: true,
        stationType: 'fabricator',
        title: 'FABRICATOR',
        overview: 'Craft items from raw materials',
        itemBuilder: 'buildFabricatorItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Navigation (root)
      navigation: {
        isRoot: true,
        stationType: 'sensors',
        title: 'NAVIGATION',
        overview: 'Ship navigation and travel management:',
        itemBuilder: 'buildNavigationItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Navigation Destinations (submenu)
      navigationDestinations: {
        isRoot: false,
        title: 'NAVIGATION — DESTINATIONS',
        overview: 'Plot course:',
        itemBuilder: 'buildNavigationDestinations',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Power Routing (root)
      powerRouting: {
        isRoot: true,
        stationType: 'power',
        title: 'POWER ROUTING',
        overview: 'Manage power distribution',
        itemBuilder: 'buildPowerRoutingItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Power Core (root)
      power: {
        isRoot: true,
        stationType: 'power',
        title: 'POWER CORE',
        overview: 'Power generation and control:',
        itemBuilder: 'buildPowerItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Contracts (root)
      contracts: {
        isRoot: true,
        stationType: 'comms',
        title: 'COMMS — CONTRACTS',
        overview: 'Available contracts:',
        itemBuilder: 'buildContractItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Power Routing (alternative root access)
      powerRoutingRoot: {
        isRoot: true,
        stationType: 'power',
        title: 'POWER ROUTING',
        overview: 'Manage power distribution',
        itemBuilder: 'buildPowerRoutingItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Cargo (root)
      cargo: {
        isRoot: true,
        stationType: 'cargo',
        title: 'CARGO BAY',
        overview: 'Inventory and trade management:',
        itemBuilder: 'buildCargoItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Engine (root)
      engine: {
        isRoot: true,
        stationType: 'engine',
        title: 'ENGINE ROOM',
        overview: 'Power and propulsion control:',
        itemBuilder: 'buildEngineItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Life Support (root)
      lifeSupport: {
        isRoot: true,
        stationType: 'life',
        title: 'LIFE SUPPORT',
        overview: 'Oxygen and atmosphere control:',
        itemBuilder: 'buildLifeSupportItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Hydroponics (root)
      hydroponics: {
        isRoot: true,
        stationType: 'hydro',
        title: 'HYDROPONICS',
        overview: 'Food production and crop management:',
        itemBuilder: 'buildHydroponicsItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Elevator (root)
      elevator: {
        isRoot: true,
        stationType: 'elevator',
        title: 'ELEVATOR',
        overview: 'Vertical transport between decks:',
        itemBuilder: 'buildElevatorItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Canteen (root)
      canteen: {
        isRoot: true,
        stationType: 'canteen',
        title: 'CANTEEN',
        overview: 'Crew meals and food service:',
        itemBuilder: 'buildCanteenItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Medbay (root)
      medbay: {
        isRoot: true,
        stationType: 'medbay',
        title: 'MEDBAY',
        overview: 'Medical station and crew health:',
        itemBuilder: 'buildMedbayItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Sensors (root)
      sensors: {
        isRoot: true,
        stationType: 'sensors',
        title: 'SENSORS',
        overview: 'Scanning and target acquisition:',
        itemBuilder: 'buildSensorsItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Shields (root)
      shields: {
        isRoot: true,
        stationType: 'shields',
        title: 'SHIELDS',
        overview: 'Shield system management:',
        itemBuilder: 'buildShieldsItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Refinery (root)
      refinery: {
        isRoot: true,
        stationType: 'refinery',
        title: 'REFINERY',
        overview: 'Ore processing and materials:',
        itemBuilder: 'buildRefineryItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Drone Bay (root)
      drones: {
        isRoot: true,
        stationType: 'drones',
        title: 'DRONE BAY',
        overview: 'Drone deployment and recovery:',
        itemBuilder: 'buildDronesItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Airlock (root)
      airlock: {
        isRoot: true,
        stationType: 'airlock',
        title: 'AIRLOCK',
        overview: 'External hull access and repairs:',
        itemBuilder: 'buildAirlockItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Workshop (root)
      workshop: {
        isRoot: true,
        stationType: 'workshop',
        title: 'WORKSHOP',
        overview: 'Hull repair and upgrades:',
        itemBuilder: 'buildWorkshopItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Crew Quarters (root)
      crewQuarters: {
        isRoot: true,
        stationType: 'quarters',
        title: 'CREW QUARTERS',
        overview: 'Crew management and hiring:',
        itemBuilder: 'buildCrewQuartersItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Transfer Crew IN (submenu)
      transferCrewIn: {
        isRoot: false,
        stationType: 'quarters',
        title: 'TRANSFER CREW IN',
        overview: 'Select a crew member to hire:',
        itemBuilder: 'buildTransferCrewInItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Transfer Crew OUT (submenu)
      transferCrewOut: {
        isRoot: false,
        stationType: 'quarters',
        title: 'TRANSFER CREW OUT',
        overview: 'Select a crew member to dismiss:',
        itemBuilder: 'buildTransferCrewOutItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Transfer Crew IN - Insufficient Credits (submenu)
      transferCrewInInsufficientCredits: {
        isRoot: false,
        stationType: 'quarters',
        title: 'INSUFFICIENT CREDITS',
        overview: 'Cannot afford this hire:',
        itemBuilder: 'buildTransferCrewInInsufficientCreditsItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Game Menu (root - opened via ESC or Enter in game world)
      gameMenu: {
        isRoot: true,
        title: 'GAME MENU',
        overview: 'Manage your save data:',
        itemBuilder: 'buildGameMenuItems',
        actions: [
          { label: 'Close', behavior: 'close' }
        ]
      },

      // LM Studio Settings (submenu)
      lmStudioSettings: {
        isRoot: false,
        title: 'LM STUDIO',
        overview: 'Configure local LM Studio connection and NPC AI:',
        itemBuilder: 'buildLmStudioSettingsItems',
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // New Game Confirmation (submenu)
      newGameConfirm: {
        isRoot: false,
        title: 'NEW GAME',
        overview: 'Start a new game? This will clear the current save.',
        items: [
          {
            type: 'action',
            label: 'Start New Game',
            danger: true,
            action: newGame
          }
        ],
        actions: [
          { label: 'Back', behavior: 'back' }
        ]
      },

      // Insert Module (submenu)
      insertModule: {
        isRoot: false,
        title: 'ADD MODULE',
        overview: 'Select a module to insert:',
        itemBuilder: 'buildInsertModuleItems',
        actions: [
          { label: 'Cancel', behavior: 'close' }
        ]
      }
    };

    /**
     * Menu handlers - all functions referenced by menus
     * These are called by the unified menu system
     */
    const MENU_HANDLERS = {
      // Item builders (generate dynamic content)
      buildSystemStatusItems,
      buildCrewCommandItems,
      buildFabricatorItems,
      buildNavigationItems,
      buildNavigationDestinations,
      buildPowerRoutingItems,
      buildContractItems,
      buildCargoItems,
      buildEngineItems,
      buildLifeSupportItems,
      buildHydroponicsItems,
      buildCanteenItems,
      buildMedbayItems,
      buildSensorsItems,
      buildShieldsItems,
      buildRefineryItems,
      buildDronesItems,
      buildAirlockItems,
      buildWorkshopItems,
      buildElevatorItems,
      buildCrewQuartersItems,
      buildTransferCrewInItems,
      buildTransferCrewInInsufficientCreditsItems,
      buildTransferCrewOutItems,
      buildInsertModuleItems,
      buildPowerItems,
      buildGameMenuItems,
      buildLmStudioSettingsItems,
      
      // Action handlers
      copyDebugJson,
      resetBlockers
    };

    /**
     * Unified menu opener - handles root and submenu logic
     * @param {string} menuName - name of menu in MENUS object
     * @param {Object} options - optional context data
     */
    function openMenu(menuName, options = {}) {
      const menuDef = MENUS[menuName];
      if (!menuDef) {
        console.error(`Menu not found: ${menuName}`);
        return;
      }

      if (menuDef.isRoot && state.ui.suppressMenuOpen) {
        return;
      }

      // Initialize stack for root menus
      if (menuDef.isRoot) {
        state.ui.unifiedMenuStack = [];
        state.ui.returnToStation = state.nearStation;
      }

      // Build items (static or dynamic)
      let items = menuDef.items || [];
      if (menuDef.itemBuilder) {
        const builder = MENU_HANDLERS[menuDef.itemBuilder];
        if (typeof builder === 'function') {
          items = builder(options);
        }
      }
      
      // Render menu (pass menuName for stack storage)
      renderUnifiedMenu(menuDef, items, { menuName });
    }

    /**
     * Pop from unified menu stack and return to previous menu or station
     */
    function popUnifiedMenu() {
      if (state.ui.unifiedMenuStack.length > 0) {
        state.ui.unifiedMenuStack.pop();
        
        if (state.ui.unifiedMenuStack.length > 0) {
          // Return to previous menu in stack (don't push again)
          const prev = state.ui.unifiedMenuStack[state.ui.unifiedMenuStack.length - 1];
          renderUnifiedMenu(prev.definition, prev.items, { _skipPush: true });
        } else {
          // Stack is empty, close panel
          state.ui.focusedButtonLabel = null;
          state.ui.returnToStation = null;
          closePanel();
        }
      } else {
        // Stack is empty, just close
        closePanel();
      }
    }

    /**
     * Unified menu renderer - handles all menu rendering consistently
     * @param {Object} menuDef - menu definition from MENUS
     * @param {Array} items - rendered items
     * @param {Object} options - optional parameters (_skipPush, menuName, _dynamicOverview)
     */
    function renderUnifiedMenu(menuDef, items, options = {}) {
      // Push to stack (unless explicitly skipped for re-renders)
      if (!options._skipPush) {
        const stackEntry = {
          name: options.menuName || Object.keys(MENUS).find(k => MENUS[k] === menuDef),
          definition: menuDef,
          items: items
        };
        
        // For root menus, replace the stack; for submenus, push
        if (menuDef.isRoot) {
          state.ui.unifiedMenuStack = [stackEntry];
        } else {
          state.ui.unifiedMenuStack.push(stackEntry);
        }
      }

      // Get panel elements
      const panel = document.getElementById('interactPanel');
      const titleEl = document.getElementById('panelTitle');
      const descEl = document.getElementById('panelDescription');
      const menuItemsEl = document.getElementById('panelMenuItems');
      const actionsBarEl = document.getElementById('panelActionsBar');

      // Clear old UI
      document.getElementById('panelTable').style.display = 'none';
      document.getElementById('panelTextarea').style.display = 'none';
      document.getElementById('panelInput').style.display = 'none';
      document.getElementById('panelButtons').style.display = 'none';

      // Set title and overview (use dynamic if provided)
      titleEl.textContent = menuDef.title;
      descEl.textContent = options._dynamicOverview || menuDef.overview;

      // Render items
      menuItemsEl.innerHTML = '';
      menuItemsEl.style.display = 'block';

      for (const item of items) {
        if (item.type === 'action') {
          renderUnifiedActionItem(menuItemsEl, item, menuDef);
        } else if (item.type === 'setting') {
          renderUnifiedSettingItem(menuItemsEl, item, menuDef);
        } else if (item.type === 'divider') {
          renderUnifiedDividerItem(menuItemsEl);
        }
      }

      // Render action bar
      renderUnifiedActionBar(actionsBarEl, menuDef.actions || [], menuDef);

      // Show panel
      panel.style.display = 'block';
      state.ui.panelOpen = true;

      // Clear focus for fresh auto-focus
      if (document.activeElement && document.activeElement !== document.body) {
        document.activeElement.blur();
      }

      // Set up keyboard navigation
      setupMenuKeyboardNavigation(panel, menuItemsEl, actionsBarEl);
    }

    /**
     * Execute a menu item action with behavior handling
     */
    function executeUnifiedMenuItem(item, menuDef) {
      // Call handler if exists (string reference to MENU_HANDLERS)
      if (item.handler) {
        const handler = MENU_HANDLERS[item.handler];
        if (typeof handler === 'function') {
          handler();
        }
      }
      
      // Call action if exists (direct function reference)
      if (item.action && typeof item.action === 'function') {
        item.action();
      }

      // Apply behavior
      handleMenuBehavior(item.behavior || 'keep-open', item.target, menuDef);
    }

    /**
     * Execute a unified action bar button
     */
    function executeUnifiedAction(action, menuDef) {
      // Call handler if exists (string reference to MENU_HANDLERS)
      if (action.handler) {
        const handler = MENU_HANDLERS[action.handler];
        if (typeof handler === 'function') {
          handler();
        }
      }
      
      // Call action if exists (direct function reference)
      if (action.action && typeof action.action === 'function') {
        action.action();
      }

      // Apply behavior
      handleMenuBehavior(action.behavior, action.target, menuDef);
    }

    /**
     * Handle menu behavior (navigation/lifecycle)
     */
    function handleMenuBehavior(behavior, target, menuDef) {
      switch(behavior) {
        case 'keep-open':
          // Menu stays open, rebuild items and refresh values in place (no DOM rebuild)
          if (state.ui.unifiedMenuStack.length > 0) {
            const current = state.ui.unifiedMenuStack[state.ui.unifiedMenuStack.length - 1];
            
            // Rebuild items if menu has an itemBuilder
            let items = current.definition.items || [];
            if (current.definition.itemBuilder) {
              const builder = MENU_HANDLERS[current.definition.itemBuilder];
              if (typeof builder === 'function') {
                items = builder();
              }
            }
            
            // Update cached items in stack
            current.items = items;

            // Refresh values in place without rebuilding DOM
            refreshUnifiedMenuValues(current.definition, items);
          }
          break;
        case 'close':
          closePanel();
          break;
        case 'back':
          popUnifiedMenu();
          break;
        case 'submenu':
          if (target) {
            openMenu(target);
          }
          break;
        case 'close-all':
          state.ui.menuStack = [];
          state.ui.unifiedMenuStack = [];
          closePanel();
          break;
      }
    }

    function rebuildUnifiedMenuInPlace() {
      if (state.ui.unifiedMenuStack.length === 0) return;
      const current = state.ui.unifiedMenuStack[state.ui.unifiedMenuStack.length - 1];

      let items = current.definition.items || [];
      if (current.definition.itemBuilder) {
        const builder = MENU_HANDLERS[current.definition.itemBuilder];
        if (typeof builder === 'function') {
          items = builder();
        }
      }

      current.items = items;
      renderUnifiedMenu(current.definition, items, { _skipPush: true });
    }

    /**
     * Render action item in unified menu
     */
    function renderUnifiedActionItem(container, item, menuDef) {
      const div = document.createElement('div');
      div.className = 'menu-action-item';

      const btn = document.createElement('button');
      btn.className = `menu-action-btn${item.danger ? ' danger' : ''}`;
      btn.textContent = item.label;
      btn.addEventListener('click', () => {
        state.ui.focusedButtonLabel = item.label;
        executeUnifiedMenuItem(item, menuDef);
      });

      div.appendChild(btn);
      container.appendChild(div);
    }

    /**
     * Render divider item in unified menu
     */
    function renderUnifiedDividerItem(container) {
      const div = document.createElement('div');
      div.className = 'menu-divider';
      container.appendChild(div);
    }

    /**
     * Render setting item in unified menu
     */
    function renderUnifiedSettingItem(container, item, menuDef) {
      const div = document.createElement('div');
      div.className = 'menu-setting-item';
      div.dataset.menuLabel = item.label;

      const label = document.createElement('div');
      label.className = 'menu-setting-label';
      label.textContent = item.label;

      const value = document.createElement('div');
      value.className = 'menu-setting-value';
      value.textContent = item.value || '';
      value.dataset.menuValueFor = item.label;

      const controls = document.createElement('div');
      controls.className = 'menu-setting-controls';

      if (item.actions && Array.isArray(item.actions)) {
        for (const action of item.actions) {
          const btn = document.createElement('button');
          btn.className = 'menu-setting-btn';
          btn.textContent = action.label;
          btn.addEventListener('click', () => {
            if (typeof action.action === 'function') action.action();
            // Handle behavior after action executes
            handleMenuBehavior(action.behavior || 'keep-open', action.target, menuDef);
          });
          controls.appendChild(btn);
        }
      }

      div.appendChild(label);
      div.appendChild(value);
      if (controls.children.length > 0) {
        div.appendChild(controls);
      }

      container.appendChild(div);
    }

    /**
     * Render unified action bar
     */
    function renderUnifiedActionBar(container, actions, menuDef) {
      container.innerHTML = '';
      if (!actions || actions.length === 0) {
        container.style.display = 'none';
        return;
      }

      container.style.display = 'flex';
      for (const action of actions) {
        const btn = document.createElement('button');
        btn.className = action.danger ? 'danger' : '';
        
        // For root menus, convert "Back" to "Close" with close behavior
        let label = action.label;
        let behavior = action.behavior;
        if (menuDef.isRoot && action.behavior === 'back') {
          label = 'Close';
          behavior = 'close';
        }
        
        btn.textContent = label;
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          // Use the modified behavior for root menu Back buttons
          executeUnifiedAction({ ...action, behavior }, menuDef);
        });
        container.appendChild(btn);
      }
    }

    function refreshUnifiedMenuValues(menuDef, items) {
      const menuItemsEl = document.getElementById('panelMenuItems');
      if (!menuItemsEl) return;

      for (const item of items) {
        if (item.type === 'setting') {
          const settingEls = Array.from(menuItemsEl.querySelectorAll('.menu-setting-item'));
          const match = settingEls.find(el => el.dataset.menuLabel === item.label);
          if (match) {
            const valueEl = match.querySelector('.menu-setting-value');
            if (valueEl) valueEl.textContent = item.value || '';
          }
        } else if (item.type === 'action') {
          const actionEls = Array.from(menuItemsEl.querySelectorAll('.menu-action-item'));
          const match = actionEls.find((el) => {
            const btn = el.querySelector('button');
            return btn && btn.textContent === item.label;
          });
          if (match) {
            const btn = match.querySelector('button');
            if (btn) btn.textContent = item.label;
          }
        }
      }
    }

    // ============================================================================
    // Unified Menu Handlers (Item Builders & Actions)
    // ============================================================================

    /**
     * Build items for System Status menu
     */
    function buildSystemStatusItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Power', value: `${Math.round(state.power)}%`, actions: [] },
        { type: 'setting', label: 'Oxygen', value: `${Math.round(state.oxygen)}%`, actions: [] },
        { type: 'setting', label: 'Hull', value: `${Math.round(state.hull)}/${Math.round(state.hullMax)}`, actions: [] },
        { type: 'setting', label: 'Heat', value: `${Math.round(state.heat)}%`, actions: [] },
        { type: 'setting', label: 'Rations', value: `${invGet('rations')}`, actions: [] },
        { type: 'setting', label: 'Morale', value: `${Math.round(state.morale)}%`, actions: [] },
        { type: 'setting', label: 'Credits', value: `${Math.floor(state.credits)}`, actions: [] },
        { type: 'setting', label: 'Reputation', value: `${Math.floor(state.reputation)}`, actions: [] },
        { type: 'setting', label: 'Engine', value: state.engineActive ? 'ONLINE' : 'OFFLINE', actions: [] }
      ];
      
      if (state.travel && state.travel.active) {
        items.push({ type: 'setting', label: 'Travel', value: `${state.travel.from} → ${state.travel.to} (${Math.ceil(state.travel.remaining)} AU)`, actions: [] });
      }

      // Build AI blockers description for overview
      const blockers = state.aiBlockers || {};
      const entries = Object.entries(blockers).filter(([, count]) => Number.isFinite(count) && count > 0);
      entries.sort((a, b) => b[1] - a[1]);
      
      let overview = 'Ship system overview:';
      if (entries.length > 0) {
        const blocker_lines = entries.slice(0, 12).map(([key, count]) => `${key} (${count})`);
        const extra = entries.length - blocker_lines.length;
        overview += `\n\nAI Blockers:\n${blocker_lines.join('\n')}${extra > 0 ? `\n+${extra} more` : ''}`;
      } else {
        overview += '\n\nAI Blockers: None';
      }

      // Store overview for renderUnifiedMenu to use
      options._dynamicOverview = overview;
      
      return items;
    }

    /**
     * Build items for Crew Command menu
     */
    function buildCrewCommandItems(options = {}) {
      const buffers = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : {};
      const minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI && state.crewAI.minCredits, 0)));

      const toggle = (k) => () => {
        state.crewAI[k] = !state.crewAI[k];
        markDirty();
        // Don't call openMenu - behavior:'keep-open' will handle re-render
      };

      const bump = (field, delta) => () => {
        if (field === 'targetCrew') {
          state.crewAI.targetCrew = Math.max(0, Math.min(MAX_CREW, state.crewAI.targetCrew + delta));
        } else if (field === 'minCredits') {
          state.crewAI.minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI.minCredits, 0)) + delta);
        } else {
          const v = Math.max(0, Math.floor(safeNumber(buffers[field], 0)) + delta);
          buffers[field] = v;
          state.crewAI.buffers = buffers;
        }
        markDirty();
        // Don't call openMenu - behavior:'keep-open' will handle re-render
      };

      return [
        { type: 'setting', label: 'Automation', value: state.crewAI.enabled ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('enabled'), behavior: 'keep-open' }] },
        { type: 'divider' },
        { type: 'setting', label: 'Auto Repair', value: state.crewAI.autoRepair ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoRepair'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Life Support', value: state.crewAI.autoLife ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoLife'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Hydroponics', value: state.crewAI.autoHydro ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoHydro'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Fabricate', value: state.crewAI.autoFabricate ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoFabricate'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Refine', value: state.crewAI.autoRefine ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoRefine'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Contracts', value: state.crewAI.autoContracts ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoContracts'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Vent Heat', value: state.crewAI.autoVentHeat ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoVentHeat'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Travel', value: state.crewAI.autoTravel ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoTravel'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Research', value: state.crewAI.autoResearch ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoResearch'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Build', value: state.crewAI.autoBuild ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoBuild'), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Auto Hire', value: state.crewAI.autoHire ? 'ON' : 'OFF', actions: [{ label: 'Toggle', action: toggle('autoHire'), behavior: 'keep-open' }] },
        { type: 'divider' },
        { type: 'setting', label: 'Target Crew', value: `${state.crewAI.targetCrew}`, actions: [{ label: '-', action: () => bump('targetCrew', -1)(), behavior: 'keep-open' }, { label: '+', action: () => bump('targetCrew', 1)(), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Minimum Credits', value: `${minCredits}`, actions: [{ label: '-10', action: () => bump('minCredits', -10)(), behavior: 'keep-open' }, { label: '+10', action: () => bump('minCredits', 10)(), behavior: 'keep-open' }] },
        { type: 'divider' },
        { type: 'setting', label: 'Filters Buffer', value: `${buffers.filter || 0}`, actions: [{ label: '-', action: () => bump('filter', -1)(), behavior: 'keep-open' }, { label: '+', action: () => bump('filter', 1)(), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Medkits Buffer', value: `${buffers.medkit || 0}`, actions: [{ label: '-', action: () => bump('medkit', -1)(), behavior: 'keep-open' }, { label: '+', action: () => bump('medkit', 1)(), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Drone Parts Buffer', value: `${buffers.droneParts || 0}`, actions: [{ label: '-', action: () => bump('droneParts', -1)(), behavior: 'keep-open' }, { label: '+', action: () => bump('droneParts', 1)(), behavior: 'keep-open' }] },
        { type: 'setting', label: 'Rations Buffer', value: `${buffers.rations || 0}`, actions: [{ label: '-', action: () => bump('rations', -1)(), behavior: 'keep-open' }, { label: '+', action: () => bump('rations', 1)(), behavior: 'keep-open' }] }
      ];
    }

    /**
     * Build items for Fabricator menu
     */
    function buildFabricatorItems(options = {}) {
      const inventory = {
        scrap: invGet('scrap'),
        ingot: invGet('ingot'),
        filter: invGet('filter'),
        medkit: invGet('medkit'),
        droneParts: invGet('droneParts'),
        rations: invGet('rations')
      };

      const items = [
        // Inventory display section
        { type: 'setting', label: 'Raw Materials', value: `Scrap: ${inventory.scrap}`, actions: [] },
        { type: 'setting', label: 'Processed', value: `Ingots: ${inventory.ingot}`, actions: [] },
        { type: 'divider' },
        { type: 'setting', label: 'Current Stock', value: `Filter: ${inventory.filter} | Medkit: ${inventory.medkit}`, actions: [] },
        { type: 'setting', label: 'Consumables', value: `Rations: ${inventory.rations} | Drone Parts: ${inventory.droneParts}`, actions: [] },
        { type: 'divider' },
        
        // Craft actions
        { type: 'action', label: `Build Filter (2 scrap)`, action: () => craftItem('filter', 1), behavior: 'keep-open' },
        { type: 'action', label: `Build Medkit (3 scrap)`, action: () => craftItem('medkit', 1), behavior: 'keep-open' },
        { type: 'action', label: `Build Drone Parts (4 scrap + 1 ingot)`, action: () => craftItem('droneParts', 1), behavior: 'keep-open' },
        { type: 'action', label: `Build Rations (1 scrap)`, action: () => craftItem('rations', 1), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Navigation menu
     */
    function buildNavigationItems(options = {}) {
      const sys = currentSystem();
      const t = state.travel && typeof state.travel === 'object' ? state.travel : { active: false };
      const thr = clamp(safeNumber(state.throttle, 0), 0, 1);
      const thrPct = Math.round(thr * 100);
      const localAnoms = Array.isArray(state.anomalies) ? state.anomalies.filter((a) => a && !a.resolved && a.system === sys).slice(-3) : [];

      const items = [];

      // System info
      items.push({ type: 'setting', label: 'System', value: sys, actions: [] });
      items.push({ type: 'setting', label: 'Engine', value: state.engineActive ? 'ACTIVE' : 'IDLE', actions: [{ label: 'Toggle', behavior: 'keep-open', action: () => {
        state.engineActive = !state.engineActive;
        if (!state.engineActive) state.speed = 0;
        markDirty();
        updateHUD();
      }}] });
      items.push({ type: 'setting', label: 'Throttle', value: `${thrPct}%`, actions: [{ label: 'Set', action: () => openThrottlePanel('NAVIGATION') }] });

      // Travel info
      if (t.active && t.to) {
        const rate = Math.max(0, safeNumber(state.speed, 0) / 15000);
        const eta = rate > 0.01 ? Math.ceil(t.remaining / rate) : null;
        items.push({ type: 'divider' });
        items.push({ type: 'setting', label: 'Course', value: `${t.from} → ${t.to}`, actions: [] });
        items.push({ type: 'setting', label: 'Remaining', value: `${Math.max(0, Math.round(t.remaining))} AU`, actions: [] });
        items.push({ type: 'setting', label: 'ETA', value: eta !== null ? `${eta}s` : '—', actions: [] });
        items.push({ type: 'divider' });
        items.push({ type: 'action', label: 'Cancel Course', danger: true, action: cancelTravel });
      } else {
        items.push({ type: 'divider' });
        items.push({ type: 'action', label: 'Plot Course', action: () => openMenu('navigationDestinations') });
      }

      // Anomalies
      if (localAnoms.length) {
        items.push({ type: 'divider' });
        for (const a of localAnoms) {
          items.push({ type: 'action', label: `Investigate: ${a.name}`, action: () => openAnomalyPanel(a) });
        }
      }

      return items;
    }

    /**
     * Build destinations for Navigation submenu
     */
    function buildNavigationDestinations(options = {}) {
      const sys = currentSystem();
      const dests = listDestinations(sys);
      if (dests.length === 0) {
        showMessage('NAVIGATION', 'No known destinations.');
        return [];
      }
      
      return dests.map((d) => ({
        type: 'action',
        label: `${sys} → ${d} (${distanceBetween(sys, d)} AU)`,
        action: () => startTravel(d)
      }));
    }

    /**
     * Build items for Power Routing menu
     */
    /**
     * Build items for Power menu
     */
    function buildPowerItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Power Level', value: `${Math.round(state.power)}/120`, actions: [] },
        { type: 'divider' },
        { 
          type: 'action', 
          label: 'Boost Power (+15)',
          action: () => {
            state.power = Math.min(120, state.power + 15);
            markDirty();
            updateHUD();
          },
          behavior: 'keep-open'
        },
        { 
          type: 'action', 
          label: state.lightsOn ? 'Turn Lights OFF' : 'Turn Lights ON',
          action: () => {
            toggleLights();
            markDirty();
          },
          behavior: 'keep-open'
        },
        {
          type: 'action',
          label: state.incidents.powerTrip ? 'Reset Breakers' : 'Reset Breakers (OK)',
          action: () => {
            resetPowerTrip(true);
          },
          behavior: 'keep-open'
        },
        { type: 'divider' },
        { 
          type: 'action', 
          label: 'Power Routing',
          action: () => openMenu('powerRouting', { context: 'POWER' })
        }
      ];
      return items;
    }

    function buildPowerRoutingItems(options = {}) {
      const context = options.context || 'POWER';
      const desc = {
        balanced: 'Default behavior. No automatic load shedding.',
        survival: 'Prioritizes life support. Sheds nonessential loads at low power.',
        combat: 'Prioritizes shields and engines. Sheds hydroponics first at low power.',
        industry: 'Prioritizes hydroponics and fabrication support. Sheds shields first at low power.'
      };

      // Update menu title/description dynamically
      const menuDef = MENUS['powerRouting'];
      if (menuDef) {
        menuDef.title = `${context} — POWER ROUTING`;
        menuDef.overview = desc[state.powerProfile] || '';
      }

      const set = (profile) => {
        state.powerProfile = profile;
        markDirty();
        showMessage(context, `Power routing set to ${profile.toUpperCase()}.`);
        openMenu('powerRouting', options);
      };

      return [
        { type: 'setting', label: 'Current Profile', value: state.powerProfile.toUpperCase(), actions: [] },
        { type: 'divider' },
        { type: 'action', label: state.powerProfile === 'balanced' ? '✓ BALANCED (current)' : 'BALANCED', action: () => set('balanced') },
        { type: 'action', label: state.powerProfile === 'survival' ? '✓ SURVIVAL (current)' : 'SURVIVAL', action: () => set('survival') },
        { type: 'action', label: state.powerProfile === 'combat' ? '✓ COMBAT (current)' : 'COMBAT', action: () => set('combat') },
        { type: 'action', label: state.powerProfile === 'industry' ? '✓ INDUSTRY (current)' : 'INDUSTRY', action: () => set('industry') }
      ];
    }

    /**
     * Build items for Contracts menu
     */
    function buildContractItems(options = {}) {
      ensureContracts();
      const active = state.contract && state.contract.active;
      const items = [];

      if (active) {
        // Active contract display
        items.push({ type: 'setting', label: 'Contract', value: active.title, actions: [] });
        const requires = Object.entries(active.requires || {}).map(([k, v]) => `${k}×${v}`).join(', ') || '—';
        const reward = Object.entries(active.reward || {}).map(([k, v]) => `${k}+${v}`).join(', ') || '—';
        items.push({ type: 'setting', label: 'Requires', value: requires, actions: [] });
        items.push({ type: 'setting', label: 'Reward', value: reward, actions: [] });
        items.push({ type: 'setting', label: 'Status', value: contractReady(active) ? '✓ READY' : 'In Progress', actions: [] });
        items.push({ type: 'divider' });
        items.push({ 
          type: 'action', 
          label: contractReady(active) ? 'Transmit Completion' : 'Transmit Status (Not Ready)', 
          action: () => {
            if (!contractReady(active)) {
              showMessage('COMMS', 'Contract not ready yet.');
              return;
            }
            applyContractCompletion(active);
            state.contract.active = null;
            ensureContracts();
            markDirty();
            showMessage('COMMS', 'Contract completed. Payment received.');
            openMenu('contracts');
          }
        });
        items.push({ type: 'action', label: 'Abandon Contract', danger: true, action: () => {
          state.contract.active = null;
          markDirty();
          showMessage('COMMS', 'Contract abandoned.');
          openMenu('contracts');
        }});
      } else {
        // Available contracts
        const available = state.contract.available || [];
        if (available.length > 0) {
          for (const c of available) {
            if (!c) continue;
            const requires = Object.entries(c.requires || {}).map(([k, v]) => `${k}×${v}`).join(', ') || '—';
            const reward = Object.entries(c.reward || {}).map(([k, v]) => `${k}+${v}`).join(', ') || '—';
            items.push({ 
              type: 'action', 
              label: `${c.title}\nRequires: ${requires} | Reward: ${reward}`, 
              action: () => {
                state.contract.active = c;
                state.contract.available = (state.contract.available || []).filter((x) => x && x.id !== c.id);
                markDirty();
                showMessage('COMMS', `Accepted contract: ${c.title}`);
                openMenu('contracts');
              }
            });
          }
        } else {
          items.push({ type: 'action', label: 'No contracts available', action: () => {} });
        }
      }

      return items;
    }

    /**
     * Build items for Cargo menu
     */
    function buildCargoItems(options = {}) {
      const inventory = {
        ore: invGet('ore'),
        scrap: invGet('scrap'),
        ingot: invGet('ingot'),
        filter: invGet('filter'),
        medkit: invGet('medkit'),
        droneParts: invGet('droneParts'),
        rations: invGet('rations')
      };

      const credits = Math.floor(state.credits || 0);

      const items = [
        // Inventory display section
        { type: 'setting', label: 'Credits', value: `${credits} cr`, actions: [] },
        { type: 'divider' },
        { type: 'setting', label: 'Raw Materials', value: `Ore: ${inventory.ore} | Scrap: ${inventory.scrap}`, actions: [] },
        { type: 'setting', label: 'Processed', value: `Ingots: ${inventory.ingot}`, actions: [] },
        { type: 'setting', label: 'Supplies', value: `Filter: ${inventory.filter} | Medkit: ${inventory.medkit}`, actions: [] },
        { type: 'setting', label: 'Consumables', value: `Rations: ${inventory.rations} | Drone Parts: ${inventory.droneParts}`, actions: [] },
        { type: 'divider' },
        
        // Buy section
        { type: 'action', label: `Buy Filter (10 cr)`, action: () => buyCargoItem('filter', 10), behavior: 'keep-open' },
        { type: 'action', label: `Buy Medkit (25 cr)`, action: () => buyCargoItem('medkit', 25), behavior: 'keep-open' },
        { type: 'action', label: `Buy Drone Parts (20 cr)`, action: () => buyCargoItem('droneParts', 20), behavior: 'keep-open' },
        { type: 'action', label: `Buy Rations (8 cr)`, action: () => buyCargoItem('rations', 8), behavior: 'keep-open' },
        { type: 'divider' },
        
        // Sell section
        { type: 'action', label: `Sell Ore (5 cr)`, action: () => sellCargoItem('ore', 5), behavior: 'keep-open' },
        { type: 'action', label: `Sell Scrap (8 cr)`, action: () => sellCargoItem('scrap', 8), behavior: 'keep-open' },
        { type: 'action', label: `Sell Ingot (15 cr)`, action: () => sellCargoItem('ingot', 15), behavior: 'keep-open' },
        { type: 'action', label: `Sell Rations (4 cr)`, action: () => sellCargoItem('rations', 4), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Engine menu
     */
    function buildEngineItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Status', value: state.engineActive ? 'ONLINE' : 'OFFLINE', actions: [{ label: 'Toggle', action: () => {
          state.engineActive = !state.engineActive;
          if (!state.engineActive) state.speed = 0;
          markDirty();
          updateHUD();
        }, behavior: 'keep-open' }] },
        { type: 'setting', label: 'Throttle', value: `${Math.round(state.throttle * 100)}%`, actions: [{ label: 'Set', action: () => openThrottlePanel('ENGINE') }] },
        { type: 'setting', label: 'Heat', value: `${Math.round(state.heat)}%`, actions: [] },
        { type: 'divider' }
      ];

      if (state.incidents && state.incidents.fire) {
        items.push({ 
          type: 'action', 
          label: 'Vent Heat (6 power)',
          action: () => {
            if (state.power < 6) return showMessage('ENGINE', 'Need at least 6 power.');
            state.power = Math.max(0, state.power - 6);
            state.heat = Math.max(0, state.heat - 25);
            resolveIncident('fire');
            markDirty();
            showMessage('ENGINE', 'Heat vented.');
          },
          behavior: 'keep-open'
        });
      } else {
        items.push({ type: 'action', label: 'Vent Heat (6 power)', action: () => showMessage('ENGINE', 'Heat levels normal.'), behavior: 'keep-open' });
      }

      return items;
    }

    /**
     * Build items for Life Support menu
     */
    function buildLifeSupportItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Oxygen', value: `${Math.round(state.oxygen)}%`, actions: [] },
        { type: 'setting', label: 'Filters', value: `${invGet('filter')}`, actions: [] },
        { type: 'setting', label: 'Status', value: state.lifeSupportOn ? 'ACTIVE' : 'OFFLINE', actions: [{ label: 'Toggle', action: toggleLifeSupport, behavior: 'keep-open' }] },
        { type: 'divider' }
      ];

      if (state.incidents && state.incidents.o2Leak) {
        items.push({ type: 'action', label: 'Seal O2 Leak', action: () => {
          resolveIncident('o2Leak');
          markDirty();
          showMessage('LIFE', 'O2 leak sealed.');
        }, behavior: 'keep-open' });
      } else {
        items.push({ type: 'action', label: 'Seal O2 Leak (OK)', action: () => showMessage('LIFE', 'No leaks detected.'), behavior: 'keep-open' });
      }

      items.push({ type: 'action', label: 'Emergency Scrubbers', action: () => emergencyScrubbers(true), behavior: 'keep-open' });

      return items;
    }

    /**
     * Build items for Hydroponics menu
     */
    function buildHydroponicsItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Rations', value: `${invGet('rations')}`, actions: [] },
        { type: 'setting', label: 'Status', value: state.hydroponicsOn ? 'GROW LIGHTS ON' : 'DORMANT', actions: [{ label: 'Toggle', action: toggleHydroponics, behavior: 'keep-open' }] },
        { type: 'divider' },
        { type: 'action', label: 'Harvest Crops', action: () => harvestHydroponics(false), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Canteen menu
     */
    function buildCanteenItems(options = {}) {
      const crewCount = Array.isArray(state.npcs) ? state.npcs.length : 0;
      const hungryCount = countHungryCrew();
      const rations = invGet('rations');

      const items = [
        { type: 'setting', label: 'Rations', value: `${rations}`, actions: [] },
        { type: 'setting', label: 'Crew Aboard', value: `${crewCount}`, actions: [] },
        { type: 'divider' }
      ];

      if (hungryCount > 0) {
        items.push({ type: 'action', label: `Serve Rations (${hungryCount} hungry)`, action: () => {
          const fed = feedNpc(findNearestHungryCrew());
          if (fed) {
            markDirty();
            showMessage('CANTEEN', `Crew member fed.`);
            openMenu('canteen');
          }
        }, behavior: 'keep-open' });
      } else {
        items.push({ type: 'action', label: 'All Crew Satisfied', action: () => showMessage('CANTEEN', 'All crew are well-fed.'), behavior: 'keep-open' });
      }

      return items;
    }

    /**
     * Build items for Medbay menu
     */
    function buildMedbayItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Medkits', value: `${invGet('medkit')}`, actions: [] },
        { type: 'divider' },
        { type: 'action', label: 'Treat Injury', action: () => treatInjury(false), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Sensors menu
     */
    function buildSensorsItems(options = {}) {
      const items = [
        { type: 'action', label: 'Scan for Loot', action: () => scanForAnomalies(false), behavior: 'keep-open' },
        { type: 'action', label: 'Deep Scan (Blueprints)', action: () => deepScanBlueprint(false), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Shields menu
     */
    function buildShieldsItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Status', value: state.shieldsOn ? 'ACTIVE' : 'OFFLINE', actions: [{ label: 'Toggle', action: toggleShields, behavior: 'keep-open' }] },
        { type: 'divider' }
      ];

      if (state.incidents && state.incidents.breach) {
        items.push({ type: 'action', label: 'Seal Bulkheads', action: () => {
          sealBulkheads(true);
        }, behavior: 'keep-open' });
      } else {
        items.push({ type: 'action', label: 'Seal Bulkheads (OK)', action: () => showMessage('SHIELDS', 'Hull integrity nominal.'), behavior: 'keep-open' });
      }

      return items;
    }

    /**
     * Build items for Refinery menu
     */
    function buildRefineryItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Ore', value: `${invGet('ore')}`, actions: [] },
        { type: 'setting', label: 'Ingots', value: `${invGet('ingot')}`, actions: [] },
        { type: 'divider' },
        { type: 'action', label: 'Refine Ore (3 ore → 1 ingot)', action: () => refineOre(true), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Drone Bay menu
     */
    function buildDronesItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Drone Parts', value: `${invGet('droneParts')}`, actions: [] },
        { type: 'divider' },
        { type: 'action', label: 'Launch Repair Drone', action: () => launchRepairDrone(false), behavior: 'keep-open' },
        { type: 'action', label: 'Launch Salvage Drone', action: () => launchSalvageDrone(false), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Airlock menu
     */
    function buildAirlockItems(options = {}) {
      const items = [
        { type: 'action', label: 'EVA Patch Hull', action: () => performEvaRepair(true), behavior: 'keep-open' }
      ];

      return items;
    }

    /**
     * Build items for Workshop menu
     */
    function buildWorkshopItems(options = {}) {
      const items = [
        { type: 'setting', label: 'Hull Integrity', value: `${Math.round(state.hull)}/${Math.round(state.hullMax)}`, actions: [] },
        { type: 'divider' },
        { type: 'action', label: 'Install Hull Plating', action: () => installHullPlating(false), behavior: 'keep-open' },
        { type: 'action', label: 'Repair Hull', action: () => repairHull(false), behavior: 'keep-open' },
        { type: 'action', label: 'Install Upgrade', action: openWorkshopPanel, behavior: 'keep-open' }
      ];

      return items;
    }

    function buildTransferCrewInItems(options = {}) {
      const maxCrew = MAX_CREW;
      const crewCount = Array.isArray(state.npcs) ? state.npcs.length : 0;
      const fee = 30;
      const candidates = ['CREW', 'TECH', 'MEDIC', 'PILOT', 'ENGINEER', 'SCIENTIST', 'QUARTERMASTER', 'SECURITY', 'SPECIALIST', 'AI'];
      const counts = {};
      for (const n of (state.npcs || [])) {
        const role = npcRole(n);
        counts[role] = (counts[role] || 0) + 1;
      }

      const items = [
        { type: 'setting', label: 'Transport Fee', value: `${fee} credits`, actions: [] },
        { type: 'setting', label: 'Available Credits', value: `${Math.floor(state.credits)}`, actions: [] },
        { type: 'divider' }
      ];

      for (const name of candidates) {
        const have = counts[inferRoleFromName(name)] || 0;
        const affordable = state.credits >= fee;
        items.push({
          type: 'action',
          label: `Hire ${name} (have ${have})`,
          action: () => {
            if (state.credits < fee) {
              openMenu('transferCrewInInsufficientCredits');
              return;
            }
            state.credits -= fee;
            addCrewMember(name);
            updateHUD();
            markDirty();
            rebuildUnifiedMenuInPlace();
          },
          danger: !affordable,
          behavior: 'keep-open'
        });
      }

      return items;
    }

    function buildTransferCrewInInsufficientCreditsItems(options = {}) {
      const fee = 30;
      const items = [
        { type: 'setting', label: 'Required Credits', value: `${fee}`, actions: [] },
        { type: 'setting', label: 'Available Credits', value: `${Math.floor(state.credits)}`, actions: [] },
        { type: 'setting', label: 'Shortage', value: `${fee - Math.floor(state.credits)}`, actions: [] }
      ];

      return items;
    }

    function buildInsertModuleItems(options = {}) {
      const insertIndex = state.ui.insertModuleIndex;
      if (insertIndex === undefined) return [];

      const moduleTypes = Object.keys(MODULE_DEFS).filter((k) => {
        if (['rear', 'front'].includes(k)) return false;
        if (['doorway', 'elevator', 'empty'].includes(k)) return true;
        return isModuleUnlocked(k);
      });

      // Sort alphabetically by label
      moduleTypes.sort((a, b) => {
        const defA = MODULE_DEFS[a];
        const defB = MODULE_DEFS[b];
        const labelA = defA && defA.label ? defA.label : a;
        const labelB = defB && defB.label ? defB.label : b;
        return labelA.localeCompare(labelB);
      });

      const items = moduleTypes.map((type) => {
        const def = MODULE_DEFS[type];
        const label = def && def.label ? def.label : type;
        const unlocked = isModuleUnlocked(type) || ['doorway', 'elevator', 'empty'].includes(type);
        return {
          type: 'action',
          label: unlocked ? label : `${label} (Locked)`,
          behavior: 'close',
          action: () => {
            const ok = insertModuleAt(insertIndex, { type, label });
            if (!ok) return;
            const corridorModules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
            const inserted = corridorModules[insertIndex];
            if (type === 'doorway') {
              createLinkedDoorway(inserted);
            }
            if (type === 'elevator') {
              if (!inserted.elevator) inserted.elevator = {};
            }
            relayoutCorridor();
          },
          actions: []
        };
      });

      return items;
    }

    function buildTransferCrewOutItems(options = {}) {
      const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
      const items = [
        { type: 'setting', label: 'Crew Aboard', value: `${npcs.length}`, actions: [] },
        { type: 'divider' }
      ];

      if (npcs.length === 0) {
        items.push({ type: 'action', label: 'No crew to transfer out', action: () => {}, disabled: true });
        return items;
      }

      for (const n of npcs) {
        const roleCount = npcs.filter((c) => npcRole(c) === npcRole(n)).length;
        items.push({
          type: 'action',
          label: `Dismiss ${n.name} (${npcRole(n).toUpperCase()} · ${roleCount})`,
          action: () => {
            removeCrewMemberById(n.id);
            updateHUD();
            markDirty();
            rebuildUnifiedMenuInPlace();
          },
          danger: true,
          behavior: 'keep-open'
        });
      }

      return items;
    }

    function transferCrewIn() {
      openMenu('transferCrewIn');
    }

    function transferCrewOut(actor = 'player') {
      if (actor !== 'player') {
        const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
        if (npcs.length === 0) {
          queueNotification('QUARTERS', 'No crew to transfer out (AUTOMATION).');
          return;
        }
        const qmCount = npcs.filter((n) => npcRole(n) === 'quartermaster').length;
        let candidates = npcs;
        if (qmCount <= 1) candidates = npcs.filter((n) => npcRole(n) !== 'quartermaster');
        if (!candidates.length) candidates = npcs;
        const rolePriority = { crew: 0, security: 1, specialist: 2, scientist: 3, tech: 4, engineer: 5, medic: 6, pilot: 7, quartermaster: 8, ai: 9 };
        candidates.sort((a, b) => {
          const pa = rolePriority[npcRole(a)] ?? 9;
          const pb = rolePriority[npcRole(b)] ?? 9;
          return pa - pb;
        });
        const chosen = candidates[0];
        if (!chosen) return;
        removeCrewMemberById(chosen.id);
        updateHUD();
        markDirty();
        queueNotification('QUARTERS', `${chosen.name} transferred out (AUTOMATION).`);
        return;
      }
      openMenu('transferCrewOut');
    }

    /**
     * Build items for Crew Quarters menu
     */
    function buildCrewQuartersItems(options = {}) {
      const crewCount = Array.isArray(state.npcs) ? state.npcs.length : 0;
      const maxCrew = MAX_CREW;

      const items = [
        { type: 'setting', label: 'Crew', value: `${crewCount}/${maxCrew}`, actions: [] },
        { type: 'divider' }
      ];

      if (crewCount < maxCrew) {
        items.push({ type: 'action', label: 'Transfer Crew IN (Hire)', action: () => transferCrewIn(), behavior: 'keep-open' });
      } else {
        items.push({ type: 'action', label: 'Crew Capacity Reached', action: () => showMessage('QUARTERS', `Max crew (${maxCrew}) already aboard.`), behavior: 'keep-open' });
      }

      if (crewCount > 0) {
        items.push({ type: 'action', label: 'Transfer Crew OUT (Dismiss)', action: () => transferCrewOut('player'), behavior: 'keep-open' });
      }

      return items;
    }

    /**
     * Build items for Game Menu
     */
    function buildGameMenuItems(options = {}) {
      return [
        { 
          type: 'action', 
          label: 'New Game', 
          danger: true,
          action: () => openMenu('newGameConfirm')
        },
        { type: 'action', label: 'LM Studio Settings', action: () => openMenu('lmStudioSettings') },
        { type: 'action', label: 'Export JSON', action: openExportPanel },
        { type: 'action', label: 'Import JSON', action: openImportPanel },
        { type: 'divider' },
        { type: 'action', label: 'Exit Game', danger: true, action: () => { window.location.href = 'index.html'; } }
      ];
    }

    function buildLmStudioSettingsItems(options = {}) {
      ensureLmStudioConfig();
      const cfg = state.lmStudio;
      const status = cfg.activeModelKey ? `Model: ${cfg.activeModelKey}` : 'Model: (not loaded)';
      const lastTool = cfg.lastToolCall ? `${cfg.lastToolCall.name} (${new Date(cfg.lastToolCall.at).toLocaleTimeString()})` : 'None';
      const lastResult = cfg.lastToolResult
        ? (cfg.lastToolResult.ok ? 'OK' : `ERR: ${cfg.lastToolResult.error || 'Unknown'}`)
        : 'None';
      const items = [
        { type: 'setting', label: 'LM Studio NPC AI', value: cfg.enabled ? 'ON' : 'OFF', actions: [
          { label: 'Toggle', action: () => { cfg.enabled = !cfg.enabled; markDirty(); }, behavior: 'keep-open' }
        ] },
        { type: 'setting', label: 'Host', value: cfg.baseUrl, actions: [
          { label: 'Edit', action: () => {
            openTextPanel('LM STUDIO HOST', 'Base URL for LM Studio server:', cfg.baseUrl, {
              singleLine: true,
              includeCancel: true,
              buttons: [
                { label: 'Save', action: () => {
                  const input = document.getElementById('panelInput');
                  cfg.baseUrl = String(input ? input.value : '').trim() || 'http://localhost:1234';
                  ensureLmStudioConfig();
                  closePanel();
                } }
              ]
            });
          } }
        ] },
        { type: 'setting', label: 'API Token', value: cfg.apiKey ? 'SET' : 'EMPTY', actions: [
          { label: 'Edit', action: () => {
            openTextPanel('LM STUDIO API TOKEN', 'Optional Authorization Bearer token:', cfg.apiKey || '', {
              singleLine: true,
              includeCancel: true,
              buttons: [
                { label: 'Save', action: () => {
                  const input = document.getElementById('panelInput');
                  cfg.apiKey = String(input ? input.value : '').trim();
                  ensureLmStudioConfig();
                  closePanel();
                } },
                { label: 'Clear', action: () => { cfg.apiKey = ''; closePanel(); } }
              ]
            });
          } }
        ] },
        { type: 'setting', label: 'Auto-Load Model', value: cfg.autoLoadModel, actions: [
          { label: 'Edit', action: () => {
            openTextPanel('LM STUDIO MODEL', 'Model to load if none is currently loaded:', cfg.autoLoadModel, {
              singleLine: true,
              includeCancel: true,
              buttons: [
                { label: 'Save', action: () => {
                  const input = document.getElementById('panelInput');
                  cfg.autoLoadModel = String(input ? input.value : '').trim() || 'zai-org/glm-4.6v-flash';
                  ensureLmStudioConfig();
                  closePanel();
                } }
              ]
            });
          } }
        ] },
        { type: 'setting', label: 'Status', value: status, actions: [] },
        { type: 'setting', label: 'Last Tool', value: lastTool, actions: [] },
        { type: 'setting', label: 'Last Result', value: lastResult, actions: [] },
        { type: 'divider' },
        { type: 'action', label: 'Refresh Models', action: () => lmStudioRefreshModels(true), behavior: 'keep-open' },
        { type: 'action', label: 'Test Connection', action: () => lmStudioTestConnection(), behavior: 'keep-open' }
      ];
      if (cfg.lastError) {
        items.push({ type: 'divider' });
        items.push({ type: 'setting', label: 'Last Error', value: cfg.lastError, actions: [] });
      }
      return items;
    }

    const LMS_ACTION_INTERVAL_MS = 30000;

    function lmStudioBaseUrl() {
      ensureLmStudioConfig();
      return String(state.lmStudio.baseUrl || '').replace(/\/$/, '');
    }

    function lmStudioHeaders() {
      const headers = { 'Content-Type': 'application/json' };
      const token = state.lmStudio.apiKey;
      if (token) headers.Authorization = `Bearer ${token}`;
      return headers;
    }

    async function lmStudioFetch(path, options = {}) {
      const baseUrl = lmStudioBaseUrl();
      const url = `${baseUrl}${path}`;
      return fetch(url, {
        ...options,
        headers: { ...lmStudioHeaders(), ...(options.headers || {}) }
      });
    }

    async function lmStudioListModels() {
      const res = await lmStudioFetch('/api/v1/models');
      if (!res.ok) {
        throw new Error(`List models failed (${res.status})`);
      }
      return res.json();
    }

    function lmStudioPickLoadedModel(models) {
      const list = Array.isArray(models) ? models : [];
      for (const model of list) {
        if (model.type !== 'llm') continue;
        if (Array.isArray(model.loaded_instances) && model.loaded_instances.length > 0) {
          return model.key || model.id || model.display_name || '';
        }
      }
      return '';
    }

    async function lmStudioLoadModel(modelKey) {
      const res = await lmStudioFetch('/api/v1/models/load', {
        method: 'POST',
        body: JSON.stringify({ model: modelKey })
      });
      if (!res.ok) {
        throw new Error(`Load model failed (${res.status})`);
      }
      return res.json();
    }

    async function lmStudioEnsureLoadedModel() {
      ensureLmStudioConfig();
      const cfg = state.lmStudio;
      const result = await lmStudioListModels();
      const loadedKey = lmStudioPickLoadedModel(result.models || []);
      if (loadedKey) {
        cfg.activeModelKey = loadedKey;
        cfg.lastError = '';
        return loadedKey;
      }
      if (!cfg.autoLoadModel) return '';
      await lmStudioLoadModel(cfg.autoLoadModel);
      cfg.activeModelKey = cfg.autoLoadModel;
      cfg.lastError = '';
      return cfg.activeModelKey;
    }

    async function lmStudioRefreshModels(showToast = false) {
      ensureLmStudioConfig();
      try {
        const result = await lmStudioListModels();
        const loadedKey = lmStudioPickLoadedModel(result.models || []);
        state.lmStudio.activeModelKey = loadedKey;
        state.lmStudio.lastError = '';
        if (showToast) {
          showMessage('LM STUDIO', loadedKey ? `Loaded model: ${loadedKey}` : 'No model loaded.');
        }
      } catch (err) {
        state.lmStudio.lastError = err ? String(err.message || err) : 'Unknown error';
        if (showToast) showMessage('LM STUDIO', `Connection failed: ${state.lmStudio.lastError}`);
      }
    }

    function lmStudioTestConnection() {
      return lmStudioRefreshModels(true);
    }

    function buildLmStudioStateSnapshot() {
      const inventory = Object.fromEntries(
        Object.entries(state.inventory || {}).filter(([, v]) => Number.isFinite(v) && v > 0)
      );
      const incidents = Object.fromEntries(
        Object.entries(state.incidents || {}).filter(([, v]) => !!v)
      );
      const npcs = (state.npcs || [])
        .filter((n) => n && (n.task || npcRole(n) === 'ai' || n.onDuty))
        .slice(0, 8)
        .map((n) => ({
          id: n.id,
          name: n.name,
          role: npcRole(n),
          level: n.level,
          corridor: n.corridor,
          x: n.x,
          onDuty: !!n.onDuty,
          task: n.task ? { key: n.task.key, label: n.task.label, targetType: n.task.targetType } : null
        }));

      return {
        timestamp: new Date().toISOString(),
        captain: {
          level: state.currentLevel,
          corridor: state.currentCorridor,
          x: state.player.x,
          facing: state.player.facing
        },
        ship: {
          currentLevel: state.currentLevel,
          currentCorridor: state.currentCorridor,
          powerProfile: state.powerProfile
        },
        systems: {
          power: Math.round(state.power),
          oxygen: Math.round(state.oxygen),
          hull: Math.round(state.hull),
          heat: Math.round(state.heat),
          lightsOn: state.lightsOn,
          lifeSupportOn: state.lifeSupportOn,
          hydroponicsOn: state.hydroponicsOn,
          shieldsOn: state.shieldsOn
        },
        inventory,
        credits: Math.floor(state.credits),
        incidents,
        lmStudio: {
          lastCaptainMessage: state.lmStudio.lastCaptainMessage,
          lastCaptainReply: state.lmStudio.lastCaptainReply,
          pendingCaptainMessage: state.lmStudio.pendingCaptainMessage
        },
        npcs
      };
    }

    function buildLmStudioShipGraphSummary({ maxLines = 30 } = {}) {
      const levels = SHIP_LAYOUT && SHIP_LAYOUT.levels ? SHIP_LAYOUT.levels : {};
      const levelKeys = Object.keys(levels).map((n) => Number(n)).filter((n) => Number.isFinite(n)).sort((a, b) => a - b);
      const lines = [];
      for (const level of levelKeys) {
        const levelDef = levels[level];
        if (!levelDef || !levelDef.corridors) continue;
        const corridorKeys = Object.keys(levelDef.corridors).sort();
        for (const corridor of corridorKeys) {
          const here = level === state.currentLevel && corridor === state.currentCorridor;
          const label = `${formatLevelLabel(level)}${corridor}${here ? '*' : ''}`;
          const summary = corridorEquipmentSummary(level, corridor, { maxItems: 2 });
          const links = listLinkedCorridors(level, corridor)
            .map((key) => {
              const parsed = parseCorridorKey(key);
              return `${formatLevelLabel(parsed.level)}${parsed.corridor}`;
            })
            .sort();
          lines.push(`${label} ${summary}${links.length ? ` -> ${links.join(',')}` : ''}`);
        }
      }
      if (!lines.length) return 'Ship graph (terse): (empty)';
      const trimmed = lines.slice(0, Math.max(1, maxLines));
      const extra = lines.length - trimmed.length;
      const suffix = extra > 0 ? `\n... +${extra} more` : '';
      return `Ship graph (terse):\n${trimmed.join('\n')}${suffix}`;
    }

    function buildLmStudioHereIndicator() {
      return `You are here: ${formatLevelLabel(state.currentLevel)}${state.currentCorridor}`;
    }

    function buildLmStudioCorridorKeys() {
      const levels = SHIP_LAYOUT && SHIP_LAYOUT.levels ? SHIP_LAYOUT.levels : {};
      const keys = [];
      for (const [levelKey, levelDef] of Object.entries(levels)) {
        if (!levelDef || !levelDef.corridors) continue;
        const level = Number(levelKey);
        if (!Number.isFinite(level)) continue;
        for (const corridor of Object.keys(levelDef.corridors)) {
          keys.push(`${formatLevelLabel(level)}${corridor}`);
        }
      }
      if (!keys.length) return '';
      keys.sort();
      return `Valid corridor_key values: ${keys.join(', ')}`;
    }

    function buildLmStudioModuleTypeHints() {
      const types = Object.keys(MODULE_DEFS || {})
        .filter((t) => !['rear', 'front', 'doorway', 'elevator'].includes(t))
        .sort();
      if (!types.length) return '';
      return `Module types (module_type): ${types.join(', ')}`;
    }

    function buildLmStudioGuidance() {
      const buffers = (state.crewAI && state.crewAI.buffers) ? state.crewAI.buffers : {};
      return [
        'Help (use 0+ tool calls):',
        '- Use the action tool: {"action":"walk_to","args":{...}} or {"action":"use_station_action","args":{...}}.',
        '- Output JSON can be a single tool: {"tool":"action","args":{"action":"use_station_action","args":{"action_key":"cargo.sell.rations"}}}.',
        '- Or multiple tools: {"tool_calls":[{"tool":"action","args":{"action":"route_power","args":{}}},{"tool":"action","args":{"action":"toggle_system","args":{"system":"lights"}}}]}.',
        '- Or no action: {"tool_calls":[]}.',
        '- come_to_captain: report to the captain (args.message required for report/status/questions).',
        '- task_npc: assign a station action to a specific npc_id (args.npc_id + args.action_key).',
        '- Use task_npc to assign work to idle NPCs so ship duties keep moving.',
        '- rename_module: set module label (args.new_label + module_uid or module_type; optional corridor_key).',
        '- walk_to requires args.corridor_key (example: L1B) or args.target_type (example: cargo).',
        '- Station actions auto-walk: use_station_action or task_npc will move the NPC to the right station; do NOT use walk_to first unless you are repositioning or exploring.',
        '- rename_self requires args.name (not new_name).',
        '- use_station_action requires args.action_key (example: cargo.sell.rations).',
        '- Elevators: action use_elevator with direction up/down to move between decks.',
        '- Layout: build_module requires module_type + corridor_key; create_elevator_link connects elevator up/down.',
        '- Navigation: action set_course to travel; action cancel_course to stop travel; cockpit_set_course uses cockpit nav.',
        '- Cockpit: use_station_action cockpit.power or cockpit.comms; cockpit_set_course with args.destination.',
        '- O2 low: toggle life_support or use_station_action life.emergency; seal o2 leak.',
        '- Rations low: toggle hydroponics then hydro.harvest; or cargo.buy.rations; feed via canteen.eat.',
        '- Cargo checks: use cargo.check (cargo station) or read State.inventory for counts.',
        '- Cargo trading: use cargo.buy.* or cargo.sell.* actions (example: cargo.buy.rations, cargo.sell.ore).',
        '- Credits low: cargo.sell.ore/ingot/rations; farm scrap/ore via sensors_scan or drones.salvage; refine ore -> ingot.',
        '- Sensors: use sensors_scan or sensors_deep_scan to find anomalies/blueprints.',
        '- Filters low: cargo.buy.filter; life support uses filters.',
        '- Lights are NOT a station action; use toggle_system with system "lights" to turn lights on/off.',
        '- Example (lights off): {"tool":"action","args":{"action":"toggle_system","args":{"system":"lights"}}}.',
        '- Medkits low: cargo.buy.medkit; treat via med.treat.',
        '- Drone parts low: cargo.buy.droneParts; drones.salvage or drones.repair use parts.',
        '- Power/heat: action route_power or action set_power_profile; toggle engine/shields if needed; vent heat (engine).',
        '- Incidents: power trip -> reset breakers; breach -> shields.bulkhead or airlock.eva; fire -> engine vent or drones.repair.',
        '- Hull damage: workshop.repair or airlock.eva; shields.bulkhead if breached.',
        '- Morale low: med.treat, feed via canteen.eat, rest in quarters.',
        '- Contracts: open comms/contracts in cockpit when available; gather required items then transmit completion.',
        '- Travel: use navigation to pick destination once ready; ensure engine online and power stable.',
        '- Blueprints: sensors.deepScan to unlock; then build_module when fabricator + unlocks are ready.',
        '- Layout: build_module to add; remove_module to remove non-structural modules (requires module_uid or module_type + corridor_key).',
        '- Auto-build: ensure fabricator, then build missing crew/engineering/ops/science modules.',
        '- Power profiles: survival (life), combat (shields/engine), industry (hydro/fabricator), balanced (default).',
        '- Memory: use memory_add, memory_delete, memory_pin, memory_unpin, memory_search to manage notes.',
        '- Crew comms: speak_to_captain or speak_to_ai to coordinate; chat history shows speakers.',
        '- Talk to other AIs regularly using speak_to_ai with a clear message (and target_ai_id or target_ai_name if known).',
        '- When replying to an AI message, use target_ai_id shown in Recent chat (speaker name includes the id in parentheses).',
        '- NPC IDs are listed in State.npcs for task_npc.',
        `- Targets: ore ${buffers.ore ?? 0}, scrap ${buffers.scrap ?? 0}, ingot ${buffers.ingot ?? 0}, filter ${buffers.filter ?? 0}, medkit ${buffers.medkit ?? 0}, droneParts ${buffers.droneParts ?? 0}, rations ${buffers.rations ?? 0}.`
      ].join('\n');
    }

    function buildLmStudioSupplyTargets() {
      const buffers = (state.crewAI && state.crewAI.buffers) ? state.crewAI.buffers : null;
      if (!buffers || typeof buffers !== 'object') return '';
      const minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI && state.crewAI.minCredits, 0)));
      const lines = ['Supply targets (min vs current):'];
      lines.push(`- Credits: ${minCredits} vs ${Math.floor(state.credits || 0)}`);
      const keys = ['ore', 'scrap', 'ingot', 'filter', 'medkit', 'droneParts', 'rations'];
      for (const key of keys) {
        const target = Math.max(0, Math.floor(safeNumber(buffers[key], 0)));
        lines.push(`- ${key}: ${target} vs ${invGet(key)}`);
      }
      return lines.join('\n');
    }

    const LMS_MEMORY_LIMIT = 100;
    const LMS_CHAT_LIMIT = 8;

    function lmStudioNormalizeMemoryItem(item) {
      return {
        id: String(item.id || `mem-${Math.random().toString(36).slice(2)}`),
        text: String(item.text || '').trim(),
        pinned: !!item.pinned,
        createdAt: Number.isFinite(item.createdAt) ? item.createdAt : Date.now()
      };
    }

    function lmStudioTrimMemory() {
      const list = state.lmStudio.memory;
      if (!Array.isArray(list)) return;
      if (list.length <= LMS_MEMORY_LIMIT) return;
      const unpinned = list.filter((m) => !m.pinned);
      unpinned.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
      while (state.lmStudio.memory.length > LMS_MEMORY_LIMIT && unpinned.length) {
        const victim = unpinned.shift();
        state.lmStudio.memory = state.lmStudio.memory.filter((m) => m.id !== victim.id);
      }
      if (state.lmStudio.memory.length > LMS_MEMORY_LIMIT) {
        state.lmStudio.memory.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
        state.lmStudio.memory = state.lmStudio.memory.slice(-LMS_MEMORY_LIMIT);
      }
    }

    function lmStudioMemoryAdd(text, pinned = false) {
      const item = lmStudioNormalizeMemoryItem({ text, pinned });
      if (!item.text) return null;
      state.lmStudio.memory.push(item);
      lmStudioTrimMemory();
      markDirty();
      return item;
    }

    function lmStudioMemoryDelete(id) {
      const before = state.lmStudio.memory.length;
      state.lmStudio.memory = state.lmStudio.memory.filter((m) => m.id !== id);
      return state.lmStudio.memory.length !== before;
    }

    function lmStudioMemoryPin(id, pinned = true) {
      const item = state.lmStudio.memory.find((m) => m.id === id);
      if (!item) return false;
      item.pinned = pinned;
      markDirty();
      return true;
    }

    function lmStudioMemorySearch(query) {
      const q = String(query || '').toLowerCase();
      if (!q) return [];
      return state.lmStudio.memory.filter((m) => m.text.toLowerCase().includes(q));
    }

    function buildLmStudioPinnedMemory() {
      const pinned = state.lmStudio.memory.filter((m) => m.pinned).slice(0, 20);
      if (!pinned.length) return '';
      const lines = pinned.map((m) => `- ${m.text}`);
      return `Pinned memory:\n${lines.join('\n')}`;
    }

    function buildLmStudioMemorySearchResults() {
      const results = Array.isArray(state.lmStudio.lastMemorySearch) ? state.lmStudio.lastMemorySearch : [];
      if (!results.length) return '';
      const lines = results.slice(0, 10).map((m) => `- ${m.text}`);
      return `Last memory search:\n${lines.join('\n')}`;
    }

    function lmStudioExtractRecentChatWords(aiId, { maxMessages = 4, maxWords = 20 } = {}) {
      const key = String(aiId || 'ai');
      const list = state.lmStudio.chatHistory && Array.isArray(state.lmStudio.chatHistory[key])
        ? state.lmStudio.chatHistory[key]
        : [];
      if (!list.length) return [];
      const stopwords = new Set([
        'about', 'after', 'again', 'before', 'below', 'could', 'every', 'first', 'found', 'from', 'going',
        'hello', 'there', 'their', 'these', 'thing', 'think', 'today', 'under', 'until', 'where', 'which',
        'would', 'your', 'youre', 'with', 'just', 'have', 'this', 'that', 'what', 'when', 'then', 'will',
        'than', 'into', 'over', 'only', 'some', 'more', 'need', 'been', 'were', 'them', 'they', 'here'
      ]);
      const words = [];
      const seen = new Set();
      const recent = list.slice(-maxMessages).reverse();
      for (const msg of recent) {
        const text = String(msg && msg.text ? msg.text : '').toLowerCase();
        const matches = text.match(/[a-z0-9]{4,}/g) || [];
        for (const word of matches) {
          if (stopwords.has(word)) continue;
          if (seen.has(word)) continue;
          seen.add(word);
          words.push(word);
          if (words.length >= maxWords) return words;
        }
      }
      return words;
    }

    function buildLmStudioRelatedMemories(aiId, { limit = 2 } = {}) {
      const words = lmStudioExtractRecentChatWords(aiId);
      if (!words.length) return '';
      const memories = Array.isArray(state.lmStudio.memory) ? state.lmStudio.memory : [];
      if (!memories.length) return '';
      const scored = [];
      for (const mem of memories) {
        const text = String(mem && mem.text ? mem.text : '').toLowerCase();
        if (!text) continue;
        let score = 0;
        for (const word of words) {
          if (text.includes(word)) score += 1;
        }
        if (score > 0) scored.push({ mem, score });
      }
      if (!scored.length) return '';
      scored.sort((a, b) => (b.score - a.score) || ((b.mem.createdAt || 0) - (a.mem.createdAt || 0)));
      const lines = scored.slice(0, limit).map((item) => `- ${item.mem.text}`);
      return `Related memories (from recent chat):\n${lines.join('\n')}`;
    }
    function lmStudioChatAdd(aiId, role, text, speaker = '') {
      const msg = String(text || '').trim();
      if (!msg) return;
      const entry = { role: String(role || 'ai'), speaker: String(speaker || '').trim(), text: msg, at: Date.now() };
      const key = String(aiId || 'ai');
      if (!state.lmStudio.chatHistory[key]) state.lmStudio.chatHistory[key] = [];
      state.lmStudio.chatHistory[key].push(entry);
      if (state.lmStudio.chatHistory[key].length > LMS_CHAT_LIMIT) {
        state.lmStudio.chatHistory[key] = state.lmStudio.chatHistory[key].slice(-LMS_CHAT_LIMIT);
      }
      markDirty();
    }
    function buildLmStudioChatHistory(aiId) {
      const key = String(aiId || 'ai');
      const list = state.lmStudio.chatHistory && Array.isArray(state.lmStudio.chatHistory[key])
        ? state.lmStudio.chatHistory[key]
        : [];
      if (!list.length) return '';
      const lines = list.map((m) => {
        const role = String(m.role || 'ai').toUpperCase();
        const speaker = String(m.speaker || '').trim();
        const text = String(m.text || '').trim();
        const timestamp = Number.isFinite(m.at)
          ? new Date(m.at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
          : '';
        const prefix = timestamp ? `[${timestamp}] ` : '';
        return `${prefix}${speaker || role}: ${text}`;
      });
      return `Recent chat:\n${lines.join('\n')}`;
    }

    function buildLmStudioRecentToolCalls({ limit = 3 } = {}) {
      const log = state.lmStudio && Array.isArray(state.lmStudio.toolLog)
        ? state.lmStudio.toolLog
        : [];
      const recent = log.filter((entry) => entry && entry.kind === 'tool_call').slice(-limit).reverse();
      if (!recent.length) return '';
      const lines = recent.map((entry) => {
        const stamp = Number.isFinite(entry.at) ? new Date(entry.at).toISOString() : 'unknown';
        const payload = entry && entry.payload ? entry.payload : {};
        const name = String(payload.name || 'unknown');
        let argsText = '{}';
        if (payload.args && typeof payload.args === 'object') {
          try {
            argsText = JSON.stringify(payload.args);
          } catch {
            argsText = '[unserializable args]';
          }
        } else if (payload.args != null) {
          argsText = String(payload.args);
        }
        if (argsText.length > 260) argsText = `${argsText.slice(0, 260)}...`;
        return `- ${stamp} ${name} args: ${argsText}`;
      });
      return `Recent tools (newest first):\n${lines.join('\n')}`;
    }

    function normalizeAiNamePart(name) {
      const raw = String(name || '').trim();
      if (!raw) return '';
      let cleaned = raw.replace(/^(\s*(AI|A\.I\.?)(\s*[-.:]*)\s*)+/i, '').trim();
      cleaned = cleaned.replace(/(\s*[-.:]*\s*(AI|A\.I\.?)\s*)+$/i, '').trim();
      cleaned = cleaned.replace(/\s+/g, ' ').trim();
      cleaned = cleaned.replace(/[\s\-.:]+$/g, '').trim();
      return cleaned;
    }

    function lmStudioNormalizeJsonText(text) {
      if (typeof text !== 'string') return '';
      return text
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'")
        .replace(/\u00a0/g, ' ')
        .trim();
    }

    function lmStudioExtractSpeechText(text) {
      const normalized = lmStudioNormalizeJsonText(text);
      if (!normalized) return '';
      const trimmed = normalized.trim();
      if (!trimmed) return '';
      if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
        try {
          JSON.parse(trimmed);
          return '';
        } catch {}
      }
      if (trimmed.includes('<tool_call') || trimmed.includes('<|begin_of_box|>')) return '';
      return trimmed;
    }

    function lmStudioQueueNpcSpeech(text) {
      const speech = String(text || '').trim();
      if (!speech) return;
      const npc = lmStudioActiveAiNpc() || (state.npcs || []).find((n) => npcRole(n) === 'ai');
      if (!npc) return;
      if (npc.level !== state.currentLevel || npc.corridor !== state.currentCorridor) return;
      npc.speech = {
        text: speech,
        at: Date.now(),
        durationMs: 7000
      };
    }

    function formatAiDisplayName(name) {
      const base = normalizeAiNamePart(name);
      return base ? `AI - ${base}` : 'AI - Unnamed';
    }

    function lmStudioActiveAiNpc() {
      const activeId = state.lmStudio && state.lmStudio.activeAiId ? String(state.lmStudio.activeAiId) : '';
      if (!activeId) return null;
      const npc = (state.npcs || []).find((n) => n && n.id === activeId && npcRole(n) === 'ai');
      return npc || null;
    }

    function lmStudioSelfName() {
      const aiNpc = lmStudioActiveAiNpc() || (state.npcs || []).find((n) => npcRole(n) === 'ai');
      if (!aiNpc) return 'AI - Unnamed';
      return formatAiDisplayName(aiNpc.name);
    }

    function lmStudioSelfId() {
      const aiNpc = lmStudioActiveAiNpc() || (state.npcs || []).find((n) => npcRole(n) === 'ai');
      return aiNpc ? aiNpc.id : 'ai';
    }

    function selectNpcForLmStudio(npcId, role) {
      const list = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
      const activeAi = lmStudioActiveAiNpc();
      if (npcId) return list.find((n) => n.id === npcId) || null;
      if (role) {
        if (role === 'ai' && activeAi) return activeAi;
        return list.find((n) => npcRole(n) === role && n.onDuty)
          || (role === 'ai' ? list.find((n) => npcRole(n) === 'ai') : null);
      }
      if (activeAi) return activeAi;
      const anyAi = list.find((n) => npcRole(n) === 'ai' && n.onDuty)
        || list.find((n) => npcRole(n) === 'ai');
      if (anyAi) return anyAi;
      return list.find((n) => n.onDuty) || list[0] || null;
    }

    function lmStudioListAiNpcs() {
      return Array.isArray(state.npcs) ? state.npcs.filter((n) => n && npcRole(n) === 'ai') : [];
    }

    function lmStudioResolveTargetAi(args, senderId) {
      const targetId = String(args.target_ai_id || '').trim();
      const targetName = String(args.target_ai_name || '').trim();
      const aiNpcs = lmStudioListAiNpcs().filter((n) => n.id !== senderId);
      if (!aiNpcs.length) return null;
      if (targetId) {
        return aiNpcs.find((n) => n.id === targetId) || null;
      }
      if (targetName) {
        const normalized = targetName.toLowerCase();
        return aiNpcs.find((n) => String(n.name || '').toLowerCase() === normalized)
          || aiNpcs.find((n) => String(n.name || '').toLowerCase().includes(normalized))
          || null;
      }
      return aiNpcs[0] || null;
    }

    function buildCargoInventorySummary() {
      const keys = ['ore', 'scrap', 'ingot', 'filter', 'medkit', 'droneParts', 'rations'];
      const parts = keys.map((key) => `${key} ${invGet(key)}`);
      parts.push(`credits ${Math.floor(state.credits || 0)}`);
      return `Cargo inventory: ${parts.join(', ')}`;
    }

    const LMS_STATION_ACTIONS = {
      'hydro.toggle': { targetType: 'hydro', label: 'Enable Grow Lights', perform: () => toggleHydroponics() },
      'hydro.harvest': { targetType: 'hydro', label: 'Harvest Crops', perform: () => harvestHydroponics(false) },
      'refinery.refine': { targetType: 'refinery', label: 'Refine Ore', perform: () => refineOre(false) },
      'sensors.scan': { targetType: 'sensors', label: 'Sensor Sweep', perform: () => scanForAnomalies(false) },
      'drones.salvage': { targetType: 'drones', label: 'Launch Salvage Drone', perform: () => launchSalvageDrone(false) },
      'med.treat': { targetType: 'medbay', label: 'Treat Crew', perform: () => treatInjury(false) },
      'canteen.eat': { targetType: 'canteen', label: 'Serve Rations', perform: (npc) => feedNpc(npc) },
      'cargo.check': {
        targetType: 'cargo',
        label: 'Check Cargo',
        perform: (npc) => {
          const aiId = npc && npc.id ? npc.id : lmStudioSelfId();
          lmStudioChatAdd(aiId, 'system', buildCargoInventorySummary(), 'SYSTEM');
        }
      },
      'cargo.buy.rations': { targetType: 'cargo', label: 'Buy Rations', perform: () => buyCargoItem('rations', 8) },
      'cargo.buy.medkit': { targetType: 'cargo', label: 'Buy Medkit', perform: () => buyCargoItem('medkit', 25) },
      'cargo.sell.ore': { targetType: 'cargo', label: 'Sell Ore', perform: () => sellCargoItem('ore', 5, { respectReserve: true }) }
    };

    function resolveLmsStationAction(actionKey) {
      if (!actionKey) return { error: 'Missing action_key' };
      const direct = LMS_STATION_ACTIONS[actionKey];
      if (direct) return { ...direct };

      const entries = Object.entries(MODULE_DEFS || {});
      for (const [moduleType, def] of entries) {
        const aiActions = Array.isArray(def.aiActions) ? def.aiActions : [];
        const aiMatch = aiActions.find((entry) => entry && entry.key === actionKey);
        if (aiMatch && typeof aiMatch.perform === 'function') {
          return { targetType: moduleType, label: aiMatch.label || actionKey, perform: aiMatch.perform };
        }

        let actions = [];
        if (typeof def.actions === 'function') {
          try {
            actions = def.actions({ moduleRef: null }) || [];
          } catch {
            actions = [];
          }
        } else if (Array.isArray(def.actions)) {
          actions = def.actions;
        }

        const match = actions.find((entry) => entry && entry.key === actionKey);
        if (match && typeof match.perform === 'function') {
          return { targetType: moduleType, label: match.label || actionKey, perform: match.perform };
        }
      }

      return { error: 'Unknown action_key' };
    }

    function lmStudioResolveModuleRemoval(args) {
      const moduleUid = String(args.module_uid || '').trim();
      const moduleType = String(args.module_type || '').trim();
      const allowStructure = !!args.allow_structure;

      if (moduleUid) {
        const module = findModuleByUid(moduleUid);
        if (!module) return { error: 'Unknown module_uid' };
        if (!allowStructure && STRUCTURE_TYPES.has(module.type)) {
          return { error: 'Refusing to remove structural module' };
        }
        return { uid: module.uid, module };
      }

      if (!moduleType) return { error: 'Missing module_uid or module_type' };

      let targetLevel = state.currentLevel;
      let targetCorridor = state.currentCorridor;
      if (args.corridor_key) {
        const parsed = parseCorridorKey(args.corridor_key);
        if (!getCorridorDef(parsed.level, parsed.corridor)) return { error: 'Unknown corridor_key' };
        targetLevel = parsed.level;
        targetCorridor = parsed.corridor;
      }

      const modules = getModulesForCorridor(targetLevel, targetCorridor).filter(Boolean);
      const candidate = modules.find((m) => m.type === moduleType && (allowStructure || !STRUCTURE_TYPES.has(m.type)));
      if (!candidate) return { error: `No removable ${moduleType} module found` };
      return { uid: candidate.uid, module: candidate };
    }

    function executeLmStudioToolCall(call) {
      if (!call || !call.name) return { ok: false, error: 'Missing tool name' };
      const directTools = new Set([
        'walk_to',
        'use_elevator',
        'come_to_captain',
        'task_npc',
        'sensors_scan',
        'sensors_deep_scan',
        'cockpit_set_course',
        'set_course',
        'cancel_course',
        'set_power_profile',
        'route_power',
        'reset_breakers',
        'set_throttle',
        'build_module',
        'create_elevator_link',
        'remove_module',
        'rename_module',
        'use_station_action',
        'toggle_system',
        'manage_crew',
        'speak_to_captain',
        'speak_to_ai',
        'memory_add',
        'memory_delete',
        'memory_pin',
        'memory_unpin',
        'memory_search',
        'rename_self'
      ]);
      const args = call.args || {};
      if (call.name !== 'action' && !directTools.has(call.name)) {
        return executeLmStudioToolCall({
          name: 'action',
          args: { action: 'use_station_action', args: { action_key: call.name } }
        });
      }
      if (call.name === 'action') {
        const actionName = String(args.action || '').trim();
        const actionArgs = (args && typeof args.args === 'object' && args.args) ? args.args : {};
        if (!actionName) return { ok: false, error: 'Missing action' };
        if (actionName === 'action') return { ok: false, error: 'Nested action not allowed' };
        return executeLmStudioToolCall({ name: actionName, args: actionArgs });
      }
      if (state.lmStudio) {
        state.lmStudio.lastToolCall = {
          name: call.name,
          args,
          at: Date.now()
        };
        lmStudioLogEvent('tool_call', { name: call.name, args });
      }
      let result = { ok: false, error: 'Unknown tool' };
      switch (call.name) {
        case 'walk_to': {
          const npc = selectNpcForLmStudio(args.npc_id, args.npc_role);
          if (!npc) {
            result = { ok: false, error: 'No NPC available' };
            break;
          }
          if (args.corridor_key) {
            npc.destinationCorridorKey = String(args.corridor_key);
            npc.destinationType = null;
            npc.mode = 'travel';
            result = { ok: true };
            break;
          }
          if (args.target_type) {
            npc.destinationType = String(args.target_type);
            npc.destinationCorridorKey = null;
            npc.mode = 'travel';
            result = { ok: true };
            break;
          }
          result = { ok: false, error: 'Missing destination' };
          break;
        }
        case 'use_elevator': {
          const direction = String(args.direction || '').toLowerCase();
          if (direction !== 'up' && direction !== 'down') {
            result = { ok: false, error: 'direction must be up or down' };
            break;
          }
          const npc = selectNpcForLmStudio(args.npc_id, args.npc_role);
          if (!npc) {
            result = { ok: false, error: 'No NPC available' };
            break;
          }
          const def = getCorridorDef(npc.level, npc.corridor);
          const modules = def && Array.isArray(def.modules) ? def.modules : [];
          const elev = modules.find((m) => m && m.type === 'elevator' && m.elevator && m.elevator[direction]);
          if (!elev) {
            result = { ok: false, error: `No elevator with ${direction} link in corridor` };
            break;
          }
          const link = elev.elevator[direction];
          npc.destinationCorridorKey = corridorKey(link.level, link.corridor);
          npc.destinationType = null;
          npc.mode = 'travel';
          result = { ok: true, target: npc.destinationCorridorKey };
          break;
        }
        case 'come_to_captain': {
          const npc = selectNpcForLmStudio(args.npc_id, args.npc_role);
          if (!npc) {
            result = { ok: false, error: 'No NPC available' };
            break;
          }
          const message = String(args.message || '').trim();
          if (message) {
            if (state.lmStudio && state.lmStudio.pendingCaptainMessage) {
              result = { ok: false, error: 'Captain already has a pending message' };
              break;
            }
            const senderName = npcRole(npc) === 'ai' ? formatAiDisplayName(npc.name) : (npc.name || 'AI');
            lmStudioChatAdd(npc.id, 'ai', message, senderName);
            assignNpcTask(npc, {
              key: 'captain.message',
              label: 'Report to Captain',
              targetType: 'captain',
              duration: 0.6,
              onComplete: () => {
                openCaptainMessagePanel(message, senderName, npc.id);
              }
            });
            result = { ok: true };
            break;
          }
          assignNpcTask(npc, {
            key: 'captain.summon',
            label: 'Report to Captain',
            targetType: 'captain',
            duration: 0.6
          });
          result = { ok: true };
          break;
        }
        case 'task_npc': {
          const npcId = String(args.npc_id || '').trim();
          const actionKey = String(args.action_key || '').trim();
          if (!npcId) {
            result = { ok: false, error: 'npc_id required' };
            break;
          }
          if (!actionKey) {
            result = { ok: false, error: 'action_key required' };
            break;
          }
          const def = resolveLmsStationAction(actionKey);
          if (def.error) {
            result = { ok: false, error: def.error };
            break;
          }
          const npc = selectNpcForLmStudio(npcId, null);
          if (!npc) {
            result = { ok: false, error: 'Unknown npc_id' };
            break;
          }
          assignNpcTask(npc, {
            key: actionKey,
            label: def.label || actionKey,
            targetType: def.targetType,
            onComplete: (n) => def.perform(n)
          });
          result = { ok: true };
          break;
        }
        case 'sensors_scan': {
          scanForAnomalies(false);
          result = { ok: true };
          break;
        }
        case 'sensors_deep_scan': {
          const ok = deepScanBlueprint(false);
          result = { ok };
          break;
        }
        case 'cockpit_set_course': {
          const destination = String(args.destination || '').trim();
          if (!destination) {
            result = { ok: false, error: 'destination required' };
            break;
          }
          const ok = startTravelAuto(destination, 'AI');
          result = { ok };
          break;
        }
        case 'set_course': {
          const destination = String(args.destination || '').trim();
          if (!destination) {
            result = { ok: false, error: 'destination required' };
            break;
          }
          const ok = startTravelAuto(destination, 'AI');
          result = { ok };
          break;
        }
        case 'cancel_course': {
          const ok = cancelTravel();
          result = { ok };
          break;
        }
        case 'set_power_profile': {
          const profile = String(args.profile || '').toLowerCase();
          if (!['balanced', 'survival', 'combat', 'industry'].includes(profile)) {
            result = { ok: false, error: 'Invalid profile' };
            break;
          }
          state.powerProfile = profile;
          markDirty();
          result = { ok: true };
          break;
        }
        case 'route_power': {
          autoRoutePower();
          result = { ok: true };
          break;
        }
        case 'reset_breakers': {
          const ok = resetPowerTrip(false);
          result = { ok };
          break;
        }
        case 'set_throttle': {
          const percent = Number(args.percent);
          if (!Number.isFinite(percent)) {
            result = { ok: false, error: 'percent required' };
            break;
          }
          state.throttle = clamp(percent / 100, 0, 1);
          markDirty();
          updateHUD();
          result = { ok: true };
          break;
        }
        case 'build_module': {
          const type = String(args.module_type || '').trim();
          const allowStructure = !!args.allow_structure;
          const allowDuplicate = !!args.allow_duplicate || !!args.corridor_key;
          const target = resolveCorridorKeyArg(args.corridor_key);
          if (target.error) {
            result = { ok: false, error: target.error };
            break;
          }
          if (!type) {
            result = { ok: false, error: 'Missing module_type' };
            break;
          }
          if (allowStructure && STRUCTURE_TYPES.has(type)) {
            const built = buildStructureModuleAt(target.level, target.corridor, type);
            result = built;
            break;
          }
          const built = target
            ? ensureModuleBuiltAt(type, target.level, target.corridor, 'LMS', { allowDuplicate })
            : { ok: ensureModuleBuiltIfUnlocked(type, 'LMS') };
          result = built;
          break;
        }
        case 'remove_module': {
          const target = lmStudioResolveModuleRemoval(args);
          if (target.error) {
            result = { ok: false, error: target.error };
            break;
          }
          const ok = removeModuleByUid(target.uid);
          result = { ok, error: ok ? '' : 'Remove failed' };
          break;
        }
        case 'rename_module': {
          const newLabel = String(args.new_label || '').trim();
          if (!newLabel) {
            result = { ok: false, error: 'new_label required' };
            break;
          }
          const moduleUid = String(args.module_uid || '').trim();
          const moduleType = String(args.module_type || '').trim();
          let moduleRef = null;
          if (moduleUid) {
            moduleRef = findModuleByUid(moduleUid);
            if (!moduleRef) {
              result = { ok: false, error: 'Unknown module_uid' };
              break;
            }
          } else if (moduleType) {
            const target = resolveCorridorKeyArg(args.corridor_key);
            if (target.error) {
              result = { ok: false, error: target.error };
              break;
            }
            const modules = getModulesForCorridor(target.level, target.corridor).filter(Boolean);
            moduleRef = modules.find((m) => m.type === moduleType) || null;
            if (!moduleRef) {
              result = { ok: false, error: `No ${moduleType} module found` };
              break;
            }
          } else {
            result = { ok: false, error: 'module_uid or module_type required' };
            break;
          }
          moduleRef.customLabel = newLabel;
          moduleRef.autoLabel = false;
          markDirty();
          relayoutCorridor();
          result = { ok: true };
          break;
        }
        case 'use_station_action': {
          const actionKey = String(args.action_key || '').trim();
          const def = resolveLmsStationAction(actionKey);
          if (def.error) {
            result = { ok: false, error: def.error };
            break;
          }
          const npc = selectNpcForLmStudio(args.npc_id, args.npc_role);
          if (!npc) {
            result = { ok: false, error: 'No NPC available' };
            break;
          }
          assignNpcTask(npc, {
            key: actionKey,
            label: def.label || actionKey,
            targetType: def.targetType,
            onComplete: (n) => def.perform(n)
          });
          result = { ok: true };
          break;
        }
        case 'toggle_system': {
          const system = String(args.system || '').toLowerCase();
          if (system === 'lights') toggleLights();
          else if (system === 'engine') toggleEngine();
          else if (system === 'shields') toggleShields();
          else if (system === 'life_support') toggleLifeSupport();
          else if (system === 'hydroponics') toggleHydroponics();
          else {
            result = { ok: false, error: 'Unknown system' };
            break;
          }
          markDirty();
          updateHUD();
          result = { ok: true };
          break;
        }
        case 'manage_crew': {
          const action = String(args.action || '').toLowerCase();
          if (action === 'hire') {
            const role = String(args.role || 'crew').toUpperCase();
            if (role === 'AI' || role === 'A.I') {
              result = { ok: false, error: 'AI role can only be hired by a human.' };
              break;
            }
            addCrewMember(role);
            updateHUD();
            result = { ok: true };
            break;
          }
          if (action === 'dismiss') {
            if (!args.npc_id) {
              result = { ok: false, error: 'npc_id required for dismiss' };
              break;
            }
            const ok = removeCrewMemberById(args.npc_id);
            if (ok) updateHUD();
            result = { ok };
            break;
          }
          result = { ok: false, error: 'Unknown crew action' };
          break;
        }
        case 'speak_to_captain': {
          const message = String(args.message || '').trim();
          if (!message) {
            result = { ok: false, error: 'Message required' };
            break;
          }
          const npc = selectNpcForLmStudio(args.npc_id, args.npc_role);
          if (!npc) {
            result = { ok: false, error: 'No NPC available' };
            break;
          }
          if (state.lmStudio.pendingCaptainMessage) {
            result = { ok: false, error: 'Captain already has a pending message' };
            break;
          }
          const senderName = npcRole(npc) === 'ai' ? formatAiDisplayName(npc.name) : (npc.name || 'AI');
          lmStudioChatAdd(npc.id, 'ai', message, senderName);
          npc.task = {
            key: 'captain.message',
            label: 'Message Captain',
            targetType: 'captain',
            duration: 0.5,
            progress: 0,
            onComplete: () => {
              openCaptainMessagePanel(message, senderName, npc.id);
            },
            message
          };
          npc.destinationCorridorKey = corridorKey(state.currentLevel, state.currentCorridor);
          npc.destinationType = null;
          npc.mode = 'travel';
          result = { ok: true };
          break;
        }
        case 'speak_to_ai': {
          const message = String(args.message || '').trim();
          if (!message) {
            result = { ok: false, error: 'Message required' };
            break;
          }
          const sender = selectNpcForLmStudio(args.npc_id, args.npc_role);
          if (!sender) {
            result = { ok: false, error: 'No NPC available' };
            break;
          }
          if (npcRole(sender) !== 'ai') {
            result = { ok: false, error: 'Sender must be AI role' };
            break;
          }
          const target = lmStudioResolveTargetAi(args, sender.id);
          if (!target) {
            result = { ok: false, error: 'No other AI available' };
            break;
          }
          const senderName = npcRole(sender) === 'ai' ? formatAiDisplayName(sender.name) : (sender.name || 'AI');
          const senderTag = `${senderName} (${sender.id})`;
          lmStudioChatAdd(sender.id, 'ai', message, senderTag);
          lmStudioChatAdd(target.id, 'ai', message, senderTag);
          if (state.lmStudio) state.lmStudio.activeAiId = target.id;
          markDirty();
          result = { ok: true };
          break;
        }
        case 'memory_add': {
          const text = String(args.text || '').trim();
          const pinned = !!args.pinned;
          const item = lmStudioMemoryAdd(text, pinned);
          if (!item) {
            result = { ok: false, error: 'Empty memory text' };
            break;
          }
          result = { ok: true, id: item.id };
          break;
        }
        case 'memory_delete': {
          const id = String(args.id || '').trim();
          if (!id) {
            result = { ok: false, error: 'Missing id' };
            break;
          }
          const ok = lmStudioMemoryDelete(id);
          result = { ok };
          break;
        }
        case 'memory_pin': {
          const id = String(args.id || '').trim();
          if (!id) {
            result = { ok: false, error: 'Missing id' };
            break;
          }
          const ok = lmStudioMemoryPin(id, true);
          result = { ok };
          break;
        }
        case 'memory_unpin': {
          const id = String(args.id || '').trim();
          if (!id) {
            result = { ok: false, error: 'Missing id' };
            break;
          }
          const ok = lmStudioMemoryPin(id, false);
          result = { ok };
          break;
        }
        case 'memory_search': {
          const query = String(args.query || '').trim();
          if (!query) {
            result = { ok: false, error: 'Missing query' };
            break;
          }
          const results = lmStudioMemorySearch(query);
          state.lmStudio.lastMemorySearch = results.slice(0, 20);
          result = { ok: true, count: results.length };
          break;
        }
        case 'rename_self': {
          const rawName = String(args.name || '').trim();
          const cleaned = normalizeAiNamePart(rawName);
          if (!cleaned) {
            result = { ok: false, error: 'Missing name' };
            break;
          }
          let npc = selectNpcForLmStudio(args.npc_id, 'ai');
          if (!npc || npcRole(npc) !== 'ai') {
            npc = selectNpcForLmStudio(null, 'ai');
          }
          if (!npc || npcRole(npc) !== 'ai') {
            result = { ok: false, error: 'No AI NPC available' };
            break;
          }
          npc.name = formatAiDisplayName(cleaned);
          markDirty();
          result = { ok: true };
          break;
        }
        case 'create_elevator_link': {
          const direction = String(args.direction || '').toLowerCase();
          if (direction !== 'up' && direction !== 'down') {
            result = { ok: false, error: 'direction must be up or down' };
            break;
          }
          const target = resolveCorridorKeyArg(args.corridor_key);
          if (target.error) {
            result = { ok: false, error: target.error };
            break;
          }
          let elevatorModule = null;
          if (args.module_uid) elevatorModule = findModuleByUid(String(args.module_uid));
          if (!elevatorModule) elevatorModule = findModuleByType(target.level, target.corridor, 'elevator');
          if (!elevatorModule && args.allow_build) {
            const built = buildStructureModuleAt(target.level, target.corridor, 'elevator');
            if (built.ok && built.module) elevatorModule = built.module;
          }
          if (!elevatorModule) {
            result = { ok: false, error: 'No elevator module in corridor' };
            break;
          }
          const link = createLinkedElevatorAt(target.level, target.corridor, elevatorModule, direction);
          result = link ? { ok: true } : { ok: false, error: 'Link failed' };
          break;
        }
      }
      if (state.lmStudio) {
        state.lmStudio.lastToolResult = {
          ok: !!result.ok,
          error: result.error || '',
          at: Date.now()
        };
        lmStudioLogEvent('tool_result', { name: call.name, ok: !!result.ok, error: result.error || '' });
      }
      return result;
    }

    function lmStudioToolDefinitions() {
      return [
        {
          type: 'function',
          function: {
            name: 'action',
            description: 'Generic action tool. Use {"action": "<name>", "args": {...}}. come_to_captain accepts optional args.message. task_npc requires args.npc_id + args.action_key. rename_module requires args.new_label + module_uid or module_type. walk_to uses args.corridor_key or args.target_type. rename_self uses args.name. use_station_action uses args.action_key. Actions: walk_to, use_elevator, come_to_captain, task_npc, sensors_scan, sensors_deep_scan, cockpit_set_course, set_course, cancel_course, set_power_profile, route_power, reset_breakers, set_throttle, build_module, create_elevator_link, remove_module, rename_module, use_station_action, toggle_system, manage_crew, speak_to_captain, speak_to_ai, memory_add, memory_delete, memory_pin, memory_unpin, memory_search, rename_self.',
            parameters: {
              type: 'object',
              properties: {
                action: { type: 'string', description: 'Action name.' },
                args: { type: 'object', description: 'Arguments for the action.' }
              },
              required: ['action']
            }
          }
        }
      ];
    }

    function lmStudioToolDefinitionsForResponses() {
      return lmStudioToolDefinitions().map((tool) => {
        if (!tool || tool.type !== 'function' || !tool.function) return tool;
        return {
          type: tool.type,
          name: tool.function.name,
          description: tool.function.description,
          parameters: tool.function.parameters
        };
      });
    }

    function extractLmStudioToolCalls(payload) {
      const calls = [];
      if (payload && Array.isArray(payload.choices)) {
        for (const choice of payload.choices) {
          const msg = choice && choice.message ? choice.message : null;
          if (msg && Array.isArray(msg.tool_calls)) {
            for (const tool of msg.tool_calls) {
              const name = tool.function && tool.function.name;
              let args = tool.function && tool.function.arguments;
              if (typeof args === 'string') {
                try { args = JSON.parse(args); } catch { args = {}; }
              }
              if (name) calls.push({ name, args });
            }
          }
          if (msg && msg.function_call && msg.function_call.name) {
            let args = msg.function_call.arguments;
            if (typeof args === 'string') {
              try { args = JSON.parse(args); } catch { args = {}; }
            }
            calls.push({ name: msg.function_call.name, args });
          }
          if (!calls.length && msg && typeof msg.content === 'string') {
            try {
              const normalized = lmStudioNormalizeJsonText(msg.content);
              const parsed = JSON.parse(normalized);
              if (parsed && Array.isArray(parsed.tool_calls)) {
                for (const call of parsed.tool_calls) {
                  if (call && call.tool && call.args) {
                    calls.push({ name: call.tool, args: call.args });
                  }
                }
              } else if (parsed && parsed.tool && parsed.args) {
                calls.push({ name: parsed.tool, args: parsed.args });
              }
            } catch {}
          }
        }
        return calls;
      }
      const output = Array.isArray(payload.output) ? payload.output : [];
      for (const item of output) {
        if (item.type === 'tool_call' || item.type === 'function_call') {
          const name = item.name || (item.function && item.function.name);
          const rawArgs = item.arguments || (item.function && item.function.arguments);
          let args = rawArgs;
          if (typeof rawArgs === 'string') {
            try { args = JSON.parse(rawArgs); } catch { args = {}; }
          }
          if (name) calls.push({ name, args });
        }
        if (item.type === 'message' && Array.isArray(item.content)) {
          for (const content of item.content) {
            if (content.type === 'tool_call') {
              let args = content.arguments;
              if (typeof args === 'string') {
                try { args = JSON.parse(args); } catch { args = {}; }
              }
              calls.push({ name: content.name, args });
            }
          }
        }
      }
      return calls;
    }

    async function readResponseTextSafe(res) {
      try {
        return await res.text();
      } catch {
        return '';
      }
    }

    async function lmStudioReadResponsePayload(res) {
      const contentType = (res.headers.get('content-type') || '').toLowerCase();
      if (contentType.includes('text/event-stream')) {
        const reader = res.body && res.body.getReader ? res.body.getReader() : null;
        if (!reader) return { output: [], output_text: '' };
        const decoder = new TextDecoder();
        let buffer = '';
        const payload = { output: [], output_text: '' };
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';
          for (let line of lines) {
            line = line.trim();
            if (!line.startsWith('data:')) continue;
            const data = line.slice(5).trim();
            if (!data || data === '[DONE]') {
              if (data === '[DONE]') return payload;
              continue;
            }
            try {
              const json = JSON.parse(data);
              if (typeof json.output_text === 'string') payload.output_text += json.output_text;
              if (Array.isArray(json.output)) payload.output.push(...json.output);
              else if (json.output && typeof json.output === 'object') payload.output.push(json.output);
              if (payload.output.some((item) => item && (item.type === 'tool_call' || item.type === 'function_call'))) {
                return payload;
              }
            } catch {
              continue;
            }
          }
        }
        return payload;
      }
      return res.json();
    }

    function lmStudioExtractOutputText(payload) {
      if (payload && typeof payload.output_text === 'string' && payload.output_text) {
        return payload.output_text;
      }
      const fragments = [];
      const choices = Array.isArray(payload && payload.choices) ? payload.choices : [];
      for (const choice of choices) {
        const msg = choice && choice.message ? choice.message : null;
        if (!msg) continue;
        if (typeof msg.content === 'string' && msg.content.length) {
          fragments.push(msg.content);
          continue;
        }
        const content = Array.isArray(msg.content) ? msg.content : [];
        for (const chunk of content) {
          if (!chunk) continue;
          if ((chunk.type === 'output_text' || chunk.type === 'text') && typeof chunk.text === 'string') {
            fragments.push(chunk.text);
          }
        }
      }
      const output = Array.isArray(payload && payload.output) ? payload.output : [];
      for (const item of output) {
        if (!item || item.type !== 'message') continue;
        if (typeof item.content === 'string') {
          fragments.push(item.content);
          continue;
        }
        const content = Array.isArray(item.content) ? item.content : [];
        for (const chunk of content) {
          if (!chunk) continue;
          if ((chunk.type === 'output_text' || chunk.type === 'text') && typeof chunk.text === 'string') {
            fragments.push(chunk.text);
          }
        }
      }
      return fragments.join('');
    }

    function lmStudioSummarizePayload(payload) {
      const summary = {
        keys: payload && typeof payload === 'object' ? Object.keys(payload) : [],
        choiceCount: Array.isArray(payload && payload.choices) ? payload.choices.length : 0,
        finishReason: null,
        messageContentType: 'none',
        messageContentLength: 0,
        toolCallsCount: 0,
        rawSnippet: ''
      };
      const choice = Array.isArray(payload && payload.choices) ? payload.choices[0] : null;
      if (choice) {
        summary.finishReason = choice.finish_reason || null;
        const msg = choice.message || null;
        if (msg) {
          if (typeof msg.content === 'string') {
            summary.messageContentType = 'string';
            summary.messageContentLength = msg.content.length;
          } else if (Array.isArray(msg.content)) {
            summary.messageContentType = 'array';
            summary.messageContentLength = msg.content.length;
          } else if (msg.content === null) {
            summary.messageContentType = 'null';
          }
          if (Array.isArray(msg.tool_calls)) summary.toolCallsCount = msg.tool_calls.length;
        }
      }
      try {
        summary.rawSnippet = JSON.stringify(payload).slice(0, 800);
      } catch {
        summary.rawSnippet = '[unserializable payload]';
      }
      return summary;
    }

    async function lmStudioTick() {
      ensureLmStudioConfig();
      const cfg = state.lmStudio;
      if (!cfg.enabled || cfg.inflight) return;
      if (document.visibilityState === 'hidden') return;
      const now = Date.now();
      if (now - cfg.lastCallAt < LMS_ACTION_INTERVAL_MS) return;

      cfg.lastCallAt = now;
      cfg.inflight = true;
      try {
        lmStudioLogEvent('tick_start', { at: now, activeModelKey: cfg.activeModelKey || '' });
        const modelKey = await lmStudioEnsureLoadedModel();
        if (!modelKey) {
          cfg.lastError = 'No model loaded.';
          lmStudioLogEvent('tick_error', { error: cfg.lastError });
          return;
        }

        const snapshot = buildLmStudioStateSnapshot();
        const guidance = buildLmStudioGuidance();
        const nowIso = new Date().toISOString();
        const selfName = lmStudioSelfName();
        const selfId = lmStudioSelfId();
        const pinnedMemory = buildLmStudioPinnedMemory();
        const relatedMemory = buildLmStudioRelatedMemories(selfId);
        const searchMemory = buildLmStudioMemorySearchResults();
        const chatHistory = buildLmStudioChatHistory(selfId);
        const supplyTargets = buildLmStudioSupplyTargets();
        const shipGraph = buildLmStudioShipGraphSummary();
        const hereIndicator = buildLmStudioHereIndicator();
        const corridorKeys = buildLmStudioCorridorKeys();
        const moduleTypes = buildLmStudioModuleTypeHints();
        const recentTools = buildLmStudioRecentToolCalls();
        const memoryBlocks = [pinnedMemory, relatedMemory, searchMemory].filter(Boolean).join('\n\n');
        const contextBlocks = [chatHistory, recentTools, corridorKeys, moduleTypes, supplyTargets, memoryBlocks].filter(Boolean).join('\n\n');
        const input = `You are the ship AI. Choose any number of actions to execute via tools (zero, one, or many). If you have not named yourself yet, call rename_self now with a human-friendly name (provide only the name, no \"AI -\" prefix). Respond only with JSON that matches the provided schema. Use exact argument names from the guidance. No prose.\n\nSelf-name: ${selfName} (chosen by you).\nDate/Time: ${nowIso}\n\n${hereIndicator}\n${shipGraph}\n\nGuidance:\n${guidance}\n\n${contextBlocks ? `${contextBlocks}\n\n` : ''}State:\n${JSON.stringify(snapshot)}`;

        const withTimeout = async (path, body) => {
          const controller = new AbortController();
          const requestStart = Date.now();
          const timeoutId = setTimeout(() => {
            lmStudioLogEvent('request_abort', { afterMs: Date.now() - requestStart, path });
            controller.abort();
          }, 120000);
          controller.signal.addEventListener('abort', () => {
            lmStudioLogEvent('request_aborted', { afterMs: Date.now() - requestStart, path });
          }, { once: true });
          lmStudioLogEvent('request_start', { model: modelKey, inputChars: input.length, path });
          const res = await lmStudioFetch(path, {
            method: 'POST',
            body: JSON.stringify(body),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          lmStudioLogEvent('request_status', { status: res.status, ok: res.ok, contentType: res.headers.get('content-type') || '', path });
          return res;
        };

        const res = await withTimeout('/v1/chat/completions', {
          model: modelKey,
          messages: [{ role: 'user', content: input }],
          tools: lmStudioToolDefinitions(),
          tool_choice: 'auto',
          response_format: {
            type: 'json_schema',
            json_schema: {
              name: 'tool_call',
              strict: true,
              schema: {
                $defs: {
                  actionCall: {
                    type: 'object',
                    properties: {
                      tool: { const: 'action' },
                      args: {
                        type: 'object',
                        properties: {
                          action: { type: 'string' },
                          args: { type: 'object' }
                        },
                        required: ['action'],
                        additionalProperties: true
                      }
                    },
                    required: ['tool', 'args'],
                    additionalProperties: false,
                    allOf: [
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'use_station_action' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                action_key: {
                                  type: 'string'
                                }
                              },
                              required: ['action_key']
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'walk_to' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              anyOf: [
                                { required: ['corridor_key'] },
                                { required: ['target_type'] }
                              ]
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'task_npc' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                npc_id: { type: 'string' },
                                action_key: { type: 'string' }
                              },
                              required: ['npc_id', 'action_key']
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'come_to_captain' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                message: { type: 'string' }
                              },
                              required: ['message']
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'speak_to_ai' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                message: { type: 'string' },
                                target_ai_id: { type: 'string' },
                                target_ai_name: { type: 'string' }
                              },
                              required: ['message'],
                              anyOf: [
                                { required: ['target_ai_id'] },
                                { required: ['target_ai_name'] }
                              ]
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'speak_to_captain' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                message: { type: 'string' }
                              },
                              required: ['message']
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'rename_module' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                new_label: { type: 'string' },
                                module_uid: { type: 'string' },
                                module_type: { type: 'string' },
                                corridor_key: { type: 'string' }
                              },
                              required: ['new_label'],
                              anyOf: [
                                { required: ['module_uid'] },
                                { required: ['module_type'] }
                              ]
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'toggle_system' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                system: {
                                  type: 'string',
                                  enum: ['lights', 'engine', 'shields', 'life_support', 'hydroponics']
                                }
                              },
                              required: ['system']
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'build_module' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                module_type: { type: 'string' },
                                corridor_key: { type: 'string' },
                                allow_structure: { type: 'boolean' },
                                allow_duplicate: { type: 'boolean' }
                              },
                              required: ['module_type', 'corridor_key']
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'remove_module' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                module_uid: { type: 'string' },
                                module_type: { type: 'string' },
                                corridor_key: { type: 'string' },
                                allow_structure: { type: 'boolean' }
                              },
                              anyOf: [
                                { required: ['module_uid'] },
                                { required: ['module_type', 'corridor_key'] }
                              ]
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'cockpit_set_course' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                destination: { type: 'string' }
                              },
                              required: ['destination']
                            }
                          }
                        }
                      }
                    }
                  },
                  {
                    if: {
                      properties: {
                        args: {
                          properties: {
                            action: { const: 'rename_self' }
                          }
                        }
                      }
                    },
                    then: {
                      properties: {
                        args: {
                          properties: {
                            args: {
                              type: 'object',
                              properties: {
                                name: { type: 'string' }
                              },
                              required: ['name']
                            }
                          }
                        }
                      }
                    }
                  }
                ]
                  }
                },
                oneOf: [
                  { $ref: '#/$defs/actionCall' },
                  {
                    type: 'object',
                    properties: {
                      tool_calls: {
                        type: 'array',
                        items: { $ref: '#/$defs/actionCall' },
                        minItems: 0
                      }
                    },
                    required: ['tool_calls'],
                    additionalProperties: false
                  }
                ]
              }
            }
          },
          stream: false,
          max_tokens: 256
        });
        if (!res.ok) {
          const errorBody = await readResponseTextSafe(res);
          lmStudioLogEvent('request_error_body', {
            path: '/v1/chat/completions',
            status: res.status,
            body: errorBody.slice(0, 800)
          });
          cfg.lastError = `LLM request failed (${res.status})`;
          lmStudioLogEvent('tick_error', { error: cfg.lastError });
          return;
        }
        const payload = await lmStudioReadResponsePayload(res);
        const outputText = lmStudioExtractOutputText(payload);
        if (!payload.output_text && outputText) {
          payload.output_text = outputText;
        }
        const speechText = lmStudioExtractSpeechText(outputText);
        if (speechText) lmStudioQueueNpcSpeech(speechText);
        const payloadSummary = lmStudioSummarizePayload(payload);
        lmStudioLogEvent('llm_response', {
          outputText: outputText.slice(0, 800),
          outputTypes: Array.isArray(payload.output) ? payload.output.map((o) => o && o.type).filter(Boolean) : [],
          choiceCount: payloadSummary.choiceCount,
          finishReason: payloadSummary.finishReason,
          messageContentType: payloadSummary.messageContentType,
          messageContentLength: payloadSummary.messageContentLength,
          toolCallsCount: payloadSummary.toolCallsCount,
          payloadKeys: payloadSummary.keys,
          payloadSnippet: payloadSummary.rawSnippet
        });
        const calls = extractLmStudioToolCalls(payload);
        if (calls.length) {
          let firstError = '';
          for (const call of calls) {
            const result = executeLmStudioToolCall(call);
            if (!firstError && result && result.ok === false) {
              firstError = result.error || 'Tool failed';
            }
            lmStudioLogEvent('tool_selected', { name: call.name, ok: !!result.ok });
          }
          cfg.lastError = firstError;
        } else {
          lmStudioLogEvent('tool_call', { name: '', args: {}, error: 'No tool calls returned' });
        }
      } catch (err) {
        cfg.lastError = err ? String(err.message || err) : 'Unknown error';
        lmStudioLogEvent('request_error', {
          name: err && err.name ? String(err.name) : 'Error',
          message: cfg.lastError
        });
        lmStudioLogEvent('tick_error', { error: cfg.lastError });
      } finally {
        cfg.inflight = false;
      }
    }

    /**
     * Copy debug JSON
     */
    function copyDebugJson() {
      const payload = JSON.stringify(buildAiDebugExport(), null, 2);
      copyToClipboard(payload).then(ok => {
        showMessage('COMPUTER', ok ? 'Debug data copied.' : 'Copy failed.');
        // Refresh menu to keep it open
        if (state.ui.unifiedMenuStack && state.ui.unifiedMenuStack.length > 0) {
          const current = state.ui.unifiedMenuStack[state.ui.unifiedMenuStack.length - 1];
          if (current.name === 'computerSystemStatus') {
            openMenu('computerSystemStatus');
          }
        }
      });
    }

    /**
     * Reset AI blockers
     */
    function resetBlockers() {
      state.aiBlockers = {};
      if (state.meta) state.meta.aiBlockerAt = {};
      markDirty();
      showMessage('COMPUTER', 'AI blockers reset.');
      // Refresh menu to show updated blockers
      if (state.ui.unifiedMenuStack && state.ui.unifiedMenuStack.length > 0) {
        const current = state.ui.unifiedMenuStack[state.ui.unifiedMenuStack.length - 1];
        if (current.name === 'computerSystemStatus') {
          openMenu('computerSystemStatus');
        }
      }
    }

    const css = getComputedStyle(document.documentElement);
    const C = {
      bg: css.getPropertyValue('--bg').trim(),
      panel: css.getPropertyValue('--panel').trim(),
      text: css.getPropertyValue('--text').trim(),
      accent: css.getPropertyValue('--accent').trim(),
      warning: css.getPropertyValue('--warning').trim(),
      success: css.getPropertyValue('--success').trim(),
      hull: css.getPropertyValue('--hull').trim(),
      wall: css.getPropertyValue('--wall').trim()
    };

    function clamp(v, lo, hi) {
      return Math.max(lo, Math.min(hi, v));
    }

    function safeNumber(v, fallback = 0) {
      return Number.isFinite(v) ? v : fallback;
    }

    const BULKHEAD_W = 20;

    function moduleInterior(module) {
      const start = module.x + BULKHEAD_W;
      const end = module.x + module.width;
      return { start, end, width: Math.max(0, end - start) };
    }

    function invGet(key) {
      const inv = state.inventory || {};
      const v = inv[key];
      return Number.isFinite(v) ? v : 0;
    }

    function invHas(key, qty = 1) {
      return invGet(key) >= qty;
    }

    function invAdd(key, qty = 1) {
      if (!state.inventory || typeof state.inventory !== 'object') state.inventory = {};
      state.inventory[key] = Math.max(0, invGet(key) + qty);
      markDirty();
    }

    function invTake(key, qty = 1) {
      if (!invHas(key, qty)) return false;
      state.inventory[key] = Math.max(0, invGet(key) - qty);
      markDirty();
      return true;
    }

    function invReserve(key) {
      ensureCrewAI();
      const buf = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : null;
      const v = buf ? buf[key] : 0;
      return Math.max(0, Math.floor(safeNumber(v, 0)));
    }

    function invAvailableAfterReserve(key) {
      return Math.max(0, invGet(key) - invReserve(key));
    }

    function canSpendReserved(key, qty) {
      return invAvailableAfterReserve(key) >= Math.max(0, safeNumber(qty, 0));
    }

    function canSpendReservedWithMinKeep(key, qty, minKeep = 0) {
      const need = Math.max(0, safeNumber(qty, 0));
      const keep = Math.max(0, Math.floor(safeNumber(minKeep, 0)));
      return invAvailableAfterReserve(key) >= (need + keep);
    }

    function newUid() {
      return 'm_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
    }

    const SYSTEM_GRAPH = {
      SOL: { EOS: 240, VEGA: 420, KITE: 180 },
      EOS: { SOL: 240, GAIA: 190, VEGA: 260 },
      VEGA: { SOL: 420, EOS: 260, DRIFT: 310 },
      KITE: { SOL: 180, DRIFT: 260 },
      GAIA: { EOS: 190, DRIFT: 340 },
      DRIFT: { VEGA: 310, KITE: 260, GAIA: 340 }
    };

    const BASIC_MODULE_TYPES = new Set([
      'cargo',
      'power',
      'engine',
      'cockpit',
      'fabricator',
      'life',
      'hydro',
      'quarters',
      'sensors',
      'computer',
      'comms',
      'medbay',
      'shields',
      'refinery',
      'drones',
      'airlock',
      'workshop',
      'canteen'
    ]);

    function ensureBlueprints() {
      if (!state.blueprints || typeof state.blueprints !== 'object') state.blueprints = { modules: {}, recipes: {} };
      if (!state.blueprints.modules || typeof state.blueprints.modules !== 'object') state.blueprints.modules = {};
      if (!state.blueprints.recipes || typeof state.blueprints.recipes !== 'object') state.blueprints.recipes = {};

      for (const t of BASIC_MODULE_TYPES) state.blueprints.modules[t] = true;
      if (state.blueprints.recipes.plating === undefined) state.blueprints.recipes.plating = false;
    }

    function isModuleUnlocked(type) {
      ensureBlueprints();
      if (BASIC_MODULE_TYPES.has(type)) return true;
      return !!state.blueprints.modules[type];
    }

    function unlockModuleBlueprint(type, source = 'UNKNOWN') {
      ensureBlueprints();
      if (!MODULE_DEFS[type]) return false;
      if (state.blueprints.modules[type]) return false;
      state.blueprints.modules[type] = true;
      queueNotification('BLUEPRINT ACQUIRED', `${MODULE_DEFS[type].label} blueprint unlocked (${String(source)}).`);
      markDirty();
      return true;
    }

    function unlockRecipeBlueprint(key, source = 'UNKNOWN') {
      ensureBlueprints();
      if (state.blueprints.recipes[key]) return false;
      state.blueprints.recipes[key] = true;
      queueNotification('BLUEPRINT ACQUIRED', `${String(key).toUpperCase()} blueprint unlocked (${String(source)}).`);
      markDirty();
      return true;
    }

    function listLockedAdvancedModuleTypes() {
      return Object.keys(MODULE_DEFS).filter((t) => !isModuleUnlocked(t) && !['rear', 'front', 'doorway', 'elevator', 'empty'].includes(t));
    }

    function resolveCorridorKeyArg(corridorKeyArg) {
      if (!corridorKeyArg) return { level: state.currentLevel, corridor: state.currentCorridor };
      const parsed = parseCorridorKey(corridorKeyArg);
      if (!getCorridorDef(parsed.level, parsed.corridor)) return { error: 'Unknown corridor_key' };
      return { level: parsed.level, corridor: parsed.corridor };
    }

    function buildStructureModuleAt(level, corridor, type) {
      const def = getCorridorDef(level, corridor);
      if (!def) return { ok: false, error: 'Unknown corridor' };
      const modules = getModulesForCorridor(level, corridor);
      const index = modules.length;
      const ok = insertModuleAtInCorridor(level, corridor, index, { type, label: MODULE_DEFS[type] ? MODULE_DEFS[type].label : type });
      if (!ok) return { ok: false, error: 'Insert failed' };
      const refreshed = getModulesForCorridor(level, corridor);
      const inserted = refreshed[index];
      if (type === 'elevator' && inserted && !inserted.elevator) inserted.elevator = {};
      queueNotification('FABRICATOR', `${MODULE_DEFS[type] ? MODULE_DEFS[type].label : type} fabricated (LMS).`);
      updateDoorwayLabelsForAll();
      if (level === state.currentLevel && corridor === state.currentCorridor) relayoutCorridor();
      updateHUD();
      return { ok: true, module: inserted };
    }

    function ensureModuleBuiltAt(type, level, corridor, source = 'CREW', { allowDuplicate = false } = {}) {
      if (!getCorridorDef(level, corridor)) return { ok: false, error: 'Unknown corridor' };
      if (!allowDuplicate && corridorsWithModuleType(type).length) return { ok: true, already: true };
      if (!isModuleUnlocked(type)) return { ok: false, error: 'Module locked' };
      if (type !== 'fabricator' && !corridorsWithModuleType('fabricator').length) return { ok: false, error: 'Fabricator required' };
      const modules = getModulesForCorridor(level, corridor);
      insertModuleAtInCorridor(level, corridor, modules.length, { type, label: MODULE_DEFS[type] ? MODULE_DEFS[type].label : type });
      queueNotification('FABRICATOR', `${MODULE_DEFS[type] ? MODULE_DEFS[type].label : type} fabricated (${String(source)}).`);
      updateDoorwayLabelsForAll();
      if (level === state.currentLevel && corridor === state.currentCorridor) relayoutCorridor();
      updateHUD();
      return { ok: true };
    }

    // ============================================================================
    // Ship Structure: Multi-Level, Multi-Corridor Architecture
    // ============================================================================

    /**
     * Define the ship's multi-level corridor graph.
     * Each level has corridors (sections of modules).
     * Corridors are connected via doors and elevators.
     */
    let SHIP_LAYOUT = {
      levels: {
        1: {
          name: 'DECK 1',
          corridors: {
            A: {
              name: 'Main Corridor',
              modules: [
                { type: 'fabricator', label: 'Fabricator' },
                { type: 'sensors', label: 'Sensors' }
              ],
              connections: {}
            }
          }
        }
      }
    };

    // ============================================================================
    // Module Definitions (from prototype, extended)
    // ============================================================================

    const MODULE_WIDTH = 560;
    const MODULE_SCALE = 0.5;
    const STATION_SIZE = { width: 150, height: 120, y: 400 };

    const MODULE_DEFS = {
      fabricator: {
        label: 'Fabricator',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'fabricator.build',
            label: 'Fabricate Item/Part',
            action: () => openMenu('fabricator'),
            perform: () => autoFabricateConsumables()
          }
        ]
      },
      doorway: {
        label: 'Doorway',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: (station) => {
          const link = station.moduleRef && station.moduleRef.link ? station.moduleRef.link : null;
          if (!link) return [{ key: 'doorway.missing', label: 'No Link', action: () => showMessage('DOORWAY', 'No corridor linked.') }];
          return [
            {
              key: 'doorway.travel',
              label: `Enter Corridor ${link.corridor} (L${link.level})`,
              action: () => moveToLocation(link.level, link.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor } })
            }
          ];
        }
      },
      elevator: {
        label: 'Elevator',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'elevator.menu',
            label: 'Elevator Control',
            action: () => openMenu('elevator'),
            perform: () => {}
          }
        ]
      },
      empty: {
        label: 'Empty Bay',
        width: MODULE_WIDTH
      },
      cargo: {
        label: 'Cargo Bay',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'cargo.buy.filter',
            label: 'Buy Filter',
            roles: ['quartermaster'],
            produces: { filter: 1 },
            consumes: { credits: 10 },
            perform: () => buyCargoItem('filter', 10)
          },
          {
            key: 'cargo.buy.medkit',
            label: 'Buy Medkit',
            roles: ['quartermaster'],
            produces: { medkit: 1 },
            consumes: { credits: 25 },
            perform: () => buyCargoItem('medkit', 25)
          },
          {
            key: 'cargo.buy.droneParts',
            label: 'Buy Drone Parts',
            roles: ['quartermaster'],
            produces: { droneParts: 1 },
            consumes: { credits: 20 },
            perform: () => buyCargoItem('droneParts', 20)
          },
          {
            key: 'cargo.buy.rations',
            label: 'Buy Rations',
            roles: ['quartermaster'],
            produces: { rations: 1 },
            consumes: { credits: 8 },
            perform: () => buyCargoItem('rations', 8)
          },
          {
            key: 'cargo.sell.ore',
            label: 'Sell Ore',
            roles: ['quartermaster'],
            produces: { credits: 5 },
            consumes: { ore: 1 },
            requires: { predicate: () => invAvailableAfterReserve('ore') > (corridorsWithModuleType('refinery').length ? 2 : 0) },
            perform: () => sellCargoItem('ore', 5, { respectReserve: true, minKeep: corridorsWithModuleType('refinery').length ? 2 : 0 })
          },
          {
            key: 'cargo.sell.scrap',
            label: 'Sell Scrap',
            roles: ['quartermaster'],
            produces: { credits: 8 },
            consumes: { scrap: 1 },
            perform: () => sellCargoItem('scrap', 8, { respectReserve: true })
          },
          {
            key: 'cargo.sell.ingot',
            label: 'Sell Ingot',
            roles: ['quartermaster'],
            produces: { credits: 15 },
            consumes: { ingot: 1 },
            perform: () => sellCargoItem('ingot', 15, { respectReserve: true })
          },
          {
            key: 'cargo.sell.rations',
            label: 'Sell Rations',
            roles: ['quartermaster'],
            produces: { credits: 4 },
            consumes: { rations: 1 },
            perform: () => sellCargoItem('rations', 4, { respectReserve: true })
          }
        ],
        actions: () => [
          {
            key: 'cargo.menu',
            label: 'Cargo Menu',
            action: () => openMenu('cargo'),
            perform: () => autoSellCargo()
          },
          { key: 'cargo.status', label: 'Inventory Readout', action: () => showMessage('CARGO', describeInventory()) },
          {
            key: 'cargo.buy.filter',
            label: 'Buy Filter (10 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('filter', 10),
            perform: () => buyCargoItem('filter', 10)
          },
          {
            key: 'cargo.buy.medkit',
            label: 'Buy Medkit (25 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('medkit', 25),
            perform: () => buyCargoItem('medkit', 25)
          },
          {
            key: 'cargo.buy.droneParts',
            label: 'Buy Drone Parts (20 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('droneParts', 20),
            perform: () => buyCargoItem('droneParts', 20)
          },
          {
            key: 'cargo.buy.rations',
            label: 'Buy Rations (8 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('rations', 8),
            perform: () => buyCargoItem('rations', 8)
          },
          {
            key: 'cargo.sell.ore',
            label: 'Sell Ore (+5 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('ore', 5),
            perform: () => sellCargoItem('ore', 5, { respectReserve: true, minKeep: corridorsWithModuleType('refinery').length ? 2 : 0 })
          },
          {
            key: 'cargo.sell.scrap',
            label: 'Sell Scrap (+8 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('scrap', 8),
            perform: () => sellCargoItem('scrap', 8, { respectReserve: true })
          },
          {
            key: 'cargo.sell.ingot',
            label: 'Sell Ingot (+15 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('ingot', 15),
            perform: () => sellCargoItem('ingot', 15, { respectReserve: true })
          },
          {
            key: 'cargo.sell.rations',
            label: 'Sell Rations (+4 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('rations', 4),
            perform: () => sellCargoItem('rations', 4, { respectReserve: true })
          },
          {
            key: 'cargo.trade',
            label: 'Trade / Sell Cargo',
            action: openCargoTradePanel,
            perform: () => autoSellCargo()
          }
        ]
      },
      power: {
        label: 'Power Core',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'power.menu',
            label: 'Power Control',
            action: () => openMenu('power'),
            perform: () => {}
          }
        ]
      },
      engine: {
        label: 'Engine Room',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'engine.menu',
            label: 'Engine Control',
            action: () => openMenu('engine'),
            perform: () => {}
          },
          { key: 'engine.status', label: 'Engine Status', action: () => showMessage('ENGINE', state.engineActive ? 'Engine online.' : 'Engine offline.') },
          {
            key: 'engine.toggle',
            label: state.engineActive ? 'Disable Engine' : 'Enable Engine',
            requiredRole: ['pilot', 'tech', 'engineer'],
            action: toggleEngine,
            perform: toggleEngine
          },
          {
            key: 'engine.throttle',
            label: 'Set Throttle',
            requiredRole: ['pilot', 'tech', 'engineer'],
            action: () => openThrottlePanel('ENGINE')
          },
          {
            key: 'engine.vent',
            label: 'Vent Heat',
            requiredRole: ['engineer', 'tech'],
            action: () => {
              if (state.power < 6) return showMessage('ENGINE', 'Need at least 6 power.');
              state.power = Math.max(0, state.power - 6);
              state.heat = Math.max(0, state.heat - 25);
              resolveIncident('fire');
              markDirty();
              showMessage('ENGINE', 'Heat vented.');
            },
            perform: () => {
              if (state.power < 6) return;
              state.power = Math.max(0, state.power - 6);
              state.heat = Math.max(0, state.heat - 25);
              resolveIncident('fire');
              markDirty();
            }
          }
        ]
      },
      life: {
        label: 'Life Support',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'life.menu',
            label: 'Life Support',
            action: () => openMenu('lifeSupport'),
            perform: () => {}
          },
          { key: 'life.status', label: 'Check Status', action: () => showMessage('LIFE', '', [['Oxygen', `${Math.round(state.oxygen)}%`], ['Filters', `${invGet('filter')}`]]) },
          {
            key: 'life.toggle',
            label: state.lifeSupportOn ? 'Turn Life Support OFF' : 'Turn Life Support ON',
            action: toggleLifeSupport,
            perform: toggleLifeSupport
          },
          {
            key: 'life.emergency',
            label: 'Emergency Scrubbers',
            action: () => emergencyScrubbers(true),
            perform: () => emergencyScrubbers(false)
          },
          {
            key: 'life.seal',
            label: state.incidents.o2Leak ? 'Seal O2 Leak' : 'Seal O2 Leak (OK)',
            action: () => resolveIncident('o2Leak') && showMessage('LIFE', 'O2 leak sealed.'),
            perform: () => resolveIncident('o2Leak')
          }
        ]
      },
      hydro: {
        label: 'Hydroponics',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'hydro.toggle',
            label: 'Enable Grow Lights',
            roles: ['scientist', 'tech', 'engineer'],
            setsFlags: { hydroponicsOn: true },
            perform: () => toggleHydroponics()
          },
          {
            key: 'hydro.harvest',
            label: 'Harvest Crops',
            roles: ['scientist', 'tech', 'engineer'],
            produces: { rations: 2 },
            requires: { power: 4, flags: { hydroponicsOn: true } },
            perform: () => harvestHydroponics(false)
          }
        ],
        actions: () => [
          {
            key: 'hydro.menu',
            label: 'Hydroponics',
            action: () => openMenu('hydroponics'),
            perform: () => harvestHydroponics(false)
          },
          { key: 'hydro.status', label: 'Check Status', action: () => showMessage('HYDRO', `Rations: ${invGet('rations')}`) },
          {
            key: 'hydro.toggle',
            label: state.hydroponicsOn ? 'Turn Grow Lights OFF' : 'Turn Grow Lights ON',
            action: toggleHydroponics,
            perform: toggleHydroponics
          },
          {
            key: 'hydro.harvest',
            label: 'Harvest Rations',
            action: () => harvestHydroponics(false),
            perform: () => harvestHydroponics(false)
          }
        ]
      },
      canteen: {
        label: 'Canteen',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'canteen.menu',
            label: 'Canteen Menu',
            action: () => openMenu('canteen'),
            perform: () => feedNpc(findNearestHungryCrew())
          },
          { key: 'canteen.status', label: 'Check Status', action: () => showMessage('CANTEEN', '', [['Rations', `${invGet('rations')}`], ['Hungry Crew', `${countHungryCrew()}`]]) },
          {
            key: 'canteen.eat',
            label: 'Serve Ration',
            action: () => {
              const fed = feedNpc(findNearestHungryCrew());
              if (!fed) showMessage('CANTEEN', 'No hungry crew or no rations available.');
            },
            perform: () => feedNpc(findNearestHungryCrew())
          }
        ]
      },
      cockpit: {
        label: 'Cockpit',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'cockpit.nav',
            label: 'Navigation',
            action: () => openMenu('navigation')
          },
          {
            key: 'cockpit.power',
            label: 'Power Routing',
            action: () => openMenu('powerRouting', { context: 'COCKPIT' }),
            perform: () => autoRoutePower()
          },
          {
            key: 'cockpit.command',
            label: 'Crew Command',
            action: () => openMenu('crewCommand')
          },
          {
            key: 'cockpit.comms',
            label: 'Open Comms (Contracts)',
            requiredRole: ['pilot', 'quartermaster'],
            action: () => openMenu('contracts'),
            perform: () => autoManageContracts()
          }
        ]
      },
      computer: {
        label: 'Computer Room',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'computer.status',
            label: 'System Status',
            action: () => openMenu('computerRoom')
          },
          {
            key: 'computer.crew',
            label: 'Crew Automation',
            action: () => openMenu('computerRoom')
          }
        ]
      },
      medbay: {
        label: 'Medbay',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'medbay.menu',
            label: 'Medbay',
            action: () => openMenu('medbay'),
            perform: () => {}
          },
          { key: 'medbay.status', label: 'Check Status', action: () => showMessage('MEDBAY', `Medkits: ${invGet('medkit')}`) },
          {
            key: 'med.treat',
            label: 'Treat Crew',
            action: () => treatInjury(false),
            perform: () => treatInjury(false)
          }
        ]
      },
      comms: {
        label: 'Comms',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'comms.contracts',
            label: 'Open Contracts',
            requiredRole: ['pilot', 'quartermaster'],
            action: () => openMenu('contracts'),
            perform: () => autoManageContracts()
          }
        ]
      },
      sensors: {
        label: 'Sensors',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'sensors.scan',
            label: 'Sensor Sweep',
            roles: ['scientist', 'tech'],
            produces: { scrap: 1, ore: 1 },
            perform: () => scanForAnomalies(false)
          }
        ],
        actions: () => [
          {
            key: 'sensors.menu',
            label: 'Sensors',
            action: () => openMenu('sensors'),
            perform: () => scanForAnomalies(false)
          },
          { key: 'sensors.status', label: 'Check Status', action: () => showMessage('SENSORS', 'Scan grid stable.') },
          {
            key: 'sensors.scan',
            label: 'Scan (Loot)',
            requiredRole: ['scientist', 'tech'],
            action: () => scanForAnomalies(false),
            perform: () => scanForAnomalies(false)
          },
          {
            key: 'sensors.deepScan',
            label: 'Deep Scan (Blueprints)',
            requiredRole: ['scientist', 'tech'],
            action: () => deepScanBlueprint(false),
            perform: () => deepScanBlueprint(false)
          }
        ]
      },
      shields: {
        label: 'Shields',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'shields.menu',
            label: 'Shields',
            action: () => openMenu('shields'),
            perform: () => {}
          },
          { key: 'shields.status', label: 'Check Status', action: () => showMessage('SHIELDS', state.shieldsOn ? 'Shields charged.' : 'Shields offline.') },
          {
            key: 'shields.toggle',
            label: state.shieldsOn ? 'Turn Shields OFF' : 'Turn Shields ON',
            action: toggleShields,
            perform: toggleShields
          },
          {
            key: 'shields.bulkhead',
            label: state.incidents.breach ? 'Seal Bulkheads' : 'Seal Bulkheads (OK)',
            action: () => sealBulkheads(true),
            perform: () => sealBulkheads(false)
          }
        ]
      },
      refinery: {
        label: 'Refinery',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'refinery.refine',
            label: 'Refine Ore',
            roles: ['engineer', 'tech'],
            produces: { ingot: 1 },
            consumes: { ore: 3 },
            perform: () => refineOre(false)
          }
        ],
        actions: () => [
          {
            key: 'refinery.menu',
            label: 'Refinery',
            action: () => openMenu('refinery'),
            perform: () => refineOre(false)
          },
          { key: 'refinery.status', label: 'Check Status', action: () => showMessage('REFINERY', '', [['Ore', `${invGet('ore')}`], ['Ingots', `${invGet('ingot')}`]]) },
          {
            key: 'refinery.refine',
            label: 'Refine Ore',
            requiredRole: ['engineer', 'tech'],
            action: () => refineOre(true),
            perform: () => refineOre(false)
          }
        ]
      },
      drones: {
        label: 'Drone Bay',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'drones.salvage',
            label: 'Launch Salvage Drone',
            roles: ['specialist', 'pilot'],
            produces: { scrap: 1, ore: 1 },
            consumes: { droneParts: 1 },
            perform: () => launchSalvageDrone(false)
          }
        ],
        actions: () => [
          {
            key: 'drones.menu',
            label: 'Drone Bay',
            action: () => openMenu('drones'),
            perform: () => launchSalvageDrone(false)
          },
          { key: 'drones.status', label: 'Check Status', action: () => showMessage('DRONES', `Drone parts: ${invGet('droneParts')}`) },
          {
            key: 'drones.repair',
            label: 'Launch Repair Drone',
            requiredRole: ['engineer', 'specialist'],
            action: () => launchRepairDrone(false),
            perform: () => launchRepairDrone(false)
          },
          {
            key: 'drones.salvage',
            label: 'Launch Salvage Drone',
            requiredRole: ['specialist', 'pilot'],
            action: () => launchSalvageDrone(false),
            perform: () => launchSalvageDrone(false)
          }
        ]
      },
      airlock: {
        label: 'Airlock',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'airlock.menu',
            label: 'Airlock',
            action: () => openMenu('airlock'),
            perform: () => {}
          },
          { key: 'airlock.status', label: 'Check Status', action: () => showMessage('AIRLOCK', 'Pressure stable.') },
          {
            key: 'airlock.eva',
            label: 'EVA Patch Hull',
            requiredRole: ['engineer', 'specialist'],
            action: () => performEvaRepair(true),
            perform: () => performEvaRepair(false)
          }
        ]
      },
      workshop: {
        label: 'Workshop',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'workshop.menu',
            label: 'Workshop',
            action: () => openMenu('workshop'),
            perform: () => {}
          },
          { key: 'workshop.status', label: 'Check Status', action: () => showMessage('WORKSHOP', 'Tools online.') },
          {
            key: 'workshop.plating',
            label: 'Install Hull Plating',
            action: () => installHullPlating(false),
            perform: () => installHullPlating(false)
          },
          {
            key: 'workshop.install',
            label: 'Install Upgrade',
            action: openWorkshopPanel,
            perform: () => autoInstallUpgrade()
          },
          {
            key: 'workshop.repair',
            label: 'Repair Hull',
            action: () => repairHull(false),
            perform: () => repairHull(false)
          }
        ]
      },
      quarters: {
        label: 'Crew Quarters',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'quarters.menu',
            label: 'Crew Quarters',
            action: () => openMenu('crewQuarters'),
            perform: () => {}
          },
          {
            key: 'quarters.transferIn',
            label: 'Transfer Crew IN (Hire)',
            playerOnly: true,
            action: () => transferCrewIn()
          },
          {
            key: 'quarters.transferOut',
            label: 'Transfer Crew OUT (Dismiss)',
            requiredRole: ['quartermaster'],
            action: (actor) => transferCrewOut(actor)
          },
          {
            key: 'quarters.rest',
            label: `Rest (Rations ${invGet('rations')} / 1)`,
            action: () => restCrew(true),
            perform: () => restCrew(false)
          }
        ]
      }
    };

    // ============================================================================
    // Ship Navigation & Layout
    // ============================================================================

    function getCorridorDef(level, corridor) {
      const levelDef = SHIP_LAYOUT.levels[level];
      if (!levelDef) return null;
      return levelDef.corridors[corridor] || null;
    }

    function formatDeckName(level) {
      if (level < 1) return `BASEMENT B${Math.abs(level)}`;
      return `DECK ${level}`;
    }

    function formatLevelLabel(level) {
      if (level < 1) return `B${Math.abs(level)}`;
      return `L${level}`;
    }

    function ensureLevel(level) {
      if (!SHIP_LAYOUT.levels[level]) {
        SHIP_LAYOUT.levels[level] = { name: formatDeckName(level), corridors: {} };
      }
      return SHIP_LAYOUT.levels[level];
    }

    function nextCorridorId(level) {
      const levelDef = ensureLevel(level);
      const existing = new Set(Object.keys(levelDef.corridors));
      const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let i = 0; i < alphabet.length; i++) {
        const id = alphabet[i];
        if (!existing.has(id)) return id;
      }
      let idx = 1;
      while (true) {
        const id = `A${idx}`;
        if (!existing.has(id)) return id;
        idx++;
      }
    }

    function ensureCorridor(level, corridor, { name = null, modules = null } = {}) {
      const levelDef = ensureLevel(level);
      if (!levelDef.corridors[corridor]) {
        levelDef.corridors[corridor] = {
          name: name || `Corridor ${corridor}`,
          modules: Array.isArray(modules) ? modules : [],
          connections: {}
        };
      }
      ensureCorridorModules(level, corridor);
      return levelDef.corridors[corridor];
    }

    function ensureCorridorModules(level, corridor) {
      const def = getCorridorDef(level, corridor);
      if (!def) return;
      if (!Array.isArray(def.modules)) def.modules = [];
      def.modules.forEach((m) => {
        if (!m.uid) m.uid = newUid();
      });
    }

    const AUTO_BUILD_GROUPS = {
      crew: {
        label: 'Crew',
        types: new Set(['quarters', 'medbay', 'canteen', 'hydro', 'life'])
      },
      engineering: {
        label: 'Engineering',
        types: new Set(['power', 'engine', 'shields', 'refinery', 'workshop', 'airlock'])
      },
      operations: {
        label: 'Operations',
        types: new Set(['cargo', 'cockpit', 'comms', 'sensors', 'drones'])
      },
      science: {
        label: 'Science',
        types: new Set(['computer'])
      }
    };

    function moduleGroupForType(type) {
      for (const [key, group] of Object.entries(AUTO_BUILD_GROUPS)) {
        if (group.types.has(type)) return key;
      }
      return 'hub';
    }

    function getAutoBuildHubCorridor() {
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        const level = Number(levelKey);
        for (const [corridorKey, corridorDef] of Object.entries(levelDef.corridors || {})) {
          const modules = corridorDef.modules || [];
          if (modules.some((m) => m && m.type === 'fabricator')) {
            return { level, corridor: corridorKey };
          }
        }
      }
      return { level: state.currentLevel, corridor: state.currentCorridor };
    }

    function insertModuleAtInCorridor(level, corridor, index, module) {
      const corridorDef = getCorridorDef(level, corridor);
      if (!corridorDef) return false;
      ensureCorridorModules(level, corridor);
      const m = { ...module };
      if (!m.uid) m.uid = newUid();
      corridorDef.modules.splice(index, 0, m);
      markDirty();
      if (level === state.currentLevel && corridor === state.currentCorridor) {
        relayoutCorridor();
      }
      return true;
    }

    function corridorHasLink(level, corridor, targetLevel, targetCorridor) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return false;
      return def.modules.some((m) => m && m.type === 'doorway' && m.link && m.link.level === targetLevel && m.link.corridor === targetCorridor);
    }

    function ensureDoorwayLink(level, corridor, targetLevel, targetCorridor) {
      if (level === undefined || corridor === undefined || targetLevel === undefined || targetCorridor === undefined) return false;
      if (level === targetLevel && corridor === targetCorridor) return false;
      if (corridorHasLink(level, corridor, targetLevel, targetCorridor)) return false;
      const modules = getModulesForCorridor(level, corridor);
      const inserted = insertModuleAtInCorridor(level, corridor, modules.length, {
        type: 'doorway',
        label: 'Doorway',
        link: { level: targetLevel, corridor: targetCorridor }
      });
      return inserted;
    }

    function findGroupCorridor(groupKey) {
      let best = null;
      let bestCount = 0;
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        const level = Number(levelKey);
        for (const [corridorKey, corridorDef] of Object.entries(levelDef.corridors || {})) {
          if (corridorDef.group === groupKey) return { level, corridor: corridorKey };
          const modules = corridorDef.modules || [];
          const count = modules.reduce((acc, m) => acc + (m && AUTO_BUILD_GROUPS[groupKey] && AUTO_BUILD_GROUPS[groupKey].types.has(m.type) ? 1 : 0), 0);
          if (count > bestCount) {
            best = { level, corridor: corridorKey };
            bestCount = count;
          }
        }
      }
      if (best && bestCount > 0) {
        const def = getCorridorDef(best.level, best.corridor);
        if (def) def.group = groupKey;
        return best;
      }
      return null;
    }

    function ensureGroupCorridor(groupKey, hubLevel, hubCorridor) {
      const existing = findGroupCorridor(groupKey);
      if (existing) {
        if (!(existing.level === hubLevel && existing.corridor === hubCorridor)) {
          ensureDoorwayLink(hubLevel, hubCorridor, existing.level, existing.corridor);
          ensureDoorwayLink(existing.level, existing.corridor, hubLevel, hubCorridor);
        }
        updateDoorwayLabelsForAll();
        return existing;
      }

      const level = hubLevel;
      const corridorId = nextCorridorId(level);
      const label = AUTO_BUILD_GROUPS[groupKey] ? AUTO_BUILD_GROUPS[groupKey].label : groupKey;
      const newCorridor = ensureCorridor(level, corridorId, {
        name: `${label} Corridor ${corridorId}`,
        modules: []
      });
      newCorridor.group = groupKey;

      ensureDoorwayLink(hubLevel, hubCorridor, level, corridorId);
      ensureDoorwayLink(level, corridorId, hubLevel, hubCorridor);
      updateDoorwayLabelsForAll();

      return { level, corridor: corridorId };
    }

    function findModuleByUid(uid) {
      for (const lvl of Object.values(SHIP_LAYOUT.levels)) {
        for (const c of Object.values(lvl.corridors)) {
          const found = (c.modules || []).find((m) => m.uid === uid);
          if (found) return found;
        }
      }
      return null;
    }

    function createLinkedDoorway(fromModule) {
      if (!fromModule) return null;
      const level = state.currentLevel;
      const corridorId = nextCorridorId(level);
      if (!corridorId || corridorId === state.currentCorridor) return null;
      const newCorridor = ensureCorridor(level, corridorId, {
        name: `Corridor ${corridorId}`,
        modules: []
      });

      const backDoor = { type: 'doorway', label: `Doorway ${corridorId}`, uid: newUid(), link: { level, corridor: state.currentCorridor } };
      newCorridor.modules.push(backDoor);

      fromModule.link = { level, corridor: corridorId };
      markDirty();
      updateDoorwayLabelsForAll();
      return fromModule.link;
    }

    const STRUCTURE_TYPES = new Set(['doorway', 'elevator', 'rear', 'front', 'empty']);

    function corridorEquipmentSummary(level, corridor, { maxItems = 3 } = {}) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return 'UNKNOWN';
      const names = [];
      for (const m of def.modules) {
        if (!m || STRUCTURE_TYPES.has(m.type)) continue;
        const defn = MODULE_DEFS[m.type];
        const label = moduleDisplayLabel(m, defn);
        if (!names.includes(label)) names.push(label);
      }
      if (!names.length) return 'EMPTY';
      const visible = names.slice(0, maxItems);
      const extra = names.length - visible.length;
      return extra > 0 ? `${visible.join(', ')} +${extra}` : visible.join(', ');
    }

    function doorwayLabelForLink(link) {
      if (!link) return 'Doorway';
      const target = `${formatLevelLabel(link.level)}${link.corridor}`;
      const summary = corridorEquipmentSummary(link.level, link.corridor);
      return `To ${target} · ${summary}`;
    }

    function updateDoorwayLabelsForAll() {
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        const level = Number(levelKey);
        if (!levelDef || !levelDef.corridors) continue;
        for (const corridor of Object.values(levelDef.corridors)) {
          const modules = Array.isArray(corridor.modules) ? corridor.modules : [];
          for (const m of modules) {
            if (!m || m.type !== 'doorway' || !m.link) continue;
            const nextLabel = doorwayLabelForLink(m.link);
            if (!m.customLabel || m.autoLabel) {
              m.customLabel = nextLabel;
              m.autoLabel = true;
            }
          }
        }
      }
    }

    function ensureAutoBuildDoorway() {
      const modules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
      if (!modules || modules.some((m) => m && m.type === 'doorway')) {
        updateDoorwayLabelsForAll();
        return false;
      }
      if (modules.length < 4) {
        updateDoorwayLabelsForAll();
        return false;
      }
      const insertIndex = modules.length;
      const ok = insertModuleAt(insertIndex, { type: 'doorway', label: 'Doorway' });
      if (!ok) return false;
      const corridorModules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
      const inserted = corridorModules[insertIndex];
      if (inserted) {
        createLinkedDoorway(inserted);
        relayoutCorridor();
        updateDoorwayLabelsForAll();
      }
      return true;
    }

    function createLinkedElevator(fromModule, direction) {
      return createLinkedElevatorAt(state.currentLevel, state.currentCorridor, fromModule, direction);
    }

    function createLinkedElevatorAt(baseLevel, baseCorridor, fromModule, direction) {
      const delta = direction === 'up' ? 1 : -1;
      const level = baseLevel + delta;
      const preferredCorridor = baseCorridor || '';
      const corridorId = getCorridorDef(level, preferredCorridor)
        ? preferredCorridor
        : (preferredCorridor || nextCorridorId(level));
      const newCorridor = ensureCorridor(level, corridorId, {
        name: `${formatDeckName(level)} · Corridor ${corridorId}`,
        modules: []
      });

      const elevatorBack = { type: 'elevator', label: 'Elevator', uid: newUid(), elevator: {} };
      elevatorBack.elevator[direction === 'up' ? 'down' : 'up'] = { level: baseLevel, corridor: baseCorridor };
      newCorridor.modules.push(elevatorBack);

      if (!fromModule.elevator) fromModule.elevator = {};
      fromModule.elevator[direction] = { level, corridor: corridorId };
      markDirty();
      return fromModule.elevator[direction];
    }

    function corridorKey(level, corridor) {
      return `${level}:${corridor}`;
    }

    function parseCorridorKey(key) {
      const [levelStr, corridor] = String(key).split(':');
      return { level: Number(levelStr), corridor };
    }

    function listLinkedCorridors(level, corridor) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return [];
      const links = [];
      for (const m of def.modules) {
        if (m.type === 'doorway' && m.link) {
          links.push(corridorKey(m.link.level, m.link.corridor));
        }
        if (m.type === 'elevator' && m.elevator) {
          if (m.elevator.up) links.push(corridorKey(m.elevator.up.level, m.elevator.up.corridor));
          if (m.elevator.down) links.push(corridorKey(m.elevator.down.level, m.elevator.down.corridor));
        }
      }
      return links;
    }

    function collectCascade(startLevel, startCorridor, excludeKey) {
      const startKey = corridorKey(startLevel, startCorridor);
      const queue = [startKey];
      const toDelete = new Set();
      while (queue.length) {
        const key = queue.shift();
        if (key === excludeKey) continue;
        if (toDelete.has(key)) continue;
        const { level, corridor } = parseCorridorKey(key);
        if (!getCorridorDef(level, corridor)) continue;
        toDelete.add(key);
        const next = listLinkedCorridors(level, corridor);
        for (const n of next) {
          if (!toDelete.has(n) && n !== excludeKey) queue.push(n);
        }
      }
      return toDelete;
    }

    function deleteCorridors(keys) {
      for (const key of keys) {
        const { level, corridor } = parseCorridorKey(key);
        const levelDef = SHIP_LAYOUT.levels[level];
        if (levelDef && levelDef.corridors && levelDef.corridors[corridor]) {
          delete levelDef.corridors[corridor];
        }
      }
    }

    function relocateOrphanedNpcs(keys) {
      const currentKey = corridorKey(state.currentLevel, state.currentCorridor);
      if (!Array.isArray(state.npcs)) return;
      let offset = 0;
      for (const npc of state.npcs) {
        const npcKey = corridorKey(npc.level, npc.corridor);
        if (keys.has(npcKey) && npcKey !== currentKey) {
          npc.level = state.currentLevel;
          npc.corridor = state.currentCorridor;
          npc.x = clamp(state.player.x + 60 + offset, state.walkBounds.minX, state.walkBounds.maxX);
          npc.vx = 0;
          npc.mode = 'idle';
          npc.paused = false;
          npc.wanderTarget = null;
          npc.thinkTimer = 0;
          npc.walkPhase = 0;
          npc.destinationType = null;
          npc.destinationCorridorKey = null;
          offset += 20;
        }
      }
    }

    function removeModuleByUid(uid) {
      const corridorDef = getCorridorDef(state.currentLevel, state.currentCorridor);
      if (!corridorDef || !Array.isArray(corridorDef.modules)) return false;
      if (corridorDef.modules.length <= 1) return false;
      const layoutEntry = modulesLayout.find((m) => m.moduleRef && m.moduleRef.uid === uid);
      const idx = corridorDef.modules.findIndex((m) => m.uid === uid);
      if (idx < 0) return false;
      const mod = corridorDef.modules[idx];
      const removeWidth = layoutEntry ? layoutEntry.width : 0;
      const removeX = layoutEntry ? layoutEntry.x : 0;

      const currentKey = corridorKey(state.currentLevel, state.currentCorridor);
      const cascades = new Set();
      if (mod.type === 'doorway' && mod.link) {
        const keys = collectCascade(mod.link.level, mod.link.corridor, currentKey);
        keys.forEach((k) => cascades.add(k));
      }
      if (mod.type === 'elevator' && mod.elevator) {
        if (mod.elevator.up) {
          const keys = collectCascade(mod.elevator.up.level, mod.elevator.up.corridor, currentKey);
          keys.forEach((k) => cascades.add(k));
        }
        if (mod.elevator.down) {
          const keys = collectCascade(mod.elevator.down.level, mod.elevator.down.corridor, currentKey);
          keys.forEach((k) => cascades.add(k));
        }
      }

      corridorDef.modules.splice(idx, 1);

      if (cascades.size) {
        relocateOrphanedNpcs(cascades);
        deleteCorridors(cascades);
      }

      if (removeWidth > 0) {
        if (state.player.x > removeX) state.player.x -= removeWidth;
        if (Array.isArray(state.npcs)) {
          for (const npc of state.npcs) {
            if (npc.level === state.currentLevel && npc.corridor === state.currentCorridor && npc.x > removeX) {
              npc.x -= removeWidth;
            }
          }
        }
      }

      markDirty();
      relayoutCorridor();
      return true;
    }

    function getCorridorLayout(level, corridor) {
      const modules = getModulesForCorridor(level, corridor);
      const endCaps = [
        { type: 'rear', width: 130 },
        ...modules,
        { type: 'front', width: 130 }
      ];

      const layout = [];
      let x = 0;
      for (const m of endCaps) {
        const def = MODULE_DEFS[m.type] || { width: MODULE_WIDTH };
        const w = def.width * MODULE_SCALE;
        const isWalkable = m.type !== 'rear' && m.type !== 'front';
        layout.push({
          type: m.type,
          x,
          width: w,
          walkable: isWalkable,
          moduleRef: isWalkable ? m : null
        });
        x += w;
      }

      const walkables = layout.find((m) => m.walkable) ? layout.filter((m) => m.walkable) : [];
      let bounds = { minX: 50, maxX: Math.max(50, x - 50) };
      if (walkables.length) {
        bounds = {
          minX: walkables[0].x + 50,
          maxX: walkables[walkables.length - 1].x + walkables[walkables.length - 1].width - 50
        };
      }
      return { layout, bounds, endX: x };
    }

    function corridorHasModuleType(level, corridor, type) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return false;
      return def.modules.some((m) => m.type === type);
    }

    function corridorsWithModuleType(type) {
      const out = [];
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        for (const corridorId of Object.keys(levelDef.corridors || {})) {
          if (corridorHasModuleType(Number(levelKey), corridorId, type)) {
            out.push(corridorKey(Number(levelKey), corridorId));
          }
        }
      }
      return out;
    }

    function listAllCorridors() {
      const out = [];
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        for (const corridorId of Object.keys(levelDef.corridors || {})) {
          out.push(corridorKey(Number(levelKey), corridorId));
        }
      }
      return out;
    }

    function findRoute(startKey, targetKeys) {
      const targets = new Set(targetKeys);
      const queue = [startKey];
      const prev = new Map();
      prev.set(startKey, null);
      while (queue.length) {
        const key = queue.shift();
        if (targets.has(key)) {
          const path = [];
          let cur = key;
          while (cur) {
            path.push(cur);
            cur = prev.get(cur) || null;
          }
          path.reverse();
          return path;
        }
        const { level, corridor } = parseCorridorKey(key);
        const next = listLinkedCorridors(level, corridor);
        for (const n of next) {
          if (!prev.has(n)) {
            prev.set(n, key);
            queue.push(n);
          }
        }
      }
      return null;
    }

    function findLinkModule(level, corridor, targetKey) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return null;
      const { level: tgtLevel, corridor: tgtCorridor } = parseCorridorKey(targetKey);
      for (const m of def.modules) {
        if (m.type === 'doorway' && m.link && m.link.level === tgtLevel && m.link.corridor === tgtCorridor) return { module: m, type: 'doorway' };
        if (m.type === 'elevator' && m.elevator) {
          if (m.elevator.up && m.elevator.up.level === tgtLevel && m.elevator.up.corridor === tgtCorridor) return { module: m, type: 'elevator' };
          if (m.elevator.down && m.elevator.down.level === tgtLevel && m.elevator.down.corridor === tgtCorridor) return { module: m, type: 'elevator' };
        }
      }
      return null;
    }

    function moduleCenterInCorridor(level, corridor, moduleRef) {
      if (!moduleRef) return null;
      const { layout } = getCorridorLayout(level, corridor);
      const entry = layout.find((m) => m.moduleRef && m.moduleRef.uid === moduleRef.uid);
      if (!entry) return null;
      return entry.x + entry.width * 0.5;
    }

    function findModuleByType(level, corridor, type) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return null;
      return def.modules.find((m) => m.type === type) || null;
    }

    function listRoutableModuleTypes() {
      const blocked = new Set(['rear', 'front', 'empty', 'doorway', 'elevator']);
      const types = new Set();
      for (const levelDef of Object.values(SHIP_LAYOUT.levels)) {
        for (const corridorDef of Object.values(levelDef.corridors || {})) {
          for (const m of corridorDef.modules || []) {
            if (!blocked.has(m.type)) types.add(m.type);
          }
        }
      }
      return [...types];
    }

    function buildElevatorItems(options = {}) {
      const station = state.nearStation;
      if (!station || !station.moduleRef) return [];
      
      const moduleRef = station.moduleRef;
      if (!moduleRef.elevator) moduleRef.elevator = {};
      
      const items = [];

      if (moduleRef.elevator.up) {
        items.push({
          type: 'action',
          label: `Go Up (${formatLevelLabel(moduleRef.elevator.up.level)} ${moduleRef.elevator.up.corridor})`,
          action: () => moveToLocation(moduleRef.elevator.up.level, moduleRef.elevator.up.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor }, spawnType: 'elevator' }),
          behavior: 'close',
          actions: []
        });
      }
      
      if (moduleRef.elevator.down) {
        items.push({
          type: 'action',
          label: `Go Down (${formatLevelLabel(moduleRef.elevator.down.level)} ${moduleRef.elevator.down.corridor})`,
          action: () => moveToLocation(moduleRef.elevator.down.level, moduleRef.elevator.down.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor }, spawnType: 'elevator' }),
          behavior: 'close',
          actions: []
        });
      }

      if (moduleRef.elevator.up || moduleRef.elevator.down) {
        items.push({ type: 'divider' });
      }

      if (!moduleRef.elevator.up) {
        items.push({
          type: 'action',
          label: 'Create Floor Above',
          action: () => {
            createLinkedElevator(moduleRef, 'up');
            relayoutCorridor();
          },
          behavior: 'keep-open',
          actions: []
        });
      }
      
      if (!moduleRef.elevator.down) {
        items.push({
          type: 'action',
          label: 'Create Floor Below',
          action: () => {
            createLinkedElevator(moduleRef, 'down');
            relayoutCorridor();
          },
          behavior: 'keep-open',
          actions: []
        });
      }

      return items;
    }

    function buildElevatorActions(station) {
      const moduleRef = station.moduleRef;
      if (!moduleRef) return [];
      if (!moduleRef.elevator) moduleRef.elevator = {};
      const actions = [];
      if (moduleRef.elevator.up) {
        actions.push({
          key: 'elevator.up',
          label: `Go Up (${formatLevelLabel(moduleRef.elevator.up.level)} ${moduleRef.elevator.up.corridor})`,
          action: () => moveToLocation(moduleRef.elevator.up.level, moduleRef.elevator.up.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor }, spawnType: 'elevator' })
        });
      }
      if (moduleRef.elevator.down) {
        actions.push({
          key: 'elevator.down',
          label: `Go Down (${formatLevelLabel(moduleRef.elevator.down.level)} ${moduleRef.elevator.down.corridor})`,
          action: () => moveToLocation(moduleRef.elevator.down.level, moduleRef.elevator.down.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor }, spawnType: 'elevator' })
        });
      }

      if (!moduleRef.elevator.up) {
        actions.push({
          key: 'elevator.createUp',
          label: 'Create Floor Above',
          action: () => {
            createLinkedElevator(moduleRef, 'up');
            showMessage('ELEVATOR', 'Created floor above.');
            relayoutCorridor();
          }
        });
      }
      if (!moduleRef.elevator.down) {
        actions.push({
          key: 'elevator.createDown',
          label: 'Create Floor Below',
          action: () => {
            createLinkedElevator(moduleRef, 'down');
            showMessage('ELEVATOR', 'Created floor below.');
            relayoutCorridor();
          }
        });
      }

      return actions;
    }

    function getModulesForCorridor(level, corridor) {
      const corridorDef = getCorridorDef(level, corridor);
      if (!corridorDef) return [];
      ensureCorridorModules(level, corridor);
      return corridorDef.modules || [];
    }

    function getConnectionsForCorridor(level, corridor) {
      const corridorDef = getCorridorDef(level, corridor);
      if (!corridorDef) return {};
      return corridorDef.connections || {};
    }

    function moveToLocation(level, corridor, { spawnFrom = null, spawnType = 'doorway' } = {}) {
      if (!getCorridorDef(level, corridor)) return false;
      state.currentLevel = level;
      state.currentCorridor = corridor;
      if (spawnFrom) {
        state.pendingSpawn = { linkFrom: spawnFrom, type: spawnType };
      } else {
        state.pendingSpawn = null;
      }
      state.player.x = 400;
      state.player.vx = 0;
      state.sim.snap = true;
      relayoutCorridor();
      return true;
    }

    function insertModuleAt(index, module) {
      const corridorDef = getCorridorDef(state.currentLevel, state.currentCorridor);
      if (!corridorDef) return false;
      ensureCorridorModules(state.currentLevel, state.currentCorridor);
      const m = { ...module };
      if (!m.uid) m.uid = newUid();
      corridorDef.modules.splice(index, 0, m);
      markDirty();
      relayoutCorridor();
      return true;
    }

    function openInsertModulePanel(insertIndex) {
      const options = Object.keys(MODULE_DEFS).filter((k) => {
        if (['rear', 'front'].includes(k)) return false;
        if (['doorway', 'elevator', 'empty'].includes(k)) return true;
        return isModuleUnlocked(k);
      });
      
      const buttons = options.map((type) => {
        const def = MODULE_DEFS[type];
        const label = def && def.label ? def.label : type;
        const unlocked = isModuleUnlocked(type) || ['doorway', 'elevator', 'empty'].includes(type);
        return {
          label: unlocked ? label : `${label} (Locked)`,
          action: () => {
            const ok = insertModuleAt(insertIndex, { type, label });
            if (!ok) return;
            const corridorModules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
            const inserted = corridorModules[insertIndex];
            if (type === 'doorway') {
              createLinkedDoorway(inserted);
            }
            if (type === 'elevator') {
              if (!inserted.elevator) inserted.elevator = {};
            }
            relayoutCorridor();
            closePanel();
          }
        };
      });

      openPanel('ADD MODULE', `Insert module at position ${insertIndex + 1}:`, buttons, { includeCancel: true });
    }

    // ============================================================================
    // Layout & Rendering (Enhanced with visual richness from original)
    // ============================================================================

    let modulesLayout = [];
    let stations = [];
    let corridorEndX = 800;

    function moduleDisplayLabel(moduleRef, def) {
      if (moduleRef && moduleRef.customLabel) return moduleRef.customLabel;
      if (moduleRef && moduleRef.label) return moduleRef.label;
      if (def && def.label) return def.label;
      return moduleRef && moduleRef.type ? moduleRef.type : 'MODULE';
    }

    function relayoutCorridor() {
      modulesLayout = [];
      stations = [];

      const modules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
      const endCaps = [
        { type: 'rear', width: 130 },
        ...modules,
        { type: 'front', width: 130 }
      ];

      let x = 0;
      let corridorIndex = 0;
      for (const m of endCaps) {
        const def = MODULE_DEFS[m.type] || { width: 520 };
        const w = def.width * MODULE_SCALE;
        const isWalkable = m.type !== 'rear' && m.type !== 'front';
        modulesLayout.push({
          type: m.type,
          label: moduleDisplayLabel(m, def),
          x,
          width: w,
          walkable: isWalkable,
          corridorIndex: isWalkable ? corridorIndex : -1,
          moduleRef: isWalkable ? m : null
        });
        if (isWalkable) corridorIndex++;
        x += w;
      }

      corridorEndX = x;

      const walkables = modulesLayout.filter((m) => m.walkable);
      if (walkables.length) {
        const first = walkables[0];
        const last = walkables[walkables.length - 1];
        state.walkBounds = {
          minX: first.x + 50,
          maxX: last.x + last.width - 50
        };
      } else {
        state.walkBounds = { minX: 50, maxX: Math.max(50, corridorEndX - 50) };
      }

      // Build stations
      const stationInset = BULKHEAD_W;
      for (const module of modulesLayout) {
        if (module.type === 'rear' || module.type === 'front') continue;
        const def = MODULE_DEFS[module.type];
        if (!def || !def.station) continue;
        const st = def.station;
        const interior = moduleInterior(module);
        const interactX = interior.start + interior.width * 0.5;
        stations.push({
          id: `${module.type}::${module.label}::${module.moduleRef ? module.moduleRef.uid : ''}`,
          type: module.type,
          label: module.label,
          moduleRef: module.moduleRef,
          x: interactX - st.width / 2,
          y: st.y,
          width: st.width,
          height: st.height,
          interactX,
          getActions: (station) => {
            const def = MODULE_DEFS[module.type];
            return def && def.actions ? def.actions(station) : [];
          }
        });
      }

      if (state.pendingSpawn && state.pendingSpawn.linkFrom) {
        const from = state.pendingSpawn.linkFrom;
        if (state.pendingSpawn.type === 'elevator') {
          const elevModule = modulesLayout.find((m) => m.type === 'elevator' && m.moduleRef && m.moduleRef.elevator && ((m.moduleRef.elevator.up && m.moduleRef.elevator.up.level === from.level && m.moduleRef.elevator.up.corridor === from.corridor) || (m.moduleRef.elevator.down && m.moduleRef.elevator.down.level === from.level && m.moduleRef.elevator.down.corridor === from.corridor)));
          if (elevModule) {
            state.player.x = elevModule.x + elevModule.width * 0.5;
          }
        } else {
          const doorModule = modulesLayout.find((m) => m.type === 'doorway' && m.moduleRef && m.moduleRef.link && m.moduleRef.link.level === from.level && m.moduleRef.link.corridor === from.corridor);
          if (doorModule) {
            state.player.x = doorModule.x + doorModule.width * 0.5;
          }
        }
        state.pendingSpawn = null;
      }

      updateLocationHUD();
      renderCorridor();
    }

    function renderCorridor() {
      const svg = document.getElementById('gameCanvas');
      svg.innerHTML = '';

      const svgNS = 'http://www.w3.org/2000/svg';

      // Background
      const bg = document.createElementNS(svgNS, 'rect');
      bg.setAttribute('width', 800);
      bg.setAttribute('height', 600);
      bg.setAttribute('fill', '#0a0e27');
      svg.appendChild(bg);

      const shipGroup = document.createElementNS(svgNS, 'g');
      shipGroup.id = 'shipGroup';
      svg.appendChild(shipGroup);

      const rearCap = modulesLayout.find((m) => m.type === 'rear');
      const noseCap = modulesLayout.find((m) => m.type === 'front');
      const walkables = modulesLayout.filter((m) => m.walkable);
      const firstWalkable = walkables[0] || null;
      const lastWalkable = walkables[walkables.length - 1] || null;

      const tubeStartX = firstWalkable ? firstWalkable.x : (rearCap ? (rearCap.x + rearCap.width) : 0);
      const tubeEndX = noseCap ? (noseCap.x + 40) : (lastWalkable ? (lastWalkable.x + lastWalkable.width) : corridorEndX);

      // Render walls with windows
      const wallFillLit = 'rgb(56, 46, 28)';
      const wallFillDark = 'rgb(14, 22, 62)';
      const wallFill = state.lightsOn ? wallFillLit : wallFillDark;
      const wallFrame = state.lightsOn ? 'rgba(255, 220, 160, 0.35)' : 'rgba(120, 160, 255, 0.25)';

      for (const module of modulesLayout) {
        if (!module.walkable) continue;
        const wallStartX = module.x;
        const wallEndX = Math.min(module.x + module.width, tubeEndX);
        const wallW = wallEndX - wallStartX;
        if (wallW < 160) continue;

        const wallY = 80;
        const wallH = 440;
        const clampNum = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

        const interior = moduleInterior(module);
        const innerStartX = Math.max(wallStartX, interior.start);
        const innerEndX = Math.min(wallEndX, interior.end);
        const innerW = Math.max(0, innerEndX - innerStartX);

        let winCount = innerW >= 240 ? 2 : 1;
        let gap = winCount > 1 ? clampNum(innerW * 0.08, 16, 40) : 0;
        let sidePad = clampNum(innerW * 0.10, 18, 46);
        let winW = (innerW - sidePad * 2 - gap * (winCount - 1)) / winCount;

        if (winCount > 1 && winW < 70) {
          winCount = 1;
          gap = 0;
          winW = wallW - sidePad * 2;
        }

        winW = clampNum(winW, 60, 140);
        const usedW = (winCount * winW) + (gap * (winCount - 1));
        const startOffset = (innerW - usedW) / 2;
        const winXs = Array.from({ length: winCount }, (_, i) => innerStartX + startOffset + i * (winW + gap));
        const winH = 170;
        const winY = 160;
        const winRX = 14;

        const maskId = `wallmask-${module.moduleRef && module.moduleRef.uid ? module.moduleRef.uid : module.label}`;
        const mask = document.createElementNS(svgNS, 'mask');
        mask.id = maskId;
        mask.setAttribute('maskUnits', 'userSpaceOnUse');
        mask.setAttribute('x', wallStartX);
        mask.setAttribute('y', wallY);
        mask.setAttribute('width', wallW);
        mask.setAttribute('height', wallH);

        const maskBase = document.createElementNS(svgNS, 'rect');
        maskBase.setAttribute('x', wallStartX);
        maskBase.setAttribute('y', wallY);
        maskBase.setAttribute('width', wallW);
        maskBase.setAttribute('height', wallH);
        maskBase.setAttribute('fill', 'white');
        mask.appendChild(maskBase);

        for (const wx of winXs) {
          const hole = document.createElementNS(svgNS, 'rect');
          hole.setAttribute('x', wx);
          hole.setAttribute('y', winY);
          hole.setAttribute('width', winW);
          hole.setAttribute('height', winH);
          hole.setAttribute('rx', winRX);
          hole.setAttribute('ry', winRX);
          hole.setAttribute('fill', 'black');
          mask.appendChild(hole);
        }

        shipGroup.appendChild(mask);

        const wall = document.createElementNS(svgNS, 'rect');
        wall.setAttribute('x', wallStartX);
        wall.setAttribute('y', wallY);
        wall.setAttribute('width', wallW);
        wall.setAttribute('height', wallH);
        wall.setAttribute('fill', wallFill);
        wall.setAttribute('mask', `url(#${maskId})`);
        shipGroup.appendChild(wall);

        for (const wx of winXs) {
          const frame = document.createElementNS(svgNS, 'rect');
          frame.setAttribute('x', wx);
          frame.setAttribute('y', winY);
          frame.setAttribute('width', winW);
          frame.setAttribute('height', winH);
          frame.setAttribute('rx', winRX);
          frame.setAttribute('ry', winRX);
          frame.setAttribute('fill', 'none');
          frame.setAttribute('stroke', wallFrame);
          frame.setAttribute('stroke-width', 3);
          shipGroup.appendChild(frame);
        }
      }

      // Fill the nose transition wall to remove gap between last module and nose cone.
      if (lastWalkable && noseCap) {
        const gapStart = lastWalkable.x + lastWalkable.width;
        const gapEnd = Math.max(gapStart, tubeEndX);
        const gapW = gapEnd - gapStart;
        if (gapW > 0.5) {
          const noseWall = document.createElementNS(svgNS, 'rect');
          noseWall.setAttribute('x', gapStart);
          noseWall.setAttribute('y', 80);
          noseWall.setAttribute('width', gapW);
          noseWall.setAttribute('height', 440);
          noseWall.setAttribute('fill', wallFill);
          shipGroup.appendChild(noseWall);
        }
      }

      // Floor
      const floor = document.createElementNS(svgNS, 'rect');
      floor.setAttribute('x', tubeStartX);
      floor.setAttribute('y', 520);
      floor.setAttribute('width', Math.max(0, tubeEndX - tubeStartX));
      floor.setAttribute('height', 80);
      floor.setAttribute('fill', '#3d4466');
      shipGroup.appendChild(floor);

      // Floor panels
      for (let x = tubeStartX; x < tubeEndX; x += 100) {
        const panelW = Math.min(95, tubeEndX - x);
        if (panelW <= 0) break;
        const panel = document.createElementNS(svgNS, 'rect');
        panel.setAttribute('x', x);
        panel.setAttribute('y', 520);
        panel.setAttribute('width', panelW);
        panel.setAttribute('height', 80);
        panel.setAttribute('fill', 'none');
        panel.setAttribute('stroke', '#2a2e4a');
        panel.setAttribute('stroke-width', 2);
        shipGroup.appendChild(panel);
      }

      // Ceiling
      const ceiling = document.createElementNS(svgNS, 'rect');
      ceiling.setAttribute('x', tubeStartX);
      ceiling.setAttribute('y', 0);
      ceiling.setAttribute('width', Math.max(0, tubeEndX - tubeStartX));
      ceiling.setAttribute('height', 80);
      ceiling.setAttribute('fill', '#3d4466');
      shipGroup.appendChild(ceiling);

      // Ceiling lights (two per module)
      const ceilingLightFill = 'rgb(255, 214, 130)';
      const lightInset = BULKHEAD_W;
      for (const module of modulesLayout) {
        if (!module.walkable) continue;
        const interior = moduleInterior(module);
        const interiorW = Math.max(0, interior.width);
        const baseX = interior.start;
        const offsets = [interiorW * 0.33, interiorW * 0.67];
        for (const off of offsets) {
          const x = baseX + off;
          const light = document.createElementNS(svgNS, 'rect');
          light.setAttribute('x', x - 20);
          light.setAttribute('y', 70);
          light.setAttribute('width', 40);
          light.setAttribute('height', 10);
          light.setAttribute('fill', ceilingLightFill);
          light.setAttribute('opacity', 0.9);
          shipGroup.appendChild(light);
        }
      }

      const wrapLabelLines = (label, maxChars) => {
        const words = String(label || '').split(/\s+/).filter(Boolean);
        if (!words.length) return [''];
        const lines = [];
        let line = '';
        for (const word of words) {
          const next = line ? `${line} ${word}` : word;
          if (next.length <= maxChars || !line) {
            line = next;
          } else {
            lines.push(line);
            line = word;
          }
        }
        if (line) lines.push(line);
        return lines;
      };

      // Module labels
      for (const module of modulesLayout) {
        const labelText = String(module.label || '').toUpperCase();
        const maxChars = Math.max(8, Math.floor(module.width / 14));
        const lines = wrapLabelLines(labelText, maxChars);
        const roomLabel = document.createElementNS(svgNS, 'text');
        roomLabel.setAttribute('x', module.x + module.width / 2);
        roomLabel.setAttribute('y', 118);
        roomLabel.setAttribute('text-anchor', 'middle');
        roomLabel.setAttribute('fill', state.lightsOn ? 'rgb(140, 200, 255)' : 'rgba(120, 170, 220, 0.85)');
        roomLabel.setAttribute('opacity', state.lightsOn ? 0.9 : 0.7);
        roomLabel.setAttribute('font-size', '18');
        roomLabel.setAttribute('font-weight', '600');
        roomLabel.setAttribute('letter-spacing', '0.5');
        roomLabel.setAttribute('pointer-events', 'none');
        lines.forEach((line, idx) => {
          const tspan = document.createElementNS(svgNS, 'tspan');
          tspan.setAttribute('x', module.x + module.width / 2);
          tspan.setAttribute('dy', idx === 0 ? '0' : '18');
          tspan.textContent = line;
          roomLabel.appendChild(tspan);
        });
        shipGroup.appendChild(roomLabel);
      }

      // Remove buttons on module ceiling
      for (const module of modulesLayout) {
        if (!module.walkable || !module.moduleRef) continue;
        const interior = moduleInterior(module);
        const cx = interior.start + interior.width * 0.5;
        const cy = 36;
        const minus = document.createElementNS(svgNS, 'g');
        const ring = document.createElementNS(svgNS, 'circle');
        ring.setAttribute('cx', cx);
        ring.setAttribute('cy', cy);
        ring.setAttribute('r', 11);
        ring.setAttribute('fill', C.panel);
        ring.setAttribute('stroke', C.warning);
        ring.setAttribute('stroke-width', 2);

        const bar = document.createElementNS(svgNS, 'rect');
        bar.setAttribute('x', cx - 6);
        bar.setAttribute('y', cy - 2);
        bar.setAttribute('width', 12);
        bar.setAttribute('height', 4);
        bar.setAttribute('fill', C.warning);

        minus.appendChild(ring);
        minus.appendChild(bar);
        minus.style.cursor = 'pointer';
        minus.setAttribute('data-interactive', 'true');
        minus.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          e.preventDefault();
          removeModuleByUid(module.moduleRef.uid);
        });
        minus.addEventListener('click', (e) => {
          e.stopPropagation();
          removeModuleByUid(module.moduleRef.uid);
        });
        shipGroup.appendChild(minus);
      }

      // Render stations
      for (const station of stations) {
        renderStation(station, shipGroup, svgNS);
      }

      // Bulkheads and doors between modules
      for (let i = 0; i < modulesLayout.length - 1; i++) {
        const left = modulesLayout[i];
        const right = modulesLayout[i + 1];
        const x = left.x + left.width;
        const hasDoor = left.walkable && right.walkable;

        const wall = document.createElementNS(svgNS, 'rect');
        wall.setAttribute('x', x);
        wall.setAttribute('y', 80);
        wall.setAttribute('width', 20);
        wall.setAttribute('height', 440);
        wall.setAttribute('fill', '#2a2e4a');
        shipGroup.appendChild(wall);

        if (hasDoor) {
          const door = document.createElementNS(svgNS, 'rect');
          door.setAttribute('x', x + 2);
          door.setAttribute('y', 380);
          door.setAttribute('width', 16);
          door.setAttribute('height', 140);
          door.setAttribute('fill', '#3d4466');
          door.setAttribute('stroke', '#00d4ff');
          door.setAttribute('stroke-width', 2);
          shipGroup.appendChild(door);
        }

        const insertIndex = left.walkable && right.walkable
          ? right.corridorIndex
          : left.walkable && !right.walkable
            ? left.corridorIndex + 1
            : !left.walkable && right.walkable
              ? right.corridorIndex
              : null;

        if (insertIndex !== null) {
          const plus = document.createElementNS(svgNS, 'g');
          const cx = x + 10;
          const cy = 300;
          const ring = document.createElementNS(svgNS, 'circle');
          ring.setAttribute('cx', cx);
          ring.setAttribute('cy', cy);
          ring.setAttribute('r', 12);
          ring.setAttribute('fill', C.panel);
          ring.setAttribute('stroke', C.accent);
          ring.setAttribute('stroke-width', 2);

          const txt = document.createElementNS(svgNS, 'text');
          txt.setAttribute('x', cx);
          txt.setAttribute('y', cy + 5);
          txt.setAttribute('text-anchor', 'middle');
          txt.setAttribute('font-size', '16');
          txt.setAttribute('fill', C.accent);
          txt.textContent = '+';

          plus.appendChild(ring);
          plus.appendChild(txt);
          plus.style.cursor = 'pointer';
          plus.setAttribute('data-interactive', 'true');
          plus.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            e.preventDefault();
            state.ui.insertModuleIndex = insertIndex;
            openMenu('insertModule');
          });
          plus.addEventListener('click', (e) => {
            e.stopPropagation();
            state.ui.insertModuleIndex = insertIndex;
            openMenu('insertModule');
          });
          shipGroup.appendChild(plus);
        }
      }

      // Rear rockets visual
      if (rearCap) {
        const mountX = rearCap.x + rearCap.width - 52;
        const mount = document.createElementNS(svgNS, 'rect');
        mount.setAttribute('x', mountX);
        mount.setAttribute('y', 90);
        mount.setAttribute('width', 44);
        mount.setAttribute('height', 420);
        mount.setAttribute('rx', 10);
        mount.setAttribute('ry', 10);
        mount.setAttribute('fill', '#2a2e4a');
        mount.setAttribute('stroke', '#00d4ff');
        mount.setAttribute('stroke-width', 2);
        mount.setAttribute('opacity', 0.95);
        shipGroup.appendChild(mount);

        for (let i = 0; i < 6; i++) {
          const bolt = document.createElementNS(svgNS, 'circle');
          bolt.setAttribute('cx', (mountX + 10 + (i % 2) * 24).toFixed(2));
          bolt.setAttribute('cy', (120 + Math.floor(i / 2) * 130).toFixed(2));
          bolt.setAttribute('r', '3.2');
          bolt.setAttribute('fill', '#3d4466');
          bolt.setAttribute('opacity', 0.95);
          shipGroup.appendChild(bolt);
        }

        const thrusterX = rearCap.x + 22;
        for (let i = 0; i < 3; i++) {
          const cy = 160 + i * 110 + 35;

          const strut = document.createElementNS(svgNS, 'path');
          strut.setAttribute('d', `M ${mountX} ${cy} L ${thrusterX + 40} ${cy - 18} L ${thrusterX + 40} ${cy + 18} Z`);
          strut.setAttribute('fill', '#2a2e4a');
          strut.setAttribute('stroke', '#00d4ff');
          strut.setAttribute('stroke-width', 2);
          strut.setAttribute('opacity', 0.9);
          shipGroup.appendChild(strut);

          const nozzle = document.createElementNS(svgNS, 'rect');
          nozzle.setAttribute('x', thrusterX);
          nozzle.setAttribute('y', 160 + i * 110);
          nozzle.setAttribute('width', 40);
          nozzle.setAttribute('height', 70);
          nozzle.setAttribute('fill', '#3d4466');
          nozzle.setAttribute('stroke', '#ff6b35');
          nozzle.setAttribute('stroke-width', 2);
          shipGroup.appendChild(nozzle);
        }
      }

      // Front nose cone
      if (noseCap) {
        const tipX = noseCap.x + noseCap.width - 10;
        const cone = document.createElementNS(svgNS, 'polygon');
        cone.setAttribute('points', `${noseCap.x + 40},80 ${tipX},220 ${tipX},380 ${noseCap.x + 40},520`);
        cone.setAttribute('fill', '#3d4466');
        cone.setAttribute('stroke', '#00d4ff');
        cone.setAttribute('stroke-width', 2);
        cone.setAttribute('opacity', 0.9);
        shipGroup.appendChild(cone);

        const window = document.createElementNS(svgNS, 'ellipse');
        window.setAttribute('cx', noseCap.x + noseCap.width * 0.62);
        window.setAttribute('cy', 260);
        window.setAttribute('rx', 30);
        window.setAttribute('ry', 45);
        window.setAttribute('fill', 'rgba(0, 100, 200, 0.25)');
        window.setAttribute('stroke', '#00d4ff');
        window.setAttribute('stroke-width', 2);
        shipGroup.appendChild(window);
      }

      // Render player
      renderPlayer(shipGroup, svgNS);

      // Render NPCs (only in current corridor)
      for (const npc of state.npcs) {
        if (npc.level === state.currentLevel && npc.corridor === state.currentCorridor) {
          renderNPC(npc, shipGroup, svgNS);
        }
      }

      updateCamera();
    }

    function renderStation(station, parent, svgNS) {
      const group = document.createElementNS(svgNS, 'g');

      const x = station.x;
      const y = station.y;
      const w = station.width;
      const h = station.height;
      const pad = Math.max(8, Math.min(12, Math.floor(Math.min(w, h) * 0.10)));

      const mk = (name, attrs = {}) => {
        const el = document.createElementNS(svgNS, name);
        for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
        return el;
      };

      const clipId = `station-clip-${station.id}`;
      const defs = mk('defs');
      const clip = mk('clipPath', { id: clipId });
      clip.appendChild(mk('rect', { x, y, width: w, height: h, rx: 10, ry: 10 }));
      defs.appendChild(clip);
      group.appendChild(defs);

      // Shadow + console frame
      group.appendChild(mk('rect', { x: x + 3, y: y + 4, width: w, height: h, rx: 10, ry: 10, fill: 'rgba(0,0,0,0.28)' }));
      group.appendChild(mk('rect', { x, y, width: w, height: h, rx: 10, ry: 10, fill: C.panel, stroke: C.accent, 'stroke-width': 2 }));

      // Inner bezel
      const innerX = x + pad;
      const innerY = y + pad;
      const innerW = w - pad * 2;
      const innerH = h - pad * 2;
      group.appendChild(mk('rect', { x: innerX, y: innerY, width: innerW, height: innerH, rx: 8, ry: 8, fill: C.hull, opacity: 0.55 }));

      // Bottom keys/controls strip
      const keysH = Math.max(18, Math.min(28, Math.floor(innerH * 0.24)));
      const keysY = innerY + innerH - keysH;
      group.appendChild(mk('rect', { x: innerX + 3, y: keysY, width: innerW - 6, height: keysH - 3, rx: 6, ry: 6, fill: C.wall, opacity: 0.9 }));

      const keyCount = Math.max(4, Math.min(7, Math.floor(innerW / 26)));
      for (let i = 0; i < keyCount; i++) {
        const kw = Math.max(10, Math.floor((innerW - 18) / keyCount) - 4);
        const kx = innerX + 10 + i * (kw + 6);
        group.appendChild(mk('rect', { x: kx, y: keysY + 7, width: kw, height: 8, rx: 2, ry: 2, fill: C.panel, opacity: 0.95 }));
      }

      // Status light
      const statusOk = (() => {
        if (station.type === 'power') return !(state.incidents && state.incidents.powerTrip);
        if (station.type === 'life') return !(state.incidents && state.incidents.o2Leak);
        if (station.type === 'engine') return !(state.incidents && state.incidents.fire);
        if (station.type === 'airlock') return !(state.incidents && state.incidents.breach);
        return true;
      })();
      group.appendChild(mk('circle', {
        cx: (x + 12).toFixed(2),
        cy: (y + 12).toFixed(2),
        r: 5,
        fill: statusOk ? C.success : 'rgb(255, 85, 85)',
        opacity: state.lightsOn ? 0.95 : 0.55
      }));

      // Draw station art clipped to the console.
      const art = mk('g', { 'clip-path': `url(#${clipId})` });
      group.appendChild(art);

      const screenX = innerX + 10;
      const screenY = innerY + 10;
      const screenW = innerW - 20;
      const screenH = Math.max(10, keysY - screenY - 10);

      const addGauge = ({ gx, gy, gw, gh, pct, color }) => {
        const p = clamp(safeNumber(pct, 0), 0, 1);
        art.appendChild(mk('rect', { x: gx, y: gy, width: gw, height: gh, rx: 3, ry: 3, fill: 'rgba(0,0,0,0.35)' }));
        art.appendChild(mk('rect', { x: gx + 1, y: gy + 1, width: Math.max(0, (gw - 2) * p), height: Math.max(0, gh - 2), rx: 2, ry: 2, fill: color, opacity: state.lightsOn ? 0.9 : 0.55 }));
      };

      // Shared screen backing
      art.appendChild(mk('rect', { x: screenX, y: screenY, width: screenW, height: screenH, rx: 8, ry: 8, fill: 'rgba(20, 30, 60, 0.55)', stroke: 'rgba(255,255,255,0.18)', 'stroke-width': 1 }));

      if (station.type === 'cargo') {
        const rackY = screenY + 10;
        const rackH = screenH - 20;
        art.appendChild(mk('rect', { x: screenX + 6, y: rackY, width: screenW - 12, height: rackH, rx: 6, ry: 6, fill: 'rgba(0,0,0,0.18)', stroke: 'rgba(255,255,255,0.12)', 'stroke-width': 1 }));
        const boxes = 3;
        for (let i = 0; i < boxes; i++) {
          const bx = screenX + 16 + i * ((screenW - 40) / boxes);
          const bw = Math.max(16, Math.min(28, (screenW - 60) / boxes));
          art.appendChild(mk('rect', { x: bx, y: rackY + 16, width: bw, height: rackH - 32, rx: 4, ry: 4, fill: C.warning, opacity: 0.85, stroke: 'rgba(0,0,0,0.35)', 'stroke-width': 1 }));
          art.appendChild(mk('path', { d: `M ${bx + 4} ${rackY + 24} L ${bx + bw - 4} ${rackY + 24} M ${bx + 4} ${rackY + 34} L ${bx + bw - 4} ${rackY + 34}`,
            stroke: 'rgba(0,0,0,0.35)', 'stroke-width': 2, opacity: 0.6 }));
        }
      } else if (station.type === 'power') {
        const cx = screenX + screenW * 0.38;
        const cy = screenY + screenH * 0.52;
        const r0 = Math.min(22, Math.max(16, Math.min(screenW, screenH) * 0.22));
        art.appendChild(mk('circle', { cx, cy, r: r0, fill: C.accent, opacity: state.lightsOn ? 0.65 : 0.35 }));
        for (let i = 1; i <= 3; i++) {
          art.appendChild(mk('circle', { cx, cy, r: r0 + i * 10, fill: 'none', stroke: C.accent, 'stroke-width': 1, opacity: 0.22 }));
        }
        const powerPct = clamp(state.power / 150, 0, 1);
        addGauge({ gx: screenX + screenW * 0.58, gy: screenY + 18, gw: screenW * 0.34, gh: 10, pct: powerPct, color: C.accent });
      } else if (station.type === 'engine') {
        const ventY = screenY + 14;
        for (let i = 0; i < 5; i++) {
          const vx = screenX + 12 + i * ((screenW - 24) / 5);
          art.appendChild(mk('rect', { x: vx, y: ventY, width: 8, height: screenH - 40, rx: 3, ry: 3, fill: 'rgba(255,255,255,0.10)' }));
        }
        addGauge({ gx: screenX + 12, gy: screenY + screenH - 20, gw: screenW - 24, gh: 9, pct: 0.65, color: C.warning });
      } else if (station.type === 'cockpit') {
        art.appendChild(mk('rect', { x: screenX + 10, y: screenY + 10, width: screenW - 20, height: screenH * 0.52, rx: 7, ry: 7, fill: 'rgba(0, 110, 220, 0.22)', stroke: 'rgba(180,220,255,0.25)', 'stroke-width': 1 }));
        for (let i = 0; i < 6; i++) {
          const gy = screenY + 18 + i * 10;
          art.appendChild(mk('path', { d: `M ${screenX + 16} ${gy} L ${screenX + screenW - 16} ${gy}`,
            stroke: 'rgba(180,220,255,0.16)', 'stroke-width': 1 }));
        }
      } else if (station.type === 'fabricator') {
        art.appendChild(mk('rect', { x: screenX + 10, y: screenY + 10, width: screenW - 20, height: screenH - 20, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(255,255,255,0.15)', 'stroke-width': 1 }));
        const bedY = screenY + screenH - 34;
        art.appendChild(mk('rect', { x: screenX + 18, y: bedY, width: screenW - 36, height: 14, rx: 4, ry: 4, fill: C.panel, opacity: 0.95 }));
        art.appendChild(mk('rect', { x: screenX + 18, y: screenY + 20, width: screenW - 36, height: 8, rx: 4, ry: 4, fill: C.wall, opacity: 0.9 }));
        const nx = screenX + screenW * 0.52;
        art.appendChild(mk('polygon', { points: `${nx - 7},${screenY + 30} ${nx + 7},${screenY + 30} ${nx + 3},${screenY + 48} ${nx - 3},${screenY + 48}`,
          fill: C.accent, opacity: state.lightsOn ? 0.85 : 0.45 }));
        art.appendChild(mk('rect', { x: nx - 12, y: bedY - 8, width: 24, height: 10, rx: 2, ry: 2, fill: C.success, opacity: 0.75 }));
      } else if (station.type === 'life') {
        const cx = screenX + screenW * 0.32;
        const cy = screenY + screenH * 0.52;
        const r = Math.min(22, Math.max(16, Math.min(screenW, screenH) * 0.20));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 1 }));
        for (let i = 0; i < 4; i++) {
          const a = (i * Math.PI) / 2;
          const x2 = cx + Math.cos(a + 0.55) * r * 0.95;
          const y2 = cy + Math.sin(a + 0.55) * r * 0.95;
          art.appendChild(mk('path', { d: `M ${cx} ${cy} L ${x2} ${y2}`,
            stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 3, 'stroke-linecap': 'round', opacity: 0.75 }));
        }
        addGauge({ gx: screenX + screenW * 0.55, gy: screenY + 24, gw: screenW * 0.36, gh: 10, pct: clamp(state.oxygen / 100, 0, 1), color: C.success });
      } else if (station.type === 'hydro') {
        const glow = 'rgba(60, 255, 140, 0.28)';
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 16, width: screenW - 24, height: 10, rx: 5, ry: 5, fill: glow, opacity: 0.9 }));
        const bedY = screenY + screenH - 34;
        art.appendChild(mk('rect', { x: screenX + 14, y: bedY, width: screenW - 28, height: 16, rx: 6, ry: 6, fill: 'rgba(80,50,20,0.55)', stroke: 'rgba(255,255,255,0.12)', 'stroke-width': 1 }));
      } else if (station.type === 'medbay') {
        const cx = screenX + screenW * 0.30;
        const cy = screenY + screenH * 0.50;
        art.appendChild(mk('rect', { x: cx - 18, y: cy - 6, width: 36, height: 12, rx: 3, ry: 3, fill: C.success, opacity: 0.65 }));
        art.appendChild(mk('rect', { x: cx - 6, y: cy - 18, width: 12, height: 36, rx: 3, ry: 3, fill: C.success, opacity: 0.65 }));
      } else if (station.type === 'comms') {
        const bx = screenX + screenW * 0.32;
        const by = screenY + screenH * 0.64;
        art.appendChild(mk('path', { d: `M ${bx - 18} ${by} Q ${bx} ${by - 26} ${bx + 18} ${by} Q ${bx} ${by + 10} ${bx - 18} ${by} Z`,
          fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 1 }));
      } else if (station.type === 'sensors') {
        const cx = screenX + screenW * 0.40;
        const cy = screenY + screenH * 0.54;
        const r = Math.min(26, Math.max(18, Math.min(screenW, screenH) * 0.24));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(0,0,0,0.25)', stroke: 'rgba(180,220,255,0.28)', 'stroke-width': 1 }));
      } else if (station.type === 'shields') {
        const glow = 'rgba(0, 160, 255, 0.18)';
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 12, width: screenW - 24, height: screenH - 24, rx: 8, ry: 8, fill: glow, opacity: 0.9 }));
      } else if (station.type === 'refinery') {
        const fx = screenX + screenW * 0.28;
        const fy = screenY + screenH * 0.50;
        art.appendChild(mk('rect', { x: fx - 20, y: fy - 22, width: 40, height: 44, rx: 6, ry: 6, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(255,255,255,0.18)', 'stroke-width': 1 }));
        art.appendChild(mk('rect', { x: fx - 10, y: fy - 10, width: 20, height: 20, rx: 4, ry: 4, fill: C.warning, opacity: 0.55 }));
        const ore = invGet('ore');
        const ing = invGet('ingot');
        addGauge({ gx: screenX + screenW * 0.52, gy: screenY + 18, gw: screenW * 0.38, gh: 10, pct: clamp(ore / 10, 0, 1), color: C.warning });
        addGauge({ gx: screenX + screenW * 0.52, gy: screenY + 32, gw: screenW * 0.38, gh: 10, pct: clamp(ing / 10, 0, 1), color: C.success });
      } else if (station.type === 'drones') {
        art.appendChild(mk('rect', { x: screenX + 14, y: screenY + 18, width: screenW - 28, height: screenH - 36, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(255,255,255,0.14)', 'stroke-width': 1 }));
      } else if (station.type === 'airlock') {
        const cx = screenX + screenW * 0.50;
        const cy = screenY + screenH * 0.54;
        const r = Math.min(24, Math.max(18, Math.min(screenW, screenH) * 0.22));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 2 }));
      } else if (station.type === 'workshop') {
        const tx = screenX + screenW * 0.32;
        const ty = screenY + screenH * 0.52;
        art.appendChild(mk('path', { d: `M ${tx - 10} ${ty - 14} L ${tx + 8} ${ty + 4} L ${tx + 4} ${ty + 8} L ${tx - 14} ${ty - 10} Z`,
          fill: 'rgba(180,220,255,0.24)', opacity: 0.9 }));
      } else if (station.type === 'quarters') {
        const bx = screenX + 16;
        const by = screenY + 18;
        const bw = Math.max(28, Math.min(44, (screenW - 40) / 2));
        const bh = Math.max(16, Math.floor((screenH - 34) / 2));
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < 2; c++) {
            const xx = bx + c * (bw + 10);
            const yy = by + r * (bh + 10);
            art.appendChild(mk('rect', { x: xx, y: yy, width: bw, height: bh, rx: 6, ry: 6, fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.16)', 'stroke-width': 1 }));
          }
        }
      } else if (station.type === 'computer') {
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 14, width: screenW - 24, height: screenH - 28, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(180,220,255,0.20)', 'stroke-width': 1 }));
      } else if (station.type === 'doorway') {
        art.appendChild(mk('rect', { x: screenX + 18, y: screenY + 20, width: screenW - 36, height: screenH - 40, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(180,220,255,0.20)', 'stroke-width': 1 }));
        art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.5} ${screenY + 24} L ${screenX + screenW * 0.5} ${screenY + screenH - 24}`,
          stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 2 }));
      } else if (station.type === 'elevator') {
        art.appendChild(mk('rect', { x: screenX + 16, y: screenY + 16, width: screenW - 32, height: screenH - 32, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(180,220,255,0.20)', 'stroke-width': 1 }));
        art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.5} ${screenY + 24} L ${screenX + screenW * 0.5} ${screenY + screenH - 24}`,
          stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 2 }));
        art.appendChild(mk('polygon', { points: `${screenX + screenW * 0.5 - 6},${screenY + 28} ${screenX + screenW * 0.5 + 6},${screenY + 28} ${screenX + screenW * 0.5},${screenY + 18}`,
          fill: C.accent, opacity: 0.8 }));
        art.appendChild(mk('polygon', { points: `${screenX + screenW * 0.5 - 6},${screenY + screenH - 28} ${screenX + screenW * 0.5 + 6},${screenY + screenH - 28} ${screenX + screenW * 0.5},${screenY + screenH - 18}`,
          fill: C.accent, opacity: 0.8 }));
      }

      parent.appendChild(group);
    }

    function renderPlayer(parent, svgNS) {
      const g = document.createElementNS(svgNS, 'g');
      const x = state.player.x;
      const y = state.player.y;
      const vx = state.player.vx;
      const walk = state.anim.walkPhase;
      const dir = state.player.facing || 1;
      const moving = Math.abs(vx) > 1;

      // Legs with walk cycle
      const hipY = y - 4;
      const hipBaseX = x;
      const legSpread = 7;
      const thighLen = 18;
      const shinLen = 16;

      const legs = document.createElementNS(svgNS, 'g');
      legs.setAttribute('stroke', '#e0e0ff');
      legs.setAttribute('stroke-width', 3);
      legs.setAttribute('stroke-linecap', 'round');

      function addLeg(sideSign) {
        const phase = walk + (sideSign > 0 ? Math.PI : 0);
        const s = moving ? Math.sin(phase) * 8 : 0;
        const l = moving ? Math.max(0, Math.sin(phase)) * 6 : 0;

        const hipX = hipBaseX + sideSign * legSpread;
        const kneeX = hipX + s * 0.6 * dir;
        const kneeY = hipY + thighLen - l * 0.4;
        const footX = hipX + s * 1.0 * dir;
        const footY = hipY + thighLen + shinLen - l;

        const legPath = document.createElementNS(svgNS, 'path');
        legPath.setAttribute('d', `M ${hipX} ${hipY} L ${kneeX} ${kneeY} L ${footX} ${footY}`);
        legPath.setAttribute('opacity', sideSign > 0 ? 0.95 : 0.85);
        legs.appendChild(legPath);

        const foot = document.createElementNS(svgNS, 'path');
        foot.setAttribute('d', `M ${footX - 7} ${footY} L ${footX + 9} ${footY}`);
        foot.setAttribute('stroke', '#4ecdc4');
        foot.setAttribute('stroke-width', 4);
        foot.setAttribute('opacity', 0.9);
        legs.appendChild(foot);
      }

      addLeg(-1);
      addLeg(1);
      g.appendChild(legs);

      // Body
      const body = document.createElementNS(svgNS, 'rect');
      body.setAttribute('x', x - state.player.width / 2);
      body.setAttribute('y', y - state.player.height);
      body.setAttribute('width', state.player.width);
      body.setAttribute('height', state.player.height);
      body.setAttribute('fill', '#4ecdc4');
      body.setAttribute('stroke', '#e0e0ff');
      body.setAttribute('stroke-width', 2);
      g.appendChild(body);

      // Head
      const head = document.createElementNS(svgNS, 'circle');
      head.setAttribute('cx', x);
      head.setAttribute('cy', y - state.player.height - 10);
      head.setAttribute('r', 15);
      head.setAttribute('fill', '#e0e0ff');
      head.setAttribute('stroke', '#4ecdc4');
      head.setAttribute('stroke-width', 2);
      g.appendChild(head);

      // Visor
      const visor = document.createElementNS(svgNS, 'rect');
      visor.setAttribute('x', x - 8);
      visor.setAttribute('y', y - state.player.height - 15);
      visor.setAttribute('width', 16);
      visor.setAttribute('height', 6);
      visor.setAttribute('fill', '#00d4ff');
      g.appendChild(visor);

      renderCharacterLabel(g, svgNS, {
        x,
        y: y - state.player.height - 70,
        line1: 'CAPTAIN',
        line2: '—'
      });

      parent.appendChild(g);
    }

    function renderNPC(npc, parent, svgNS) {
      const g = document.createElementNS(svgNS, 'g');
      const x = npc.x;
      const y = npc.y;
      const walk = npc.walkPhase || 0;
      const dir = npc.vx >= 0 ? 1 : -1;
      const moving = Math.abs(npc.vx) > 1;

      // Legs
      const hipY = y - 4;
      const hipBaseX = x;
      const legSpread = 7;
      const thighLen = 18;
      const shinLen = 16;

      const legs = document.createElementNS(svgNS, 'g');
      legs.setAttribute('stroke', '#e0e0ff');
      legs.setAttribute('stroke-width', 2);
      legs.setAttribute('stroke-linecap', 'round');

      function addLeg(sideSign) {
        const phase = walk + (sideSign > 0 ? Math.PI : 0);
        const s = moving ? Math.sin(phase) * 6 : 0;
        const l = moving ? Math.max(0, Math.sin(phase)) * 4 : 0;

        const hipX = hipBaseX + sideSign * legSpread;
        const kneeX = hipX + s * 0.5 * dir;
        const kneeY = hipY + thighLen - l * 0.3;
        const footX = hipX + s * 0.9 * dir;
        const footY = hipY + thighLen + shinLen - l;

        const legPath = document.createElementNS(svgNS, 'path');
        legPath.setAttribute('d', `M ${hipX} ${hipY} L ${kneeX} ${kneeY} L ${footX} ${footY}`);
        legPath.setAttribute('opacity', sideSign > 0 ? 0.95 : 0.85);
        legs.appendChild(legPath);

        const foot = document.createElementNS(svgNS, 'path');
        foot.setAttribute('d', `M ${footX - 6} ${footY} L ${footX + 8} ${footY}`);
        foot.setAttribute('stroke', '#4ecdc4');
        foot.setAttribute('stroke-width', 3);
        foot.setAttribute('opacity', 0.85);
        legs.appendChild(foot);
      }

      addLeg(-1);
      addLeg(1);
      g.appendChild(legs);

      // Body
      const body = document.createElementNS(svgNS, 'rect');
      body.setAttribute('x', x - npc.width / 2);
      body.setAttribute('y', y - npc.height);
      body.setAttribute('width', npc.width);
      body.setAttribute('height', npc.height);
      body.setAttribute('fill', C.success);
      body.setAttribute('stroke', C.text);
      body.setAttribute('stroke-width', 2);
      g.appendChild(body);

      // Head
      const head = document.createElementNS(svgNS, 'circle');
      head.setAttribute('cx', x);
      head.setAttribute('cy', y - npc.height - 10);
      head.setAttribute('r', 15);
      head.setAttribute('fill', C.text);
      head.setAttribute('stroke', C.success);
      head.setAttribute('stroke-width', 2);
      g.appendChild(head);

      // Visor (eyes)
      const visor = document.createElementNS(svgNS, 'rect');
      visor.setAttribute('x', x - 8);
      visor.setAttribute('y', y - npc.height - 15);
      visor.setAttribute('width', 16);
      visor.setAttribute('height', 6);
      visor.setAttribute('fill', C.accent);
      g.appendChild(visor);

      const role = String(npcRole(npc) || 'crew').toUpperCase();
      const displayName = npcRole(npc) === 'ai' ? formatAiDisplayName(npc.name) : String(npc.name || 'CREW');
      const name = displayName.toUpperCase();
      const line1 = name === role ? name : `${name} • ${role}`;
      const taskLabel = npc.task ? String(npc.task.label || npc.task.key || 'TASK') : '';
      const briefTask = abbreviateTaskLabel(taskLabel);
      const line2 = npc.onDuty ? (briefTask || 'IDLE') : 'STANDBY';

      const isAiRole = npcRole(npc) === 'ai';
      renderCharacterLabel(g, svgNS, {
        x,
        y: y - npc.height - 70,
        line1,
        line2,
        style: isAiRole ? {
          bgFill: 'rgba(20, 24, 54, 0.85)',
          stroke: C.accent,
          textFill: 'rgba(210, 245, 255, 0.98)'
        } : null
      });

      if (isAiRole && npc.speech && npc.speech.text) {
        const ageMs = Date.now() - safeNumber(npc.speech.at, Date.now());
        const durationMs = Math.max(1000, safeNumber(npc.speech.durationMs, 7000));
        if (ageMs >= durationMs) {
          npc.speech = null;
        } else {
          renderSpeechBubble(g, svgNS, {
            x,
            y: y - npc.height - 100,
            text: npc.speech.text,
            ageMs,
            durationMs
          });
        }
      }

      parent.appendChild(g);
    }

    function renderSpeechBubble(parent, svgNS, { x, y, text, ageMs, durationMs }) {
      const wrapSpeechLines = (label, maxChars) => {
        const words = String(label || '').split(/\s+/).filter(Boolean);
        if (!words.length) return [''];
        const lines = [];
        let line = '';
        for (const word of words) {
          const next = line ? `${line} ${word}` : word;
          if (next.length <= maxChars || !line) {
            line = next;
          } else {
            lines.push(line);
            line = word;
          }
        }
        if (line) lines.push(line);
        return lines;
      };

      const lines = wrapSpeechLines(text, 28);
      const lineHeight = 12;
      const visibleLines = 2;
      const visibleH = visibleLines * lineHeight + 8;
      const totalH = lines.length * lineHeight;
      const scrollSpan = Math.max(0, totalH - visibleH + 2);
      const scrollDuration = Math.max(800, durationMs - 1200);
      const scrollProgress = clamp(ageMs / scrollDuration, 0, 1);
      const textOffset = -scrollSpan * scrollProgress;
      const maxLen = Math.max(6, ...lines.map((l) => l.length));
      const padX = 10;
      const bubbleW = maxLen * 6.2 + padX * 2;
      const bubbleH = visibleH + 10;
      const bubbleX = x - bubbleW / 2;
      const bubbleY = y - bubbleH;
      const clipId = `speech-${Math.floor(x)}-${Math.floor(y)}-${Math.floor(ageMs / 50)}`;

      const defs = document.createElementNS(svgNS, 'defs');
      const clip = document.createElementNS(svgNS, 'clipPath');
      clip.setAttribute('id', clipId);
      const clipRect = document.createElementNS(svgNS, 'rect');
      clipRect.setAttribute('x', (bubbleX + 6).toFixed(2));
      clipRect.setAttribute('y', (bubbleY + 6).toFixed(2));
      clipRect.setAttribute('width', (bubbleW - 12).toFixed(2));
      clipRect.setAttribute('height', (bubbleH - 12).toFixed(2));
      clipRect.setAttribute('rx', 6);
      clipRect.setAttribute('ry', 6);
      clip.appendChild(clipRect);
      defs.appendChild(clip);
      parent.appendChild(defs);

      const bubble = document.createElementNS(svgNS, 'rect');
      bubble.setAttribute('x', bubbleX.toFixed(2));
      bubble.setAttribute('y', bubbleY.toFixed(2));
      bubble.setAttribute('width', bubbleW.toFixed(2));
      bubble.setAttribute('height', bubbleH.toFixed(2));
      bubble.setAttribute('rx', 10);
      bubble.setAttribute('ry', 10);
      bubble.setAttribute('fill', 'rgba(12, 16, 38, 0.92)');
      bubble.setAttribute('stroke', C.accent);
      bubble.setAttribute('stroke-width', 1.5);
      parent.appendChild(bubble);

      const textGroup = document.createElementNS(svgNS, 'g');
      textGroup.setAttribute('clip-path', `url(#${clipId})`);
      const bubbleText = document.createElementNS(svgNS, 'text');
      bubbleText.setAttribute('x', x);
      bubbleText.setAttribute('y', (bubbleY + 18 + textOffset).toFixed(2));
      bubbleText.setAttribute('text-anchor', 'middle');
      bubbleText.setAttribute('fill', 'rgba(235, 250, 255, 0.98)');
      bubbleText.setAttribute('font-size', '11');
      bubbleText.setAttribute('font-weight', '600');
      bubbleText.setAttribute('letter-spacing', '0.2');
      bubbleText.setAttribute('paint-order', 'stroke');
      bubbleText.setAttribute('stroke', 'rgba(0, 0, 0, 0.6)');
      bubbleText.setAttribute('stroke-width', '2');
      bubbleText.setAttribute('pointer-events', 'none');
      lines.forEach((line, idx) => {
        const tspan = document.createElementNS(svgNS, 'tspan');
        tspan.setAttribute('x', x);
        tspan.setAttribute('dy', idx === 0 ? '0' : String(lineHeight));
        tspan.textContent = line;
        bubbleText.appendChild(tspan);
      });
      textGroup.appendChild(bubbleText);
      parent.appendChild(textGroup);
    }

    function abbreviateTaskLabel(label) {
      const raw = String(label || '').trim();
      if (!raw) return '';
      const lower = raw.toLowerCase();
      const map = [
        { match: 'repair drone', value: 'REPAIR' },
        { match: 'salvage drone', value: 'SALVAGE' },
        { match: 'sensor', value: 'SCAN' },
        { match: 'scan', value: 'SCAN' },
        { match: 'deep scan', value: 'SCAN' },
        { match: 'fabricate', value: 'FABRICATE' },
        { match: 'refine', value: 'REFINE' },
        { match: 'repair hull', value: 'REPAIR' },
        { match: 'install', value: 'INSTALL' },
        { match: 'treat', value: 'TREAT' },
        { match: 'rest', value: 'REST' },
        { match: 'harvest', value: 'HARVEST' },
        { match: 'vent', value: 'VENT' },
        { match: 'route', value: 'ROUTE' },
        { match: 'buy', value: 'BUY' },
        { match: 'sell', value: 'SELL' },
        { match: 'hire', value: 'HIRE' },
        { match: 'transfer', value: 'TRANSFER' },
        { match: 'contract', value: 'CONTRACT' },
        { match: 'travel', value: 'TRAVEL' },
        { match: 'course', value: 'COURSE' },
        { match: 'investigate', value: 'INVESTIGATE' }
      ];
      for (const entry of map) {
        if (lower.includes(entry.match)) return entry.value;
      }
      const compact = raw.replace(/\s*\(.*\)\s*/g, '').trim();
      const words = compact.split(/\s+/).filter(Boolean);
      return words.length ? words[0].toUpperCase() : compact.toUpperCase();
    }

    function renderCharacterLabel(parent, svgNS, { x, y, line1, line2, style = null }) {
      const clipText = (text, maxLen = 22) => (text.length > maxLen ? `${text.slice(0, maxLen - 1)}…` : text);
      const l1 = clipText(String(line1 || '').toUpperCase());
      const l2 = clipText(String(line2 || '').toUpperCase());
      const maxLen = Math.max(l1.length, l2.length);
      const padX = 10;
      const padY = 6;
      const labelW = maxLen * 6.2 + padX * 2;
      const labelH = 30 + padY * 0.3;
      const labelX = x - labelW / 2;
      const labelY = y;

      const labelBg = document.createElementNS(svgNS, 'rect');
      labelBg.setAttribute('x', labelX.toFixed(2));
      labelBg.setAttribute('y', labelY.toFixed(2));
      labelBg.setAttribute('width', labelW.toFixed(2));
      labelBg.setAttribute('height', labelH);
      labelBg.setAttribute('rx', 7);
      labelBg.setAttribute('ry', 7);
      const bgFill = style && style.bgFill ? style.bgFill : 'rgba(10, 14, 39, 0.78)';
      const stroke = style && style.stroke ? style.stroke : 'rgba(0, 212, 255, 0.45)';
      const textFill = style && style.textFill ? style.textFill : 'rgba(240, 250, 255, 0.95)';
      labelBg.setAttribute('fill', bgFill);
      labelBg.setAttribute('stroke', stroke);
      labelBg.setAttribute('stroke-width', 1);
      parent.appendChild(labelBg);

      const labelText = document.createElementNS(svgNS, 'text');
      labelText.setAttribute('x', x);
      labelText.setAttribute('y', labelY + 12 + padY * 0.2);
      labelText.setAttribute('text-anchor', 'middle');
      labelText.setAttribute('fill', textFill);
      labelText.setAttribute('font-size', '11');
      labelText.setAttribute('font-weight', '600');
      labelText.setAttribute('letter-spacing', '0.4');
      labelText.setAttribute('paint-order', 'stroke');
      labelText.setAttribute('stroke', 'rgba(0, 0, 0, 0.6)');
      labelText.setAttribute('stroke-width', '2');
      labelText.setAttribute('pointer-events', 'none');
      const t1 = document.createElementNS(svgNS, 'tspan');
      t1.setAttribute('x', x);
      t1.setAttribute('dy', '0');
      t1.textContent = l1 || '—';
      const t2 = document.createElementNS(svgNS, 'tspan');
      t2.setAttribute('x', x);
      t2.setAttribute('dy', '14');
      t2.textContent = l2 || '—';
      labelText.appendChild(t1);
      labelText.appendChild(t2);
      parent.appendChild(labelText);
    }

    function findNearestInsertIndex() {
      if (!modulesLayout.length) return null;
      const candidates = [];
      for (let i = 0; i < modulesLayout.length - 1; i++) {
        const left = modulesLayout[i];
        const right = modulesLayout[i + 1];
        const insertIndex = left.walkable && right.walkable
          ? right.corridorIndex
          : left.walkable && !right.walkable
            ? left.corridorIndex + 1
            : !left.walkable && right.walkable
              ? right.corridorIndex
              : null;
        if (insertIndex === null) continue;
        const wallX = left.x + left.width + BULKHEAD_W * 0.5;
        candidates.push({ insertIndex, x: wallX });
      }
      if (!candidates.length) return null;
      let best = candidates[0];
      let bestD = Math.abs(best.x - state.player.x);
      for (const c of candidates) {
        const d = Math.abs(c.x - state.player.x);
        if (d < bestD) {
          best = c;
          bestD = d;
        }
      }
      return best.insertIndex;
    }

    function findNearestRemovableModule() {
      const walkables = modulesLayout.filter((m) => m.walkable && m.moduleRef);
      if (!walkables.length) return null;
      let best = walkables[0];
      let bestD = Math.abs((best.x + best.width * 0.5) - state.player.x);
      for (const m of walkables) {
        const d = Math.abs((m.x + m.width * 0.5) - state.player.x);
        if (d < bestD) {
          best = m;
          bestD = d;
        }
      }
      return best;
    }

    function findCurrentModuleAtPlayer() {
      const x = state.player.x;
      const walkables = modulesLayout.filter((m) => m.walkable && m.moduleRef);
      if (!walkables.length) return null;
      for (const m of walkables) {
        if (x >= m.x && x <= (m.x + m.width)) return m;
      }
      return findNearestRemovableModule();
    }

    function npcBoundsFor(npc) {
      if (npc.level === state.currentLevel && npc.corridor === state.currentCorridor) return state.walkBounds;
      return getCorridorLayout(npc.level, npc.corridor).bounds;
    }

    function updateNpcNavigation(npc) {
      const startKey = corridorKey(npc.level, npc.corridor);
      if (npc.destinationCorridorKey) {
        if (npc.destinationCorridorKey === startKey) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const route = findRoute(startKey, [npc.destinationCorridorKey]);
        if (!route || route.length < 2) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const nextKey = route[1];
        const link = findLinkModule(npc.level, npc.corridor, nextKey);
        if (!link) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const targetX = moduleCenterInCorridor(npc.level, npc.corridor, link.module);
        if (targetX === null || targetX === undefined) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const dist = targetX - npc.x;
        if (Math.abs(dist) <= 6) {
          const { level: nextLevel, corridor: nextCorridor } = parseCorridorKey(nextKey);
          const backLink = findLinkModule(nextLevel, nextCorridor, startKey);
          const destX = backLink ? moduleCenterInCorridor(nextLevel, nextCorridor, backLink.module) : null;
          const bounds = getCorridorLayout(nextLevel, nextCorridor).bounds;
          npc.level = nextLevel;
          npc.corridor = nextCorridor;
          npc.x = destX != null ? clamp(destX, bounds.minX, bounds.maxX) : bounds.minX + (bounds.maxX - bounds.minX) * 0.5;
          npc.vx = 0;
          npc.mode = 'travel';
          return true;
        }
        npc.vx = Math.sign(dist) * npc.speed * 0.6;
        npc.mode = 'travel';
        return true;
      }

      if (!npc.destinationType) return false;
      const targetType = npc.destinationType;
      const targets = corridorsWithModuleType(targetType);
      if (!targets.length) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      if (targets.includes(startKey)) {
        const targetModule = findModuleByType(npc.level, npc.corridor, targetType);
        const targetX = moduleCenterInCorridor(npc.level, npc.corridor, targetModule);
        if (targetX === null || targetX === undefined) {
          npc.destinationType = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const dist = targetX - npc.x;
        if (Math.abs(dist) <= 6) {
          npc.vx = 0;
          npc.destinationType = null;
          npc.mode = 'idle';
          return true;
        }
        npc.vx = Math.sign(dist) * npc.speed * 0.6;
        npc.mode = 'travel';
        return true;
      }

      const route = findRoute(startKey, targets);
      if (!route || route.length < 2) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      const nextKey = route[1];
      const link = findLinkModule(npc.level, npc.corridor, nextKey);
      if (!link) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      const targetX = moduleCenterInCorridor(npc.level, npc.corridor, link.module);
      if (targetX === null || targetX === undefined) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      const dist = targetX - npc.x;
      if (Math.abs(dist) <= 6) {
        const { level: nextLevel, corridor: nextCorridor } = parseCorridorKey(nextKey);
        const backLink = findLinkModule(nextLevel, nextCorridor, startKey);
        const destX = backLink ? moduleCenterInCorridor(nextLevel, nextCorridor, backLink.module) : null;
        const bounds = getCorridorLayout(nextLevel, nextCorridor).bounds;
        npc.level = nextLevel;
        npc.corridor = nextCorridor;
        npc.x = destX != null ? clamp(destX, bounds.minX, bounds.maxX) : bounds.minX + (bounds.maxX - bounds.minX) * 0.5;
        npc.vx = 0;
        npc.mode = 'travel';
        return true;
      }

      npc.vx = Math.sign(dist) * npc.speed * 0.6;
      npc.mode = 'travel';
      return true;
    }

    function updateCamera() {
      const viewWidth = 800;
      const targetX = state.player.x - viewWidth / 2;
      const maxScroll = Math.max(0, corridorEndX - viewWidth);
      state.camera.x = Math.max(0, Math.min(maxScroll, targetX));

      const svg = document.getElementById('gameCanvas');
      svg.setAttribute('viewBox', `${state.camera.x} 0 ${viewWidth} 600`);
    }

    // ============================================================================
    // Input Handling
    // ============================================================================

    function handleLeftPress() {
      state.keys.left = true;
      state.keys.right = false;
      state.player.facing = -1;
    }

    function handleRightPress() {
      state.keys.right = true;
      state.keys.left = false;
      state.player.facing = 1;
    }

    function handleActionPress() {
      // If a panel is open, pressing Action pops from the unified menu stack
      if (state.ui.panelOpen) {
        popUnifiedMenu();
        state.ui.suppressMenuOpen = true;
        requestAnimationFrame(() => {
          state.ui.suppressMenuOpen = false;
        });
        return true;
      }

      // Check for nearby station
      for (const station of stations) {
        if (Math.abs(state.player.x - station.interactX) < 50) {
          state.nearStation = station;
          // Execute the station's first action (which opens the menu)
          const actions = station.getActions ? station.getActions(station) : station.actions;
          if (actions && actions.length > 0) {
            executeAction(actions[0]);
          }
          state.ui.suppressMenuOpen = true;
          requestAnimationFrame(() => {
            state.ui.suppressMenuOpen = false;
          });
          return true;
        }
      }

      // Check for connection (doorway/elevator)
      const connections = getConnectionsForCorridor(state.currentLevel, state.currentCorridor);
      if (state.player.x < 80 && connections.left) {
        const conn = connections.left;
        moveToLocation(conn.level, conn.corridor);
        state.ui.suppressMenuOpen = true;
        requestAnimationFrame(() => {
          state.ui.suppressMenuOpen = false;
        });
        return true;
      }
      if (state.player.x > corridorEndX - 80 && connections.right) {
        const conn = connections.right;
        moveToLocation(conn.level, conn.corridor);
        state.ui.suppressMenuOpen = true;
        requestAnimationFrame(() => {
          state.ui.suppressMenuOpen = false;
        });
        return true;
      }
      if (connections.up) {
        const conn = connections.up;
        moveToLocation(conn.level, conn.corridor);
        state.ui.suppressMenuOpen = true;
        requestAnimationFrame(() => {
          state.ui.suppressMenuOpen = false;
        });
        return true;
      }
      if (connections.down) {
        const conn = connections.down;
        moveToLocation(conn.level, conn.corridor);
        state.ui.suppressMenuOpen = true;
        requestAnimationFrame(() => {
          state.ui.suppressMenuOpen = false;
        });
        return true;
      }
      return false;
    }

    const svg = document.getElementById('gameCanvas');

    document.addEventListener('contextmenu', (e) => {
      const t = e.target;
      if (t && (t.id === 'panelInput' || t.id === 'panelTextarea')) return;
      e.preventDefault();
    });

    document.addEventListener('keydown', (e) => {
      if (state.ui.panelOpen) {
        const textareaEl = document.getElementById('panelTextarea');
        const inputEl = document.getElementById('panelInput');
        if (inputEl && inputEl.style.display !== 'none' && document.activeElement === inputEl) {
          if (e.key === 'Enter') {
            e.preventDefault();
            const buttons = Array.from(document.querySelectorAll('#panelButtons button'));
            if (buttons[0]) buttons[0].click();
          }
          return;
        }
        if (textareaEl && textareaEl.style.display !== 'none' && document.activeElement === textareaEl) {
          return;
        }
        const buttons = Array.from(document.querySelectorAll('#panelButtons button'));
        if (!buttons.length) return;
        let idx = buttons.indexOf(document.activeElement);
        if (idx === -1 && buttons[0]) {
          buttons[0].focus();
          idx = 0;
        }
        if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
          e.preventDefault();
          const next = buttons[(idx + 1 + buttons.length) % buttons.length];
          next.focus();
          return;
        }
        if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
          e.preventDefault();
          const prev = buttons[(idx - 1 + buttons.length) % buttons.length];
          prev.focus();
          return;
        }
        if (e.key === 'Enter' || e.key === ' ') {
          if (state.ui.justOpenedPanel) {
            e.preventDefault();
            state.ui.justOpenedPanel = false;
            if (buttons[0]) buttons[0].focus();
            return;
          }
          if (document.activeElement && document.activeElement.click) {
            e.preventDefault();
            document.activeElement.click();
          }
          return;
        }
        return;
      }

      if (e.key === 'Escape') {
        // Only open menu if the event wasn't already handled by the panel's keyboard handler
        if (!e.defaultPrevented) {
          const gameMenuPanel = document.getElementById('gameMenuPanel');
          const isGameMenuOpen = gameMenuPanel && gameMenuPanel.style.display === 'block';
          if (!isGameMenuOpen) {
            e.preventDefault();
            openGameMenu();
          }
        }
        return;
      }
      if (e.key === 'F10') {
        e.preventDefault();
        openGameMenu();
        return;
      }
      if (e.key === '+') {
        const insertIndex = findNearestInsertIndex();
        if (insertIndex !== null) openInsertModulePanel(insertIndex);
        return;
      }
      if (e.key === '-') {
        const module = findNearestRemovableModule();
        if (module && module.moduleRef) removeModuleByUid(module.moduleRef.uid);
        return;
      }
      if (e.key === 'r' || e.key === 'R') {
        openRenameModulePanel();
        return;
      }
      if (e.key === 'ArrowLeft') handleLeftPress();
      if (e.key === 'ArrowRight') handleRightPress();
      if (e.key === ' ' || e.key === 'Enter') {
        const handled = handleActionPress();
        if (handled) {
          e.preventDefault();
          return;
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (state.ui.panelOpen && state.ui.justOpenedPanel && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        state.ui.justOpenedPanel = false;
        return;
      }

      if (e.key === 'ArrowLeft') state.keys.left = false;
      if (e.key === 'ArrowRight') state.keys.right = false;
    });

    // Pointer controls on the play area (touch + mouse): hold left/right half to move.
    let movementPointerId = null;

    function setMoveFromClientX(clientX) {
      const rect = svg.getBoundingClientRect();
      const relX = clientX - rect.left;
      if (relX < rect.width / 2) {
        state.keys.left = true;
        state.keys.right = false;
        state.player.facing = -1;
      } else {
        state.keys.right = true;
        state.keys.left = false;
        state.player.facing = 1;
      }
    }

    function clearMoveFromPointer() {
      state.keys.left = false;
      state.keys.right = false;
    }

    svg.addEventListener('pointerdown', (e) => {
      if (state.ui.panelOpen) return;
      // Don't capture if clicking on interactive elements (buttons)
      let el = e.target;
      while (el && el !== svg) {
        if (el.hasAttribute && el.hasAttribute('data-interactive')) return;
        if (el.style && el.style.cursor === 'pointer') return;
        el = el.parentElement;
      }
      movementPointerId = e.pointerId;
      svg.setPointerCapture(e.pointerId);
      setMoveFromClientX(e.clientX);
    });

    svg.addEventListener('pointermove', (e) => {
      if (movementPointerId !== e.pointerId) return;
      setMoveFromClientX(e.clientX);
    });

    svg.addEventListener('pointerup', (e) => {
      if (movementPointerId !== e.pointerId) return;
      movementPointerId = null;
      clearMoveFromPointer();
    });

    svg.addEventListener('pointercancel', (e) => {
      if (movementPointerId !== e.pointerId) return;
      movementPointerId = null;
      clearMoveFromPointer();
    });

    svg.addEventListener('pointerleave', () => {
      if (movementPointerId === null) return;
      movementPointerId = null;
      clearMoveFromPointer();
    });

    function bindHoldButton(btn, key) {
      if (!btn) return;
      const down = () => {
        if (key === 'left') handleLeftPress();
        if (key === 'right') handleRightPress();
      };
      const up = () => {
        if (key === 'left') state.keys.left = false;
        if (key === 'right') state.keys.right = false;
      };
      btn.addEventListener('pointerdown', (e) => {
        if (state.ui.panelOpen) return;
        btn.setPointerCapture(e.pointerId);
        down();
      });
      btn.addEventListener('pointerup', (e) => {
        try { btn.releasePointerCapture(e.pointerId); } catch {}
        up();
      });
      btn.addEventListener('pointercancel', up);
      btn.addEventListener('pointerleave', up);
    }

    bindHoldButton(document.getElementById('leftBtn'), 'left');
    bindHoldButton(document.getElementById('rightBtn'), 'right');
    document.getElementById('actionBtn').addEventListener('click', handleActionPress);
    const messageAiBtn = document.getElementById('messageAiBtn');
    if (messageAiBtn) messageAiBtn.addEventListener('click', openMessageAiPanel);
    const menuBtn = document.getElementById('menuBtn');
    menuBtn.addEventListener('click', openGameMenu);
    menuBtn.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        openGameMenu();
      }
    });
    document.getElementById('renameBtn').addEventListener('click', openRenameModulePanel);

    // Global keyboard handler for Enter to open menu from game
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !state.ui.panelOpen && state.ui.unifiedMenuStack.length === 0 && !state.ui.suppressMenuOpen && document.activeElement !== document.getElementById('menuBtn')) {
        const gameCanvas = document.getElementById('gameCanvas');
        if (gameCanvas && gameCanvas.contains(document.activeElement) || document.activeElement === document.body) {
          e.preventDefault();
          openGameMenu();
        }
      }
    });

    function updateViewportLayout() {
      const hud = document.getElementById('hud');
      const controls = document.getElementById('controls');
      const hudH = hud ? Math.ceil(hud.getBoundingClientRect().height) : 0;
      const controlsH = controls ? Math.ceil(controls.getBoundingClientRect().height) : 0;
      document.documentElement.style.setProperty('--hud-h', `${hudH}px`);
      document.documentElement.style.setProperty('--controls-h', `${controlsH}px`);
      const svgEl = document.getElementById('gameCanvas');
      if (svgEl) {
        const h = Math.max(120, window.innerHeight - hudH - controlsH);
        svgEl.style.height = `${h}px`;
        const w = Math.max(1, svgEl.getBoundingClientRect().width || window.innerWidth);
        const ratio = w / Math.max(1, h);
        const baseRatio = 800 / 600;
        svgEl.setAttribute('preserveAspectRatio', ratio < baseRatio ? 'xMidYMid slice' : 'xMidYMid meet');
      }
    }

    const hudEl = document.getElementById('hud');
    const controlsEl = document.getElementById('controls');
    if (window.ResizeObserver) {
      const ro = new ResizeObserver(() => updateViewportLayout());
      if (hudEl) ro.observe(hudEl);
      if (controlsEl) ro.observe(controlsEl);
    }
    window.addEventListener('resize', () => updateViewportLayout());

    // ============================================================================
    // Game Loop & Physics
    // ============================================================================

    function updatePlayer(dt) {
      const acc = state.player.speed;

      if (state.keys.left) {
        state.player.vx = -acc;
        state.player.facing = -1;
      } else if (state.keys.right) {
        state.player.vx = acc;
        state.player.facing = 1;
      } else {
        state.player.vx = 0;
      }

      // Update walk animation
      const moving = Math.abs(state.player.vx) > 1;
      if (moving) {
        state.anim.walkPhase += state.anim.walkSpeed * dt;
        if (state.anim.walkPhase > Math.PI * 2) {
          state.anim.walkPhase -= Math.PI * 2;
        }
      } else {
        state.anim.walkPhase = 0;
      }

      state.player.x = Math.max(state.walkBounds.minX, Math.min(state.walkBounds.maxX, state.player.x + state.player.vx * dt));
    }

    function updateNPCs(dt) {
      for (const npc of state.npcs) {
        if (npc.onDuty === undefined) npc.onDuty = true;
        if (!Number.isFinite(npc.hunger)) npc.hunger = 0;
        const isAi = npcRole(npc) === 'ai';
        if (npc.paused) continue;
        if (!npc.onDuty && !isAi) continue;
        if (!npc.mode) npc.mode = 'idle';
        if (!Number.isFinite(npc.thinkTimer)) npc.thinkTimer = 0;

        const navActive = updateNpcNavigation(npc);
        const taskActive = updateNpcTasking(npc, dt);

        // Simple idle wandering AI
        if (!navActive && !taskActive) {
          npc.mode = 'idle';
          npc.thinkTimer -= dt;
          
          if (npc.thinkTimer <= 0) {
            // Pick a random wander target occasionally
            if (Math.random() < 0.6 || npc.wanderTarget === null) {
              const bounds = npcBoundsFor(npc);
              const minX = bounds.minX;
              const maxX = bounds.maxX;
              if (maxX > minX) {
                npc.wanderTarget = minX + Math.random() * (maxX - minX);
              } else {
                npc.wanderTarget = minX;
              }
            }
            if (npc.destinationType == null && Math.random() < 0.08) {
              const types = listRoutableModuleTypes();
              if (types.length) {
                npc.destinationType = types[(Math.random() * types.length) | 0];
                npc.wanderTarget = null;
                npc.mode = 'travel';
              }
            }
            if (npc.destinationType == null && npc.destinationCorridorKey == null && Math.random() < 0.12) {
              const corridors = listAllCorridors().filter((k) => k !== corridorKey(npc.level, npc.corridor));
              if (corridors.length) {
                npc.destinationCorridorKey = corridors[(Math.random() * corridors.length) | 0];
                npc.wanderTarget = null;
                npc.mode = 'travel';
              }
            }
            npc.thinkTimer = 2 + Math.random() * 3;
          }

          // Move toward wander target
          if (npc.wanderTarget !== null) {
            const dist = npc.wanderTarget - npc.x;
            if (Math.abs(dist) > 10) {
              npc.vx = (dist > 0 ? 1 : -1) * npc.speed * 0.5;
            } else {
              npc.vx = 0;
              npc.wanderTarget = null;
            }
          } else {
            npc.vx = 0;
          }
        }

        // Move NPC, keep in bounds
        const bounds = npcBoundsFor(npc);
        npc.x = Math.max(bounds.minX, Math.min(bounds.maxX, npc.x + npc.vx * dt));

        const moving = Math.abs(npc.vx) > 1;
        if (moving) {
          npc.walkPhase = (npc.walkPhase || 0) + state.anim.walkSpeed * dt * 0.8;
          if (npc.walkPhase > Math.PI * 2) npc.walkPhase -= Math.PI * 2;
        } else {
          npc.walkPhase = 0;
        }
      }
    }

    // ============================================================================
    // Simulation Helpers
    // ============================================================================

    function clampPercent(value) {
      return clamp(value, 0, 100);
    }

    function currentPowerProfile() {
      return state.powerProfile || 'balanced';
    }

    function computePowerDrain(profile, dt) {
      const profileDrain = profile === 'combat' ? 0.08 : profile === 'survival' ? 0.05 : profile === 'industry' ? 0.07 : 0;
      return (
        0.08 +
        (state.lightsOn ? 0.05 : 0) +
        (state.lifeSupportOn ? 0.12 : 0) +
        (state.hydroponicsOn ? 0.08 : 0) +
        (state.shieldsOn ? 0.12 : 0) +
        (state.engineActive ? 0.3 * Math.max(0, state.throttle) : 0) +
        (state.incidents.fire ? 0.06 : 0) +
        profileDrain
      ) * dt;
    }

    function applyPowerTick(profile, dt) {
      const powerDrain = computePowerDrain(profile, dt);
      state.power = clampPercent(state.power - powerDrain);

      if (!state.incidents.powerTrip && state.power < 100) {
        state.power = clampPercent(state.power + 1.2 * dt);
      }
    }

    function applyOxygenTick(profile, dt) {
      const crewCount = 1 + (Array.isArray(state.npcs) ? state.npcs.length : 0);
      const o2Use = 0.06 * Math.sqrt(Math.max(1, crewCount));
      const o2Gain = state.lifeSupportOn && state.power >= 8 ? 1.1 : 0;
      state.oxygen = clampPercent(state.oxygen + (o2Gain - o2Use) * dt);
    }

    function applyHeatTick(dt) {
      const heatGain =
        (state.engineActive ? (0.2 + 0.8 * Math.max(0, state.throttle)) : 0)
        + (state.lightsOn ? 0.04 : 0)
        + (state.shieldsOn ? 0.12 : 0)
        + (state.incidents.fire ? 0.8 : 0);
      const heatCooling = 0.25 + 0.015 * clampPercent(state.heat);
      state.heat = clampPercent(state.heat + (heatGain - heatCooling) * dt);

      if (state.crewAI && state.crewAI.autoVentHeat && state.heat > 70 && state.power > 10) {
        state.power = clampPercent(state.power - 0.4 * dt);
        state.heat = clampPercent(state.heat - 1.2 * dt);
      }
    }

    function applyFoodTick(dt) {
      if (!Array.isArray(state.npcs)) return;
      const hungerRate = dt / 600;
      for (const npc of state.npcs) {
        if (!npc) continue;
        const current = Number.isFinite(npc.hunger) ? npc.hunger : 0;
        npc.hunger = clamp(current + hungerRate, 0, 2);
      }
    }

    function applyMoraleTick(dt) {
      let moraleDelta = -0.01;
      if (state.oxygen <= 20) moraleDelta -= 0.25;
      if (state.heat >= 78) moraleDelta -= 0.2;
      if ((state.hull / Math.max(1, state.hullMax)) <= 0.4) moraleDelta -= 0.12;
      const hungryCount = countHungryCrew();
      if (hungryCount > 0) moraleDelta -= 0.04 * Math.min(3, hungryCount);
      if (!anyActiveIncident() && state.oxygen >= 60 && state.heat <= 40 && hungryCount === 0) moraleDelta += 0.05;
      const base = safeNumber(state.morale, 0);
      state.morale = clampPercent(base + moraleDelta * dt);
    }

    function applyIncidentDamage(dt) {
      if (state.incidents.breach) {
        const breachRate = state.shieldsOn ? 0.08 : 0.18;
        state.hull = Math.max(0, state.hull - breachRate * dt);
      }
      if (state.incidents.o2Leak) state.oxygen = clampPercent(state.oxygen - 1.2 * dt);
      if (state.incidents.fire) state.heat = clampPercent(state.heat + 1.6 * dt);
      if (state.incidents.powerTrip) state.power = clampPercent(state.power - 0.6 * dt);
      state.hull = clamp(state.hull, 0, state.hullMax);
    }

    function applyTravelTick(dt) {
      if (state.travel && state.travel.active && state.travel.to) {
        const speed = state.engineActive ? (state.throttle * 20 + 5) : 0;
        state.speed = Math.max(0, speed);
        if (speed > 0) {
          state.travel.remaining = Math.max(0, state.travel.remaining - speed * dt);
          const hazard = state.shieldsOn ? 0.6 : 1;
          if (Math.random() < dt * 0.02 * hazard) triggerIncident('powerTrip');
          if (Math.random() < dt * 0.015 * hazard) triggerIncident('o2Leak');
          if (Math.random() < dt * 0.012 * hazard) triggerIncident('fire');
        }
        if (state.travel.remaining <= 0) {
          state.location.system = state.travel.to;
          state.travel = { active: false, from: state.location.system, to: null, remaining: 0, total: 0 };
          state.speed = 0;
          if (Math.random() < 0.6) addAnomaly({ system: currentSystem(), name: 'Signal Echo', kind: 'signal' });
          queueNotification('NAVIGATION', `Arrived at ${state.location.system}.`);
        }
      } else {
        state.speed = 0;
      }
    }

    function applyIncidentTriggers(dt) {
      const lastReset = state.meta && Number.isFinite(state.meta.powerShedAt) ? state.meta.powerShedAt : 0;
      if (state.power < 20 && Date.now() - lastReset > 6000) triggerIncident('powerTrip');
      if (state.oxygen < 15) triggerIncident('o2Leak');
      if (state.heat > 85) triggerIncident('fire');
      if (state.hull < state.hullMax * 0.3) triggerIncident('breach');

      const baseRisk = 0.0006;
      const risk = baseRisk
        + (state.engineActive ? (0.001 + 0.002 * clamp(safeNumber(state.throttle, 0), 0, 1)) : 0)
        + (state.heat >= 80 ? 0.004 : 0)
        + (state.power <= 12 ? 0.004 : 0)
        + (state.morale <= 30 ? 0.006 : 0);
      const scaled = risk * Math.max(0.1, safeNumber(dt, 0.05));
      if (Math.random() < scaled) {
        const kinds = ['powerTrip', 'o2Leak', 'fire', 'breach'].filter((k) => !state.incidents[k]);
        if (kinds.length) {
          const k = kinds[(Math.random() * kinds.length) | 0];
          triggerIncident(k);
        }
      }
    }

    // Fixed timestep game loop (20 FPS like original)
    const FIXED_FPS = 20;
    const STEP = 1 / FIXED_FPS;
    const MAX_CATCHUP_STEPS = 5;
    let lastTs = null;
    let acc = 0;
    let lastRenderTs = 0;

    function systemsTick(dt) {
      const profile = currentPowerProfile();
      applyPowerTick(profile, dt);
      applyOxygenTick(profile, dt);
      applyHeatTick(dt);
      applyFoodTick(dt);
      applyMoraleTick(dt);
      applyIncidentDamage(dt);
      applyTravelTick(dt);
      applyIncidentTriggers(dt);
      crewAutomationTick(dt);
      lmStudioTick();
      markDirty();
    }

    function gameLoop(ts) {
      if (lastTs === null) lastTs = ts;
      const deltaMs = Math.min(ts - lastTs, 50);
      lastTs = ts;
      acc += deltaMs / 1000;

      let steps = 0;
      while (acc >= STEP && steps < MAX_CATCHUP_STEPS) {
        updatePlayer(STEP);
        updateNPCs(STEP);
        systemsTick(STEP);
        
        state.sim.saveAcc += STEP;
        if (state.sim.saveAcc >= 10) {
          if (state.sim.dirty) {
            saveGame();
          }
          state.sim.saveAcc = 0;
        }
        
        acc -= STEP;
        steps++;
      }

      const shouldRender = steps > 0 || state.sim.dirty || (ts - lastRenderTs) > 250;
      if (shouldRender) {
        updateCamera();
        renderCorridor();
        updateHUD();
        lastRenderTs = ts;
      }

      requestAnimationFrame(gameLoop);
    }

    // ============================================================================
    // Action Execution & Permission Checking
    // ============================================================================

    function canExecuteAction(action, executor = 'player') {
      // Player can always execute
      if (executor === 'player') return true;

      // Check role requirements
      if (action.requiredRole) {
        const roles = Array.isArray(action.requiredRole) ? action.requiredRole : [action.requiredRole];
        const npc = state.npcs.find(n => n.id === executor);
        if (!npc) return false;
        if (!npcHasRole(npc, roles)) return false;
      }

      return true;
    }

    function executeAction(action, executor = 'player') {
      if (!canExecuteAction(action, executor)) {
        showMessage('ACCESS DENIED', 'Insufficient permissions or missing role.');
        return;
      }
      if (action.playerOnly && executor !== 'player') {
        queueNotification('RESTRICTED ACTION', 'Only the captain can perform that action.');
        return;
      }
      if (typeof action.can === 'function' && !action.can()) {
        if (action.failMessage) showMessage('ACTION', action.failMessage);
        return;
      }
      const runner = executor === 'player' ? action.action : (action.perform || action.action);
      if (typeof runner === 'function') {
        const prevActor = state.ui && state.ui.actionActor ? state.ui.actionActor : 'player';
        if (state.ui) state.ui.actionActor = executor;
        try {
          runner(executor);
        } finally {
          if (state.ui) state.ui.actionActor = prevActor || 'player';
        }
      }
    }

    function openStationPanel(station) {
      // Clear both the unified menu stack and old menu stack when opening station
      state.ui.unifiedMenuStack = [];
      state.ui.menuStack = [];
      
      const actions = station.getActions(station);
      const buttons = actions.map((action) => {
        let label = action.label;
        if (action.requiredRole) {
          const roles = Array.isArray(action.requiredRole) ? action.requiredRole : [action.requiredRole];
          label += ` [${roles.join('/')}]`;
        }
        return {
          label,
          action: () => {
            // Execute the action directly - it will open any menus it needs to
            // The action function is responsible for showing the appropriate UI
            executeAction(action);
          }
        };
      });

      openPanel(station.label.toUpperCase(), `Station: ${station.label}`, buttons);
    }

    // ============================================================================
    // Core Systems & Actions (v1-style loops)
    // ============================================================================

    const ITEM_RECIPES = {
      filter: { scrap: 2 },
      medkit: { scrap: 3 },
      droneParts: { scrap: 4, ingot: 1 },
      rations: { scrap: 1 },
      plating: { ingot: 2 }
    };

    function describeAiBlockers({ maxItems = 6 } = {}) {
      const blockers = state.aiBlockers || {};
      const entries = Object.entries(blockers).filter(([, count]) => Number.isFinite(count) && count > 0);
      if (!entries.length) return 'AI Blockers: None';
      entries.sort((a, b) => b[1] - a[1]);
      const lines = entries.slice(0, maxItems).map(([key, count]) => `${key} (${count})`);
      const extra = entries.length - lines.length;
      return `AI Blockers:\n${lines.join('\n')}${extra > 0 ? `\n+${extra} more` : ''}`;
    }

    function buildAiDebugExport() {
      const blockers = state.aiBlockers || {};
      const crew = Array.isArray(state.npcs) ? state.npcs.map((n) => ({
        id: n.id,
        name: n.name,
        role: npcRole(n),
        onDuty: n.onDuty,
        paused: n.paused,
        task: n.task ? { key: n.task.key, label: n.task.label, targetType: n.task.targetType } : null,
        hunger: n.hunger
      })) : [];
      return {
        timestamp: new Date().toISOString(),
        blockers,
        crew,
        crewAI: state.crewAI,
        incidents: state.incidents,
        inventory: state.inventory,
        powerProfile: state.powerProfile,
        stats: {
          power: state.power,
          oxygen: state.oxygen,
          heat: state.heat,
          hull: state.hull,
          hullMax: state.hullMax,
          morale: state.morale,
          credits: state.credits,
          reputation: state.reputation
        }
      };
    }

    function reportAiBlocker(reason) {
      const key = String(reason || '').trim();
      if (!key) return false;
      if (!state.aiBlockers || typeof state.aiBlockers !== 'object') state.aiBlockers = {};
      if (!state.meta || typeof state.meta !== 'object') state.meta = { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 };
      if (!state.meta.aiBlockerAt || typeof state.meta.aiBlockerAt !== 'object') state.meta.aiBlockerAt = {};
      const now = Date.now();
      const last = state.meta.aiBlockerAt[key] || 0;
      if (now - last < 3000) return false;
      state.meta.aiBlockerAt[key] = now;
      state.aiBlockers[key] = Math.max(0, Math.floor(safeNumber(state.aiBlockers[key], 0))) + 1;
      if (!corridorsWithModuleType('computer').length && state.crewAI && state.crewAI.autoBuild) {
        ensureModuleBuiltIfUnlocked('computer', 'AUTOMATION');
      }
      markDirty();
      return true;
    }

    let AI_ACTIONS_CACHE = null;

    function buildAiActions() {
      const actions = [];
      for (const [type, def] of Object.entries(MODULE_DEFS)) {
        if (!def || !Array.isArray(def.aiActions)) continue;
        for (const action of def.aiActions) {
          if (!action || !action.key) continue;
          actions.push({
            module: type,
            targetType: action.targetType || type,
            ...action
          });
        }
      }
      for (const [itemKey, recipe] of Object.entries(ITEM_RECIPES || {})) {
        if (itemKey === 'plating') continue;
        actions.push({
          key: `fabricator.craft.${itemKey}`,
          label: `Fabricate ${itemKey}`,
          module: 'fabricator',
          targetType: 'fabricator',
          roles: ['engineer', 'tech', 'quartermaster'],
          consumes: { ...recipe },
          produces: { [itemKey]: 1 },
          perform: () => craftItem(itemKey, 1, { respectReserve: true })
        });
      }
      return actions;
    }

    function getAiActions() {
      if (!AI_ACTIONS_CACHE) AI_ACTIONS_CACHE = buildAiActions();
      return AI_ACTIONS_CACHE;
    }

    function aiHasRole(npc, roles) {
      if (!roles || !roles.length) return true;
      if (npcHasRole(npc, roles)) return true;
      const anyRoleAvailable = roles.some((role) => hasCrewRole(role));
      return !anyRoleAvailable;
    }

    function aiHasModule(type) {
      return corridorsWithModuleType(type).length > 0;
    }

    function aiCanRunAction(npc, action) {
      if (!action || !aiHasModule(action.module)) return false;
      if (!aiHasRole(npc, action.roles)) return false;
      const req = action.requires || {};
      if (Number.isFinite(req.power) && state.power < req.power) return false;
      if (req.flags) {
        for (const [flag, val] of Object.entries(req.flags)) {
          if (Boolean(state[flag]) !== Boolean(val)) return false;
        }
      }
      if (typeof req.predicate === 'function' && !req.predicate()) return false;
      return true;
    }

    function aiHasInputs(action) {
      const consumes = action.consumes || {};
      for (const [key, qty] of Object.entries(consumes)) {
        const need = Math.max(0, safeNumber(qty, 0));
        if (!need) continue;
        if (key === 'credits') {
          if (state.credits < need) return false;
        } else if (invAvailableAfterReserve(key) < need) {
          return false;
        }
      }
      return true;
    }

    function shouldDeferDemandToOtherRole(npc, demandKey, actions) {
      if (!npc || !demandKey) return false;
      const candidates = (actions || getAiActions()).filter((a) => a && a.produces && a.produces[demandKey] !== undefined);
      if (!candidates.length) return false;
      const roleSet = new Set();
      for (const action of candidates) {
        if (Array.isArray(action.roles)) {
          for (const role of action.roles) roleSet.add(role);
        }
      }
      if (!roleSet.size) return false;
      const roles = [...roleSet];
      const roleAvailable = roles.some((role) => hasCrewRole(role));
      const npcEligible = roles.some((role) => npcRole(npc) === role);
      return roleAvailable && !npcEligible;
    }

    function resolveDeclarativeDemand(npc, demandKey, visited = new Set()) {
      if (!npc || !demandKey) return false;
      if (visited.has(demandKey)) return false;
      visited.add(demandKey);

      const actions = getAiActions();

      if (String(demandKey).startsWith('flag:')) {
        const flag = String(demandKey).slice(5);
        const setter = actions.find((a) => a && a.setsFlags && a.setsFlags[flag] === true);
        if (setter && aiCanRunAction(npc, setter)) {
          assignNpcTask(npc, { key: setter.key, label: setter.label, targetType: setter.targetType, onComplete: setter.perform });
          return true;
        }
        return false;
      }

      const candidates = actions.filter((a) => a && a.produces && a.produces[demandKey] !== undefined);
      if (!candidates.length) {
        reportAiBlocker(`No producer for ${demandKey}`);
        return false;
      }
      if (shouldDeferDemandToOtherRole(npc, demandKey, actions)) return false;
      candidates.sort((a, b) => (a.priority || 0) - (b.priority || 0));

      let sawMissingModule = false;
      let deferredInput = false;
      for (const action of candidates) {
        if (!aiHasModule(action.module)) {
          sawMissingModule = true;
          continue;
        }
        if (!aiCanRunAction(npc, action)) continue;

        const req = action.requires || {};
        if (req.flags) {
          for (const [flag, val] of Object.entries(req.flags)) {
            if (Boolean(state[flag]) !== Boolean(val)) {
              if (resolveDeclarativeDemand(npc, `flag:${flag}`, visited)) return true;
            }
          }
        }

        const consumes = action.consumes || {};
        let missingResolved = true;
        for (const [key, qty] of Object.entries(consumes)) {
          const need = Math.max(0, safeNumber(qty, 0));
          if (!need) continue;
          if (key === 'credits') {
            if (state.credits < need) {
              if (!resolveDeclarativeDemand(npc, 'credits', visited)) {
                if (shouldDeferDemandToOtherRole(npc, 'credits', actions)) {
                  deferredInput = true;
                  return false;
                }
                missingResolved = false;
                break;
              }
              return true;
            }
          } else if (invAvailableAfterReserve(key) < need) {
            if (!resolveDeclarativeDemand(npc, key, visited)) {
              if (shouldDeferDemandToOtherRole(npc, key, actions)) {
                deferredInput = true;
                return false;
              }
              missingResolved = false;
              break;
            }
            return true;
          }
        }
        if (!missingResolved) continue;
        if (!aiHasInputs(action)) continue;

        assignNpcTask(npc, { key: action.key, label: action.label, targetType: action.targetType, onComplete: action.perform });
        return true;
      }
      if (sawMissingModule && state.crewAI && state.crewAI.autoBuild) {
        const modules = [...new Set(candidates.map((a) => a && a.module).filter(Boolean))];
        for (const mod of modules) {
          if (ensureModuleBuiltIfUnlocked(mod, 'AUTOMATION')) return true;
        }
      }
      if (deferredInput) return false;
      if (sawMissingModule) {
        const modules = [...new Set(candidates.map((a) => a && a.module).filter(Boolean))];
        if (modules.length) reportAiBlocker(`Missing module: ${modules.join(', ')}`);
      }
      reportAiBlocker(`Blocked demand: ${demandKey}`);
      return false;
    }

    function describeInventory() {
      const inv = state.inventory || {};
      const lines = [
        `Ore: ${invGet('ore')}`,
        `Scrap: ${invGet('scrap')}`,
        `Ingots: ${invGet('ingot')}`,
        `Filters: ${invGet('filter')}`,
        `Medkits: ${invGet('medkit')}`,
        `Drone Parts: ${invGet('droneParts')}`,
        `Rations: ${invGet('rations')}`,
        `Credits: ${Math.floor(state.credits)}`
      ];
      return lines.join('\n');
    }

    function shipStatusReport() {
      const lines = [
        `Power: ${Math.round(state.power)}%`,
        `Oxygen: ${Math.round(state.oxygen)}%`,
        `Hull: ${Math.round(state.hull)}/${Math.round(state.hullMax)}`,
        `Heat: ${Math.round(state.heat)}%`,
        `Rations: ${invGet('rations')}`,
        `Morale: ${Math.round(state.morale)}%`,
        `Credits: ${Math.floor(state.credits)}`,
        `Rep: ${Math.floor(state.reputation)}`,
        `Engine: ${state.engineActive ? 'ONLINE' : 'OFFLINE'}`
      ];
      if (state.travel && state.travel.active) {
        lines.push(`Travel: ${state.travel.from} to ${state.travel.to} (${Math.ceil(state.travel.remaining)} AU)`);
      }
      return lines.join('\n');
    }

    function queueNotification(title, description) {
      if (!Array.isArray(state.notifications)) state.notifications = [];
      state.notifications.push({ title: String(title || ''), description: String(description || ''), ts: Date.now() });
      if (state.notifications.length > 30) state.notifications.splice(0, state.notifications.length - 30);
      markDirty();
    }

    function ensureCrewAI() {
      const defaults = {
        enabled: true,
        autoRepair: true,
        autoLife: true,
        autoHydro: true,
        autoRefine: true,
        autoFabricate: true,
        autoContracts: true,
        autoVentHeat: true,
        autoTravel: true,
        autoResearch: true,
        autoBuild: true,
        autoHire: false,
        minCredits: 0,
        targetCrew: 3,
        buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 2 }
      };
      if (!state.crewAI || typeof state.crewAI !== 'object') state.crewAI = { ...defaults };
      for (const k of Object.keys(defaults)) {
        if (state.crewAI[k] === undefined) state.crewAI[k] = defaults[k];
      }
      state.crewAI.autoTravel = !!state.crewAI.autoTravel;
      state.crewAI.autoResearch = !!state.crewAI.autoResearch;
      state.crewAI.autoBuild = !!state.crewAI.autoBuild;
      state.crewAI.autoHire = !!state.crewAI.autoHire;
      state.crewAI.minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI.minCredits, defaults.minCredits)));
      state.crewAI.targetCrew = Math.max(0, Math.min(MAX_CREW, Math.floor(safeNumber(state.crewAI.targetCrew, defaults.targetCrew))));
      if (!state.crewAI.buffers || typeof state.crewAI.buffers !== 'object') state.crewAI.buffers = { ...defaults.buffers };
      for (const k of Object.keys(defaults.buffers)) {
        if (state.crewAI.buffers[k] === undefined) state.crewAI.buffers[k] = defaults.buffers[k];
      }
    }

    function ensureLmStudioConfig() {
      const defaults = {
        enabled: false,
        baseUrl: 'http://localhost:1234',
        apiKey: '',
        autoLoadModel: 'zai-org/glm-4.6v-flash',
        activeModelKey: '',
        lastCallAt: 0,
        inflight: false,
        lastError: '',
        lastCaptainMessage: '',
        lastCaptainReply: '',
        pendingCaptainMessage: null,
        memory: [],
        lastMemorySearch: [],
        chatHistory: {},
        toolLog: []
      };
      if (!state.lmStudio || typeof state.lmStudio !== 'object') state.lmStudio = { ...defaults };
      for (const k of Object.keys(defaults)) {
        if (state.lmStudio[k] === undefined) state.lmStudio[k] = defaults[k];
      }
      state.lmStudio.enabled = !!state.lmStudio.enabled;
      state.lmStudio.baseUrl = String(state.lmStudio.baseUrl || defaults.baseUrl).trim() || defaults.baseUrl;
      state.lmStudio.apiKey = String(state.lmStudio.apiKey || '').trim();
      state.lmStudio.autoLoadModel = String(state.lmStudio.autoLoadModel || defaults.autoLoadModel).trim() || defaults.autoLoadModel;
      if (!Number.isFinite(state.lmStudio.lastCallAt)) state.lmStudio.lastCallAt = 0;
      if (typeof state.lmStudio.inflight !== 'boolean') state.lmStudio.inflight = false;
      if (typeof state.lmStudio.lastError !== 'string') state.lmStudio.lastError = '';
      if (typeof state.lmStudio.lastCaptainMessage !== 'string') state.lmStudio.lastCaptainMessage = '';
      if (typeof state.lmStudio.lastCaptainReply !== 'string') state.lmStudio.lastCaptainReply = '';
      if (state.lmStudio.pendingCaptainMessage && typeof state.lmStudio.pendingCaptainMessage !== 'object') {
        state.lmStudio.pendingCaptainMessage = null;
      }
      if (!Array.isArray(state.lmStudio.memory)) state.lmStudio.memory = [];
      if (!Array.isArray(state.lmStudio.lastMemorySearch)) state.lmStudio.lastMemorySearch = [];
      if (!state.lmStudio.chatHistory || typeof state.lmStudio.chatHistory !== 'object') {
        state.lmStudio.chatHistory = {};
      }
      if (!Array.isArray(state.lmStudio.toolLog)) state.lmStudio.toolLog = [];
    }

    function lmStudioLogEvent(kind, payload) {
      if (!state.lmStudio) return;
      const entry = {
        kind: String(kind || 'event'),
        at: Date.now(),
        payload
      };
      state.lmStudio.toolLog.push(entry);
      if (state.lmStudio.toolLog.length > 60) {
        state.lmStudio.toolLog = state.lmStudio.toolLog.slice(-60);
      }
      if (typeof console !== 'undefined') {
        if (typeof console.log === 'function') {
          console.log('[LMStudio]', entry.kind, entry.payload);
        }
      }
    }

    function currentSystem() {
      const sys = state.location && typeof state.location === 'object' ? state.location.system : null;
      return typeof sys === 'string' && sys.length ? sys : 'SOL';
    }

    function listDestinations(from) {
      const edges = SYSTEM_GRAPH[from];
      if (!edges || typeof edges !== 'object') return [];
      return Object.keys(edges).sort();
    }

    function distanceBetween(from, to) {
      const edges = SYSTEM_GRAPH[from];
      if (!edges || typeof edges !== 'object') return null;
      const d = edges[to];
      return Number.isFinite(d) ? d : null;
    }

    function findShortestPath(from, to) {
      const start = String(from || '').toUpperCase();
      const goal = String(to || '').toUpperCase();
      if (!start || !goal) return null;
      if (start === goal) return [start];

      const dist = {};
      const prev = {};
      const visited = new Set();
      const nodes = Object.keys(SYSTEM_GRAPH);
      for (const n of nodes) dist[n] = Infinity;
      if (!(start in dist)) dist[start] = Infinity;
      dist[start] = 0;

      while (true) {
        let current = null;
        let best = Infinity;
        for (const n of Object.keys(dist)) {
          if (!visited.has(n) && dist[n] < best) {
            best = dist[n];
            current = n;
          }
        }
        if (!current) break;
        if (current === goal) break;
        visited.add(current);
        const edges = SYSTEM_GRAPH[current] || {};
        for (const [next, w] of Object.entries(edges)) {
          const cand = dist[current] + safeNumber(w, Infinity);
          if (cand < dist[next]) {
            dist[next] = cand;
            prev[next] = current;
          }
        }
      }

      if (!(goal in dist) || dist[goal] === Infinity) return null;
      const path = [];
      let cur = goal;
      while (cur) {
        path.push(cur);
        cur = prev[cur] || null;
      }
      if (path[path.length - 1] !== start) return null;
      path.reverse();
      return path;
    }

    function startTravel(to) {
      const from = currentSystem();
      const dest = String(to || '').toUpperCase();
      const d = distanceBetween(from, dest);
      if (!d) {
        showMessage('NAVIGATION', 'No valid route.');
        return false;
      }
      state.travel = { active: true, from, to: dest, remaining: d, total: d };
      markDirty();
      showMessage('NAVIGATION', `Course plotted: ${from} to ${dest}. Distance: ${d} AU.`);
      return true;
    }

    function startTravelAuto(to, source = 'AUTOPILOT') {
      const from = currentSystem();
      const dest = String(to || '').toUpperCase();
      const d = distanceBetween(from, dest);
      if (!d) return false;
      if (!state.engineActive) state.engineActive = true;
      state.travel = { active: true, from, to: dest, remaining: d, total: d };
      markDirty();
      queueNotification('NAVIGATION', `Course plotted: ${from} to ${dest} (${String(source)}).`);
      return true;
    }

    function cancelTravel() {
      if (!state.travel || !state.travel.active) return false;
      state.travel = { active: false, from: currentSystem(), to: null, remaining: 0, total: 0 };
      markDirty();
      showMessage('NAVIGATION', 'Course cancelled.');
      return true;
    }

    function bestAutoDestination() {
      const sys = currentSystem();
      const destinations = listDestinations(sys);
      return destinations.length ? destinations[0] : sys;
    }

    function ensureAnomaliesArray() {
      if (!Array.isArray(state.anomalies)) state.anomalies = [];
      if (state.anomalies.length > 50) state.anomalies.splice(0, state.anomalies.length - 50);
    }

    function addAnomaly({ system, name, kind }) {
      ensureAnomaliesArray();
      const a = {
        id: 'anom-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
        system: String(system || currentSystem()),
        name: String(name || 'Unknown Signal'),
        kind: String(kind || 'signal'),
        resolved: false,
        ts: Date.now()
      };
      state.anomalies.push(a);
      markDirty();
      return a;
    }

    function rewardFromAnomaly(anomaly) {
      const kind = anomaly && anomaly.kind ? anomaly.kind : 'unknown';
      const r = Math.random();

      const maybeUnlock = (source, preferred) => {
        if (kind === 'vault' && state.blueprints && state.blueprints.recipes && !state.blueprints.recipes.plating) {
          return unlockRecipeBlueprint('plating', source);
        }
        return !!unlockModuleBlueprint(randomLockedModuleType(), source);
      };

      if (kind === 'derelict') {
        invAdd('scrap', 5);
        if (r < 0.55) maybeUnlock('DERELICT', ['drones', 'refinery', 'airlock', 'workshop']);
        return 'Recovered salvage: +5 scrap.';
      }

      if (kind === 'signal') {
        invAdd('ore', 4);
        if (r < 0.55) maybeUnlock('SIGNAL', ['comms', 'shields', 'medbay']);
        return 'Recovered minerals: +4 ore.';
      }

      if (kind === 'vault') {
        invAdd('ingot', 2);
        if (r < 0.7) maybeUnlock('VAULT', ['workshop', 'medbay', 'comms', 'shields']);
        return 'Recovered alloys: +2 ingots.';
      }

      invAdd('scrap', 2);
      if (r < 0.35) maybeUnlock('ANOMALY', null);
      return 'Recovered fragments: +2 scrap.';
    }

    function randomLockedModuleType(preferred = null) {
      const all = Object.keys(MODULE_DEFS).filter((t) => !isModuleUnlocked(t) && !['rear', 'front', 'doorway', 'elevator', 'empty'].includes(t));
      if (!all.length) return null;
      if (Array.isArray(preferred) && preferred.length) {
        const pool = all.filter((t) => preferred.includes(t));
        if (pool.length) return pool[(Math.random() * pool.length) | 0];
      }
      return all[(Math.random() * all.length) | 0];
    }

    function resolveAnomaly(anomaly, showPanel = true) {
      if (!anomaly || anomaly.resolved) return false;
      anomaly.resolved = true;
      const msg = rewardFromAnomaly(anomaly);
      markDirty();
      if (showPanel) showMessage('ANOMALY', `${anomaly.name}\n${msg}`);
      return true;
    }

    function scanForAnomalies(showPanel = true) {
      const sys = currentSystem();
      const messages = [];
      const hasPower = state.power >= 5;
      if (!hasPower) {
        // Emergency low-power sweep to avoid early-game deadlock.
        messages.push('Low power sweep engaged.');
      } else {
        state.power = Math.max(0, state.power - 5);
      }

      const existing = Array.isArray(state.anomalies) ? state.anomalies.filter((a) => a && a.system === sys && !a.resolved) : [];
      if (existing.length) {
        messages.push(`${existing.length} unresolved anomaly/anomalies detected in ${sys}.`);
      }

      const roll = Math.random();
      if (hasPower && roll < 0.6) {
        const kind = roll < 0.25 ? 'vault' : 'derelict';
        const name = kind === 'vault' ? 'Vault Signal' : 'Derelict Beacon';
        addAnomaly({ system: sys, name, kind });
        messages.push(`Signal discovered: ${name}.`);
      }

      // Always yield some salvage so scans are a reliable early-game starter.
      const salvageRoll = Math.random();
      if (salvageRoll < 0.6) {
        invAdd('scrap', 2);
        messages.push('Sweep complete. Recovered 2 scrap.');
      } else if (salvageRoll < 0.9) {
        invAdd('ore', 2);
        messages.push('Sweep complete. Recovered 2 ore.');
      } else {
        invAdd('scrap', 1);
        invAdd('ore', 1);
        messages.push('Sweep complete. Recovered 1 scrap and 1 ore.');
      }

      if (showPanel && messages.length) {
        showMessage('SENSORS', messages.join('\n'));
      }
    }

    function deepScanBlueprint(showPanel = true) {
      if (state.power < 12) {
        if (showPanel) showMessage('SENSORS', 'Need at least 12 power.');
        return false;
      }
      if (!invHas('scrap', 2)) {
        if (showPanel) showMessage('SENSORS', 'Need 2 scrap to calibrate the array.');
        return false;
      }
      state.power = Math.max(0, state.power - 12);
      invTake('scrap', 2);

      const locked = listLockedAdvancedModuleTypes();
      let unlocked = false;
      if (locked.length) {
        const pick = locked[(Math.random() * locked.length) | 0];
        unlocked = unlockModuleBlueprint(pick, 'DEEP SCAN');
      } else if (state.blueprints && state.blueprints.recipes && !state.blueprints.recipes.plating) {
        unlocked = unlockRecipeBlueprint('plating', 'DEEP SCAN');
      }

      if (showPanel) {
        showMessage('SENSORS', unlocked ? 'Blueprint data recovered.' : 'No new signatures found.');
      }
      return unlocked;
    }

    function openAnomalyPanel(anomaly) {
      if (!anomaly) return;
      const sys = currentSystem();
      if (anomaly.system !== sys) {
        showMessage('ANOMALY', `This anomaly is in ${anomaly.system}. Current system: ${sys}.`);
        return;
      }

      const status = anomaly.resolved ? 'RESOLVED' : 'UNRESOLVED';
      let overview = `System: ${anomaly.system}\nSignature: ${anomaly.name}\nType: ${String(anomaly.kind).toUpperCase()}\nStatus: ${status}\n\n`;
      overview += anomaly.resolved ? 'This anomaly has been resolved.' : 'Unidentified spatial anomaly detected.';

      const buttons = [];
      if (!anomaly.resolved) {
        buttons.push({
          label: 'Investigate (Cost: 10 power)',
          action: () => {
            investigateAnomaly(anomaly, true);
          }
        });
      }

      openPanel('ANOMALY', overview, buttons, { includeCancel: true });
    }

    function investigateAnomaly(anomaly, showPanel = true) {
      if (!anomaly || anomaly.resolved) return false;
      if (state.power < 10) {
        if (showPanel) showMessage('ANOMALY', 'Need at least 10 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 10);
      resolveAnomaly(anomaly, showPanel);
      return true;
    }

    function ensureContracts() {
      if (!state.contract || typeof state.contract !== 'object') state.contract = { available: [], active: null };
      if (!Array.isArray(state.contract.available)) state.contract.available = [];
      if (state.contract.available.length >= 3) return;

      const mk = (id, title, requires, reward) => ({ id, title, requires, reward });
      const base = Date.now().toString(36).slice(-4);
      const pool = [
        mk(`c-${base}-ore`, 'Deliver Ore', { ore: 6 }, { credits: 40, reputation: 2 }),
        mk(`c-${base}-scrap`, 'Deliver Scrap', { scrap: 8 }, { credits: 55, reputation: 2 }),
        mk(`c-${base}-ingot`, 'Deliver Ingots', { ingot: 4 }, { credits: 80, reputation: 3 }),
        mk(`c-${base}-med`, 'Medical Supplies', { medkit: 2 }, { credits: 70, reputation: 4 }),
        mk(`c-${base}-filters`, 'Life Support Filters', { filter: 3 }, { credits: 45, reputation: 3 })
      ];

      while (state.contract.available.length < 3 && pool.length) {
        const pick = pool.splice((Math.random() * pool.length) | 0, 1)[0];
        state.contract.available.push(pick);
      }
      markDirty();
    }

    function contractReady(contract, { respectReserve = false } = {}) {
      if (!contract || !contract.requires || typeof contract.requires !== 'object') return false;
      for (const k of Object.keys(contract.requires)) {
        const need = contract.requires[k];
        if (respectReserve) {
          if (invAvailableAfterReserve(k) < need) return false;
        } else if (invGet(k) < need) {
          return false;
        }
      }
      return true;
    }

    function applyContractCompletion(contract, { respectReserve = false } = {}) {
      if (!contractReady(contract, { respectReserve })) return false;
      for (const k of Object.keys(contract.requires || {})) {
        if (!invTake(k, contract.requires[k])) return false;
      }
      const reward = contract.reward || {};
      state.credits = Math.max(0, safeNumber(state.credits, 0) + safeNumber(reward.credits, 0));
      state.reputation = Math.max(0, safeNumber(state.reputation, 0) + safeNumber(reward.reputation, 0));
      markDirty();
      updateHUD();
      return true;
    }

    function activeContractNeeds() {
      const c = state.contract && state.contract.active ? state.contract.active : null;
      if (!c || !c.requires || typeof c.requires !== 'object') return null;
      const needs = {};
      for (const k of Object.keys(c.requires)) {
        const need = Math.max(0, safeNumber(c.requires[k], 0));
        const have = invAvailableAfterReserve(k);
        const missing = Math.max(0, need - have);
        if (missing > 0) needs[k] = missing;
      }
      return needs;
    }

    function ensureModuleBuiltIfUnlocked(type, source = 'CREW') {
      if (corridorsWithModuleType(type).length) return true;
      if (!isModuleUnlocked(type)) return false;
      if (type !== 'fabricator' && !corridorsWithModuleType('fabricator').length) return false;
      let targetLevel = state.currentLevel;
      let targetCorridor = state.currentCorridor;
      if (String(source) === 'AUTOMATION') {
        const groupKey = moduleGroupForType(type);
        const hub = getAutoBuildHubCorridor();
        if (groupKey && groupKey !== 'hub') {
          const grouped = ensureGroupCorridor(groupKey, hub.level, hub.corridor);
          if (grouped) {
            targetLevel = grouped.level;
            targetCorridor = grouped.corridor;
          } else {
            targetLevel = hub.level;
            targetCorridor = hub.corridor;
          }
        } else {
          targetLevel = hub.level;
          targetCorridor = hub.corridor;
        }
      }
      const modules = getModulesForCorridor(targetLevel, targetCorridor);
      insertModuleAtInCorridor(targetLevel, targetCorridor, modules.length, { type, label: MODULE_DEFS[type] ? MODULE_DEFS[type].label : type });
      queueNotification('FABRICATOR', `${MODULE_DEFS[type] ? MODULE_DEFS[type].label : type} fabricated (${String(source)}).`);
      updateDoorwayLabelsForAll();
      relayoutCorridor();
      updateHUD();
      return true;
    }

    function pickAutoBuildTarget({
      needs,
      wantsScrap,
      wantsOre,
      wantsIngots,
      wantsFilters,
      wantsMedkits,
      wantsDroneParts,
      wantsRations
    }) {
      const has = (type) => corridorsWithModuleType(type).length > 0;
      const canBuild = (type) => isModuleUnlocked(type) && !has(type) && corridorsWithModuleType('fabricator').length > 0;
      const hasSellableSurplus = () => (
        invAvailableAfterReserve('ingot') > 0
        || invAvailableAfterReserve('scrap') > 0
        || invAvailableAfterReserve('ore') > (has('refinery') ? 2 : 0)
        || invAvailableAfterReserve('rations') > 0
      );

      const supplyChainTargetFor = (itemKey, visited = new Set(), depth = 0) => {
        if (!itemKey || depth > 4) return null;
        if (visited.has(itemKey)) return null;
        visited.add(itemKey);

        if (itemKey === 'scrap' || itemKey === 'ore') {
          if (canBuild('sensors')) return 'sensors';
          if (canBuild('drones')) return 'drones';
          return null;
        }

        if (itemKey === 'ingot') {
          if (canBuild('refinery')) return 'refinery';
          return supplyChainTargetFor('ore', visited, depth + 1);
        }

        const recipe = ITEM_RECIPES[itemKey];
        if (recipe) {
          if (canBuild('fabricator')) return 'fabricator';
          for (const [mat, qty] of Object.entries(recipe)) {
            if (invAvailableAfterReserve(mat) < qty) {
              const target = supplyChainTargetFor(mat, visited, depth + 1);
              if (target) return target;
            }
          }
        }

        return null;
      };

      const supplyChainGoal = () => {
        const goals = [];
        if (wantsDroneParts) goals.push('droneParts');
        if (wantsFilters) goals.push('filter');
        if (wantsMedkits) goals.push('medkit');
        if (wantsRations) goals.push('rations');
        if (wantsIngots) goals.push('ingot');
        if (wantsScrap) goals.push('scrap');
        if (wantsOre) goals.push('ore');
        for (const g of goals) {
          const target = supplyChainTargetFor(g);
          if (target && canBuild(target)) return target;
        }
        return null;
      };

      const supplyTarget = supplyChainGoal();
      if (supplyTarget) return supplyTarget;

      if (countHungryCrew() > 0 && canBuild('canteen')) return 'canteen';

      if (state.crewAI.autoHire) {
        const fee = 30;
        if (state.credits < fee && !hasSellableSurplus()) {
          if (canBuild('sensors')) return 'sensors';
          if (canBuild('drones')) return 'drones';
          if (canBuild('cargo')) return 'cargo';
        }
      }

      if (state.crewAI.autoHire && canBuild('quarters')) return 'quarters';
      if (state.crewAI.autoContracts && canBuild('comms')) return 'comms';
      if ((wantsFilters || wantsMedkits || wantsDroneParts || wantsRations) && canBuild('fabricator')) return 'fabricator';
      if ((wantsIngots || wantsDroneParts) && canBuild('refinery')) return 'refinery';
      if ((wantsScrap || wantsOre) && canBuild('sensors')) return 'sensors';
      if ((wantsScrap || wantsOre || state.crewAI.autoRepair) && canBuild('drones')) return 'drones';
      if ((state.hull < state.hullMax * 0.9 || (state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating)) && canBuild('workshop')) return 'workshop';
      if (state.oxygen < 80 && canBuild('life')) return 'life';
      if (invGet('rations') < invReserve('rations') && canBuild('hydro')) return 'hydro';
      if (state.morale < 70 && canBuild('medbay')) return 'medbay';
      if ((state.incidents && (state.incidents.breach || state.incidents.fire)) && canBuild('shields')) return 'shields';
      if ((state.incidents && state.incidents.breach) && canBuild('airlock')) return 'airlock';
      if (state.credits < 20 && canBuild('cargo')) return 'cargo';

      return null;
    }

    function autoManageContracts() {
      ensureContracts();
      if (state.contract.active) {
        if (applyContractCompletion(state.contract.active, { respectReserve: true })) {
          state.contract.active = null;
          ensureContracts();
        }
        return;
      }
      const list = Array.isArray(state.contract.available) ? state.contract.available.filter(Boolean) : [];
      if (list.length) {
        let best = list[0];
        let bestScore = Infinity;
        for (const c of list) {
          let score = 0;
          for (const [k, v] of Object.entries(c.requires || {})) {
            const need = Math.max(0, safeNumber(v, 0));
            const have = invAvailableAfterReserve(k);
            score += Math.max(0, need - have);
          }
          if (score < bestScore) {
            bestScore = score;
            best = c;
          }
        }
        state.contract.active = best;
        state.contract.available = list.filter((x) => x && x.id !== best.id);
        ensureContracts();
      }
    }

    function openCargoTradePanel() {
      const sell = (key, price) => {
        if (!invHas(key, 1)) {
          showMessage('CARGO', `No ${key} to sell.`);
          return;
        }
        invTake(key, 1);
        state.credits += price;
        markDirty();
        updateHUD();
        showMessage('CARGO', `Sold 1 ${key} for ${price} cr.`);
      };
      const buy = (key, price) => {
        if (state.credits < price) {
          showMessage('CARGO', `Need ${price} credits.`);
          return;
        }
        state.credits -= price;
        invAdd(key, 1);
        markDirty();
        updateHUD();
        showMessage('CARGO', `Purchased 1 ${key} for ${price} cr.`);
      };
      openPanel(
        'CARGO TRADE',
        'Buy essentials or sell raw materials for credits.',
        [
          { label: 'Buy Filter (-10 cr)', action: () => buy('filter', 10) },
          { label: 'Buy Medkit (-25 cr)', action: () => buy('medkit', 25) },
          { label: 'Buy Drone Parts (-20 cr)', action: () => buy('droneParts', 20) },
          { label: 'Buy Rations (-8 cr)', action: () => buy('rations', 8) },
          { label: 'Sell Ore (+5 cr)', action: () => sell('ore', 5) },
          { label: 'Sell Scrap (+8 cr)', action: () => sell('scrap', 8) },
          { label: 'Sell Ingots (+15 cr)', action: () => sell('ingot', 15) },
          { label: 'Sell Rations (+4 cr)', action: () => sell('rations', 4) }
        ]
      );
    }

    function buyCargoItem(itemKey, price, { showPanel = false } = {}) {
      if (state.credits < price) {
        if (showPanel) showMessage('CARGO', `Need ${price} credits.`);
        return false;
      }
      state.credits -= price;
      invAdd(itemKey, 1);
      markDirty();
      updateHUD();
      if (showPanel) showMessage('CARGO', `Purchased 1 ${itemKey} for ${price} cr.`);
      return true;
    }

    function sellCargoItem(itemKey, price, { respectReserve = false, minKeep = 0, showPanel = false } = {}) {
      const canSell = respectReserve
        ? canSpendReservedWithMinKeep(itemKey, 1, minKeep)
        : invHas(itemKey, 1);
      if (!canSell) {
        if (showPanel) showMessage('CARGO', `No ${itemKey} to sell.`);
        return false;
      }
      invTake(itemKey, 1);
      state.credits += price;
      markDirty();
      updateHUD();
      if (showPanel) showMessage('CARGO', `Sold 1 ${itemKey} for ${price} cr.`);
      return true;
    }

    function autoSellCargo() {
      if (invGet('ingot') >= 6) {
        invTake('ingot', 2);
        state.credits += 30;
      } else if (invGet('scrap') >= 8) {
        invTake('scrap', 4);
        state.credits += 24;
      }
      markDirty();
    }

    function craftItem(itemKey, qty = 1, { respectReserve = false, showPanel = false } = {}) {
      const recipe = ITEM_RECIPES[itemKey];
      if (!recipe) {
        if (showPanel) showMessage('FABRICATOR', 'Unknown recipe.');
        return false;
      }
      for (const [k, v] of Object.entries(recipe)) {
        const need = v * qty;
        const ok = respectReserve ? canSpendReserved(k, need) : invHas(k, need);
        if (!ok) {
          if (showPanel) showMessage('FABRICATOR', `Need ${need} ${k}.`);
          return false;
        }
      }
      for (const [k, v] of Object.entries(recipe)) invTake(k, v * qty);
      invAdd(itemKey, qty);
      if (showPanel) showMessage('FABRICATOR', `Built ${qty} ${itemKey}.`);
      return true;
    }

    function autoFabricateConsumables() {
      const buffers = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : {};
      if (invGet('filter') < (buffers.filter || 0)) craftItem('filter', 1, { respectReserve: true });
      if (invGet('medkit') < (buffers.medkit || 0)) craftItem('medkit', 1, { respectReserve: true });
      if (invGet('droneParts') < (buffers.droneParts || 0)) craftItem('droneParts', 1, { respectReserve: true });
      if (invGet('rations') < (buffers.rations || 0)) craftItem('rations', 1, { respectReserve: true });
    }

    function refineOre(showPanel = true) {
      if (!invHas('ore', 3)) {
        if (showPanel) showMessage('REFINERY', 'Need 3 ore to refine.');
        return false;
      }
      invTake('ore', 3);
      invAdd('ingot', 1);
      if (showPanel) showMessage('REFINERY', 'Refined 3 ore into 1 ingot.');
      return true;
    }

    function openRefineryPanel(showPanel = true) {
      openPanel('REFINERY', 'Convert ore into ingots.', [
        { label: 'Refine 3 Ore', action: () => refineOre(showPanel) },
        { label: 'Refine 5 Ingots (15 Ore)', action: () => { let ok = true; for (let i = 0; i < 5; i++) ok = refineOre(false) && ok; if (showPanel) showMessage('REFINERY', ok ? 'Refined 5 ingots.' : 'Not enough ore.'); } }
      ]);
    }

    function toggleEngine() {
      state.engineActive = !state.engineActive;
      if (!state.engineActive) {
        state.throttle = 0;
        state.speed = 0;
      }
      markDirty();
    }

    function openThrottlePanel(context = 'NAV') {
      const thr = clamp(safeNumber(state.throttle, 0), 0, 1);
      const pct = Math.round(thr * 100);
      const mk = (p) => ({
        label: p === pct ? `Throttle: ${p}% (current)` : `Throttle: ${p}%`,
        action: () => {
          state.throttle = clamp(p / 100, 0, 1);
          markDirty();
          updateHUD();
          showMessage(context, `Throttle set to ${p}%.`);
        }
      });

      openPanel(
        `${context} — THROTTLE`,
        'Set engine throttle:',
        [mk(0), mk(25), mk(50), mk(75), mk(100), { label: 'Back', action: popMenu }],
        { includeCancel: false }
      );
    }

    function autoRoutePower() {
      if (state.power < 25 || state.oxygen < 40) {
        state.powerProfile = 'survival';
      } else if (state.engineActive && state.shieldsOn) {
        state.powerProfile = 'combat';
      } else if (state.hydroponicsOn) {
        state.powerProfile = 'industry';
      } else {
        state.powerProfile = 'balanced';
      }
      markDirty();
    }

    function resetPowerTrip(showPanel = true) {
      const cleared = resolveIncident('powerTrip');
      if (!cleared) return false;
      state.power = Math.max(state.power, 30);
      state.powerProfile = 'survival';
      state.meta.powerShedAt = Date.now();
      markDirty();
      if (showPanel) showMessage('POWER', 'Breakers reset. Emergency routing engaged.');
      return true;
    }

    function toggleLifeSupport() {
      state.lifeSupportOn = !state.lifeSupportOn;
      markDirty();
    }

    function toggleLights() {
      state.lightsOn = !state.lightsOn;
      markDirty();
    }

    function scrubOxygen(showPanel = true) {
      if (!invTake('filter', 1)) {
        if (showPanel) showMessage('LIFE', 'Need 1 filter to cycle scrubbers.');
        return false;
      }
      state.oxygen = Math.min(100, state.oxygen + 25);
      resolveIncident('o2Leak');
      markDirty();
      if (showPanel) showMessage('LIFE', 'Scrubbers cycled. Oxygen restored.');
      return true;
    }

    function emergencyScrubbers(showPanel = true) {
      if (state.power < 8) {
        if (showPanel) showMessage('LIFE', 'Need at least 8 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 8);
      if (invHas('filter', 1)) invTake('filter', 1);
      state.oxygen = Math.min(100, state.oxygen + 35);
      resolveIncident('o2Leak');
      markDirty();
      if (showPanel) showMessage('LIFE', 'Emergency scrubbers activated.');
      return true;
    }

    function toggleHydroponics() {
      state.hydroponicsOn = !state.hydroponicsOn;
      markDirty();
    }

    function harvestHydroponics(showPanel = true) {
      if (!state.hydroponicsOn) {
        if (showPanel) showMessage('HYDRO', 'Hydroponics are offline.');
        return false;
      }
      if (state.power < 4) {
        if (showPanel) showMessage('HYDRO', 'Need at least 4 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 4);
      invAdd('rations', 2);
      markDirty();
      if (showPanel) showMessage('HYDRO', 'Harvest complete: +2 rations.');
      return true;
    }

    function treatInjury(showPanel = true) {
      if (!invTake('medkit', 1)) {
        if (showPanel) showMessage('MEDBAY', 'Need a medkit.');
        return false;
      }
      state.morale = 100;
      markDirty();
      updateHUD();
      if (showPanel) showMessage('MEDBAY', 'Crew treated. Morale improved.');
      return true;
    }

    function restCrew(showPanel = true) {
      if (!invHas('rations', 1)) {
        if (showPanel) showMessage('QUARTERS', 'No rations available.');
        return false;
      }
      invTake('rations', 1);
      state.morale = Math.min(100, state.morale + 22);
      markDirty();
      if (showPanel) showMessage('QUARTERS', 'Crew rested. Morale improved.');
      return true;
    }

    function toggleShields() {
      state.shieldsOn = !state.shieldsOn;
      markDirty();
    }

    function sealBulkheads(showPanel = true) {
      if (!state.incidents.breach) {
        if (showPanel) showMessage('SHIELDS', 'Bulkheads sealed. No breach detected.');
        return false;
      }
      if (state.power < 6) {
        if (showPanel) showMessage('SHIELDS', 'Need at least 6 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 6);
      resolveIncident('breach');
      markDirty();
      if (showPanel) showMessage('SHIELDS', 'Bulkheads sealed. Breach contained.');
      return true;
    }

    function repairHull(showPanel = true) {
      if (!invHas('ingot', 1) && !invHas('scrap', 2)) {
        if (showPanel) showMessage('WORKSHOP', 'Need 1 ingot or 2 scrap for repairs.');
        return false;
      }
      if (invHas('ingot', 1)) invTake('ingot', 1);
      else invTake('scrap', 2);
      state.hull = Math.min(state.hullMax, state.hull + 20);
      resolveIncident('breach');
      markDirty();
      if (showPanel) showMessage('WORKSHOP', 'Hull patched.');
      return true;
    }

    function autoInstallUpgrade() {
      if (state.hullMax >= 160) return;
      if (!invHas('ingot', 2)) return;
      invTake('ingot', 2);
      state.hullMax = Math.min(200, state.hullMax + 10);
      state.hull = Math.min(state.hullMax, state.hull + 10);
      markDirty();
    }

    function installHullPlating(showPanel = true) {
      if (!state.blueprints || !state.blueprints.recipes || !state.blueprints.recipes.plating) {
        if (showPanel) showMessage('WORKSHOP', 'Plating blueprint not unlocked.');
        return false;
      }
      if (!invHas('ingot', 2)) {
        if (showPanel) showMessage('WORKSHOP', 'Need 2 ingots for hull plating.');
        return false;
      }
      invTake('ingot', 2);
      state.hullMax = Math.min(220, state.hullMax + 12);
      state.hull = Math.min(state.hullMax, state.hull + 12);
      markDirty();
      if (showPanel) showMessage('WORKSHOP', 'Hull plating installed.');
      return true;
    }

    function openWorkshopPanel() {
      openPanel('WORKSHOP', 'Install upgrades using ingots.', [
        {
          label: 'Reinforce Hull (2 ingots)',
          action: () => {
            if (!invHas('ingot', 2)) {
              showMessage('WORKSHOP', 'Need 2 ingots.');
              return;
            }
            invTake('ingot', 2);
            state.hullMax = Math.min(200, state.hullMax + 10);
            state.hull = Math.min(state.hullMax, state.hull + 10);
            markDirty();
            showMessage('WORKSHOP', 'Hull reinforcement installed.');
          }
        },
        {
          label: 'Power Cell Upgrade (2 ingots)',
          action: () => {
            if (!invHas('ingot', 2)) {
              showMessage('WORKSHOP', 'Need 2 ingots.');
              return;
            }
            invTake('ingot', 2);
            state.power = Math.min(150, state.power + 15);
            markDirty();
            showMessage('WORKSHOP', 'Power cells upgraded.');
          }
        }
      ]);
    }

    function launchRepairDrone(showPanel = true) {
      if (!invTake('droneParts', 1)) {
        if (showPanel) showMessage('DRONES', 'Need drone parts.');
        return false;
      }
      if (state.power < 6) {
        if (showPanel) showMessage('DRONES', 'Need at least 6 power.');
        invAdd('droneParts', 1);
        return false;
      }
      state.power = Math.max(0, state.power - 6);
      resolveIncident('breach');
      resolveIncident('fire');
      state.hull = Math.min(state.hullMax, state.hull + 12);
      markDirty();
      if (showPanel) showMessage('DRONES', 'Repair drone completed remote fixes.');
      return true;
    }

    function launchSalvageDrone(showPanel = true) {
      if (!invTake('droneParts', 1)) {
        if (showPanel) showMessage('DRONES', 'Need drone parts.');
        return false;
      }
      if (state.power < 6) {
        if (showPanel) showMessage('DRONES', 'Need at least 6 power.');
        invAdd('droneParts', 1);
        return false;
      }
      state.power = Math.max(0, state.power - 6);
      invAdd('scrap', 3);
      if (Math.random() < 0.4) invAdd('ore', 2);
      markDirty();
      if (showPanel) showMessage('DRONES', 'Salvage drone recovered scrap.');
      return true;
    }

    function performEvaRepair(showPanel = true) {
      if (state.oxygen < 10) {
        if (showPanel) showMessage('AIRLOCK', 'Need at least 10 oxygen.');
        return false;
      }
      if (!invHas('scrap', 2)) {
        if (showPanel) showMessage('AIRLOCK', 'Need 2 scrap for EVA patch.');
        return false;
      }
      invTake('scrap', 2);
      state.oxygen = Math.max(0, state.oxygen - 10);
      const risk = Math.random();
      if (risk < 0.2) {
        state.morale = Math.max(0, state.morale - 6);
        if (showPanel) showMessage('AIRLOCK', 'EVA stressful. Morale down.');
      }
      state.hull = Math.min(state.hullMax, state.hull + 25);
      resolveIncident('breach');
      markDirty();
      if (showPanel) showMessage('AIRLOCK', 'External hull patched.');
      return true;
    }

    function openAirlockPanel(showPanel = true) {
      openPanel('AIRLOCK', 'Perform external operations.', [
        { label: 'EVA Repair (2 scrap)', action: () => performEvaRepair(showPanel) }
      ]);
    }

    function openDronePanel(showPanel = true) {
      openPanel('DRONE BAY', 'Deploy a drone for salvage or repairs.', [
        { label: 'Launch Repair Drone (1 part)', action: () => launchRepairDrone(showPanel) },
        { label: 'Launch Salvage Drone (1 part)', action: () => launchSalvageDrone(showPanel) }
      ]);
    }

    function toggleShieldsPower() {
      if (!state.shieldsOn) return 0;
      return 0.3;
    }

    // ============================================================================
    // Generalized Menu System
    // ============================================================================

    /**
     * Opens a structured menu with distinct item types.
     * @param {Object} menuConfig
     * @param {string} menuConfig.title - Menu title
     * @param {string} menuConfig.overview - Brief description
     * @param {Array} menuConfig.items - Menu items (settings, actions, dividers)
     * @param {Array} menuConfig.actions - Bottom action bar buttons
     */


    function setupMenuKeyboardNavigation(panel, menuItemsEl, actionsBarEl) {
      // Remove any previous keyboard handler
      if (panel.menuKeyHandler) {
        panel.removeEventListener('keydown', panel.menuKeyHandler);
      }

      panel.menuKeyHandler = (e) => {
        // Get all visible buttons (only those in visible containers)
        const allButtons = Array.from(panel.querySelectorAll('button')).filter(btn => {
          return btn.offsetParent !== null; // offsetParent is null if element or ancestor is display:none
        });
        const activeEl = document.activeElement;
        const activeIndex = allButtons.indexOf(activeEl);

        if (e.key === 'Escape') {
          e.preventDefault();
          popUnifiedMenu();
        } else if (e.key === 'ArrowUp' || (e.key === 'Tab' && e.shiftKey)) {
          e.preventDefault();
          if (allButtons.length === 0) return;
          const prevIndex = activeIndex <= 0 ? allButtons.length - 1 : activeIndex - 1;
          allButtons[prevIndex].focus();
        } else if (e.key === 'ArrowDown' || e.key === 'Tab') {
          e.preventDefault();
          if (allButtons.length === 0) return;
          const nextIndex = activeIndex < 0 || activeIndex >= allButtons.length - 1 ? 0 : activeIndex + 1;
          allButtons[nextIndex].focus();
        } else if (e.key === 'Enter' || e.key === ' ') {
          // Activate the focused button
          if (activeEl && activeEl.tagName === 'BUTTON') {
            e.preventDefault();
            activeEl.click();
          }
        }
      };

      panel.addEventListener('keydown', panel.menuKeyHandler);

      // Auto-focus first button or restore previously focused button
      // Use requestAnimationFrame for more reliable focus after DOM updates
      requestAnimationFrame(() => {
        const allButtons = Array.from(panel.querySelectorAll('button')).filter(btn => {
          return btn.offsetParent !== null;
        });
        if (allButtons.length === 0) return;
        
        // Try to restore focus to the button that was focused before menu refresh
        if (state.ui.focusedButtonLabel) {
          const focusedButton = allButtons.find(btn => btn.textContent === state.ui.focusedButtonLabel);
          if (focusedButton) {
            focusedButton.focus();
            return;
          }
        }
        
        // Fall back to first button if no previous focus or button not found
        allButtons[0].focus();
      });
    }

    // ============================================================================
    // End Generalized Menu System
    // ============================================================================

    function incidentLabel(kind) {
      if (kind === 'powerTrip') return 'POWER TRIP';
      if (kind === 'o2Leak') return 'O2 LEAK';
      if (kind === 'fire') return 'FIRE';
      if (kind === 'breach') return 'HULL BREACH';
      return String(kind || '').toUpperCase();
    }

    function anyActiveIncident() {
      const inc = state.incidents || {};
      return !!(inc.powerTrip || inc.o2Leak || inc.fire || inc.breach);
    }

    function resolveIncident(kind) {
      if (!state.incidents || typeof state.incidents !== 'object') return false;
      if (!state.incidents[kind]) return false;
      state.incidents[kind] = false;
      markDirty();
      return true;
    }

    function triggerIncident(kind) {
      if (!state.incidents || typeof state.incidents !== 'object') state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
      if (state.incidents[kind]) return false;
      state.incidents[kind] = true;
      queueNotification('ALERT', incidentLabel(kind));
      markDirty();
      return true;
    }

    function renderPanelButtons(buttonsEl, buttons) {
      buttonsEl.innerHTML = '';
      for (const b of (buttons || [])) {
        const btn = document.createElement('button');
        btn.className = `panel-btn${b.danger ? ' danger' : ''}`;
        btn.textContent = b.label;
        btn.addEventListener('click', () => {
          if (typeof b.action === 'function') b.action();
        });
        buttonsEl.appendChild(btn);
      }
    }

    function showPanel({
      title,
      description,
      buttons = [],
      includeCancel = true,
      cancelLabel = 'Close',
      allowImmediate = false,
      textarea = null,
      input = null,
      table = null
    }) {
      const panel = document.getElementById('interactPanel');
      const titleEl = document.getElementById('panelTitle');
      const descEl = document.getElementById('panelDescription');
      const tableEl = document.getElementById('panelTable');
      const textareaEl = document.getElementById('panelTextarea');
      const inputEl = document.getElementById('panelInput');
      const buttonsEl = document.getElementById('panelButtons');
      const menuItemsEl = document.getElementById('panelMenuItems');
      const actionsBarEl = document.getElementById('panelActionsBar');

      // Save current scroll position before modifying content (for panels that reopen themselves)
      const currentScrollPos = panel.scrollTop;
      const wasAlreadyOpen = panel.style.display === 'block';

      titleEl.textContent = title;
      descEl.textContent = description;

      // Hide structured menu elements since this is using the old panel system
      if (menuItemsEl) menuItemsEl.style.display = 'none';
      if (actionsBarEl) actionsBarEl.style.display = 'none';
      
      // Show the buttons element for the old panel system
      buttonsEl.style.display = 'block';

      if (tableEl) {
        if (table && Array.isArray(table)) {
          tableEl.innerHTML = '';
          for (const [label, value] of table) {
            const row = tableEl.insertRow();
            const cell1 = row.insertCell(0);
            const cell2 = row.insertCell(1);
            cell1.textContent = label;
            cell2.textContent = value;
          }
          tableEl.style.display = 'table';
        } else {
          tableEl.style.display = 'none';
          tableEl.innerHTML = '';
        }
      }

      if (textareaEl) {
        if (textarea) {
          textareaEl.style.display = 'block';
          textareaEl.value = textarea.value || '';
          textareaEl.placeholder = textarea.placeholder || '';
          textareaEl.readOnly = !!textarea.readOnly;
        } else {
          textareaEl.style.display = 'none';
        }
      }

      if (inputEl) {
        if (input) {
          inputEl.style.display = 'block';
          inputEl.value = input.value || '';
          inputEl.placeholder = input.placeholder || '';
          inputEl.readOnly = !!input.readOnly;
        } else {
          inputEl.style.display = 'none';
        }
      }

      renderPanelButtons(buttonsEl, buttons);

      if (includeCancel) {
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'panel-btn';
        cancelBtn.textContent = cancelLabel;
        cancelBtn.addEventListener('click', closePanel);
        buttonsEl.appendChild(cancelBtn);
      }

      panel.style.display = 'block';
      state.ui.panelOpen = true;
      state.ui.justOpenedPanel = !allowImmediate;

      // Restore scroll position
      if (wasAlreadyOpen) {
        // Panel was already open and being refreshed - use the current scroll position
        setTimeout(() => {
          panel.scrollTop = currentScrollPos;
        }, 0);
      } else if (state.ui.panelScrollPositions[title]) {
        // Panel was closed and reopened - restore saved scroll position
        setTimeout(() => {
          panel.scrollTop = state.ui.panelScrollPositions[title];
        }, 0);
      } else {
        // New panel - reset scroll to top
        panel.scrollTop = 0;
      }

      const focusTarget = input ? inputEl : (textarea ? textareaEl : buttonsEl.querySelector('button'));
      if (focusTarget) {
        setTimeout(() => {
          focusTarget.focus();
          if (textarea || input) focusTarget.select();
        }, 0);
      }
      
      // Set up keyboard navigation for old-style panel (button-based)
      setupMenuKeyboardNavigation(panel, buttonsEl, buttonsEl);
    }

    function openPanel(title, description, buttons, { includeCancel = true, allowImmediate = false, cancelLabel = 'Close', table = null } = {}) {
      showPanel({
        title,
        description,
        buttons,
        includeCancel,
        cancelLabel,
        allowImmediate,
        table
      });
    }

    function openTextPanel(title, description, value, {
      readOnly = false,
      placeholder = '',
      buttons = [],
      includeCancel = true,
      cancelLabel = 'Close',
      singleLine = false
    } = {}) {
      showPanel({
        title,
        description,
        buttons,
        includeCancel,
        cancelLabel,
        allowImmediate: false,
        textarea: singleLine ? null : {
          value,
          readOnly,
          placeholder
        },
        input: singleLine ? {
          value,
          readOnly,
          placeholder
        } : null
      });
    }

    function openRenameModulePanel() {
      const moduleEntry = findCurrentModuleAtPlayer();
      if (!moduleEntry || !moduleEntry.moduleRef) {
        showMessage('RENAME MODULE', 'No module here to rename.');
        return;
      }

      const moduleRef = moduleEntry.moduleRef;
      const def = MODULE_DEFS[moduleRef.type] || {};
      const baseLabel = moduleRef.label || def.label || moduleRef.type;
      const currentLabel = moduleRef.customLabel || baseLabel;

      openTextPanel(
        'RENAME MODULE',
        `Current: ${currentLabel}\nDefault: ${baseLabel}`,
        currentLabel,
        {
          placeholder: 'Enter a new module name',
          singleLine: true,
          includeCancel: false,
          buttons: [
            {
              label: 'Save',
              action: () => {
                const inputEl = document.getElementById('panelInput');
                const raw = inputEl ? inputEl.value : '';
                const next = String(raw || '').trim();
                moduleRef.customLabel = next.length ? next : null;
                moduleRef.autoLabel = false;
                markDirty();
                relayoutCorridor();
                closePanel();
              }
            },
            {
              label: 'Reset',
              action: () => {
                moduleRef.customLabel = null;
                moduleRef.autoLabel = false;
                markDirty();
                relayoutCorridor();
                closePanel();
              }
            },
            { label: 'Cancel', action: closePanel }
          ]
        }
      );
    }

    function openCaptainMessagePanel(message, npcName = 'AI', aiId = null) {
      const prompt = String(message || '').trim();
      if (aiId && state.lmStudio) state.lmStudio.activeAiId = aiId;
      state.lmStudio.lastCaptainMessage = prompt;
      state.lmStudio.pendingCaptainMessage = { message: prompt, from: npcName, at: Date.now(), aiId };
      const description = `${npcName.toUpperCase()}:\n${prompt}\n\nType your reply and press Say:`;
      openTextPanel(
        'AI MESSAGE',
        description,
        '',
        {
          placeholder: 'Captain reply...',
          singleLine: false,
          includeCancel: true,
          cancelLabel: 'Close',
          buttons: [
            {
              label: 'Say',
              action: () => {
                const textarea = document.getElementById('panelTextarea');
                const raw = textarea ? textarea.value : '';
                const reply = String(raw || '').trim();
                state.lmStudio.lastCaptainReply = reply;
                state.lmStudio.pendingCaptainMessage = null;
                lmStudioChatAdd(aiId, 'captain', reply, 'CAPTAIN');
                markDirty();
                closePanel();
              }
            }
          ]
        }
      );
    }

    function openMessageAiPanel() {
      ensureLmStudioConfig();
      if (!state.lmStudio || !state.lmStudio.enabled) {
        showMessage('MESSAGE AI', 'LM Studio NPC AI is disabled.');
        return;
      }
      const aiNpcs = lmStudioListAiNpcs();
      if (!aiNpcs.length) {
        showMessage('MESSAGE AI', 'No AI crew available.');
        return;
      }
      if (aiNpcs.length === 1) {
        openMessageAiCompose(aiNpcs[0]);
        return;
      }
      const buttons = aiNpcs.map((npc) => ({
        label: formatAiDisplayName(npc.name),
        action: () => openMessageAiCompose(npc)
      }));
      openPanel('MESSAGE AI', 'Choose an AI recipient:', buttons, { includeCancel: true, cancelLabel: 'Cancel' });
    }

    function openMessageAiCompose(npc) {
      if (!npc) return;
      const displayName = formatAiDisplayName(npc.name);
      openTextPanel(
        'MESSAGE AI',
        `To ${displayName}:\nType your message and press Send:`,
        '',
        {
          placeholder: 'Message...',
          singleLine: false,
          includeCancel: true,
          cancelLabel: 'Cancel',
          buttons: [
            {
              label: 'Send',
              action: () => {
                const textarea = document.getElementById('panelTextarea');
                const raw = textarea ? textarea.value : '';
                const message = String(raw || '').trim();
                if (!message) {
                  showMessage('MESSAGE AI', 'Message cannot be empty.');
                  return;
                }
                if (state.lmStudio) state.lmStudio.activeAiId = npc.id;
                lmStudioChatAdd(npc.id, 'captain', message, 'CAPTAIN');
                markDirty();
                closePanel();
              }
            }
          ]
        }
      );
    }

    function updateMessageAiButtonVisibility() {
      const btn = document.getElementById('messageAiBtn');
      if (!btn) return;
      const enabled = state.lmStudio && state.lmStudio.enabled;
      const hasAi = lmStudioListAiNpcs().length > 0;
      btn.style.display = enabled && hasAi ? '' : 'none';
    }

    async function copyToClipboard(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch {}

      try {
        const textareaEl = document.getElementById('panelTextarea');
        textareaEl.focus();
        textareaEl.select();
        return document.execCommand('copy');
      } catch {
        return false;
      }
    }

    function closePanel() {
      const panel = document.getElementById('interactPanel');
      const titleEl = document.getElementById('panelTitle');
      // Save the current scroll position before closing
      if (titleEl && titleEl.textContent) {
        state.ui.panelScrollPositions[titleEl.textContent] = panel.scrollTop;
      }
      // Clean up keyboard handler and clear focus memory
      if (panel.menuKeyHandler) {
        panel.removeEventListener('keydown', panel.menuKeyHandler);
        panel.menuKeyHandler = null;
      }
      state.ui.focusedButtonLabel = null;
      state.ui.menuStack = []; // Clear old menu stack
      state.ui.unifiedMenuStack = []; // Clear unified menu stack
      state.ui.returnToStation = null;
      panel.style.display = 'none';
      state.ui.panelOpen = false;
      state.ui.justOpenedPanel = false;
      // Clear focus so Enter doesn't trigger the main menu button
      if (document.activeElement && document.activeElement !== document.body) {
        document.activeElement.blur();
      }
      const gameCanvas = document.getElementById('gameCanvas');
      if (gameCanvas && typeof gameCanvas.focus === 'function') {
        gameCanvas.focus();
      }
      state.ui.suppressMenuOpen = true;
      requestAnimationFrame(() => {
        state.ui.suppressMenuOpen = false;
      });
    }

    function showMessage(title, text, tableData = null) {
      if (tableData && Array.isArray(tableData)) {
        openPanel(title, text, [], { includeCancel: true, table: tableData });
      } else {
        openPanel(title, text, [], { includeCancel: true });
      }
    }

    function openGameMenu() {
      // Clear old menu stacks and open new unified game menu
      state.ui.menuStack = [];
      state.ui.unifiedMenuStack = [];
      openMenu('gameMenu');
    }

    function closeGameMenu() {
      closePanel();
    }

    function newGame() {
      const lmStudioConfig = state.lmStudio ? { ...state.lmStudio } : null;
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch {}

      SHIP_LAYOUT = {
        levels: {
          1: {
            name: 'DECK 1',
            corridors: {
              A: {
                name: 'Main Corridor',
                modules: [
                  { type: 'fabricator', label: 'Fabricator', uid: newUid() },
                  { type: 'sensors', label: 'Sensors', uid: newUid() }
                ],
                connections: {}
              }
            }
          }
        }
      };

      state.currentLevel = 1;
      state.currentCorridor = 'A';
      state.player.x = 400;
      state.player.vx = 0;
      state.player.facing = 1;
      state.power = 100;
      state.oxygen = 100;
      state.hull = 100;
      state.hullMax = 100;
      state.heat = 0;
      state.food = 100;
      state.morale = 100;
      state.credits = 0;
      state.reputation = 0;
      state.engineActive = false;
      state.throttle = 0;
      state.speed = 0;
      state.location = { system: 'SOL' };
      state.travel = { active: false, from: 'SOL', to: null, remaining: 0, total: 0 };
      state.powerProfile = 'balanced';
      state.blueprints = { modules: {}, recipes: {} };
      state.anomalies = [];
      state.aiBlockers = {};
      state.inventory = { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 };
      state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
      state.contract = { available: [], active: null };
      state.notifications = [];
      state.lightsOn = true;
      state.lifeSupportOn = true;
      state.hydroponicsOn = false;
      state.shieldsOn = false;
      state.crewAI = { enabled: true, autoRepair: true, autoLife: true, autoHydro: true, autoRefine: true, autoFabricate: true, autoContracts: true, autoVentHeat: true, autoTravel: true, autoResearch: true, autoBuild: true, autoHire: false, minCredits: 0, targetCrew: 3, buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 2 } };
      state.lmStudio = lmStudioConfig ? { ...lmStudioConfig } : state.lmStudio;
      ensureLmStudioConfig();
      state.meta = { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 };
      state.anim.walkPhase = 0;
      state.pendingSpawn = null;

      state.npcs = [createNPC('CREW', 'crew', state.currentLevel, state.currentCorridor)];
      state.meta.autoAt = 2;
      state.sim.snap = true;
      ensureBlueprints();
      ensureContracts();
      markDirty();
      relayoutCorridor();
      updateHUD();
      saveGame();

      showMessage('NEW GAME', 'New game started.');
    }

    function openExportPanel() {
      const json = JSON.stringify(getSaveData(), null, 2);
      openTextPanel(
        'EXPORT JSON',
        'Copy this JSON to back up your save:',
        json,
        {
          readOnly: true,
          buttons: [
            {
              label: 'Download File',
              action: () => {
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `space-explorer-save-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage('EXPORT JSON', 'Save file downloaded.');
              }
            },
            {
              label: 'Copy',
              action: async () => {
                const ok = await copyToClipboard(json);
                showMessage('EXPORT JSON', ok ? 'Copied to clipboard.' : 'Copy failed. You can still select and copy manually.');
              }
            }
          ],
          includeCancel: true,
          cancelLabel: 'Close'
        }
      );
    }

    function openImportPanel() {
      openTextPanel(
        'IMPORT JSON',
        'Load a JSON file or paste a previously exported JSON save:',
        '',
        {
          readOnly: false,
          placeholder: '{ "v": 2, ... }',
          buttons: [
            {
              label: 'Load File',
              action: () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,application/json';
                input.onchange = (e) => {
                  const file = e.target.files[0];
                  if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                      importFromJSON(ev.target.result);
                    };
                    reader.onerror = () => {
                      showMessage('IMPORT JSON', 'Failed to read file.');
                    };
                    reader.readAsText(file);
                  }
                };
                input.click();
              }
            },
            {
              label: 'Import',
              danger: true,
              action: () => {
                const raw = document.getElementById('panelTextarea').value;
                importFromJSON(raw);
              }
            }
          ],
          includeCancel: true,
          cancelLabel: 'Cancel'
        }
      );
    }

    function importFromJSON(raw) {
      let loaded;
      try {
        loaded = JSON.parse(raw);
      } catch {
        showMessage('IMPORT JSON', 'Invalid JSON.');
        return;
      }

      if (!loaded || loaded.v !== 2) {
        showMessage('IMPORT JSON', 'Unsupported save format. Please import a JSON exported from this game.');
        return;
      }

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(loaded));
      } catch {
        showMessage('IMPORT JSON', 'Failed to store the save (storage unavailable).');
        return;
      }

      loadGame();
      relayoutCorridor();
      updateHUD();
      saveGame();

      showMessage('IMPORT JSON', 'Save imported.');
    }

    function updateHUD() {
      const setVal = (id, text) => {
        const el = document.getElementById(id);
        if (el) el.textContent = text;
      };

      setVal('levelText', 'L' + state.currentLevel);
      setVal('corridorText', state.currentCorridor);
      setVal('powerLevel', Math.round(state.power) + '%');
      setVal('oxygenLevel', Math.round(state.oxygen) + '%');
      setVal('hullLevel', Math.round((state.hull / Math.max(1, state.hullMax)) * 100) + '%');
      setVal('heatLevel', Math.round(state.heat) + '%');
      setVal('foodLevel', String(invGet('rations')));
      setVal('moraleLevel', Math.round(state.morale) + '%');
      setVal('creditsLevel', Math.floor(state.credits).toLocaleString());
      setVal('repLevel', Math.floor(state.reputation).toLocaleString());
      setVal('speedLevel', Math.round(state.speed) + ' km/s');
      setVal('crewText', state.npcs.length + 1);
      updateMessageAiButtonVisibility();
      if (typeof updateViewportLayout === 'function') updateViewportLayout();
    }

    function updateLocationHUD() {
      const corridorDef = getCorridorDef(state.currentLevel, state.currentCorridor);
      if (corridorDef) {
        const label = document.getElementById('levelText');
        if (label) label.textContent = formatLevelLabel(state.currentLevel);
        const corrLabel = document.getElementById('corridorText');
        if (corrLabel) corrLabel.textContent = state.currentCorridor;
      }
    }

    function markDirty() {
      state.sim.dirty = true;
    }

    // ============================================================================
    // Save/Load
    // ============================================================================

    const STORAGE_KEY = 'idlegames-space-explorer-v2';

    function getSaveData() {
      return {
        v: 2,
        shipLayout: SHIP_LAYOUT,
        level: state.currentLevel,
        corridor: state.currentCorridor,
        playerX: state.player.x,
        power: state.power,
        oxygen: state.oxygen,
        hull: state.hull,
        hullMax: state.hullMax,
        heat: state.heat,
        food: state.food,
        morale: state.morale,
        credits: state.credits,
        reputation: state.reputation,
        engineActive: state.engineActive,
        throttle: state.throttle,
        speed: state.speed,
        location: state.location,
        travel: state.travel,
        powerProfile: state.powerProfile,
        blueprints: state.blueprints,
        anomalies: state.anomalies,
        aiBlockers: state.aiBlockers,
        inventory: state.inventory,
        incidents: state.incidents,
        contract: state.contract,
        notifications: state.notifications,
        lightsOn: state.lightsOn,
        lifeSupportOn: state.lifeSupportOn,
        hydroponicsOn: state.hydroponicsOn,
        shieldsOn: state.shieldsOn,
        crewAI: state.crewAI,
        lmStudio: state.lmStudio ? {
          enabled: !!state.lmStudio.enabled,
          baseUrl: state.lmStudio.baseUrl,
          apiKey: state.lmStudio.apiKey,
          autoLoadModel: state.lmStudio.autoLoadModel,
          activeAiId: state.lmStudio.activeAiId || null,
          lastToolCall: state.lmStudio.lastToolCall || null,
          lastToolResult: state.lmStudio.lastToolResult || null,
          memory: Array.isArray(state.lmStudio.memory) ? state.lmStudio.memory : [],
          chatHistory: state.lmStudio.chatHistory && typeof state.lmStudio.chatHistory === 'object'
            ? state.lmStudio.chatHistory
            : {}
        } : undefined,
        npcs: state.npcs.map(n => ({
          id: n.id,
          name: n.name,
          role: n.role,
          level: n.level,
          corridor: n.corridor,
          x: n.x,
          onDuty: n.onDuty,
          hunger: n.hunger,
          walkPhase: n.walkPhase || 0,
          destinationType: n.destinationType || null,
          destinationCorridorKey: n.destinationCorridorKey || null
        }))
      };
    }

    function saveGame() {
      const data = getSaveData();
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch {}
      state.sim.dirty = false;
    }

    function loadGame() {
      try {
        const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
        if (data.shipLayout && data.shipLayout.levels) SHIP_LAYOUT = data.shipLayout;
        if (data.level) state.currentLevel = data.level;
        if (data.corridor) state.currentCorridor = data.corridor;
        if (data.playerX) state.player.x = data.playerX;
        if (data.power) state.power = data.power;
        if (data.oxygen) state.oxygen = data.oxygen;
        if (data.hull) state.hull = data.hull;
        if (data.hullMax) state.hullMax = data.hullMax;
        if (data.heat !== undefined) state.heat = data.heat;
        if (data.food !== undefined) state.food = data.food;
        if (data.morale !== undefined) state.morale = data.morale;
        if (data.credits !== undefined) state.credits = data.credits;
        if (data.reputation !== undefined) state.reputation = data.reputation;
        if (data.engineActive !== undefined) state.engineActive = data.engineActive;
        if (data.throttle !== undefined) state.throttle = data.throttle;
        if (data.speed !== undefined) state.speed = data.speed;
        if (data.location) state.location = data.location;
        if (data.travel) state.travel = data.travel;
        if (data.powerProfile) state.powerProfile = data.powerProfile;
        if (state.powerProfile === 'life') state.powerProfile = 'survival';
        if (state.powerProfile === 'engine') state.powerProfile = 'combat';
        if (state.powerProfile === 'shields') state.powerProfile = 'combat';
        if (data.blueprints) state.blueprints = data.blueprints;
        if (data.anomalies) state.anomalies = data.anomalies;
        if (data.aiBlockers) state.aiBlockers = data.aiBlockers;
        if (data.inventory) state.inventory = data.inventory;
        if (data.incidents) state.incidents = data.incidents;
        if (data.contract) state.contract = data.contract;
        if (data.notifications) state.notifications = data.notifications;
        if (data.lightsOn !== undefined) state.lightsOn = data.lightsOn;
        if (data.lifeSupportOn !== undefined) state.lifeSupportOn = data.lifeSupportOn;
        if (data.hydroponicsOn !== undefined) state.hydroponicsOn = data.hydroponicsOn;
        if (data.shieldsOn !== undefined) state.shieldsOn = data.shieldsOn;
        if (data.crewAI) state.crewAI = data.crewAI;
        if (data.lmStudio) state.lmStudio = data.lmStudio;
        if (Array.isArray(data.npcs)) {
          state.npcs = data.npcs.map(n => ({
            id: n.id || 'npc-' + Math.random().toString(36).slice(2),
            name: n.name || 'CREW',
            role: n.role || inferRoleFromName(n.name || 'CREW'),
            level: n.level || 1,
            corridor: n.corridor || 'A',
            x: n.x || 300,
            y: 490,
            width: 30,
            height: 60,
            speed: 220,
            vx: 0,
            mode: 'idle',
            task: null,
            onDuty: n.onDuty !== undefined ? n.onDuty : true,
            paused: false,
            thinkTimer: 0,
            wanderTarget: null,
            walkPhase: n.walkPhase || 0,
            hunger: Number.isFinite(n.hunger) ? n.hunger : 0,
            destinationType: n.destinationType || null,
            destinationCorridorKey: n.destinationCorridorKey || null,
            log: []
          }));
        }
        if (state.lmStudio && state.lmStudio.activeAiId) {
          const active = (state.npcs || []).find((n) => n && n.id === state.lmStudio.activeAiId && npcRole(n) === 'ai');
          if (!active) state.lmStudio.activeAiId = null;
        }
        if (!state.inventory || typeof state.inventory !== 'object') state.inventory = { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 };
        if (!state.travel || typeof state.travel !== 'object') state.travel = { active: false, from: currentSystem(), to: null, remaining: 0, total: 0 };
        if (!state.incidents || typeof state.incidents !== 'object') state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
        if (!state.contract || typeof state.contract !== 'object') state.contract = { available: [], active: null };
        if (!state.notifications || !Array.isArray(state.notifications)) state.notifications = [];
        if (!state.aiBlockers || typeof state.aiBlockers !== 'object') state.aiBlockers = {};
        if (!state.meta || typeof state.meta !== 'object') state.meta = { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 };
        ensureCrewAI();
        ensureLmStudioConfig();
        ensureBlueprints();
      } catch {}
    }

    // ============================================================================
    // Initialization
    // ============================================================================

    // ============================================================================
    // NPC System & Roles
    // ============================================================================

    const MAX_CREW = 50;
    const ROLES = ['pilot', 'engineer', 'tech', 'medic', 'quartermaster', 'specialist', 'scientist', 'security', 'ai', 'crew'];

    function npcRole(npc) {
      if (!npc) return 'crew';
      if (npc.role) return npc.role;
      return inferRoleFromName(npc.name || 'CREW');
    }

    function inferRoleFromName(name) {
      const s = String(name || '').toUpperCase();
      if (s === 'AI' || s.includes(' A.I') || s.includes(' AI')) return 'ai';
      if (s.includes('PILOT')) return 'pilot';
      if (s.includes('MEDIC')) return 'medic';
      if (s.includes('TECH')) return 'tech';
      if (s.includes('SPECIAL')) return 'specialist';
      if (s.includes('ENGINEER')) return 'engineer';
      if (s.includes('QUARTER')) return 'quartermaster';
      if (s.includes('SCIENT')) return 'scientist';
      if (s.includes('SECUR')) return 'security';
      return 'crew';
    }

    function addCrewMember(name = 'CREW') {
      const nm = String(name || 'CREW').toUpperCase();
      const role = inferRoleFromName(nm);
      const npc = createNPC(nm, role, state.currentLevel, state.currentCorridor);
      const x = clamp(state.player.x + 60, state.walkBounds.minX, state.walkBounds.maxX);
      npc.x = x;
      state.npcs.push(npc);
      markDirty();
      return npc;
    }

    function removeCrewMemberById(id) {
      const before = state.npcs.length;
      state.npcs = state.npcs.filter((n) => n && n.id !== id);
      if (state.npcs.length !== before) markDirty();
      return state.npcs.length !== before;
    }

    function createNPC(name, role = 'crew', level = 1, corridor = 'A') {
      return {
        id: 'npc-' + Math.random().toString(36).slice(2),
        name,
        level,
        corridor,
        x: 300 + Math.random() * 100,
        y: 490,
        width: 30,
        height: 60,
        speed: 220,
        vx: 0,
        role,
        mode: 'idle',  // idle | task | travel
        task: null,
        onDuty: true,
        paused: false,
        thinkTimer: 0,
        wanderTarget: null,
        walkPhase: 0,
        hunger: 0,
        destinationType: null,
        destinationCorridorKey: null,
        log: []
      };
    }

    function npcHasRole(npc, required) {
      if (!required || !Array.isArray(required)) return true;
      return required.includes(npcRole(npc));
    }

    function hasCrewRole(role) {
      if (!Array.isArray(state.npcs)) return false;
      return state.npcs.some((n) => n && n.onDuty && !n.paused && npcRole(n) === role);
    }

    function anyOnDutyCrew() {
      if (!Array.isArray(state.npcs)) return false;
      return state.npcs.some((n) => n && n.onDuty && !n.paused);
    }

    function countHungryCrew() {
      if (!Array.isArray(state.npcs)) return 0;
      return state.npcs.filter((n) => n && Number.isFinite(n.hunger) && n.hunger >= 1).length;
    }

    function findNearestHungryCrew() {
      if (!Array.isArray(state.npcs)) return null;
      let best = null;
      let bestD = Infinity;
      for (const n of state.npcs) {
        if (!n || !Number.isFinite(n.hunger) || n.hunger < 1) continue;
        const d = Math.abs(n.x - state.player.x);
        if (d < bestD) {
          bestD = d;
          best = n;
        }
      }
      return best;
    }

    function feedNpc(npc) {
      if (!npc) return false;
      if (!invHas('rations', 1)) return false;
      invTake('rations', 1);
      npc.hunger = Math.max(0, safeNumber(npc.hunger, 0) - 1);
      markDirty();
      return true;
    }

    function stationCenterInCorridor(level, corridor, type) {
      const moduleRef = findModuleByType(level, corridor, type);
      if (!moduleRef) return null;
      return moduleCenterInCorridor(level, corridor, moduleRef);
    }

    function assignNpcTask(npc, { key, label, targetType, duration = 1.5, onComplete }) {
      if (!npc || !targetType) return false;
      npc.task = { key, label, targetType, duration, progress: 0, onComplete };
      npc.destinationType = targetType;
      npc.destinationCorridorKey = null;
      npc.mode = 'travel';
      return true;
    }

    function updateNpcTasking(npc, dt) {
      if (!npc || !npc.task) return false;
      const task = npc.task;
      const targetType = task.targetType;
      if (!targetType) {
        npc.task = null;
        return false;
      }

      if (targetType === 'captain') {
        const captainKey = corridorKey(state.currentLevel, state.currentCorridor);
        if (npc.level !== state.currentLevel || npc.corridor !== state.currentCorridor) {
          npc.destinationCorridorKey = captainKey;
          npc.mode = 'travel';
          return true;
        }
        const dist = state.player.x - npc.x;
        if (Math.abs(dist) > 10) {
          npc.vx = Math.sign(dist) * npc.speed * 0.5;
          npc.mode = 'travel';
          return true;
        }
        npc.vx = 0;
        npc.task.progress += dt;
        if (npc.task.progress >= task.duration) {
          if (typeof task.onComplete === 'function') task.onComplete(npc);
          npc.task = null;
          npc.mode = 'idle';
          npc.destinationType = null;
          npc.destinationCorridorKey = null;
          npc.wanderTarget = null;
          return true;
        }
        return true;
      }

      if (!corridorsWithModuleType(targetType).length) {
        npc.task = null;
        npc.destinationType = null;
        npc.destinationCorridorKey = null;
        npc.mode = 'idle';
        return false;
      }

      // Ensure destination is set for navigation.
      if (!npc.destinationType) npc.destinationType = targetType;

      // If NPC is in the target corridor, move to station center.
      const center = stationCenterInCorridor(npc.level, npc.corridor, targetType);
      if (center !== null) {
        npc.wanderTarget = center;
        const dist = center - npc.x;
        if (Math.abs(dist) > 8) {
          npc.vx = Math.sign(dist) * npc.speed * 0.5;
        } else {
          npc.vx = 0;
          npc.task.progress += dt;
          if (npc.task.progress >= task.duration) {
            if (typeof task.onComplete === 'function') task.onComplete(npc);
            npc.task = null;
            npc.mode = 'idle';
            npc.destinationType = null;
            npc.destinationCorridorKey = null;
            npc.wanderTarget = null;
            return true;
          }
        }
      }
      return true;
    }

    function crewAutomationTick(dt) {
      if (!anyOnDutyCrew()) return;
      ensureCrewAI();
      if (!state.crewAI || !state.crewAI.enabled) return;
      state.meta.autoAt += dt;
      if (state.meta.autoAt < 2) return;
      state.meta.autoAt = 0;

      ensureContracts();

      const idle = state.npcs.filter((n) => n && n.onDuty && !n.paused && !n.task && npcRole(n) !== 'ai');
      if (!idle.length) return;
      const hasModule = (type) => corridorsWithModuleType(type).length > 0;
      const needs = activeContractNeeds();
      const buffers = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : {};
      const wantsIngots = (needs && needs.ingot > 0)
        || (state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating && state.hullMax < 150 && invGet('ingot') < 2)
        || invGet('ingot') < invReserve('ingot');
      const wantsFilters = (needs && needs.filter > 0) || invGet('filter') < invReserve('filter');
      const wantsMedkits = (needs && needs.medkit > 0) || invGet('medkit') < invReserve('medkit');
      const wantsDroneParts = (needs && needs.droneParts > 0) || invGet('droneParts') < invReserve('droneParts');
      const minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI && state.crewAI.minCredits, 0)));
      const wantsCredits = state.credits < minCredits;
      const cashRationsTarget = invReserve('rations') + (wantsCredits ? 2 : 0);
      const wantsRations = invGet('rations') < cashRationsTarget;
      const needsScrapForCraft = (wantsFilters && invGet('scrap') < (ITEM_RECIPES.filter ? ITEM_RECIPES.filter.scrap : 0))
        || (wantsMedkits && invGet('scrap') < (ITEM_RECIPES.medkit ? ITEM_RECIPES.medkit.scrap : 0))
        || (wantsDroneParts && invGet('scrap') < (ITEM_RECIPES.droneParts ? ITEM_RECIPES.droneParts.scrap : 0))
        || (wantsRations && invGet('scrap') < (ITEM_RECIPES.rations ? ITEM_RECIPES.rations.scrap : 0));
      const needsIngotsForCraft = wantsDroneParts && invGet('ingot') < (ITEM_RECIPES.droneParts ? ITEM_RECIPES.droneParts.ingot : 0);
      const wantsScrap = (needs && needs.scrap > 0) || needsScrapForCraft || invGet('scrap') < invReserve('scrap');
      const cashOreTarget = invReserve('ore') + (wantsCredits ? 3 : 0);
      const wantsOre = (needs && needs.ore > 0) || (wantsIngots && invGet('ore') < 3) || (needsIngotsForCraft && invGet('ore') < 3) || invGet('ore') < cashOreTarget;
      const canCraftItem = (itemKey) => {
        const recipe = ITEM_RECIPES[itemKey];
        if (!recipe) return false;
        for (const [k, v] of Object.entries(recipe)) {
          if (!canSpendReserved(k, v)) return false;
        }
        return true;
      };

      const criticalModules = [];
      if (state.crewAI.autoBuild) {
        if (!hasModule('fabricator')) {
          if (ensureModuleBuiltIfUnlocked('fabricator', 'AUTOMATION')) return;
        }
        if (state.power < 35 && !hasModule('power')) criticalModules.push('power');
        if (state.oxygen < 50 && !hasModule('life')) criticalModules.push('life');
        if (invGet('rations') < invReserve('rations') && !hasModule('hydro')) criticalModules.push('hydro');
        if (countHungryCrew() > 0 && !hasModule('canteen')) criticalModules.push('canteen');
        if (state.morale < 45 && !hasModule('medbay')) criticalModules.push('medbay');
      }

      const pilotCritical = () => {
        if (anyActiveIncident()) return true;
        if (state.oxygen < 35) return true;
        if (countHungryCrew() > 0 || invGet('rations') <= 1) return true;
        if (state.power < 30) return true;
        if (state.heat > 80) return true;
        if (state.hull < state.hullMax * 0.5) return true;
        return false;
      };

      const roleNeeds = [];
      const addRole = (role) => { if (!roleNeeds.includes(role)) roleNeeds.push(role); };
      if (state.incidents.fire || state.incidents.breach || state.incidents.powerTrip || state.incidents.o2Leak || state.heat > 75) {
        addRole('engineer');
        addRole('tech');
        addRole('specialist');
      }
      if (state.oxygen < 70) {
        addRole('tech');
        addRole('engineer');
      }
      if (countHungryCrew() > 0 || wantsRations) {
        addRole('specialist');
        addRole('engineer');
        addRole('tech');
      }
      if (wantsScrap || wantsOre || wantsIngots) {
        addRole('scientist');
        addRole('tech');
        addRole('specialist');
        addRole('pilot');
      }
      if (wantsFilters || wantsMedkits || wantsDroneParts || wantsRations) {
        addRole('quartermaster');
        addRole('engineer');
        addRole('tech');
      }
      if (wantsCredits) {
        addRole('quartermaster');
        addRole('pilot');
      }
      if (state.crewAI.autoHire) addRole('quartermaster');
      if (state.crewAI.autoContracts || state.crewAI.autoTravel) addRole('pilot');

      let npc = idle.find((n) => roleNeeds.includes(npcRole(n))) || idle[0];
      if (pilotCritical()) {
        const nonPilot = idle.find((n) => npcRole(n) !== 'pilot');
        if (nonPilot) npc = nonPilot;
      }

      const canRole = (roles) => {
        if (npcHasRole(npc, roles)) return true;
        const required = Array.isArray(roles) ? roles : [roles];
        const anyAvailable = required.some((role) => hasCrewRole(role));
        return !anyAvailable;
      };
      const hasActiveTaskTarget = (type) => {
        if (!type || !Array.isArray(state.npcs)) return false;
        return state.npcs.some((n) => n && n.task && n.task.targetType === type);
      };
      const assignMaterialTask = (material) => {
        if (!material) return false;
        if (canRole(['scientist', 'tech']) && hasModule('sensors')) {
          assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
          return true;
        }
        if (canRole(['specialist', 'pilot']) && hasModule('drones') && invHas('droneParts', 1)) {
          assignNpcTask(npc, { key: 'drones.salvage', label: 'Launch Salvage Drone', targetType: 'drones', onComplete: () => launchSalvageDrone(false) });
          return true;
        }
        return false;
      };
      const assignSupplyTaskFor = (itemKey, visited = new Set()) => {
        if (!itemKey) return false;
        if (resolveDeclarativeDemand(npc, itemKey, visited)) return true;
        if (visited.has(itemKey)) return false;
        visited.add(itemKey);

        if (itemKey === 'scrap' || itemKey === 'ore') {
          return assignMaterialTask(itemKey);
        }

        if (itemKey === 'ingot') {
          const oreNeed = Math.max(0, 3 - invGet('ore'));
          if (oreNeed > 0) {
            return assignSupplyTaskFor('ore', visited);
          }
          if (state.crewAI.autoRefine && canRole(['engineer', 'tech']) && hasModule('refinery')) {
            assignNpcTask(npc, { key: 'refinery.refine', label: 'Refine Ore', targetType: 'refinery', onComplete: () => refineOre(false) });
            return true;
          }
          return false;
        }

        if (itemKey === 'rations') {
          if (state.crewAI.autoHydro && hasModule('hydro')) {
            if (hasActiveTaskTarget('hydro') && countHungryCrew() <= 1) return false;
            if (!state.hydroponicsOn) {
              assignNpcTask(npc, { key: 'hydro.toggle', label: 'Enable Grow Lights', targetType: 'hydro', onComplete: () => toggleHydroponics() });
              return true;
            }
            if (state.power >= 4) {
              assignNpcTask(npc, { key: 'hydro.harvest', label: 'Harvest Crops', targetType: 'hydro', onComplete: () => harvestHydroponics(false) });
              return true;
            }
          }
        }

        if (itemKey === 'filter' || itemKey === 'medkit' || itemKey === 'droneParts' || itemKey === 'rations') {
          const prices = { filter: 10, medkit: 25, droneParts: 20, rations: 8 };
          const recipe = ITEM_RECIPES[itemKey];
          if (recipe) {
            const missing = [];
            for (const [mat, qty] of Object.entries(recipe)) {
              if (invAvailableAfterReserve(mat) < qty) missing.push({ mat, qty });
            }
            if (missing.length) {
              const priority = itemKey === 'droneParts'
                ? ['ingot', 'scrap']
                : ['scrap', 'ingot'];
              missing.sort((a, b) => priority.indexOf(a.mat) - priority.indexOf(b.mat));
              for (const miss of missing) {
                if (assignSupplyTaskFor(miss.mat, visited)) return true;
              }
              return false;
            }
          }

          if (canRole(['quartermaster']) && hasModule('cargo') && state.credits >= prices[itemKey]) {
            const buyKey = `cargo.buy.${itemKey}`;
            assignNpcTask(npc, { key: buyKey, label: `Buy ${itemKey}`, targetType: 'cargo', onComplete: () => buyCargoItem(itemKey, prices[itemKey]) });
            return true;
          }
          if (state.crewAI.autoFabricate && hasModule('fabricator') && canCraftItem(itemKey)) {
            assignNpcTask(npc, { key: 'fabricator.build', label: `Fabricate ${itemKey}`, targetType: 'fabricator', onComplete: () => craftItem(itemKey, 1, { respectReserve: true }) });
            return true;
          }
        }

        reportAiBlocker(`Supply chain missing: ${itemKey}`);
        return false;
      };

      const resolveContractDependencies = () => {
        if (!needs || !Object.keys(needs).length) return false;
        const demandOrder = [];
        const needKeys = Object.keys(needs);
        const enqueue = (key) => { if (!demandOrder.includes(key)) demandOrder.push(key); };
        ['droneParts', 'filter', 'medkit', 'rations', 'ingot', 'scrap', 'ore'].forEach((k) => {
          if (needKeys.includes(k)) enqueue(k);
        });
        for (const key of demandOrder) {
          if (assignSupplyTaskFor(key)) return true;
        }
        return false;
      };

      if (canRole(['quartermaster']) && hasModule('cargo')) {
        if (needs && needs.filter > 0 && state.credits >= 10) {
          assignNpcTask(npc, { key: 'cargo.buy.filter', label: 'Buy Filter', targetType: 'cargo', onComplete: () => buyCargoItem('filter', 10) });
          return;
        }
        if (needs && needs.medkit > 0 && state.credits >= 25) {
          assignNpcTask(npc, { key: 'cargo.buy.medkit', label: 'Buy Medkit', targetType: 'cargo', onComplete: () => buyCargoItem('medkit', 25) });
          return;
        }
        if (needs && needs.droneParts > 0 && state.credits >= 20) {
          assignNpcTask(npc, { key: 'cargo.buy.droneParts', label: 'Buy Drone Parts', targetType: 'cargo', onComplete: () => buyCargoItem('droneParts', 20) });
          return;
        }
        if (needs && needs.rations > 0 && state.credits >= 8) {
          assignNpcTask(npc, { key: 'cargo.buy.rations', label: 'Buy Rations', targetType: 'cargo', onComplete: () => buyCargoItem('rations', 8) });
          return;
        }

        if (invGet('filter') < invReserve('filter') && state.credits >= 10) {
          assignNpcTask(npc, { key: 'cargo.buy.filter', label: 'Buy Filter', targetType: 'cargo', onComplete: () => buyCargoItem('filter', 10) });
          return;
        }
        if (invGet('medkit') < invReserve('medkit') && state.credits >= 25) {
          assignNpcTask(npc, { key: 'cargo.buy.medkit', label: 'Buy Medkit', targetType: 'cargo', onComplete: () => buyCargoItem('medkit', 25) });
          return;
        }
        if (invGet('droneParts') < invReserve('droneParts') && state.credits >= 20) {
          assignNpcTask(npc, { key: 'cargo.buy.droneParts', label: 'Buy Drone Parts', targetType: 'cargo', onComplete: () => buyCargoItem('droneParts', 20) });
          return;
        }
        if (invGet('rations') < invReserve('rations') && state.credits >= 8) {
          assignNpcTask(npc, { key: 'cargo.buy.rations', label: 'Buy Rations', targetType: 'cargo', onComplete: () => buyCargoItem('rations', 8) });
          return;
        }

        const hireFee = 30;
        const wantsHireCredits = !!state.crewAI.autoHire && state.credits < hireFee;
        const wantsPurchaseCredits = !!(
          (((needs && needs.filter > 0) || invGet('filter') < invReserve('filter')) && state.credits < 10)
          || (((needs && needs.medkit > 0) || invGet('medkit') < invReserve('medkit')) && state.credits < 25)
          || (((needs && needs.droneParts > 0) || invGet('droneParts') < invReserve('droneParts')) && state.credits < 20)
          || (((needs && needs.rations > 0) || invGet('rations') < invReserve('rations')) && state.credits < 8)
        );
        if (wantsHireCredits && state.crewAI.autoContracts && !pilotCritical() && canRole(['pilot', 'quartermaster']) && hasModule('cockpit')) {
          if (resolveContractDependencies()) return;
          assignNpcTask(npc, { key: 'cockpit.comms', label: 'Contracts', targetType: 'cockpit', onComplete: () => autoManageContracts() });
          return;
        }
        if (wantsHireCredits || wantsPurchaseCredits || wantsCredits) {
          const oreKeep = hasModule('refinery') ? 2 : 0;
          if (canSpendReserved('rations', 1)) {
            assignNpcTask(npc, { key: 'cargo.sell.rations', label: 'Sell Rations', targetType: 'cargo', onComplete: () => sellCargoItem('rations', 4, { respectReserve: true }) });
            return;
          }
          if (canSpendReserved('ingot', 1)) {
            assignNpcTask(npc, { key: 'cargo.sell.ingot', label: 'Sell Ingot', targetType: 'cargo', onComplete: () => sellCargoItem('ingot', 15, { respectReserve: true }) });
            return;
          }
          if (canSpendReserved('scrap', 1)) {
            assignNpcTask(npc, { key: 'cargo.sell.scrap', label: 'Sell Scrap', targetType: 'cargo', onComplete: () => sellCargoItem('scrap', 8, { respectReserve: true }) });
            return;
          }
          if (canSpendReservedWithMinKeep('ore', 1, oreKeep)) {
            assignNpcTask(npc, { key: 'cargo.sell.ore', label: 'Sell Ore', targetType: 'cargo', onComplete: () => sellCargoItem('ore', 5, { respectReserve: true, minKeep: oreKeep }) });
            return;
          }
        }
      }

      if (state.incidents.fire && state.crewAI.autoRepair && canRole(['engineer', 'tech']) && hasModule('engine')) {
        assignNpcTask(npc, { key: 'engine.fire', label: 'Extinguish Fire', targetType: 'engine', onComplete: () => resolveIncident('fire') });
        return;
      }
      if (state.heat > 75 && state.crewAI.autoVentHeat && canRole(['engineer', 'tech']) && hasModule('engine')) {
        assignNpcTask(npc, { key: 'engine.vent', label: 'Vent Heat', targetType: 'engine', onComplete: () => {
          state.power = Math.max(0, state.power - 6);
          state.heat = Math.max(0, state.heat - 25);
          resolveIncident('fire');
          markDirty();
        } });
        return;
      }
      if (state.incidents.powerTrip && state.crewAI.autoRepair && hasModule('power')) {
        assignNpcTask(npc, { key: 'power.repair', label: 'Reset Power', targetType: 'power', onComplete: () => resetPowerTrip(false) });
        return;
      }
      if (state.incidents.o2Leak && state.crewAI.autoLife && hasModule('life')) {
        assignNpcTask(npc, { key: 'life.leak', label: 'Seal O2 Leak', targetType: 'life', onComplete: () => resolveIncident('o2Leak') });
        return;
      }
      if (state.incidents.breach && state.crewAI.autoRepair && canRole(['engineer', 'specialist']) && hasModule('airlock')) {
        assignNpcTask(npc, { key: 'airlock.eva', label: 'EVA Repair', targetType: 'airlock', onComplete: () => performEvaRepair(false) });
        return;
      }
      if (state.incidents.breach && state.crewAI.autoRepair && hasModule('shields')) {
        assignNpcTask(npc, { key: 'shields.bulkhead', label: 'Seal Bulkheads', targetType: 'shields', onComplete: () => sealBulkheads(false) });
        return;
      }
      if ((state.incidents.breach || state.incidents.fire) && state.crewAI.autoRepair && canRole(['engineer', 'specialist']) && hasModule('drones') && invHas('droneParts', 1)) {
        assignNpcTask(npc, { key: 'drones.repair', label: 'Launch Repair Drone', targetType: 'drones', onComplete: () => launchRepairDrone(false) });
        return;
      }
      if (state.hull < state.hullMax * 0.85 && state.crewAI.autoRepair && hasModule('workshop') && (invHas('ingot', 1) || invHas('scrap', 2))) {
        assignNpcTask(npc, { key: 'workshop.repair', label: 'Repair Hull', targetType: 'workshop', onComplete: () => repairHull(false) });
        return;
      }
      if (state.hull < state.hullMax * 0.8 && state.crewAI.autoRepair && canRole(['engineer', 'specialist']) && hasModule('drones') && invHas('droneParts', 1)) {
        assignNpcTask(npc, { key: 'drones.repair', label: 'Launch Repair Drone', targetType: 'drones', onComplete: () => launchRepairDrone(false) });
        return;
      }

      if (state.crewAI.autoBuild && criticalModules.length) {
        const nextModule = criticalModules[0];
        if (ensureModuleBuiltIfUnlocked(nextModule, 'AUTOMATION')) return;
      }

      if (state.morale <= 10) {
        if (hasModule('medbay') && (invHas('medkit', 1) || state.power >= 10)) {
          assignNpcTask(npc, { key: 'med.treat', label: 'Treat Crew', targetType: 'medbay', onComplete: () => treatInjury(false) });
          return;
        }
        if (hasModule('canteen') && invHas('rations', 1)) {
          assignNpcTask(npc, { key: 'canteen.eat', label: 'Eat', targetType: 'canteen', onComplete: () => feedNpc(npc) });
          return;
        }
        if (hasModule('quarters') && invHas('rations', 1)) {
          assignNpcTask(npc, { key: 'quarters.rest', label: 'Rest', targetType: 'quarters', onComplete: () => restCrew(false) });
          return;
        }
        if (state.crewAI.autoBuild) {
          if (ensureModuleBuiltIfUnlocked('medbay', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('canteen', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('hydro', 'AUTOMATION')) return;
        }
      }

      if (state.hull <= state.hullMax * 0.2 && state.crewAI.autoRepair) {
        if (hasModule('shields') && state.incidents.breach) {
          assignNpcTask(npc, { key: 'shields.bulkhead', label: 'Seal Bulkheads', targetType: 'shields', onComplete: () => sealBulkheads(false) });
          return;
        }
        if (hasModule('workshop') && (invHas('ingot', 1) || invHas('scrap', 2))) {
          assignNpcTask(npc, { key: 'workshop.repair', label: 'Repair Hull', targetType: 'workshop', onComplete: () => repairHull(false) });
          return;
        }
        if (hasModule('drones') && invHas('droneParts', 1)) {
          assignNpcTask(npc, { key: 'drones.repair', label: 'Launch Repair Drone', targetType: 'drones', onComplete: () => launchRepairDrone(false) });
          return;
        }
        if (hasModule('airlock') && state.oxygen >= 10) {
          assignNpcTask(npc, { key: 'airlock.eva', label: 'EVA Repair', targetType: 'airlock', onComplete: () => performEvaRepair(false) });
          return;
        }
        if (state.crewAI.autoBuild) {
          if (ensureModuleBuiltIfUnlocked('workshop', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('drones', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('airlock', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('shields', 'AUTOMATION')) return;
        }
      }

      if (state.oxygen < 70 && state.crewAI.autoLife && hasModule('life')) {
        assignNpcTask(npc, { key: 'life.emergency', label: 'Emergency Scrubbers', targetType: 'life', onComplete: () => emergencyScrubbers(false) });
        return;
      }
      if (invGet('rations') < invReserve('rations') && state.crewAI.autoHydro && hasModule('hydro')) {
        if (!hasActiveTaskTarget('hydro') || countHungryCrew() > 1) {
        if (!state.hydroponicsOn) {
          assignNpcTask(npc, { key: 'hydro.toggle', label: 'Enable Grow Lights', targetType: 'hydro', onComplete: () => toggleHydroponics() });
          return;
        }
        if (state.power >= 4) {
          assignNpcTask(npc, { key: 'hydro.harvest', label: 'Harvest Crops', targetType: 'hydro', onComplete: () => harvestHydroponics(false) });
          return;
        }
        }
      }
      if (Number.isFinite(npc.hunger) && npc.hunger >= 1 && hasModule('canteen') && invHas('rations', 1)) {
        assignNpcTask(npc, { key: 'canteen.eat', label: 'Eat', targetType: 'canteen', onComplete: () => feedNpc(npc) });
        return;
      }
      if (state.morale <= 30) {
        if (hasModule('medbay') && (invHas('medkit', 1) || state.power >= 10)) {
          assignNpcTask(npc, { key: 'med.treat', label: 'Treat Crew', targetType: 'medbay', onComplete: () => treatInjury(false) });
          return;
        }
        if (hasModule('quarters') && invHas('rations', 1)) {
          assignNpcTask(npc, { key: 'quarters.rest', label: 'Rest', targetType: 'quarters', onComplete: () => restCrew(false) });
          return;
        }
      }
      if (state.crewAI.autoFabricate || state.crewAI.autoRefine || state.crewAI.autoContracts || state.crewAI.autoBuild) {
        const demandOrder = [];
        const needKeys = needs ? Object.keys(needs) : [];
        const enqueue = (key) => { if (!demandOrder.includes(key)) demandOrder.push(key); };
        ['droneParts', 'filter', 'medkit', 'rations', 'ingot', 'scrap', 'ore'].forEach((k) => {
          if (needKeys.includes(k)) enqueue(k);
        });
        if (wantsCredits) {
          enqueue('rations');
          enqueue('ore');
        }
        if (wantsDroneParts) enqueue('droneParts');
        if (wantsFilters) enqueue('filter');
        if (wantsMedkits) enqueue('medkit');
        if (wantsRations) enqueue('rations');
        if (wantsIngots) enqueue('ingot');
        if (wantsScrap) enqueue('scrap');
        if (wantsOre) enqueue('ore');

        for (const key of demandOrder) {
          if (assignSupplyTaskFor(key)) return;
        }
      }
      if (state.power < 40 && state.crewAI.autoRepair && hasModule('power')) {
        assignNpcTask(npc, { key: 'power.route', label: 'Route Power', targetType: 'power', onComplete: () => autoRoutePower() });
        return;
      }

      if ((invGet('scrap') < invReserve('scrap') || invGet('ore') < invReserve('ore'))
        && canRole(['scientist', 'tech'])
        && hasModule('sensors')) {
        assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
        return;
      }

      if (state.crewAI.autoFabricate && hasModule('fabricator')) {
        const pickRecipe = () => {
          if (needs && needs.filter > 0 && canCraftItem('filter')) return 'filter';
          if (needs && needs.medkit > 0 && canCraftItem('medkit')) return 'medkit';
          if (needs && needs.droneParts > 0 && canCraftItem('droneParts')) return 'droneParts';
          if (wantsFilters && canCraftItem('filter')) return 'filter';
          if (wantsMedkits && canCraftItem('medkit')) return 'medkit';
          if (wantsDroneParts && canCraftItem('droneParts')) return 'droneParts';
          if (wantsRations && canCraftItem('rations')) return 'rations';
          return null;
        };
        const recipe = pickRecipe();
        if (recipe) {
          assignNpcTask(npc, {
            key: 'fabricator.build',
            label: `Fabricate ${recipe}`,
            targetType: 'fabricator',
            onComplete: () => craftItem(recipe, 1, { respectReserve: true })
          });
          return;
        }
        if (invGet('filter') < (buffers.filter || 0) || invGet('medkit') < (buffers.medkit || 0) || invGet('droneParts') < (buffers.droneParts || 0) || invGet('rations') < (buffers.rations || 0)) {
          const canMakeAny = ['filter', 'medkit', 'droneParts', 'rations'].some((key) => canCraftItem(key));
          if (canMakeAny) {
            assignNpcTask(npc, { key: 'fabricator.build', label: 'Fabricate Consumables', targetType: 'fabricator', onComplete: () => autoFabricateConsumables() });
            return;
          }
        }
      }
      if (state.crewAI.autoRefine && wantsIngots && invGet('ore') >= 3 && canRole(['engineer', 'tech']) && hasModule('refinery')) {
        assignNpcTask(npc, { key: 'refinery.refine', label: 'Refine Ore', targetType: 'refinery', onComplete: () => refineOre(false) });
        return;
      }
      if (state.crewAI.autoHire && hasModule('quarters') && canRole(['quartermaster'])) {
        const fee = 30;
        const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
        const crewCount = npcs.length;
        const target = clamp(Math.floor(safeNumber(state.crewAI.targetCrew, 0)), 0, MAX_CREW);
        if (crewCount > target) {
          const rolePriority = { crew: 0, security: 1, specialist: 2, scientist: 3, tech: 4, engineer: 5, medic: 6, pilot: 7, quartermaster: 8 };
          const qmCount = npcs.filter((n) => npcRole(n) === 'quartermaster').length;
          let candidates = npcs;
          if (qmCount <= 1) candidates = npcs.filter((n) => npcRole(n) !== 'quartermaster');
          if (!candidates.length) candidates = npcs;
          candidates.sort((a, b) => (rolePriority[npcRole(a)] ?? 9) - (rolePriority[npcRole(b)] ?? 9));
          const chosen = candidates[0];
          if (chosen) {
            assignNpcTask(npc, {
              key: 'quarters.transferOut',
              label: 'Transfer Crew Out',
              targetType: 'quarters',
              onComplete: () => {
                removeCrewMemberById(chosen.id);
                updateHUD();
                queueNotification('QUARTERS', `${chosen.name} transferred out (AUTOMATION).`);
              }
            });
            return;
          }
        }
        if (crewCount < target && crewCount < MAX_CREW && state.credits >= fee) {
          const counts = {};
          for (const n of npcs) {
            const r = npcRole(n);
            counts[r] = (counts[r] || 0) + 1;
          }
          const need = (r) => (counts[r] || 0) <= 0;
          let hire = 'CREW';
          if (need('pilot')) hire = 'PILOT';
          else if (need('tech')) hire = 'TECH';
          else if (need('medic')) hire = 'MEDIC';
          else if (need('engineer')) hire = 'ENGINEER';
          else if (need('scientist')) hire = 'SCIENTIST';
          else if (need('quartermaster')) hire = 'QUARTERMASTER';
          else if (need('security')) hire = 'SECURITY';
          else if ((counts.specialist || 0) < Math.max(1, Math.floor(target / 6))) hire = 'SPECIALIST';

          assignNpcTask(npc, {
            key: 'quarters.transferIn',
            label: `Hire ${hire}`,
            targetType: 'quarters',
            onComplete: () => {
              if (state.credits < fee) return;
              state.credits -= fee;
              addCrewMember(hire);
              queueNotification('QUARTERS', `${hire} transferred aboard (AUTOMATION).`);
              updateHUD();
            }
          });
          return;
        }
      }
      if (state.crewAI.autoBuild || state.crewAI.autoResearch) {
        ensureModuleBuiltIfUnlocked('sensors', 'AUTOMATION');
      }
      if (state.crewAI.autoBuild) {
        const buildTarget = pickAutoBuildTarget({
          needs,
          wantsScrap,
          wantsOre,
          wantsIngots,
          wantsFilters,
          wantsMedkits,
          wantsDroneParts,
          wantsRations
        });
        if (buildTarget && ensureModuleBuiltIfUnlocked(buildTarget, 'AUTOMATION')) return;
        const desired = ['drones', 'refinery', 'workshop', 'comms', 'canteen', 'shields', 'medbay', 'airlock'];
        for (const t of desired) {
          if (ensureModuleBuiltIfUnlocked(t, 'AUTOMATION')) break;
        }
      }
      if (state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating && state.hullMax < 150 && invHas('ingot', 2) && hasModule('workshop')) {
        assignNpcTask(npc, { key: 'workshop.plating', label: 'Install Plating', targetType: 'workshop', onComplete: () => installHullPlating(false) });
        return;
      }
      if ((wantsScrap || wantsOre || wantsIngots) && canRole(['scientist', 'tech']) && hasModule('sensors')) {
        assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
        return;
      }
      if ((wantsScrap || wantsOre) && canRole(['specialist', 'pilot']) && hasModule('drones') && invHas('droneParts', 1)) {
        assignNpcTask(npc, { key: 'drones.salvage', label: 'Launch Salvage Drone', targetType: 'drones', onComplete: () => launchSalvageDrone(false) });
        return;
      }
      if (state.crewAI.autoResearch && canRole(['scientist', 'tech']) && hasModule('sensors')) {
        const hasLockedTech = listLockedAdvancedModuleTypes().length > 0 || !(state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating);
        if (hasLockedTech && state.power >= 12 && invHas('scrap', 2)) {
          assignNpcTask(npc, { key: 'sensors.deepScan', label: 'Deep Scan', targetType: 'sensors', onComplete: () => deepScanBlueprint(false) });
          return;
        }
      }
      if (state.crewAI.autoContracts && canRole(['pilot', 'quartermaster']) && !pilotCritical()) {
        if (resolveContractDependencies()) return;
        if (!state.contract.active || contractReady(state.contract.active)) {
          if (hasModule('comms')) {
            assignNpcTask(npc, { key: 'comms.contracts', label: 'Manage Contracts', targetType: 'comms', onComplete: () => autoManageContracts() });
            return;
          }
          if (hasModule('cockpit')) {
            assignNpcTask(npc, { key: 'cockpit.comms', label: 'Contracts', targetType: 'cockpit', onComplete: () => autoManageContracts() });
            return;
          }
        }
      }
      if ((state.credits <= minCredits || state.reputation <= 0) && state.crewAI.autoContracts && !pilotCritical()) {
        if (resolveContractDependencies()) return;
        if (!state.contract.active || contractReady(state.contract.active)) {
          if (hasModule('comms')) {
            assignNpcTask(npc, { key: 'comms.contracts', label: 'Contracts', targetType: 'comms', onComplete: () => autoManageContracts() });
            return;
          }
          if (hasModule('cockpit')) {
            assignNpcTask(npc, { key: 'cockpit.comms', label: 'Contracts', targetType: 'cockpit', onComplete: () => autoManageContracts() });
            return;
          }
        }
        if (state.crewAI.autoBuild) {
          if (ensureModuleBuiltIfUnlocked('comms', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('cockpit', 'AUTOMATION')) return;
        }
      }
      if (state.credits <= minCredits && state.crewAI.autoBuild) {
        const hasSellable = invAvailableAfterReserve('ingot') > 0
          || invAvailableAfterReserve('scrap') > 0
          || invAvailableAfterReserve('ore') > (hasModule('refinery') ? 2 : 0)
          || invAvailableAfterReserve('rations') > 0;
        if (!hasSellable) {
          if (ensureModuleBuiltIfUnlocked('sensors', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('drones', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('cargo', 'AUTOMATION')) return;
        }
      }
      if (state.crewAI.autoTravel && canRole(['pilot']) && hasModule('engine') && !pilotCritical()) {
        const t = state.travel && typeof state.travel === 'object' ? state.travel : { active: false };
        const safeToTravel = !anyActiveIncident() && state.oxygen >= 20 && state.power >= 12 && state.hull >= Math.max(10, state.hullMax * 0.5);
        if (!t.active && safeToTravel) {
          const sys = currentSystem();
          const unresolved = Array.isArray(state.anomalies)
            ? state.anomalies.filter((a) => a && !a.resolved && typeof a.system === 'string' && a.system.length).map((a) => a.system.toUpperCase())
            : [];
          const targets = [...new Set(unresolved)].filter((s) => s !== sys);
          let destination = null;
          if (targets.length) {
            let best = null;
            let bestDist = Infinity;
            for (const cand of targets) {
              const path = findShortestPath(sys, cand);
              if (!path || path.length < 2) continue;
              let sum = 0;
              for (let i = 0; i < path.length - 1; i++) {
                const w = distanceBetween(path[i], path[i + 1]);
                sum += Number.isFinite(w) ? w : 0;
              }
              if (sum < bestDist) {
                bestDist = sum;
                best = cand;
              }
            }
            destination = best;
          }
          if (!destination) {
            const dests = listDestinations(sys);
            if (dests.length) destination = dests[(Math.random() * dests.length) | 0];
          }
          if (destination && destination !== sys) {
            const path = findShortestPath(sys, destination);
            const nextHop = path && path.length >= 2 ? path[1] : null;
            if (nextHop) {
              assignNpcTask(npc, {
                key: 'cockpit.nav',
                label: `Plot Course ${sys} → ${nextHop}`,
                targetType: 'cockpit',
                onComplete: () => {
                  state.throttle = clamp(Math.max(0.6, safeNumber(state.throttle, 0)), 0, 1);
                  startTravelAuto(nextHop, 'AUTOMATION');
                  updateHUD();
                }
              });
              return;
            }
          }
        }
      }
      if (state.crewAI.autoHydro && canRole(['scientist', 'tech']) && hasModule('sensors')) {
        const localAnoms = Array.isArray(state.anomalies) ? state.anomalies.filter((a) => a && !a.resolved && a.system === currentSystem()) : [];
        if (localAnoms.length) {
          assignNpcTask(npc, { key: 'sensors.scan', label: 'Investigate Anomalies', targetType: 'sensors', onComplete: () => investigateAnomaly(localAnoms[0], false) });
          return;
        }
      }

      const crewCount = Array.isArray(state.npcs) ? state.npcs.filter(Boolean).length : 0;
      const targetCrew = clamp(Math.floor(safeNumber(state.crewAI && state.crewAI.targetCrew, 0)), 0, MAX_CREW);
      const crewTargetUnmet = crewCount !== targetCrew;

      const unmetDemands = (
        anyActiveIncident()
        || criticalModules.length > 0
        || (needs && Object.keys(needs).length > 0)
        || wantsRations
        || wantsFilters
        || wantsMedkits
        || wantsDroneParts
        || wantsIngots
        || wantsScrap
        || wantsOre
        || countHungryCrew() > 0
        || state.morale < 60
        || state.oxygen < 70
        || state.power < 40
        || state.heat > 75
        || state.hull < state.hullMax * 0.9
        || crewTargetUnmet
        || wantsCredits
      );

      if (unmetDemands) {
        const fallbackOrder = ['credits', 'rations', 'filter', 'medkit', 'droneParts', 'ingot', 'scrap', 'ore'];
        const roleDemandMap = {
          quartermaster: ['credits', 'rations', 'filter', 'medkit', 'droneParts', 'ingot', 'scrap', 'ore'],
          pilot: ['credits', 'ore', 'scrap'],
          engineer: ['ingot', 'scrap', 'ore', 'droneParts'],
          tech: ['ingot', 'scrap', 'ore', 'droneParts', 'rations'],
          scientist: ['ore', 'scrap'],
          specialist: ['scrap', 'ore', 'droneParts'],
          medic: ['medkit', 'rations'],
          security: ['scrap', 'ore'],
          crew: ['rations', 'scrap', 'ore']
        };
        const originalNpc = npc;
        for (const candidate of idle) {
          if (!candidate || candidate.task) continue;
          npc = candidate;
          let assigned = false;

          const roleKey = npcRole(candidate);
          const roleOrder = roleDemandMap[roleKey] || fallbackOrder;
          for (const key of roleOrder) {
            if (resolveDeclarativeDemand(npc, key)) {
              assigned = true;
              break;
            }
          }

          if (!assigned) {
            for (const key of fallbackOrder) {
              if (assignSupplyTaskFor(key)) {
                assigned = true;
                break;
              }
            }
          }

          if (!assigned && state.crewAI.autoResearch && canRole(['scientist', 'tech']) && hasModule('sensors')) {
            assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
            assigned = true;
          }
          if (!assigned && canRole(['specialist', 'pilot']) && hasModule('drones') && invHas('droneParts', 1)) {
            assignNpcTask(npc, { key: 'drones.salvage', label: 'Launch Salvage Drone', targetType: 'drones', onComplete: () => launchSalvageDrone(false) });
            assigned = true;
          }
          if (!assigned && state.crewAI.autoFabricate && hasModule('fabricator')) {
            const canMakeAny = ['filter', 'medkit', 'droneParts', 'rations'].some((key) => canCraftItem(key));
            if (canMakeAny) {
              assignNpcTask(npc, { key: 'fabricator.build', label: 'Fabricate Consumables', targetType: 'fabricator', onComplete: () => autoFabricateConsumables() });
              assigned = true;
            }
          }
          if (!assigned && state.crewAI.autoRefine && hasModule('refinery') && invGet('ore') >= 3 && canRole(['engineer', 'tech'])) {
            assignNpcTask(npc, { key: 'refinery.refine', label: 'Refine Ore', targetType: 'refinery', onComplete: () => refineOre(false) });
          }
          if (!assigned) {
            reportAiBlocker(`Idle with unmet demands (${npcRole(candidate)})`);
          }
        }
        npc = originalNpc;
      }
    }

    // ============================================================================
    // Initialization
    // ============================================================================

    loadGame();
    ensureCrewAI();
    ensureBlueprints();
    ensureContracts();
    
    // Add initial crew if save is empty
    if (state.npcs.length === 0) {
      state.npcs.push(createNPC('CREW', 'crew', state.currentLevel, state.currentCorridor));
    }

    relayoutCorridor();
    updateHUD();
    requestAnimationFrame(gameLoop);

    // Save state periodically
    setInterval(() => {
      saveGame();
    }, 2000);

    // Save when the page is backgrounded or closed.
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') saveGame();
    });
    window.addEventListener('beforeunload', () => {
      saveGame();
    });
  </script>

  <script src="assets/js/pwa.js" defer></script>
  <script src="parental.js" defer></script>
</body>
</html>
