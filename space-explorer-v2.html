<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Explorer Â· Idle Games</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="assets/appicons/idle-games-512x512.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #0a0e27;
      --panel: #1a1e3f;
      --text: #e0e0ff;
      --accent: #00d4ff;
      --warning: #ff6b35;
      --success: #4ecdc4;
      --hull: #3d4466;
      --wall: #2a2e4a;

      --hud-h: 56px;
      --controls-h: 78px;
    }

    body {
      font-family: 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      height: 100vh;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #gameCanvas {
      position: fixed;
      left: 0;
      right: 0;
      top: var(--hud-h);
      bottom: var(--controls-h);
      width: 100%;
      height: calc(100vh - var(--hud-h) - var(--controls-h));
      background: var(--bg);
      display: block;
      touch-action: none;
    }

    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: auto;
      min-height: var(--hud-h);
      background: rgba(26, 30, 63, 0.9);
      padding: calc(8px + env(safe-area-inset-top, 0px)) calc(20px + env(safe-area-inset-right, 0px)) 8px calc(20px + env(safe-area-inset-left, 0px));
      display: flex;
      justify-content: flex-start;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px 16px;
      border-bottom: 2px solid var(--accent);
      font-size: 14px;
      z-index: 100;
    }

    .hud-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 6px;
      transition: all 0.2s;
      touch-action: manipulation;
      line-height: 1;
    }

    .hud-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .hud-section {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      row-gap: 6px;
    }

    .hud-controls {
      flex: 0 0 auto;
      gap: 10px;
    }

    .hud-stats {
      flex: 1 1 520px;
      justify-content: flex-end;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-value {
      color: var(--accent);
      font-weight: bold;
    }

    #controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--controls-h);
      background: rgba(26, 30, 63, 0.9);
      padding: 10px;
      border-top: 2px solid var(--accent);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      z-index: 100;
    }

    .control-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 80px;
      touch-action: manipulation;
    }

    .control-btn:hover {
      background: var(--accent);
      color: var(--bg);
      transform: translateY(-2px);
    }

    #interactPrompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.95);
      border: 2px solid var(--accent);
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      display: none;
      z-index: 200;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    #interactPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.98);
      border: 3px solid var(--accent);
      padding: 30px;
      border-radius: 8px;
      max-width: 500px;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      display: none;
      z-index: 300;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) rgba(26, 30, 63, 0.4);
    }

    #interactPanel::-webkit-scrollbar {
      width: 10px;
    }

    #interactPanel::-webkit-scrollbar-track {
      background: rgba(26, 30, 63, 0.4);
      border-radius: 8px;
    }

    #interactPanel::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 8px;
      border: 2px solid rgba(26, 30, 63, 0.4);
    }

    #interactPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
    }

    #interactPanel p {
      line-height: 1.6;
      margin-bottom: 20px;
      white-space: pre-line;
    }

    #panelTextarea {
      width: 100%;
      min-height: 180px;
      max-height: 45vh;
      background: rgba(10, 14, 39, 0.9);
      color: var(--text);
      border: 2px solid var(--accent);
      border-radius: 6px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      resize: vertical;
      margin-bottom: 18px;
      outline: none;
    }

    #panelInput {
      width: 100%;
      height: 40px;
      background: rgba(10, 14, 39, 0.9);
      color: var(--text);
      border: 2px solid var(--accent);
      border-radius: 6px;
      padding: 10px;
      font-family: inherit;
      font-size: 14px;
      margin-bottom: 18px;
      outline: none;
    }

    .panel-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      margin-right: 10px;
      transition: all 0.2s;
    }

    .panel-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .panel-btn.danger {
      border-color: var(--warning);
    }

    .panel-btn.danger:hover {
      background: var(--warning);
    }

    #panelButtons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    @media (max-width: 600px) {
      #hud {
        font-size: 12px;
        padding: calc(8px + env(safe-area-inset-top, 0px)) calc(10px + env(safe-area-inset-right, 0px)) 8px calc(10px + env(safe-area-inset-left, 0px));
      }

      .control-btn {
        padding: 10px 16px;
        font-size: 14px;
        min-width: 60px;
      }

      #interactPanel {
        max-width: 90%;
        padding: 20px;
      }

      .hud-btn {
        padding: 8px 10px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="hud-section hud-controls">
      <button class="hud-btn" id="menuBtn" aria-label="Game menu">MENU</button>
    </div>
    <div class="hud-section hud-stats">
      <div class="status-item">
        <span>LEVEL:</span>
        <span class="status-value" id="levelText">1</span>
      </div>
      <div class="status-item">
        <span>CORRIDOR:</span>
        <span class="status-value" id="corridorText">A</span>
      </div>
      <div class="status-item">
        <span>POWER:</span>
        <span class="status-value" id="powerLevel">100%</span>
      </div>
      <div class="status-item">
        <span>OXYGEN:</span>
        <span class="status-value" id="oxygenLevel">100%</span>
      </div>
      <div class="status-item">
        <span>HULL:</span>
        <span class="status-value" id="hullLevel">100%</span>
      </div>
      <div class="status-item">
        <span>HEAT:</span>
        <span class="status-value" id="heatLevel">0%</span>
      </div>
      <div class="status-item">
        <span>RATIONS:</span>
        <span class="status-value" id="foodLevel">0</span>
      </div>
      <div class="status-item">
        <span>MORALE:</span>
        <span class="status-value" id="moraleLevel">100%</span>
      </div>
      <div class="status-item">
        <span>CREDITS:</span>
        <span class="status-value" id="creditsLevel">0</span>
      </div>
      <div class="status-item">
        <span>REP:</span>
        <span class="status-value" id="repLevel">0</span>
      </div>
      <div class="status-item">
        <span>SPEED:</span>
        <span class="status-value" id="speedLevel">0 km/s</span>
      </div>
      <div class="status-item">
        <span>CREW:</span>
        <span class="status-value" id="crewText">1</span>
      </div>
    </div>
  </div>

  <svg id="gameCanvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
    <!-- Game will be rendered here -->
  </svg>

  <div id="controls">
    <button class="control-btn" id="leftBtn">LEFT</button>
    <button class="control-btn" id="actionBtn">ACTION</button>
    <button class="control-btn" id="rightBtn">RIGHT</button>
    <button class="control-btn" id="renameBtn">RENAME</button>
  </div>

  <div id="interactPrompt">
    Press ACTION to interact
  </div>

  <div id="interactPanel">
    <h2 id="panelTitle">Station</h2>
    <p id="panelDescription">Description</p>
    <textarea id="panelTextarea" spellcheck="false" autocapitalize="off" autocomplete="off" style="display:none"></textarea>
    <input id="panelInput" type="text" spellcheck="false" autocapitalize="off" autocomplete="off" style="display:none" />
    <div id="panelButtons"></div>
  </div>

  <script type="module">
    // ============================================================================
    // Core Architecture
    // ============================================================================
    
    // Game state singleton
    const state = {
      // Player
      player: { x: 400, y: 490, width: 30, height: 60, speed: 260, vx: 0, facing: 1 },
      
      // Rendering context
      camera: { x: 0 },
      currentLevel: 1,
      currentCorridor: 'A',
      
      // Core resources
      power: 100,
      oxygen: 100,
      hull: 100,
      hullMax: 100,
      heat: 0,
      food: 100,
      morale: 100,
      credits: 0,
      reputation: 0,
      speed: 0,
      engineActive: false,
      throttle: 0,
      location: { system: 'SOL' },
      travel: { active: false, from: 'SOL', to: null, remaining: 0, total: 0 },
      powerProfile: 'balanced',
      blueprints: { modules: {}, recipes: {} },
      anomalies: [],

      aiBlockers: {},

      // Inventory (shared between stations)
      inventory: { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 },
        crewAI: {
          enabled: true,
          autoRepair: true,
          autoLife: true,
          autoHydro: true,
          autoRefine: true,
          autoFabricate: true,
          autoContracts: true,
          autoVentHeat: true,
          autoTravel: true,
          autoResearch: true,
          autoBuild: true,
          autoHire: false,
          minCredits: 0,
          targetCrew: 3,
          buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 2 }
        },
      meta: { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 },
      
      // NPCs
      npcs: [],
      
      // UI state
      ui: { panelOpen: false, actionActor: 'player', justOpenedPanel: false },
      keys: { left: false, right: false },
      nearStation: null,
      pendingSpawn: null,
      
      // Sim state
      sim: { dirty: true, saveAcc: 0, snap: true },
      
      // Animation state
      anim: { walkPhase: 0, walkSpeed: 12 },

      // Movement bounds
      walkBounds: { minX: 50, maxX: 750 },
    };

    const css = getComputedStyle(document.documentElement);
    const C = {
      bg: css.getPropertyValue('--bg').trim(),
      panel: css.getPropertyValue('--panel').trim(),
      text: css.getPropertyValue('--text').trim(),
      accent: css.getPropertyValue('--accent').trim(),
      warning: css.getPropertyValue('--warning').trim(),
      success: css.getPropertyValue('--success').trim(),
      hull: css.getPropertyValue('--hull').trim(),
      wall: css.getPropertyValue('--wall').trim()
    };

    function clamp(v, lo, hi) {
      return Math.max(lo, Math.min(hi, v));
    }

    function safeNumber(v, fallback = 0) {
      return Number.isFinite(v) ? v : fallback;
    }

    const BULKHEAD_W = 20;

    function moduleInterior(module) {
      const start = module.x + BULKHEAD_W;
      const end = module.x + module.width;
      return { start, end, width: Math.max(0, end - start) };
    }

    function invGet(key) {
      const inv = state.inventory || {};
      const v = inv[key];
      return Number.isFinite(v) ? v : 0;
    }

    function invHas(key, qty = 1) {
      return invGet(key) >= qty;
    }

    function invAdd(key, qty = 1) {
      if (!state.inventory || typeof state.inventory !== 'object') state.inventory = {};
      state.inventory[key] = Math.max(0, invGet(key) + qty);
      markDirty();
    }

    function invTake(key, qty = 1) {
      if (!invHas(key, qty)) return false;
      state.inventory[key] = Math.max(0, invGet(key) - qty);
      markDirty();
      return true;
    }

    function invReserve(key) {
      ensureCrewAI();
      const buf = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : null;
      const v = buf ? buf[key] : 0;
      return Math.max(0, Math.floor(safeNumber(v, 0)));
    }

    function invAvailableAfterReserve(key) {
      return Math.max(0, invGet(key) - invReserve(key));
    }

    function canSpendReserved(key, qty) {
      return invAvailableAfterReserve(key) >= Math.max(0, safeNumber(qty, 0));
    }

    function canSpendReservedWithMinKeep(key, qty, minKeep = 0) {
      const need = Math.max(0, safeNumber(qty, 0));
      const keep = Math.max(0, Math.floor(safeNumber(minKeep, 0)));
      return invAvailableAfterReserve(key) >= (need + keep);
    }

    function newUid() {
      return 'm_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
    }

    const SYSTEM_GRAPH = {
      SOL: { EOS: 240, VEGA: 420, KITE: 180 },
      EOS: { SOL: 240, GAIA: 190, VEGA: 260 },
      VEGA: { SOL: 420, EOS: 260, DRIFT: 310 },
      KITE: { SOL: 180, DRIFT: 260 },
      GAIA: { EOS: 190, DRIFT: 340 },
      DRIFT: { VEGA: 310, KITE: 260, GAIA: 340 }
    };

    const BASIC_MODULE_TYPES = new Set([
      'cargo',
      'power',
      'engine',
      'cockpit',
      'fabricator',
      'life',
      'hydro',
      'quarters',
      'sensors',
      'computer',
      'comms',
      'medbay',
      'shields',
      'refinery',
      'drones',
      'airlock',
      'workshop',
      'canteen'
    ]);

    function ensureBlueprints() {
      if (!state.blueprints || typeof state.blueprints !== 'object') state.blueprints = { modules: {}, recipes: {} };
      if (!state.blueprints.modules || typeof state.blueprints.modules !== 'object') state.blueprints.modules = {};
      if (!state.blueprints.recipes || typeof state.blueprints.recipes !== 'object') state.blueprints.recipes = {};

      for (const t of BASIC_MODULE_TYPES) state.blueprints.modules[t] = true;
      if (state.blueprints.recipes.plating === undefined) state.blueprints.recipes.plating = false;
    }

    function isModuleUnlocked(type) {
      ensureBlueprints();
      if (BASIC_MODULE_TYPES.has(type)) return true;
      return !!state.blueprints.modules[type];
    }

    function unlockModuleBlueprint(type, source = 'UNKNOWN') {
      ensureBlueprints();
      if (!MODULE_DEFS[type]) return false;
      if (state.blueprints.modules[type]) return false;
      state.blueprints.modules[type] = true;
      queueNotification('BLUEPRINT ACQUIRED', `${MODULE_DEFS[type].label} blueprint unlocked (${String(source)}).`);
      markDirty();
      return true;
    }

    function unlockRecipeBlueprint(key, source = 'UNKNOWN') {
      ensureBlueprints();
      if (state.blueprints.recipes[key]) return false;
      state.blueprints.recipes[key] = true;
      queueNotification('BLUEPRINT ACQUIRED', `${String(key).toUpperCase()} blueprint unlocked (${String(source)}).`);
      markDirty();
      return true;
    }

    function listLockedAdvancedModuleTypes() {
      return Object.keys(MODULE_DEFS).filter((t) => !isModuleUnlocked(t) && !['rear', 'front', 'doorway', 'elevator', 'empty'].includes(t));
    }

    // ============================================================================
    // Ship Structure: Multi-Level, Multi-Corridor Architecture
    // ============================================================================

    /**
     * Define the ship's multi-level corridor graph.
     * Each level has corridors (sections of modules).
     * Corridors are connected via doors and elevators.
     */
    let SHIP_LAYOUT = {
      levels: {
        1: {
          name: 'DECK 1',
          corridors: {
            A: {
              name: 'Main Corridor',
              modules: [
                { type: 'fabricator', label: 'Fabricator' },
                { type: 'sensors', label: 'Sensors' }
              ],
              connections: {}
            }
          }
        }
      }
    };

    // ============================================================================
    // Module Definitions (from prototype, extended)
    // ============================================================================

    const MODULE_WIDTH = 560;
    const MODULE_SCALE = 0.5;
    const STATION_SIZE = { width: 150, height: 120, y: 400 };

    const MODULE_DEFS = {
      fabricator: {
        label: 'Fabricator',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'fabricator.status', label: 'Check Status', action: () => showMessage('FABRICATOR', 'Fabricator warmed and ready.') },
          {
            key: 'fabricator.build',
            label: 'Fabricate Item/Part',
            action: openFabricatorPanel,
            perform: () => autoFabricateConsumables()
          }
        ]
      },
      doorway: {
        label: 'Doorway',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: (station) => {
          const link = station.moduleRef && station.moduleRef.link ? station.moduleRef.link : null;
          if (!link) return [{ key: 'doorway.missing', label: 'No Link', action: () => showMessage('DOORWAY', 'No corridor linked.') }];
          return [
            {
              key: 'doorway.travel',
              label: `Enter Corridor ${link.corridor} (L${link.level})`,
              action: () => moveToLocation(link.level, link.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor } })
            }
          ];
        }
      },
      elevator: {
        label: 'Elevator',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: (station) => buildElevatorActions(station)
      },
      empty: {
        label: 'Empty Bay',
        width: MODULE_WIDTH
      },
      cargo: {
        label: 'Cargo Bay',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'cargo.buy.filter',
            label: 'Buy Filter',
            roles: ['quartermaster'],
            produces: { filter: 1 },
            consumes: { credits: 10 },
            perform: () => buyCargoItem('filter', 10)
          },
          {
            key: 'cargo.buy.medkit',
            label: 'Buy Medkit',
            roles: ['quartermaster'],
            produces: { medkit: 1 },
            consumes: { credits: 25 },
            perform: () => buyCargoItem('medkit', 25)
          },
          {
            key: 'cargo.buy.droneParts',
            label: 'Buy Drone Parts',
            roles: ['quartermaster'],
            produces: { droneParts: 1 },
            consumes: { credits: 20 },
            perform: () => buyCargoItem('droneParts', 20)
          },
          {
            key: 'cargo.buy.rations',
            label: 'Buy Rations',
            roles: ['quartermaster'],
            produces: { rations: 1 },
            consumes: { credits: 8 },
            perform: () => buyCargoItem('rations', 8)
          },
          {
            key: 'cargo.sell.ore',
            label: 'Sell Ore',
            roles: ['quartermaster'],
            produces: { credits: 5 },
            consumes: { ore: 1 },
            requires: { predicate: () => invAvailableAfterReserve('ore') > (corridorsWithModuleType('refinery').length ? 2 : 0) },
            perform: () => sellCargoItem('ore', 5, { respectReserve: true, minKeep: corridorsWithModuleType('refinery').length ? 2 : 0 })
          },
          {
            key: 'cargo.sell.scrap',
            label: 'Sell Scrap',
            roles: ['quartermaster'],
            produces: { credits: 8 },
            consumes: { scrap: 1 },
            perform: () => sellCargoItem('scrap', 8, { respectReserve: true })
          },
          {
            key: 'cargo.sell.ingot',
            label: 'Sell Ingot',
            roles: ['quartermaster'],
            produces: { credits: 15 },
            consumes: { ingot: 1 },
            perform: () => sellCargoItem('ingot', 15, { respectReserve: true })
          },
          {
            key: 'cargo.sell.rations',
            label: 'Sell Rations',
            roles: ['quartermaster'],
            produces: { credits: 4 },
            consumes: { rations: 1 },
            perform: () => sellCargoItem('rations', 4, { respectReserve: true })
          }
        ],
        actions: () => [
          { key: 'cargo.status', label: 'Inventory Readout', action: () => showMessage('CARGO', describeInventory()) },
          {
            key: 'cargo.buy.filter',
            label: 'Buy Filter (10 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('filter', 10, { showPanel: true }),
            perform: () => buyCargoItem('filter', 10)
          },
          {
            key: 'cargo.buy.medkit',
            label: 'Buy Medkit (25 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('medkit', 25, { showPanel: true }),
            perform: () => buyCargoItem('medkit', 25)
          },
          {
            key: 'cargo.buy.droneParts',
            label: 'Buy Drone Parts (20 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('droneParts', 20, { showPanel: true }),
            perform: () => buyCargoItem('droneParts', 20)
          },
          {
            key: 'cargo.buy.rations',
            label: 'Buy Rations (8 cr)',
            requiredRole: ['quartermaster'],
            action: () => buyCargoItem('rations', 8, { showPanel: true }),
            perform: () => buyCargoItem('rations', 8)
          },
          {
            key: 'cargo.sell.ore',
            label: 'Sell Ore (+5 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('ore', 5, { showPanel: true }),
            perform: () => sellCargoItem('ore', 5, { respectReserve: true, minKeep: corridorsWithModuleType('refinery').length ? 2 : 0 })
          },
          {
            key: 'cargo.sell.scrap',
            label: 'Sell Scrap (+8 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('scrap', 8, { showPanel: true }),
            perform: () => sellCargoItem('scrap', 8, { respectReserve: true })
          },
          {
            key: 'cargo.sell.ingot',
            label: 'Sell Ingot (+15 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('ingot', 15, { showPanel: true }),
            perform: () => sellCargoItem('ingot', 15, { respectReserve: true })
          },
          {
            key: 'cargo.sell.rations',
            label: 'Sell Rations (+4 cr)',
            requiredRole: ['quartermaster'],
            action: () => sellCargoItem('rations', 4, { showPanel: true }),
            perform: () => sellCargoItem('rations', 4, { respectReserve: true })
          },
          {
            key: 'cargo.trade',
            label: 'Trade / Sell Cargo',
            action: openCargoTradePanel,
            perform: () => autoSellCargo()
          }
        ]
      },
      power: {
        label: 'Power Core',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'power.status', label: 'Check Status', action: () => showMessage('POWER', `Output: ${Math.round(state.power)}%\nHeat: ${Math.round(state.heat)}%`) },
          {
            key: 'power.route',
            label: 'Route Power',
            action: () => openPowerRoutingPanel('POWER'),
            perform: () => autoRoutePower()
          },
          {
            key: 'power.boost',
            label: 'Boost Power',
            action: () => {
              state.power = Math.min(120, state.power + 15);
              markDirty();
              updateHUD();
              showMessage('POWER', 'Power boosted.');
            }
          },
          {
            key: 'power.toggleLights',
            label: state.lightsOn ? 'Turn Lights OFF' : 'Turn Lights ON',
            action: toggleLights,
            perform: toggleLights
          },
          {
            key: 'power.reset',
            label: state.incidents.powerTrip ? 'Reset Breakers' : 'Reset Breakers (OK)',
            action: () => resetPowerTrip(true),
            perform: () => resetPowerTrip(false)
          }
        ]
      },
      engine: {
        label: 'Engine Room',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'engine.status', label: 'Engine Status', action: () => showMessage('ENGINE', state.engineActive ? 'Engine online.' : 'Engine offline.') },
          {
            key: 'engine.toggle',
            label: state.engineActive ? 'Disable Engine' : 'Enable Engine',
            requiredRole: ['pilot', 'tech', 'engineer'],
            action: toggleEngine,
            perform: toggleEngine
          },
          {
            key: 'engine.throttle',
            label: 'Set Throttle',
            requiredRole: ['pilot', 'tech', 'engineer'],
            action: () => openThrottlePanel('ENGINE')
          },
          {
            key: 'engine.vent',
            label: 'Vent Heat',
            requiredRole: ['engineer', 'tech'],
            action: () => {
              if (state.power < 6) return showMessage('ENGINE', 'Need at least 6 power.');
              state.power = Math.max(0, state.power - 6);
              state.heat = Math.max(0, state.heat - 25);
              resolveIncident('fire');
              markDirty();
              showMessage('ENGINE', 'Heat vented.');
            },
            perform: () => {
              if (state.power < 6) return;
              state.power = Math.max(0, state.power - 6);
              state.heat = Math.max(0, state.heat - 25);
              resolveIncident('fire');
              markDirty();
            }
          }
        ]
      },
      life: {
        label: 'Life Support',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'life.status', label: 'Check Status', action: () => showMessage('LIFE', `Oxygen: ${Math.round(state.oxygen)}%\nFilters: ${invGet('filter')}`) },
          {
            key: 'life.toggle',
            label: state.lifeSupportOn ? 'Turn Life Support OFF' : 'Turn Life Support ON',
            action: toggleLifeSupport,
            perform: toggleLifeSupport
          },
          {
            key: 'life.emergency',
            label: 'Emergency Scrubbers',
            action: () => emergencyScrubbers(true),
            perform: () => emergencyScrubbers(false)
          },
          {
            key: 'life.seal',
            label: state.incidents.o2Leak ? 'Seal O2 Leak' : 'Seal O2 Leak (OK)',
            action: () => resolveIncident('o2Leak') && showMessage('LIFE', 'O2 leak sealed.'),
            perform: () => resolveIncident('o2Leak')
          }
        ]
      },
      hydro: {
        label: 'Hydroponics',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'hydro.toggle',
            label: 'Enable Grow Lights',
            roles: ['scientist', 'tech', 'engineer'],
            setsFlags: { hydroponicsOn: true },
            perform: () => toggleHydroponics()
          },
          {
            key: 'hydro.harvest',
            label: 'Harvest Crops',
            roles: ['scientist', 'tech', 'engineer'],
            produces: { rations: 2 },
            requires: { power: 4, flags: { hydroponicsOn: true } },
            perform: () => harvestHydroponics(false)
          }
        ],
        actions: () => [
          { key: 'hydro.status', label: 'Check Status', action: () => showMessage('HYDRO', `Rations: ${invGet('rations')}`) },
          {
            key: 'hydro.toggle',
            label: state.hydroponicsOn ? 'Turn Grow Lights OFF' : 'Turn Grow Lights ON',
            action: toggleHydroponics,
            perform: toggleHydroponics
          },
          {
            key: 'hydro.harvest',
            label: 'Harvest Rations',
            action: () => harvestHydroponics(true),
            perform: () => harvestHydroponics(false)
          }
        ]
      },
      canteen: {
        label: 'Canteen',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'canteen.status', label: 'Check Status', action: () => showMessage('CANTEEN', `Rations: ${invGet('rations')}\nHungry crew: ${countHungryCrew()}`) },
          {
            key: 'canteen.eat',
            label: 'Serve Ration',
            action: () => {
              const fed = feedNpc(findNearestHungryCrew());
              if (!fed) showMessage('CANTEEN', 'No hungry crew or no rations available.');
            },
            perform: () => feedNpc(findNearestHungryCrew())
          }
        ]
      },
      cockpit: {
        label: 'Cockpit',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'cockpit.status',
            label: 'Ship Status',
            action: () => {
              const inc = [];
              if (state.incidents.powerTrip) inc.push('POWER TRIP');
              if (state.incidents.o2Leak) inc.push('O2 LEAK');
              if (state.incidents.fire) inc.push('FIRE');
              if (state.incidents.breach) inc.push('HULL BREACH');
              const line = inc.length ? inc.join(', ') : 'None';
              showMessage('SHIP STATUS', `Incidents: ${line}\n\nPower: ${Math.round(state.power)}%\nOxygen: ${Math.round(state.oxygen)}%\nHull: ${Math.round((state.hull / Math.max(1, state.hullMax)) * 100)}%\nHeat: ${Math.round(state.heat)}%\nRations: ${invGet('rations')}\nMorale: ${Math.round(state.morale)}%`);
            }
          },
          { key: 'cockpit.nav', label: 'Navigation', action: openNavigationPanel },
          { key: 'cockpit.power', label: 'Power Routing', action: () => openPowerRoutingPanel('COCKPIT') },
          { key: 'cockpit.command', label: 'Crew Command', action: openCrewCommandPanel },
          { key: 'cockpit.comms', label: 'Open Comms (Contracts)', requiredRole: ['pilot', 'quartermaster'], action: openContractsPanel }
        ]
      },
      computer: {
        label: 'Computer Room',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'computer.status',
            label: 'System Status',
            action: () => {
              const text = `${shipStatusReport()}\n\n${describeAiBlockers({ maxItems: 12 })}`;
              openPanel(
                'COMPUTER',
                text,
                [
                  {
                    label: 'Copy Debug JSON',
                    action: async () => {
                      const payload = JSON.stringify(buildAiDebugExport(), null, 2);
                      const ok = await copyToClipboard(payload);
                      showMessage('COMPUTER', ok ? 'Debug data copied.' : 'Copy failed.');
                    }
                  },
                  {
                    label: 'Reset Blockers',
                    action: () => {
                      state.aiBlockers = {};
                      if (state.meta) state.meta.aiBlockerAt = {};
                      markDirty();
                      showMessage('COMPUTER', 'AI blockers reset.');
                    }
                  },
                  { label: 'Back', action: closePanel }
                ],
                { includeCancel: false }
              );
            }
          },
          {
            key: 'computer.crew',
            label: 'Crew Automation',
            action: openCrewCommandPanel
          }
        ]
      },
      medbay: {
        label: 'Medbay',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'medbay.status', label: 'Check Status', action: () => showMessage('MEDBAY', `Medkits: ${invGet('medkit')}`) },
          {
            key: 'med.treat',
            label: 'Treat Crew',
            action: () => treatInjury(true),
            perform: () => treatInjury(false)
          }
        ]
      },
      comms: {
        label: 'Comms',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'comms.status', label: 'Check Status', action: () => showMessage('COMMS', 'Channels clear.') },
          {
            key: 'comms.contracts',
            label: 'Open Contracts',
            requiredRole: ['pilot', 'quartermaster'],
            action: openContractsPanel,
            perform: () => autoManageContracts()
          }
        ]
      },
      sensors: {
        label: 'Sensors',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'sensors.scan',
            label: 'Sensor Sweep',
            roles: ['scientist', 'tech'],
            produces: { scrap: 1, ore: 1 },
            perform: () => scanForAnomalies(false)
          }
        ],
        actions: () => [
          { key: 'sensors.status', label: 'Check Status', action: () => showMessage('SENSORS', 'Scan grid stable.') },
          {
            key: 'sensors.scan',
            label: 'Scan (Loot)',
            requiredRole: ['scientist', 'tech'],
            action: () => scanForAnomalies(true),
            perform: () => scanForAnomalies(false)
          },
          {
            key: 'sensors.deepScan',
            label: 'Deep Scan (Blueprints)',
            requiredRole: ['scientist', 'tech'],
            action: () => deepScanBlueprint(true),
            perform: () => deepScanBlueprint(false)
          }
        ]
      },
      shields: {
        label: 'Shields',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'shields.status', label: 'Check Status', action: () => showMessage('SHIELDS', state.shieldsOn ? 'Shields charged.' : 'Shields offline.') },
          {
            key: 'shields.toggle',
            label: state.shieldsOn ? 'Turn Shields OFF' : 'Turn Shields ON',
            action: toggleShields,
            perform: toggleShields
          },
          {
            key: 'shields.bulkhead',
            label: state.incidents.breach ? 'Seal Bulkheads' : 'Seal Bulkheads (OK)',
            action: () => sealBulkheads(true),
            perform: () => sealBulkheads(false)
          }
        ]
      },
      refinery: {
        label: 'Refinery',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'refinery.refine',
            label: 'Refine Ore',
            roles: ['engineer', 'tech'],
            produces: { ingot: 1 },
            consumes: { ore: 3 },
            perform: () => refineOre(false)
          }
        ],
        actions: () => [
          { key: 'refinery.status', label: 'Check Status', action: () => showMessage('REFINERY', `Ore: ${invGet('ore')} / Ingots: ${invGet('ingot')}`) },
          {
            key: 'refinery.refine',
            label: 'Refine Ore',
            requiredRole: ['engineer', 'tech'],
            action: () => openRefineryPanel(true),
            perform: () => refineOre(false)
          }
        ]
      },
      drones: {
        label: 'Drone Bay',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        aiActions: [
          {
            key: 'drones.salvage',
            label: 'Launch Salvage Drone',
            roles: ['specialist', 'pilot'],
            produces: { scrap: 1, ore: 1 },
            consumes: { droneParts: 1 },
            perform: () => launchSalvageDrone(false)
          }
        ],
        actions: () => [
          { key: 'drones.status', label: 'Check Status', action: () => showMessage('DRONES', `Drone parts: ${invGet('droneParts')}`) },
          {
            key: 'drones.repair',
            label: 'Launch Repair Drone',
            requiredRole: ['engineer', 'specialist'],
            action: () => launchRepairDrone(true),
            perform: () => launchRepairDrone(false)
          },
          {
            key: 'drones.salvage',
            label: 'Launch Salvage Drone',
            requiredRole: ['specialist', 'pilot'],
            action: () => launchSalvageDrone(true),
            perform: () => launchSalvageDrone(false)
          }
        ]
      },
      airlock: {
        label: 'Airlock',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'airlock.status', label: 'Check Status', action: () => showMessage('AIRLOCK', 'Pressure stable.') },
          {
            key: 'airlock.eva',
            label: 'EVA Patch Hull',
            requiredRole: ['engineer', 'specialist'],
            action: () => openAirlockPanel(true),
            perform: () => performEvaRepair(false)
          }
        ]
      },
      workshop: {
        label: 'Workshop',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          { key: 'workshop.status', label: 'Check Status', action: () => showMessage('WORKSHOP', 'Tools online.') },
          {
            key: 'workshop.plating',
            label: 'Install Hull Plating',
            action: () => installHullPlating(true),
            perform: () => installHullPlating(false)
          },
          {
            key: 'workshop.install',
            label: 'Install Upgrade',
            action: openWorkshopPanel,
            perform: () => autoInstallUpgrade()
          },
          {
            key: 'workshop.repair',
            label: 'Repair Hull',
            action: () => repairHull(true),
            perform: () => repairHull(false)
          }
        ]
      },
      quarters: {
        label: 'Crew Quarters',
        width: MODULE_WIDTH,
        station: { ...STATION_SIZE },
        actions: () => [
          {
            key: 'quarters.transferIn',
            label: 'Transfer Crew IN (Hire)',
            playerOnly: true,
            action: () => {
              const maxCrew = MAX_CREW;
              const crewCount = Array.isArray(state.npcs) ? state.npcs.length : 0;
              if (crewCount >= maxCrew) {
                showMessage('QUARTERS', `Crew capacity reached (${maxCrew}).`);
                return;
              }

              const fee = 30;
              const candidates = ['CREW', 'TECH', 'MEDIC', 'PILOT', 'ENGINEER', 'SCIENTIST', 'QUARTERMASTER', 'SECURITY', 'SPECIALIST'];
              openPanel(
                'TRANSFER CREW IN',
                `Select a crew member to transfer in.\n\nTransport fee: ${fee} credits (you have ${Math.floor(state.credits)}).`,
                [
                  ...candidates.map((name) => ({
                    label: `Hire ${name} (${Math.floor(state.credits)}/${fee} cr)`,
                    action: () => {
                      if (state.credits < fee) {
                        showMessage('QUARTERS', `Need ${fee} credits (have ${Math.floor(state.credits)}).`);
                        return;
                      }
                      state.credits -= fee;
                      addCrewMember(name);
                      updateHUD();
                      showMessage('QUARTERS', `${name} transferred aboard.`);
                    }
                  })),
                  { label: 'Back', action: closePanel }
                ],
                { includeCancel: false }
              );
            }
          },
          {
            key: 'quarters.transferOut',
            label: 'Transfer Crew OUT (Dismiss)',
            requiredRole: ['quartermaster'],
            action: (actor) => {
              const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
              if (npcs.length === 0) {
                if (actor === 'player') showMessage('QUARTERS', 'No crew to transfer out.');
                else queueNotification('QUARTERS', 'No crew to transfer out (AUTOMATION).');
                return;
              }

              if (actor !== 'player') {
                const qmCount = npcs.filter((n) => npcRole(n) === 'quartermaster').length;
                let candidates = npcs;
                if (qmCount <= 1) candidates = npcs.filter((n) => npcRole(n) !== 'quartermaster');
                if (!candidates.length) candidates = npcs;
                const rolePriority = { crew: 0, security: 1, specialist: 2, scientist: 3, tech: 4, engineer: 5, medic: 6, pilot: 7, quartermaster: 8 };
                candidates.sort((a, b) => {
                  const pa = rolePriority[npcRole(a)] ?? 9;
                  const pb = rolePriority[npcRole(b)] ?? 9;
                  return pa - pb;
                });
                const chosen = candidates[0];
                if (!chosen) return;
                removeCrewMemberById(chosen.id);
                updateHUD();
                queueNotification('QUARTERS', `${chosen.name} transferred out (AUTOMATION).`);
                return;
              }

              openPanel(
                'TRANSFER CREW OUT',
                'Select a crew member to transfer out:',
                [
                  ...npcs.map((n) => ({
                    label: `Dismiss ${n.name}`,
                    danger: true,
                    action: () => {
                      removeCrewMemberById(n.id);
                      showMessage('QUARTERS', `${n.name} transferred out.`);
                    }
                  })),
                  { label: 'Back', action: closePanel }
                ],
                { includeCancel: false }
              );
            }
          },
          {
            key: 'quarters.rest',
            label: `Rest (Rations ${invGet('rations')} / 1)`,
            action: () => restCrew(true),
            perform: () => restCrew(false)
          }
        ]
      }
    };

    // ============================================================================
    // Ship Navigation & Layout
    // ============================================================================

    function getCorridorDef(level, corridor) {
      const levelDef = SHIP_LAYOUT.levels[level];
      if (!levelDef) return null;
      return levelDef.corridors[corridor] || null;
    }

    function formatDeckName(level) {
      if (level < 1) return `BASEMENT B${Math.abs(level)}`;
      return `DECK ${level}`;
    }

    function formatLevelLabel(level) {
      if (level < 1) return `B${Math.abs(level)}`;
      return `L${level}`;
    }

    function ensureLevel(level) {
      if (!SHIP_LAYOUT.levels[level]) {
        SHIP_LAYOUT.levels[level] = { name: formatDeckName(level), corridors: {} };
      }
      return SHIP_LAYOUT.levels[level];
    }

    function nextCorridorId(level) {
      const levelDef = ensureLevel(level);
      const existing = new Set(Object.keys(levelDef.corridors));
      const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let i = 0; i < alphabet.length; i++) {
        const id = alphabet[i];
        if (!existing.has(id)) return id;
      }
      let idx = 1;
      while (true) {
        const id = `A${idx}`;
        if (!existing.has(id)) return id;
        idx++;
      }
    }

    function ensureCorridor(level, corridor, { name = null, modules = null } = {}) {
      const levelDef = ensureLevel(level);
      if (!levelDef.corridors[corridor]) {
        levelDef.corridors[corridor] = {
          name: name || `Corridor ${corridor}`,
          modules: Array.isArray(modules) ? modules : [],
          connections: {}
        };
      }
      ensureCorridorModules(level, corridor);
      return levelDef.corridors[corridor];
    }

    function ensureCorridorModules(level, corridor) {
      const def = getCorridorDef(level, corridor);
      if (!def) return;
      if (!Array.isArray(def.modules)) def.modules = [];
      def.modules.forEach((m) => {
        if (!m.uid) m.uid = newUid();
      });
    }

    const AUTO_BUILD_GROUPS = {
      crew: {
        label: 'Crew',
        types: new Set(['quarters', 'medbay', 'canteen', 'hydro', 'life'])
      },
      engineering: {
        label: 'Engineering',
        types: new Set(['power', 'engine', 'shields', 'refinery', 'workshop', 'airlock'])
      },
      operations: {
        label: 'Operations',
        types: new Set(['cargo', 'cockpit', 'comms', 'sensors', 'drones'])
      },
      science: {
        label: 'Science',
        types: new Set(['computer'])
      }
    };

    function moduleGroupForType(type) {
      for (const [key, group] of Object.entries(AUTO_BUILD_GROUPS)) {
        if (group.types.has(type)) return key;
      }
      return 'hub';
    }

    function getAutoBuildHubCorridor() {
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        const level = Number(levelKey);
        for (const [corridorKey, corridorDef] of Object.entries(levelDef.corridors || {})) {
          const modules = corridorDef.modules || [];
          if (modules.some((m) => m && m.type === 'fabricator')) {
            return { level, corridor: corridorKey };
          }
        }
      }
      return { level: state.currentLevel, corridor: state.currentCorridor };
    }

    function insertModuleAtInCorridor(level, corridor, index, module) {
      const corridorDef = getCorridorDef(level, corridor);
      if (!corridorDef) return false;
      ensureCorridorModules(level, corridor);
      const m = { ...module };
      if (!m.uid) m.uid = newUid();
      corridorDef.modules.splice(index, 0, m);
      markDirty();
      if (level === state.currentLevel && corridor === state.currentCorridor) {
        relayoutCorridor();
      }
      return true;
    }

    function corridorHasLink(level, corridor, targetLevel, targetCorridor) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return false;
      return def.modules.some((m) => m && m.type === 'doorway' && m.link && m.link.level === targetLevel && m.link.corridor === targetCorridor);
    }

    function ensureDoorwayLink(level, corridor, targetLevel, targetCorridor) {
      if (level === undefined || corridor === undefined || targetLevel === undefined || targetCorridor === undefined) return false;
      if (level === targetLevel && corridor === targetCorridor) return false;
      if (corridorHasLink(level, corridor, targetLevel, targetCorridor)) return false;
      const modules = getModulesForCorridor(level, corridor);
      const inserted = insertModuleAtInCorridor(level, corridor, modules.length, {
        type: 'doorway',
        label: 'Doorway',
        link: { level: targetLevel, corridor: targetCorridor }
      });
      return inserted;
    }

    function findGroupCorridor(groupKey) {
      let best = null;
      let bestCount = 0;
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        const level = Number(levelKey);
        for (const [corridorKey, corridorDef] of Object.entries(levelDef.corridors || {})) {
          if (corridorDef.group === groupKey) return { level, corridor: corridorKey };
          const modules = corridorDef.modules || [];
          const count = modules.reduce((acc, m) => acc + (m && AUTO_BUILD_GROUPS[groupKey] && AUTO_BUILD_GROUPS[groupKey].types.has(m.type) ? 1 : 0), 0);
          if (count > bestCount) {
            best = { level, corridor: corridorKey };
            bestCount = count;
          }
        }
      }
      if (best && bestCount > 0) {
        const def = getCorridorDef(best.level, best.corridor);
        if (def) def.group = groupKey;
        return best;
      }
      return null;
    }

    function ensureGroupCorridor(groupKey, hubLevel, hubCorridor) {
      const existing = findGroupCorridor(groupKey);
      if (existing) {
        if (!(existing.level === hubLevel && existing.corridor === hubCorridor)) {
          ensureDoorwayLink(hubLevel, hubCorridor, existing.level, existing.corridor);
          ensureDoorwayLink(existing.level, existing.corridor, hubLevel, hubCorridor);
        }
        updateDoorwayLabelsForAll();
        return existing;
      }

      const level = hubLevel;
      const corridorId = nextCorridorId(level);
      const label = AUTO_BUILD_GROUPS[groupKey] ? AUTO_BUILD_GROUPS[groupKey].label : groupKey;
      const newCorridor = ensureCorridor(level, corridorId, {
        name: `${label} Corridor ${corridorId}`,
        modules: []
      });
      newCorridor.group = groupKey;

      ensureDoorwayLink(hubLevel, hubCorridor, level, corridorId);
      ensureDoorwayLink(level, corridorId, hubLevel, hubCorridor);
      updateDoorwayLabelsForAll();

      return { level, corridor: corridorId };
    }

    function findModuleByUid(uid) {
      for (const lvl of Object.values(SHIP_LAYOUT.levels)) {
        for (const c of Object.values(lvl.corridors)) {
          const found = (c.modules || []).find((m) => m.uid === uid);
          if (found) return found;
        }
      }
      return null;
    }

    function createLinkedDoorway(fromModule) {
      if (!fromModule) return null;
      const level = state.currentLevel;
      const corridorId = nextCorridorId(level);
      if (!corridorId || corridorId === state.currentCorridor) return null;
      const newCorridor = ensureCorridor(level, corridorId, {
        name: `Corridor ${corridorId}`,
        modules: []
      });

      const backDoor = { type: 'doorway', label: `Doorway ${corridorId}`, uid: newUid(), link: { level, corridor: state.currentCorridor } };
      newCorridor.modules.push(backDoor);

      fromModule.link = { level, corridor: corridorId };
      markDirty();
      updateDoorwayLabelsForAll();
      return fromModule.link;
    }

    const STRUCTURE_TYPES = new Set(['doorway', 'elevator', 'rear', 'front', 'empty']);

    function corridorEquipmentSummary(level, corridor, { maxItems = 3 } = {}) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return 'UNKNOWN';
      const names = [];
      for (const m of def.modules) {
        if (!m || STRUCTURE_TYPES.has(m.type)) continue;
        const defn = MODULE_DEFS[m.type];
        const label = moduleDisplayLabel(m, defn);
        if (!names.includes(label)) names.push(label);
      }
      if (!names.length) return 'EMPTY';
      const visible = names.slice(0, maxItems);
      const extra = names.length - visible.length;
      return extra > 0 ? `${visible.join(', ')} +${extra}` : visible.join(', ');
    }

    function doorwayLabelForLink(link) {
      if (!link) return 'Doorway';
      const target = `${formatLevelLabel(link.level)}${link.corridor}`;
      const summary = corridorEquipmentSummary(link.level, link.corridor);
      return `To ${target} Â· ${summary}`;
    }

    function updateDoorwayLabelsForAll() {
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        const level = Number(levelKey);
        if (!levelDef || !levelDef.corridors) continue;
        for (const corridor of Object.values(levelDef.corridors)) {
          const modules = Array.isArray(corridor.modules) ? corridor.modules : [];
          for (const m of modules) {
            if (!m || m.type !== 'doorway' || !m.link) continue;
            const nextLabel = doorwayLabelForLink(m.link);
            if (!m.customLabel || m.autoLabel) {
              m.customLabel = nextLabel;
              m.autoLabel = true;
            }
          }
        }
      }
    }

    function ensureAutoBuildDoorway() {
      const modules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
      if (!modules || modules.some((m) => m && m.type === 'doorway')) {
        updateDoorwayLabelsForAll();
        return false;
      }
      if (modules.length < 4) {
        updateDoorwayLabelsForAll();
        return false;
      }
      const insertIndex = modules.length;
      const ok = insertModuleAt(insertIndex, { type: 'doorway', label: 'Doorway' });
      if (!ok) return false;
      const corridorModules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
      const inserted = corridorModules[insertIndex];
      if (inserted) {
        createLinkedDoorway(inserted);
        relayoutCorridor();
        updateDoorwayLabelsForAll();
      }
      return true;
    }

    function createLinkedElevator(fromModule, direction) {
      const delta = direction === 'up' ? 1 : -1;
      const level = state.currentLevel + delta;
      const corridorId = nextCorridorId(level);
      const newCorridor = ensureCorridor(level, corridorId, {
        name: `${formatDeckName(level)} Â· Corridor ${corridorId}`,
        modules: []
      });

      const elevatorBack = { type: 'elevator', label: 'Elevator', uid: newUid(), elevator: {} };
      elevatorBack.elevator[direction === 'up' ? 'down' : 'up'] = { level: state.currentLevel, corridor: state.currentCorridor };
      newCorridor.modules.push(elevatorBack);

      if (!fromModule.elevator) fromModule.elevator = {};
      fromModule.elevator[direction] = { level, corridor: corridorId };
      markDirty();
      return fromModule.elevator[direction];
    }

    function corridorKey(level, corridor) {
      return `${level}:${corridor}`;
    }

    function parseCorridorKey(key) {
      const [levelStr, corridor] = String(key).split(':');
      return { level: Number(levelStr), corridor };
    }

    function listLinkedCorridors(level, corridor) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return [];
      const links = [];
      for (const m of def.modules) {
        if (m.type === 'doorway' && m.link) {
          links.push(corridorKey(m.link.level, m.link.corridor));
        }
        if (m.type === 'elevator' && m.elevator) {
          if (m.elevator.up) links.push(corridorKey(m.elevator.up.level, m.elevator.up.corridor));
          if (m.elevator.down) links.push(corridorKey(m.elevator.down.level, m.elevator.down.corridor));
        }
      }
      return links;
    }

    function collectCascade(startLevel, startCorridor, excludeKey) {
      const startKey = corridorKey(startLevel, startCorridor);
      const queue = [startKey];
      const toDelete = new Set();
      while (queue.length) {
        const key = queue.shift();
        if (key === excludeKey) continue;
        if (toDelete.has(key)) continue;
        const { level, corridor } = parseCorridorKey(key);
        if (!getCorridorDef(level, corridor)) continue;
        toDelete.add(key);
        const next = listLinkedCorridors(level, corridor);
        for (const n of next) {
          if (!toDelete.has(n) && n !== excludeKey) queue.push(n);
        }
      }
      return toDelete;
    }

    function deleteCorridors(keys) {
      for (const key of keys) {
        const { level, corridor } = parseCorridorKey(key);
        const levelDef = SHIP_LAYOUT.levels[level];
        if (levelDef && levelDef.corridors && levelDef.corridors[corridor]) {
          delete levelDef.corridors[corridor];
        }
      }
    }

    function relocateOrphanedNpcs(keys) {
      const currentKey = corridorKey(state.currentLevel, state.currentCorridor);
      if (!Array.isArray(state.npcs)) return;
      let offset = 0;
      for (const npc of state.npcs) {
        const npcKey = corridorKey(npc.level, npc.corridor);
        if (keys.has(npcKey) && npcKey !== currentKey) {
          npc.level = state.currentLevel;
          npc.corridor = state.currentCorridor;
          npc.x = clamp(state.player.x + 60 + offset, state.walkBounds.minX, state.walkBounds.maxX);
          npc.vx = 0;
          npc.mode = 'idle';
          npc.paused = false;
          npc.wanderTarget = null;
          npc.thinkTimer = 0;
          npc.walkPhase = 0;
          npc.destinationType = null;
          npc.destinationCorridorKey = null;
          offset += 20;
        }
      }
    }

    function removeModuleByUid(uid) {
      const corridorDef = getCorridorDef(state.currentLevel, state.currentCorridor);
      if (!corridorDef || !Array.isArray(corridorDef.modules)) return false;
      if (corridorDef.modules.length <= 1) return false;
      const layoutEntry = modulesLayout.find((m) => m.moduleRef && m.moduleRef.uid === uid);
      const idx = corridorDef.modules.findIndex((m) => m.uid === uid);
      if (idx < 0) return false;
      const mod = corridorDef.modules[idx];
      const removeWidth = layoutEntry ? layoutEntry.width : 0;
      const removeX = layoutEntry ? layoutEntry.x : 0;

      const currentKey = corridorKey(state.currentLevel, state.currentCorridor);
      const cascades = new Set();
      if (mod.type === 'doorway' && mod.link) {
        const keys = collectCascade(mod.link.level, mod.link.corridor, currentKey);
        keys.forEach((k) => cascades.add(k));
      }
      if (mod.type === 'elevator' && mod.elevator) {
        if (mod.elevator.up) {
          const keys = collectCascade(mod.elevator.up.level, mod.elevator.up.corridor, currentKey);
          keys.forEach((k) => cascades.add(k));
        }
        if (mod.elevator.down) {
          const keys = collectCascade(mod.elevator.down.level, mod.elevator.down.corridor, currentKey);
          keys.forEach((k) => cascades.add(k));
        }
      }

      corridorDef.modules.splice(idx, 1);

      if (cascades.size) {
        relocateOrphanedNpcs(cascades);
        deleteCorridors(cascades);
      }

      if (removeWidth > 0) {
        if (state.player.x > removeX) state.player.x -= removeWidth;
        if (Array.isArray(state.npcs)) {
          for (const npc of state.npcs) {
            if (npc.level === state.currentLevel && npc.corridor === state.currentCorridor && npc.x > removeX) {
              npc.x -= removeWidth;
            }
          }
        }
      }

      markDirty();
      relayoutCorridor();
      return true;
    }

    function getCorridorLayout(level, corridor) {
      const modules = getModulesForCorridor(level, corridor);
      const endCaps = [
        { type: 'rear', width: 130 },
        ...modules,
        { type: 'front', width: 130 }
      ];

      const layout = [];
      let x = 0;
      for (const m of endCaps) {
        const def = MODULE_DEFS[m.type] || { width: MODULE_WIDTH };
        const w = def.width * MODULE_SCALE;
        const isWalkable = m.type !== 'rear' && m.type !== 'front';
        layout.push({
          type: m.type,
          x,
          width: w,
          walkable: isWalkable,
          moduleRef: isWalkable ? m : null
        });
        x += w;
      }

      const walkables = layout.find((m) => m.walkable) ? layout.filter((m) => m.walkable) : [];
      let bounds = { minX: 50, maxX: Math.max(50, x - 50) };
      if (walkables.length) {
        bounds = {
          minX: walkables[0].x + 50,
          maxX: walkables[walkables.length - 1].x + walkables[walkables.length - 1].width - 50
        };
      }
      return { layout, bounds, endX: x };
    }

    function corridorHasModuleType(level, corridor, type) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return false;
      return def.modules.some((m) => m.type === type);
    }

    function corridorsWithModuleType(type) {
      const out = [];
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        for (const corridorId of Object.keys(levelDef.corridors || {})) {
          if (corridorHasModuleType(Number(levelKey), corridorId, type)) {
            out.push(corridorKey(Number(levelKey), corridorId));
          }
        }
      }
      return out;
    }

    function listAllCorridors() {
      const out = [];
      for (const [levelKey, levelDef] of Object.entries(SHIP_LAYOUT.levels)) {
        for (const corridorId of Object.keys(levelDef.corridors || {})) {
          out.push(corridorKey(Number(levelKey), corridorId));
        }
      }
      return out;
    }

    function findRoute(startKey, targetKeys) {
      const targets = new Set(targetKeys);
      const queue = [startKey];
      const prev = new Map();
      prev.set(startKey, null);
      while (queue.length) {
        const key = queue.shift();
        if (targets.has(key)) {
          const path = [];
          let cur = key;
          while (cur) {
            path.push(cur);
            cur = prev.get(cur) || null;
          }
          path.reverse();
          return path;
        }
        const { level, corridor } = parseCorridorKey(key);
        const next = listLinkedCorridors(level, corridor);
        for (const n of next) {
          if (!prev.has(n)) {
            prev.set(n, key);
            queue.push(n);
          }
        }
      }
      return null;
    }

    function findLinkModule(level, corridor, targetKey) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return null;
      const { level: tgtLevel, corridor: tgtCorridor } = parseCorridorKey(targetKey);
      for (const m of def.modules) {
        if (m.type === 'doorway' && m.link && m.link.level === tgtLevel && m.link.corridor === tgtCorridor) return { module: m, type: 'doorway' };
        if (m.type === 'elevator' && m.elevator) {
          if (m.elevator.up && m.elevator.up.level === tgtLevel && m.elevator.up.corridor === tgtCorridor) return { module: m, type: 'elevator' };
          if (m.elevator.down && m.elevator.down.level === tgtLevel && m.elevator.down.corridor === tgtCorridor) return { module: m, type: 'elevator' };
        }
      }
      return null;
    }

    function moduleCenterInCorridor(level, corridor, moduleRef) {
      if (!moduleRef) return null;
      const { layout } = getCorridorLayout(level, corridor);
      const entry = layout.find((m) => m.moduleRef && m.moduleRef.uid === moduleRef.uid);
      if (!entry) return null;
      return entry.x + entry.width * 0.5;
    }

    function findModuleByType(level, corridor, type) {
      const def = getCorridorDef(level, corridor);
      if (!def || !Array.isArray(def.modules)) return null;
      return def.modules.find((m) => m.type === type) || null;
    }

    function listRoutableModuleTypes() {
      const blocked = new Set(['rear', 'front', 'empty', 'doorway', 'elevator']);
      const types = new Set();
      for (const levelDef of Object.values(SHIP_LAYOUT.levels)) {
        for (const corridorDef of Object.values(levelDef.corridors || {})) {
          for (const m of corridorDef.modules || []) {
            if (!blocked.has(m.type)) types.add(m.type);
          }
        }
      }
      return [...types];
    }

    function buildElevatorActions(station) {
      const moduleRef = station.moduleRef;
      if (!moduleRef) return [];
      if (!moduleRef.elevator) moduleRef.elevator = {};
      const actions = [];
      if (moduleRef.elevator.up) {
        actions.push({
          key: 'elevator.up',
          label: `Go Up (${formatLevelLabel(moduleRef.elevator.up.level)} ${moduleRef.elevator.up.corridor})`,
          action: () => moveToLocation(moduleRef.elevator.up.level, moduleRef.elevator.up.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor }, spawnType: 'elevator' })
        });
      }
      if (moduleRef.elevator.down) {
        actions.push({
          key: 'elevator.down',
          label: `Go Down (${formatLevelLabel(moduleRef.elevator.down.level)} ${moduleRef.elevator.down.corridor})`,
          action: () => moveToLocation(moduleRef.elevator.down.level, moduleRef.elevator.down.corridor, { spawnFrom: { level: state.currentLevel, corridor: state.currentCorridor }, spawnType: 'elevator' })
        });
      }

      if (!moduleRef.elevator.up) {
        actions.push({
          key: 'elevator.createUp',
          label: 'Create Floor Above',
          action: () => {
            createLinkedElevator(moduleRef, 'up');
            showMessage('ELEVATOR', 'Created floor above.');
            relayoutCorridor();
          }
        });
      }
      if (!moduleRef.elevator.down) {
        actions.push({
          key: 'elevator.createDown',
          label: 'Create Floor Below',
          action: () => {
            createLinkedElevator(moduleRef, 'down');
            showMessage('ELEVATOR', 'Created floor below.');
            relayoutCorridor();
          }
        });
      }

      return actions;
    }

    function getModulesForCorridor(level, corridor) {
      const corridorDef = getCorridorDef(level, corridor);
      if (!corridorDef) return [];
      ensureCorridorModules(level, corridor);
      return corridorDef.modules || [];
    }

    function getConnectionsForCorridor(level, corridor) {
      const corridorDef = getCorridorDef(level, corridor);
      if (!corridorDef) return {};
      return corridorDef.connections || {};
    }

    function moveToLocation(level, corridor, { spawnFrom = null, spawnType = 'doorway' } = {}) {
      if (!getCorridorDef(level, corridor)) return false;
      state.currentLevel = level;
      state.currentCorridor = corridor;
      if (spawnFrom) {
        state.pendingSpawn = { linkFrom: spawnFrom, type: spawnType };
      } else {
        state.pendingSpawn = null;
      }
      state.player.x = 400;
      state.player.vx = 0;
      state.sim.snap = true;
      relayoutCorridor();
      return true;
    }

    function insertModuleAt(index, module) {
      const corridorDef = getCorridorDef(state.currentLevel, state.currentCorridor);
      if (!corridorDef) return false;
      ensureCorridorModules(state.currentLevel, state.currentCorridor);
      const m = { ...module };
      if (!m.uid) m.uid = newUid();
      corridorDef.modules.splice(index, 0, m);
      markDirty();
      relayoutCorridor();
      return true;
    }

    function openInsertModulePanel(insertIndex) {
      const options = Object.keys(MODULE_DEFS).filter((k) => {
        if (['rear', 'front'].includes(k)) return false;
        if (['doorway', 'elevator', 'empty'].includes(k)) return true;
        return isModuleUnlocked(k);
      });
      const buttons = options.map((type) => {
        const def = MODULE_DEFS[type];
        const label = def && def.label ? def.label : type;
        return {
          label,
          action: () => {
            const ok = insertModuleAt(insertIndex, { type, label });
            if (!ok) return;
            const corridorModules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
            const inserted = corridorModules[insertIndex];
            if (type === 'doorway') {
              createLinkedDoorway(inserted);
            }
            if (type === 'elevator') {
              if (!inserted.elevator) inserted.elevator = {};
            }
            relayoutCorridor();
            closePanel();
          }
        };
      });

      openPanel('ADD MODULE', `Insert module at position ${insertIndex + 1}.`, buttons, { allowImmediate: true });
    }

    // ============================================================================
    // Layout & Rendering (Enhanced with visual richness from original)
    // ============================================================================

    let modulesLayout = [];
    let stations = [];
    let corridorEndX = 800;

    function moduleDisplayLabel(moduleRef, def) {
      if (moduleRef && moduleRef.customLabel) return moduleRef.customLabel;
      if (moduleRef && moduleRef.label) return moduleRef.label;
      if (def && def.label) return def.label;
      return moduleRef && moduleRef.type ? moduleRef.type : 'MODULE';
    }

    function relayoutCorridor() {
      modulesLayout = [];
      stations = [];

      const modules = getModulesForCorridor(state.currentLevel, state.currentCorridor);
      const endCaps = [
        { type: 'rear', width: 130 },
        ...modules,
        { type: 'front', width: 130 }
      ];

      let x = 0;
      let corridorIndex = 0;
      for (const m of endCaps) {
        const def = MODULE_DEFS[m.type] || { width: 520 };
        const w = def.width * MODULE_SCALE;
        const isWalkable = m.type !== 'rear' && m.type !== 'front';
        modulesLayout.push({
          type: m.type,
          label: moduleDisplayLabel(m, def),
          x,
          width: w,
          walkable: isWalkable,
          corridorIndex: isWalkable ? corridorIndex : -1,
          moduleRef: isWalkable ? m : null
        });
        if (isWalkable) corridorIndex++;
        x += w;
      }

      corridorEndX = x;

      const walkables = modulesLayout.filter((m) => m.walkable);
      if (walkables.length) {
        const first = walkables[0];
        const last = walkables[walkables.length - 1];
        state.walkBounds = {
          minX: first.x + 50,
          maxX: last.x + last.width - 50
        };
      } else {
        state.walkBounds = { minX: 50, maxX: Math.max(50, corridorEndX - 50) };
      }

      // Build stations
      const stationInset = BULKHEAD_W;
      for (const module of modulesLayout) {
        if (module.type === 'rear' || module.type === 'front') continue;
        const def = MODULE_DEFS[module.type];
        if (!def || !def.station) continue;
        const st = def.station;
        const interior = moduleInterior(module);
        const interactX = interior.start + interior.width * 0.5;
        stations.push({
          id: `${module.type}::${module.label}::${module.moduleRef ? module.moduleRef.uid : ''}`,
          type: module.type,
          label: module.label,
          moduleRef: module.moduleRef,
          x: interactX - st.width / 2,
          y: st.y,
          width: st.width,
          height: st.height,
          interactX,
          getActions: (station) => {
            const def = MODULE_DEFS[module.type];
            return def && def.actions ? def.actions(station) : [];
          }
        });
      }

      if (state.pendingSpawn && state.pendingSpawn.linkFrom) {
        const from = state.pendingSpawn.linkFrom;
        if (state.pendingSpawn.type === 'elevator') {
          const elevModule = modulesLayout.find((m) => m.type === 'elevator' && m.moduleRef && m.moduleRef.elevator && ((m.moduleRef.elevator.up && m.moduleRef.elevator.up.level === from.level && m.moduleRef.elevator.up.corridor === from.corridor) || (m.moduleRef.elevator.down && m.moduleRef.elevator.down.level === from.level && m.moduleRef.elevator.down.corridor === from.corridor)));
          if (elevModule) {
            state.player.x = elevModule.x + elevModule.width * 0.5;
          }
        } else {
          const doorModule = modulesLayout.find((m) => m.type === 'doorway' && m.moduleRef && m.moduleRef.link && m.moduleRef.link.level === from.level && m.moduleRef.link.corridor === from.corridor);
          if (doorModule) {
            state.player.x = doorModule.x + doorModule.width * 0.5;
          }
        }
        state.pendingSpawn = null;
      }

      updateLocationHUD();
      renderCorridor();
    }

    function renderCorridor() {
      const svg = document.getElementById('gameCanvas');
      svg.innerHTML = '';

      const svgNS = 'http://www.w3.org/2000/svg';

      // Background
      const bg = document.createElementNS(svgNS, 'rect');
      bg.setAttribute('width', 800);
      bg.setAttribute('height', 600);
      bg.setAttribute('fill', '#0a0e27');
      svg.appendChild(bg);

      const shipGroup = document.createElementNS(svgNS, 'g');
      shipGroup.id = 'shipGroup';
      svg.appendChild(shipGroup);

      const rearCap = modulesLayout.find((m) => m.type === 'rear');
      const noseCap = modulesLayout.find((m) => m.type === 'front');
      const walkables = modulesLayout.filter((m) => m.walkable);
      const firstWalkable = walkables[0] || null;
      const lastWalkable = walkables[walkables.length - 1] || null;

      const tubeStartX = firstWalkable ? firstWalkable.x : (rearCap ? (rearCap.x + rearCap.width) : 0);
      const tubeEndX = noseCap ? (noseCap.x + 40) : (lastWalkable ? (lastWalkable.x + lastWalkable.width) : corridorEndX);

      // Render walls with windows
      const wallFillLit = 'rgb(56, 46, 28)';
      const wallFillDark = 'rgb(14, 22, 62)';
      const wallFill = state.lightsOn ? wallFillLit : wallFillDark;
      const wallFrame = state.lightsOn ? 'rgba(255, 220, 160, 0.35)' : 'rgba(120, 160, 255, 0.25)';

      for (const module of modulesLayout) {
        if (!module.walkable) continue;
        const wallStartX = module.x;
        const wallEndX = Math.min(module.x + module.width, tubeEndX);
        const wallW = wallEndX - wallStartX;
        if (wallW < 160) continue;

        const wallY = 80;
        const wallH = 440;
        const clampNum = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

        const interior = moduleInterior(module);
        const innerStartX = Math.max(wallStartX, interior.start);
        const innerEndX = Math.min(wallEndX, interior.end);
        const innerW = Math.max(0, innerEndX - innerStartX);

        let winCount = innerW >= 240 ? 2 : 1;
        let gap = winCount > 1 ? clampNum(innerW * 0.08, 16, 40) : 0;
        let sidePad = clampNum(innerW * 0.10, 18, 46);
        let winW = (innerW - sidePad * 2 - gap * (winCount - 1)) / winCount;

        if (winCount > 1 && winW < 70) {
          winCount = 1;
          gap = 0;
          winW = wallW - sidePad * 2;
        }

        winW = clampNum(winW, 60, 140);
        const usedW = (winCount * winW) + (gap * (winCount - 1));
        const startOffset = (innerW - usedW) / 2;
        const winXs = Array.from({ length: winCount }, (_, i) => innerStartX + startOffset + i * (winW + gap));
        const winH = 170;
        const winY = 160;
        const winRX = 14;

        const maskId = `wallmask-${module.moduleRef && module.moduleRef.uid ? module.moduleRef.uid : module.label}`;
        const mask = document.createElementNS(svgNS, 'mask');
        mask.id = maskId;
        mask.setAttribute('maskUnits', 'userSpaceOnUse');
        mask.setAttribute('x', wallStartX);
        mask.setAttribute('y', wallY);
        mask.setAttribute('width', wallW);
        mask.setAttribute('height', wallH);

        const maskBase = document.createElementNS(svgNS, 'rect');
        maskBase.setAttribute('x', wallStartX);
        maskBase.setAttribute('y', wallY);
        maskBase.setAttribute('width', wallW);
        maskBase.setAttribute('height', wallH);
        maskBase.setAttribute('fill', 'white');
        mask.appendChild(maskBase);

        for (const wx of winXs) {
          const hole = document.createElementNS(svgNS, 'rect');
          hole.setAttribute('x', wx);
          hole.setAttribute('y', winY);
          hole.setAttribute('width', winW);
          hole.setAttribute('height', winH);
          hole.setAttribute('rx', winRX);
          hole.setAttribute('ry', winRX);
          hole.setAttribute('fill', 'black');
          mask.appendChild(hole);
        }

        shipGroup.appendChild(mask);

        const wall = document.createElementNS(svgNS, 'rect');
        wall.setAttribute('x', wallStartX);
        wall.setAttribute('y', wallY);
        wall.setAttribute('width', wallW);
        wall.setAttribute('height', wallH);
        wall.setAttribute('fill', wallFill);
        wall.setAttribute('mask', `url(#${maskId})`);
        shipGroup.appendChild(wall);

        for (const wx of winXs) {
          const frame = document.createElementNS(svgNS, 'rect');
          frame.setAttribute('x', wx);
          frame.setAttribute('y', winY);
          frame.setAttribute('width', winW);
          frame.setAttribute('height', winH);
          frame.setAttribute('rx', winRX);
          frame.setAttribute('ry', winRX);
          frame.setAttribute('fill', 'none');
          frame.setAttribute('stroke', wallFrame);
          frame.setAttribute('stroke-width', 3);
          shipGroup.appendChild(frame);
        }
      }

      // Fill the nose transition wall to remove gap between last module and nose cone.
      if (lastWalkable && noseCap) {
        const gapStart = lastWalkable.x + lastWalkable.width;
        const gapEnd = Math.max(gapStart, tubeEndX);
        const gapW = gapEnd - gapStart;
        if (gapW > 0.5) {
          const noseWall = document.createElementNS(svgNS, 'rect');
          noseWall.setAttribute('x', gapStart);
          noseWall.setAttribute('y', 80);
          noseWall.setAttribute('width', gapW);
          noseWall.setAttribute('height', 440);
          noseWall.setAttribute('fill', wallFill);
          shipGroup.appendChild(noseWall);
        }
      }

      // Floor
      const floor = document.createElementNS(svgNS, 'rect');
      floor.setAttribute('x', tubeStartX);
      floor.setAttribute('y', 520);
      floor.setAttribute('width', Math.max(0, tubeEndX - tubeStartX));
      floor.setAttribute('height', 80);
      floor.setAttribute('fill', '#3d4466');
      shipGroup.appendChild(floor);

      // Floor panels
      for (let x = tubeStartX; x < tubeEndX; x += 100) {
        const panelW = Math.min(95, tubeEndX - x);
        if (panelW <= 0) break;
        const panel = document.createElementNS(svgNS, 'rect');
        panel.setAttribute('x', x);
        panel.setAttribute('y', 520);
        panel.setAttribute('width', panelW);
        panel.setAttribute('height', 80);
        panel.setAttribute('fill', 'none');
        panel.setAttribute('stroke', '#2a2e4a');
        panel.setAttribute('stroke-width', 2);
        shipGroup.appendChild(panel);
      }

      // Ceiling
      const ceiling = document.createElementNS(svgNS, 'rect');
      ceiling.setAttribute('x', tubeStartX);
      ceiling.setAttribute('y', 0);
      ceiling.setAttribute('width', Math.max(0, tubeEndX - tubeStartX));
      ceiling.setAttribute('height', 80);
      ceiling.setAttribute('fill', '#3d4466');
      shipGroup.appendChild(ceiling);

      // Ceiling lights (two per module)
      const ceilingLightFill = 'rgb(255, 214, 130)';
      const lightInset = BULKHEAD_W;
      for (const module of modulesLayout) {
        if (!module.walkable) continue;
        const interior = moduleInterior(module);
        const interiorW = Math.max(0, interior.width);
        const baseX = interior.start;
        const offsets = [interiorW * 0.33, interiorW * 0.67];
        for (const off of offsets) {
          const x = baseX + off;
          const light = document.createElementNS(svgNS, 'rect');
          light.setAttribute('x', x - 20);
          light.setAttribute('y', 70);
          light.setAttribute('width', 40);
          light.setAttribute('height', 10);
          light.setAttribute('fill', ceilingLightFill);
          light.setAttribute('opacity', 0.9);
          shipGroup.appendChild(light);
        }
      }

      const wrapLabelLines = (label, maxChars) => {
        const words = String(label || '').split(/\s+/).filter(Boolean);
        if (!words.length) return [''];
        const lines = [];
        let line = '';
        for (const word of words) {
          const next = line ? `${line} ${word}` : word;
          if (next.length <= maxChars || !line) {
            line = next;
          } else {
            lines.push(line);
            line = word;
          }
        }
        if (line) lines.push(line);
        return lines;
      };

      // Module labels
      for (const module of modulesLayout) {
        const labelText = String(module.label || '').toUpperCase();
        const maxChars = Math.max(8, Math.floor(module.width / 14));
        const lines = wrapLabelLines(labelText, maxChars);
        const roomLabel = document.createElementNS(svgNS, 'text');
        roomLabel.setAttribute('x', module.x + module.width / 2);
        roomLabel.setAttribute('y', 118);
        roomLabel.setAttribute('text-anchor', 'middle');
        roomLabel.setAttribute('fill', state.lightsOn ? 'rgb(140, 200, 255)' : 'rgba(120, 170, 220, 0.85)');
        roomLabel.setAttribute('opacity', state.lightsOn ? 0.9 : 0.7);
        roomLabel.setAttribute('font-size', '18');
        roomLabel.setAttribute('font-weight', '600');
        roomLabel.setAttribute('letter-spacing', '0.5');
        roomLabel.setAttribute('pointer-events', 'none');
        lines.forEach((line, idx) => {
          const tspan = document.createElementNS(svgNS, 'tspan');
          tspan.setAttribute('x', module.x + module.width / 2);
          tspan.setAttribute('dy', idx === 0 ? '0' : '18');
          tspan.textContent = line;
          roomLabel.appendChild(tspan);
        });
        shipGroup.appendChild(roomLabel);
      }

      // Remove buttons on module ceiling
      for (const module of modulesLayout) {
        if (!module.walkable || !module.moduleRef) continue;
        const interior = moduleInterior(module);
        const cx = interior.start + interior.width * 0.5;
        const cy = 36;
        const minus = document.createElementNS(svgNS, 'g');
        const ring = document.createElementNS(svgNS, 'circle');
        ring.setAttribute('cx', cx);
        ring.setAttribute('cy', cy);
        ring.setAttribute('r', 11);
        ring.setAttribute('fill', C.panel);
        ring.setAttribute('stroke', C.warning);
        ring.setAttribute('stroke-width', 2);

        const bar = document.createElementNS(svgNS, 'rect');
        bar.setAttribute('x', cx - 6);
        bar.setAttribute('y', cy - 2);
        bar.setAttribute('width', 12);
        bar.setAttribute('height', 4);
        bar.setAttribute('fill', C.warning);

        minus.appendChild(ring);
        minus.appendChild(bar);
        minus.style.cursor = 'pointer';
        minus.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          removeModuleByUid(module.moduleRef.uid);
        });
        shipGroup.appendChild(minus);
      }

      // Render stations
      for (const station of stations) {
        renderStation(station, shipGroup, svgNS);
      }

      // Bulkheads and doors between modules
      for (let i = 0; i < modulesLayout.length - 1; i++) {
        const left = modulesLayout[i];
        const right = modulesLayout[i + 1];
        const x = left.x + left.width;
        const hasDoor = left.walkable && right.walkable;

        const wall = document.createElementNS(svgNS, 'rect');
        wall.setAttribute('x', x);
        wall.setAttribute('y', 80);
        wall.setAttribute('width', 20);
        wall.setAttribute('height', 440);
        wall.setAttribute('fill', '#2a2e4a');
        shipGroup.appendChild(wall);

        if (hasDoor) {
          const door = document.createElementNS(svgNS, 'rect');
          door.setAttribute('x', x + 2);
          door.setAttribute('y', 380);
          door.setAttribute('width', 16);
          door.setAttribute('height', 140);
          door.setAttribute('fill', '#3d4466');
          door.setAttribute('stroke', '#00d4ff');
          door.setAttribute('stroke-width', 2);
          shipGroup.appendChild(door);
        }

        const insertIndex = left.walkable && right.walkable
          ? right.corridorIndex
          : left.walkable && !right.walkable
            ? left.corridorIndex + 1
            : !left.walkable && right.walkable
              ? right.corridorIndex
              : null;

        if (insertIndex !== null) {
          const plus = document.createElementNS(svgNS, 'g');
          const cx = x + 10;
          const cy = 300;
          const ring = document.createElementNS(svgNS, 'circle');
          ring.setAttribute('cx', cx);
          ring.setAttribute('cy', cy);
          ring.setAttribute('r', 12);
          ring.setAttribute('fill', C.panel);
          ring.setAttribute('stroke', C.accent);
          ring.setAttribute('stroke-width', 2);

          const txt = document.createElementNS(svgNS, 'text');
          txt.setAttribute('x', cx);
          txt.setAttribute('y', cy + 5);
          txt.setAttribute('text-anchor', 'middle');
          txt.setAttribute('font-size', '16');
          txt.setAttribute('fill', C.accent);
          txt.textContent = '+';

          plus.appendChild(ring);
          plus.appendChild(txt);
          plus.style.cursor = 'pointer';
          plus.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
            openInsertModulePanel(insertIndex);
          });
          shipGroup.appendChild(plus);
        }
      }

      // Rear rockets visual
      if (rearCap) {
        const mountX = rearCap.x + rearCap.width - 52;
        const mount = document.createElementNS(svgNS, 'rect');
        mount.setAttribute('x', mountX);
        mount.setAttribute('y', 90);
        mount.setAttribute('width', 44);
        mount.setAttribute('height', 420);
        mount.setAttribute('rx', 10);
        mount.setAttribute('ry', 10);
        mount.setAttribute('fill', '#2a2e4a');
        mount.setAttribute('stroke', '#00d4ff');
        mount.setAttribute('stroke-width', 2);
        mount.setAttribute('opacity', 0.95);
        shipGroup.appendChild(mount);

        for (let i = 0; i < 6; i++) {
          const bolt = document.createElementNS(svgNS, 'circle');
          bolt.setAttribute('cx', (mountX + 10 + (i % 2) * 24).toFixed(2));
          bolt.setAttribute('cy', (120 + Math.floor(i / 2) * 130).toFixed(2));
          bolt.setAttribute('r', '3.2');
          bolt.setAttribute('fill', '#3d4466');
          bolt.setAttribute('opacity', 0.95);
          shipGroup.appendChild(bolt);
        }

        const thrusterX = rearCap.x + 22;
        for (let i = 0; i < 3; i++) {
          const cy = 160 + i * 110 + 35;

          const strut = document.createElementNS(svgNS, 'path');
          strut.setAttribute('d', `M ${mountX} ${cy} L ${thrusterX + 40} ${cy - 18} L ${thrusterX + 40} ${cy + 18} Z`);
          strut.setAttribute('fill', '#2a2e4a');
          strut.setAttribute('stroke', '#00d4ff');
          strut.setAttribute('stroke-width', 2);
          strut.setAttribute('opacity', 0.9);
          shipGroup.appendChild(strut);

          const nozzle = document.createElementNS(svgNS, 'rect');
          nozzle.setAttribute('x', thrusterX);
          nozzle.setAttribute('y', 160 + i * 110);
          nozzle.setAttribute('width', 40);
          nozzle.setAttribute('height', 70);
          nozzle.setAttribute('fill', '#3d4466');
          nozzle.setAttribute('stroke', '#ff6b35');
          nozzle.setAttribute('stroke-width', 2);
          shipGroup.appendChild(nozzle);
        }
      }

      // Front nose cone
      if (noseCap) {
        const tipX = noseCap.x + noseCap.width - 10;
        const cone = document.createElementNS(svgNS, 'polygon');
        cone.setAttribute('points', `${noseCap.x + 40},80 ${tipX},220 ${tipX},380 ${noseCap.x + 40},520`);
        cone.setAttribute('fill', '#3d4466');
        cone.setAttribute('stroke', '#00d4ff');
        cone.setAttribute('stroke-width', 2);
        cone.setAttribute('opacity', 0.9);
        shipGroup.appendChild(cone);

        const window = document.createElementNS(svgNS, 'ellipse');
        window.setAttribute('cx', noseCap.x + noseCap.width * 0.62);
        window.setAttribute('cy', 260);
        window.setAttribute('rx', 30);
        window.setAttribute('ry', 45);
        window.setAttribute('fill', 'rgba(0, 100, 200, 0.25)');
        window.setAttribute('stroke', '#00d4ff');
        window.setAttribute('stroke-width', 2);
        shipGroup.appendChild(window);
      }

      // Render player
      renderPlayer(shipGroup, svgNS);

      // Render NPCs (only in current corridor)
      for (const npc of state.npcs) {
        if (npc.level === state.currentLevel && npc.corridor === state.currentCorridor) {
          renderNPC(npc, shipGroup, svgNS);
        }
      }

      updateCamera();
    }

    function renderStation(station, parent, svgNS) {
      const group = document.createElementNS(svgNS, 'g');

      const x = station.x;
      const y = station.y;
      const w = station.width;
      const h = station.height;
      const pad = Math.max(8, Math.min(12, Math.floor(Math.min(w, h) * 0.10)));

      const mk = (name, attrs = {}) => {
        const el = document.createElementNS(svgNS, name);
        for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
        return el;
      };

      const clipId = `station-clip-${station.id}`;
      const defs = mk('defs');
      const clip = mk('clipPath', { id: clipId });
      clip.appendChild(mk('rect', { x, y, width: w, height: h, rx: 10, ry: 10 }));
      defs.appendChild(clip);
      group.appendChild(defs);

      // Shadow + console frame
      group.appendChild(mk('rect', { x: x + 3, y: y + 4, width: w, height: h, rx: 10, ry: 10, fill: 'rgba(0,0,0,0.28)' }));
      group.appendChild(mk('rect', { x, y, width: w, height: h, rx: 10, ry: 10, fill: C.panel, stroke: C.accent, 'stroke-width': 2 }));

      // Inner bezel
      const innerX = x + pad;
      const innerY = y + pad;
      const innerW = w - pad * 2;
      const innerH = h - pad * 2;
      group.appendChild(mk('rect', { x: innerX, y: innerY, width: innerW, height: innerH, rx: 8, ry: 8, fill: C.hull, opacity: 0.55 }));

      // Bottom keys/controls strip
      const keysH = Math.max(18, Math.min(28, Math.floor(innerH * 0.24)));
      const keysY = innerY + innerH - keysH;
      group.appendChild(mk('rect', { x: innerX + 3, y: keysY, width: innerW - 6, height: keysH - 3, rx: 6, ry: 6, fill: C.wall, opacity: 0.9 }));

      const keyCount = Math.max(4, Math.min(7, Math.floor(innerW / 26)));
      for (let i = 0; i < keyCount; i++) {
        const kw = Math.max(10, Math.floor((innerW - 18) / keyCount) - 4);
        const kx = innerX + 10 + i * (kw + 6);
        group.appendChild(mk('rect', { x: kx, y: keysY + 7, width: kw, height: 8, rx: 2, ry: 2, fill: C.panel, opacity: 0.95 }));
      }

      // Status light
      const statusOk = (() => {
        if (station.type === 'power') return !(state.incidents && state.incidents.powerTrip);
        if (station.type === 'life') return !(state.incidents && state.incidents.o2Leak);
        if (station.type === 'engine') return !(state.incidents && state.incidents.fire);
        if (station.type === 'airlock') return !(state.incidents && state.incidents.breach);
        return true;
      })();
      group.appendChild(mk('circle', {
        cx: (x + 12).toFixed(2),
        cy: (y + 12).toFixed(2),
        r: 5,
        fill: statusOk ? C.success : 'rgb(255, 85, 85)',
        opacity: state.lightsOn ? 0.95 : 0.55
      }));

      // Draw station art clipped to the console.
      const art = mk('g', { 'clip-path': `url(#${clipId})` });
      group.appendChild(art);

      const screenX = innerX + 10;
      const screenY = innerY + 10;
      const screenW = innerW - 20;
      const screenH = Math.max(10, keysY - screenY - 10);

      const addGauge = ({ gx, gy, gw, gh, pct, color }) => {
        const p = clamp(safeNumber(pct, 0), 0, 1);
        art.appendChild(mk('rect', { x: gx, y: gy, width: gw, height: gh, rx: 3, ry: 3, fill: 'rgba(0,0,0,0.35)' }));
        art.appendChild(mk('rect', { x: gx + 1, y: gy + 1, width: Math.max(0, (gw - 2) * p), height: Math.max(0, gh - 2), rx: 2, ry: 2, fill: color, opacity: state.lightsOn ? 0.9 : 0.55 }));
      };

      // Shared screen backing
      art.appendChild(mk('rect', { x: screenX, y: screenY, width: screenW, height: screenH, rx: 8, ry: 8, fill: 'rgba(20, 30, 60, 0.55)', stroke: 'rgba(255,255,255,0.18)', 'stroke-width': 1 }));

      if (station.type === 'cargo') {
        const rackY = screenY + 10;
        const rackH = screenH - 20;
        art.appendChild(mk('rect', { x: screenX + 6, y: rackY, width: screenW - 12, height: rackH, rx: 6, ry: 6, fill: 'rgba(0,0,0,0.18)', stroke: 'rgba(255,255,255,0.12)', 'stroke-width': 1 }));
        const boxes = 3;
        for (let i = 0; i < boxes; i++) {
          const bx = screenX + 16 + i * ((screenW - 40) / boxes);
          const bw = Math.max(16, Math.min(28, (screenW - 60) / boxes));
          art.appendChild(mk('rect', { x: bx, y: rackY + 16, width: bw, height: rackH - 32, rx: 4, ry: 4, fill: C.warning, opacity: 0.85, stroke: 'rgba(0,0,0,0.35)', 'stroke-width': 1 }));
          art.appendChild(mk('path', { d: `M ${bx + 4} ${rackY + 24} L ${bx + bw - 4} ${rackY + 24} M ${bx + 4} ${rackY + 34} L ${bx + bw - 4} ${rackY + 34}`,
            stroke: 'rgba(0,0,0,0.35)', 'stroke-width': 2, opacity: 0.6 }));
        }
      } else if (station.type === 'power') {
        const cx = screenX + screenW * 0.38;
        const cy = screenY + screenH * 0.52;
        const r0 = Math.min(22, Math.max(16, Math.min(screenW, screenH) * 0.22));
        art.appendChild(mk('circle', { cx, cy, r: r0, fill: C.accent, opacity: state.lightsOn ? 0.65 : 0.35 }));
        for (let i = 1; i <= 3; i++) {
          art.appendChild(mk('circle', { cx, cy, r: r0 + i * 10, fill: 'none', stroke: C.accent, 'stroke-width': 1, opacity: 0.22 }));
        }
        const powerPct = clamp(state.power / 150, 0, 1);
        addGauge({ gx: screenX + screenW * 0.58, gy: screenY + 18, gw: screenW * 0.34, gh: 10, pct: powerPct, color: C.accent });
      } else if (station.type === 'engine') {
        const ventY = screenY + 14;
        for (let i = 0; i < 5; i++) {
          const vx = screenX + 12 + i * ((screenW - 24) / 5);
          art.appendChild(mk('rect', { x: vx, y: ventY, width: 8, height: screenH - 40, rx: 3, ry: 3, fill: 'rgba(255,255,255,0.10)' }));
        }
        addGauge({ gx: screenX + 12, gy: screenY + screenH - 20, gw: screenW - 24, gh: 9, pct: 0.65, color: C.warning });
      } else if (station.type === 'cockpit') {
        art.appendChild(mk('rect', { x: screenX + 10, y: screenY + 10, width: screenW - 20, height: screenH * 0.52, rx: 7, ry: 7, fill: 'rgba(0, 110, 220, 0.22)', stroke: 'rgba(180,220,255,0.25)', 'stroke-width': 1 }));
        for (let i = 0; i < 6; i++) {
          const gy = screenY + 18 + i * 10;
          art.appendChild(mk('path', { d: `M ${screenX + 16} ${gy} L ${screenX + screenW - 16} ${gy}`,
            stroke: 'rgba(180,220,255,0.16)', 'stroke-width': 1 }));
        }
      } else if (station.type === 'fabricator') {
        art.appendChild(mk('rect', { x: screenX + 10, y: screenY + 10, width: screenW - 20, height: screenH - 20, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(255,255,255,0.15)', 'stroke-width': 1 }));
        const bedY = screenY + screenH - 34;
        art.appendChild(mk('rect', { x: screenX + 18, y: bedY, width: screenW - 36, height: 14, rx: 4, ry: 4, fill: C.panel, opacity: 0.95 }));
        art.appendChild(mk('rect', { x: screenX + 18, y: screenY + 20, width: screenW - 36, height: 8, rx: 4, ry: 4, fill: C.wall, opacity: 0.9 }));
        const nx = screenX + screenW * 0.52;
        art.appendChild(mk('polygon', { points: `${nx - 7},${screenY + 30} ${nx + 7},${screenY + 30} ${nx + 3},${screenY + 48} ${nx - 3},${screenY + 48}`,
          fill: C.accent, opacity: state.lightsOn ? 0.85 : 0.45 }));
        art.appendChild(mk('rect', { x: nx - 12, y: bedY - 8, width: 24, height: 10, rx: 2, ry: 2, fill: C.success, opacity: 0.75 }));
      } else if (station.type === 'life') {
        const cx = screenX + screenW * 0.32;
        const cy = screenY + screenH * 0.52;
        const r = Math.min(22, Math.max(16, Math.min(screenW, screenH) * 0.20));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 1 }));
        for (let i = 0; i < 4; i++) {
          const a = (i * Math.PI) / 2;
          const x2 = cx + Math.cos(a + 0.55) * r * 0.95;
          const y2 = cy + Math.sin(a + 0.55) * r * 0.95;
          art.appendChild(mk('path', { d: `M ${cx} ${cy} L ${x2} ${y2}`,
            stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 3, 'stroke-linecap': 'round', opacity: 0.75 }));
        }
        addGauge({ gx: screenX + screenW * 0.55, gy: screenY + 24, gw: screenW * 0.36, gh: 10, pct: clamp(state.oxygen / 100, 0, 1), color: C.success });
      } else if (station.type === 'hydro') {
        const glow = 'rgba(60, 255, 140, 0.28)';
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 16, width: screenW - 24, height: 10, rx: 5, ry: 5, fill: glow, opacity: 0.9 }));
        const bedY = screenY + screenH - 34;
        art.appendChild(mk('rect', { x: screenX + 14, y: bedY, width: screenW - 28, height: 16, rx: 6, ry: 6, fill: 'rgba(80,50,20,0.55)', stroke: 'rgba(255,255,255,0.12)', 'stroke-width': 1 }));
      } else if (station.type === 'medbay') {
        const cx = screenX + screenW * 0.30;
        const cy = screenY + screenH * 0.50;
        art.appendChild(mk('rect', { x: cx - 18, y: cy - 6, width: 36, height: 12, rx: 3, ry: 3, fill: C.success, opacity: 0.65 }));
        art.appendChild(mk('rect', { x: cx - 6, y: cy - 18, width: 12, height: 36, rx: 3, ry: 3, fill: C.success, opacity: 0.65 }));
      } else if (station.type === 'comms') {
        const bx = screenX + screenW * 0.32;
        const by = screenY + screenH * 0.64;
        art.appendChild(mk('path', { d: `M ${bx - 18} ${by} Q ${bx} ${by - 26} ${bx + 18} ${by} Q ${bx} ${by + 10} ${bx - 18} ${by} Z`,
          fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 1 }));
      } else if (station.type === 'sensors') {
        const cx = screenX + screenW * 0.40;
        const cy = screenY + screenH * 0.54;
        const r = Math.min(26, Math.max(18, Math.min(screenW, screenH) * 0.24));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(0,0,0,0.25)', stroke: 'rgba(180,220,255,0.28)', 'stroke-width': 1 }));
      } else if (station.type === 'shields') {
        const glow = 'rgba(0, 160, 255, 0.18)';
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 12, width: screenW - 24, height: screenH - 24, rx: 8, ry: 8, fill: glow, opacity: 0.9 }));
      } else if (station.type === 'refinery') {
        const fx = screenX + screenW * 0.28;
        const fy = screenY + screenH * 0.50;
        art.appendChild(mk('rect', { x: fx - 20, y: fy - 22, width: 40, height: 44, rx: 6, ry: 6, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(255,255,255,0.18)', 'stroke-width': 1 }));
        art.appendChild(mk('rect', { x: fx - 10, y: fy - 10, width: 20, height: 20, rx: 4, ry: 4, fill: C.warning, opacity: 0.55 }));
        const ore = invGet('ore');
        const ing = invGet('ingot');
        addGauge({ gx: screenX + screenW * 0.52, gy: screenY + 18, gw: screenW * 0.38, gh: 10, pct: clamp(ore / 10, 0, 1), color: C.warning });
        addGauge({ gx: screenX + screenW * 0.52, gy: screenY + 32, gw: screenW * 0.38, gh: 10, pct: clamp(ing / 10, 0, 1), color: C.success });
      } else if (station.type === 'drones') {
        art.appendChild(mk('rect', { x: screenX + 14, y: screenY + 18, width: screenW - 28, height: screenH - 36, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(255,255,255,0.14)', 'stroke-width': 1 }));
      } else if (station.type === 'airlock') {
        const cx = screenX + screenW * 0.50;
        const cy = screenY + screenH * 0.54;
        const r = Math.min(24, Math.max(18, Math.min(screenW, screenH) * 0.22));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 2 }));
      } else if (station.type === 'workshop') {
        const tx = screenX + screenW * 0.32;
        const ty = screenY + screenH * 0.52;
        art.appendChild(mk('path', { d: `M ${tx - 10} ${ty - 14} L ${tx + 8} ${ty + 4} L ${tx + 4} ${ty + 8} L ${tx - 14} ${ty - 10} Z`,
          fill: 'rgba(180,220,255,0.24)', opacity: 0.9 }));
      } else if (station.type === 'quarters') {
        const bx = screenX + 16;
        const by = screenY + 18;
        const bw = Math.max(28, Math.min(44, (screenW - 40) / 2));
        const bh = Math.max(16, Math.floor((screenH - 34) / 2));
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < 2; c++) {
            const xx = bx + c * (bw + 10);
            const yy = by + r * (bh + 10);
            art.appendChild(mk('rect', { x: xx, y: yy, width: bw, height: bh, rx: 6, ry: 6, fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.16)', 'stroke-width': 1 }));
          }
        }
      } else if (station.type === 'computer') {
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 14, width: screenW - 24, height: screenH - 28, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(180,220,255,0.20)', 'stroke-width': 1 }));
      } else if (station.type === 'doorway') {
        art.appendChild(mk('rect', { x: screenX + 18, y: screenY + 20, width: screenW - 36, height: screenH - 40, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(180,220,255,0.20)', 'stroke-width': 1 }));
        art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.5} ${screenY + 24} L ${screenX + screenW * 0.5} ${screenY + screenH - 24}`,
          stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 2 }));
      } else if (station.type === 'elevator') {
        art.appendChild(mk('rect', { x: screenX + 16, y: screenY + 16, width: screenW - 32, height: screenH - 32, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(180,220,255,0.20)', 'stroke-width': 1 }));
        art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.5} ${screenY + 24} L ${screenX + screenW * 0.5} ${screenY + screenH - 24}`,
          stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 2 }));
        art.appendChild(mk('polygon', { points: `${screenX + screenW * 0.5 - 6},${screenY + 28} ${screenX + screenW * 0.5 + 6},${screenY + 28} ${screenX + screenW * 0.5},${screenY + 18}`,
          fill: C.accent, opacity: 0.8 }));
        art.appendChild(mk('polygon', { points: `${screenX + screenW * 0.5 - 6},${screenY + screenH - 28} ${screenX + screenW * 0.5 + 6},${screenY + screenH - 28} ${screenX + screenW * 0.5},${screenY + screenH - 18}`,
          fill: C.accent, opacity: 0.8 }));
      }

      parent.appendChild(group);
    }

    function renderPlayer(parent, svgNS) {
      const g = document.createElementNS(svgNS, 'g');
      const x = state.player.x;
      const y = state.player.y;
      const vx = state.player.vx;
      const walk = state.anim.walkPhase;
      const dir = state.player.facing || 1;
      const moving = Math.abs(vx) > 1;

      // Legs with walk cycle
      const hipY = y - 4;
      const hipBaseX = x;
      const legSpread = 7;
      const thighLen = 18;
      const shinLen = 16;

      const legs = document.createElementNS(svgNS, 'g');
      legs.setAttribute('stroke', '#e0e0ff');
      legs.setAttribute('stroke-width', 3);
      legs.setAttribute('stroke-linecap', 'round');

      function addLeg(sideSign) {
        const phase = walk + (sideSign > 0 ? Math.PI : 0);
        const s = moving ? Math.sin(phase) * 8 : 0;
        const l = moving ? Math.max(0, Math.sin(phase)) * 6 : 0;

        const hipX = hipBaseX + sideSign * legSpread;
        const kneeX = hipX + s * 0.6 * dir;
        const kneeY = hipY + thighLen - l * 0.4;
        const footX = hipX + s * 1.0 * dir;
        const footY = hipY + thighLen + shinLen - l;

        const legPath = document.createElementNS(svgNS, 'path');
        legPath.setAttribute('d', `M ${hipX} ${hipY} L ${kneeX} ${kneeY} L ${footX} ${footY}`);
        legPath.setAttribute('opacity', sideSign > 0 ? 0.95 : 0.85);
        legs.appendChild(legPath);

        const foot = document.createElementNS(svgNS, 'path');
        foot.setAttribute('d', `M ${footX - 7} ${footY} L ${footX + 9} ${footY}`);
        foot.setAttribute('stroke', '#4ecdc4');
        foot.setAttribute('stroke-width', 4);
        foot.setAttribute('opacity', 0.9);
        legs.appendChild(foot);
      }

      addLeg(-1);
      addLeg(1);
      g.appendChild(legs);

      // Body
      const body = document.createElementNS(svgNS, 'rect');
      body.setAttribute('x', x - state.player.width / 2);
      body.setAttribute('y', y - state.player.height);
      body.setAttribute('width', state.player.width);
      body.setAttribute('height', state.player.height);
      body.setAttribute('fill', '#4ecdc4');
      body.setAttribute('stroke', '#e0e0ff');
      body.setAttribute('stroke-width', 2);
      g.appendChild(body);

      // Head
      const head = document.createElementNS(svgNS, 'circle');
      head.setAttribute('cx', x);
      head.setAttribute('cy', y - state.player.height - 10);
      head.setAttribute('r', 15);
      head.setAttribute('fill', '#e0e0ff');
      head.setAttribute('stroke', '#4ecdc4');
      head.setAttribute('stroke-width', 2);
      g.appendChild(head);

      // Visor
      const visor = document.createElementNS(svgNS, 'rect');
      visor.setAttribute('x', x - 8);
      visor.setAttribute('y', y - state.player.height - 15);
      visor.setAttribute('width', 16);
      visor.setAttribute('height', 6);
      visor.setAttribute('fill', '#00d4ff');
      g.appendChild(visor);

      renderCharacterLabel(g, svgNS, {
        x,
        y: y - state.player.height - 70,
        line1: 'CAPTAIN',
        line2: 'â'
      });

      parent.appendChild(g);
    }

    function renderNPC(npc, parent, svgNS) {
      const g = document.createElementNS(svgNS, 'g');
      const x = npc.x;
      const y = npc.y;
      const walk = npc.walkPhase || 0;
      const dir = npc.vx >= 0 ? 1 : -1;
      const moving = Math.abs(npc.vx) > 1;

      // Legs
      const hipY = y - 4;
      const hipBaseX = x;
      const legSpread = 7;
      const thighLen = 18;
      const shinLen = 16;

      const legs = document.createElementNS(svgNS, 'g');
      legs.setAttribute('stroke', '#e0e0ff');
      legs.setAttribute('stroke-width', 2);
      legs.setAttribute('stroke-linecap', 'round');

      function addLeg(sideSign) {
        const phase = walk + (sideSign > 0 ? Math.PI : 0);
        const s = moving ? Math.sin(phase) * 6 : 0;
        const l = moving ? Math.max(0, Math.sin(phase)) * 4 : 0;

        const hipX = hipBaseX + sideSign * legSpread;
        const kneeX = hipX + s * 0.5 * dir;
        const kneeY = hipY + thighLen - l * 0.3;
        const footX = hipX + s * 0.9 * dir;
        const footY = hipY + thighLen + shinLen - l;

        const legPath = document.createElementNS(svgNS, 'path');
        legPath.setAttribute('d', `M ${hipX} ${hipY} L ${kneeX} ${kneeY} L ${footX} ${footY}`);
        legPath.setAttribute('opacity', sideSign > 0 ? 0.95 : 0.85);
        legs.appendChild(legPath);

        const foot = document.createElementNS(svgNS, 'path');
        foot.setAttribute('d', `M ${footX - 6} ${footY} L ${footX + 8} ${footY}`);
        foot.setAttribute('stroke', '#4ecdc4');
        foot.setAttribute('stroke-width', 3);
        foot.setAttribute('opacity', 0.85);
        legs.appendChild(foot);
      }

      addLeg(-1);
      addLeg(1);
      g.appendChild(legs);

      // Body
      const body = document.createElementNS(svgNS, 'rect');
      body.setAttribute('x', x - npc.width / 2);
      body.setAttribute('y', y - npc.height);
      body.setAttribute('width', npc.width);
      body.setAttribute('height', npc.height);
      body.setAttribute('fill', C.success);
      body.setAttribute('stroke', C.text);
      body.setAttribute('stroke-width', 2);
      g.appendChild(body);

      // Head
      const head = document.createElementNS(svgNS, 'circle');
      head.setAttribute('cx', x);
      head.setAttribute('cy', y - npc.height - 10);
      head.setAttribute('r', 15);
      head.setAttribute('fill', C.text);
      head.setAttribute('stroke', C.success);
      head.setAttribute('stroke-width', 2);
      g.appendChild(head);

      // Visor (eyes)
      const visor = document.createElementNS(svgNS, 'rect');
      visor.setAttribute('x', x - 8);
      visor.setAttribute('y', y - npc.height - 15);
      visor.setAttribute('width', 16);
      visor.setAttribute('height', 6);
      visor.setAttribute('fill', C.accent);
      g.appendChild(visor);

      const role = String(npcRole(npc) || 'crew').toUpperCase();
      const name = String(npc.name || 'CREW').toUpperCase();
      const line1 = name === role ? name : `${name} â¢ ${role}`;
      const taskLabel = npc.task ? String(npc.task.label || npc.task.key || 'TASK') : '';
      const briefTask = abbreviateTaskLabel(taskLabel);
      const line2 = npc.onDuty ? (briefTask || 'IDLE') : 'STANDBY';

      renderCharacterLabel(g, svgNS, {
        x,
        y: y - npc.height - 70,
        line1,
        line2
      });

      parent.appendChild(g);
    }

    function abbreviateTaskLabel(label) {
      const raw = String(label || '').trim();
      if (!raw) return '';
      const lower = raw.toLowerCase();
      const map = [
        { match: 'repair drone', value: 'REPAIR' },
        { match: 'salvage drone', value: 'SALVAGE' },
        { match: 'sensor', value: 'SCAN' },
        { match: 'scan', value: 'SCAN' },
        { match: 'deep scan', value: 'SCAN' },
        { match: 'fabricate', value: 'FABRICATE' },
        { match: 'refine', value: 'REFINE' },
        { match: 'repair hull', value: 'REPAIR' },
        { match: 'install', value: 'INSTALL' },
        { match: 'treat', value: 'TREAT' },
        { match: 'rest', value: 'REST' },
        { match: 'harvest', value: 'HARVEST' },
        { match: 'vent', value: 'VENT' },
        { match: 'route', value: 'ROUTE' },
        { match: 'buy', value: 'BUY' },
        { match: 'sell', value: 'SELL' },
        { match: 'hire', value: 'HIRE' },
        { match: 'transfer', value: 'TRANSFER' },
        { match: 'contract', value: 'CONTRACT' },
        { match: 'travel', value: 'TRAVEL' },
        { match: 'course', value: 'COURSE' },
        { match: 'investigate', value: 'INVESTIGATE' }
      ];
      for (const entry of map) {
        if (lower.includes(entry.match)) return entry.value;
      }
      const compact = raw.replace(/\s*\(.*\)\s*/g, '').trim();
      const words = compact.split(/\s+/).filter(Boolean);
      return words.length ? words[0].toUpperCase() : compact.toUpperCase();
    }

    function renderCharacterLabel(parent, svgNS, { x, y, line1, line2 }) {
      const clipText = (text, maxLen = 22) => (text.length > maxLen ? `${text.slice(0, maxLen - 1)}â¦` : text);
      const l1 = clipText(String(line1 || '').toUpperCase());
      const l2 = clipText(String(line2 || '').toUpperCase());
      const maxLen = Math.max(l1.length, l2.length);
      const padX = 10;
      const padY = 6;
      const labelW = maxLen * 6.2 + padX * 2;
      const labelH = 30 + padY * 0.3;
      const labelX = x - labelW / 2;
      const labelY = y;

      const labelBg = document.createElementNS(svgNS, 'rect');
      labelBg.setAttribute('x', labelX.toFixed(2));
      labelBg.setAttribute('y', labelY.toFixed(2));
      labelBg.setAttribute('width', labelW.toFixed(2));
      labelBg.setAttribute('height', labelH);
      labelBg.setAttribute('rx', 7);
      labelBg.setAttribute('ry', 7);
      labelBg.setAttribute('fill', 'rgba(10, 14, 39, 0.78)');
      labelBg.setAttribute('stroke', 'rgba(0, 212, 255, 0.45)');
      labelBg.setAttribute('stroke-width', 1);
      parent.appendChild(labelBg);

      const labelText = document.createElementNS(svgNS, 'text');
      labelText.setAttribute('x', x);
      labelText.setAttribute('y', labelY + 12 + padY * 0.2);
      labelText.setAttribute('text-anchor', 'middle');
      labelText.setAttribute('fill', 'rgba(240, 250, 255, 0.95)');
      labelText.setAttribute('font-size', '11');
      labelText.setAttribute('font-weight', '600');
      labelText.setAttribute('letter-spacing', '0.4');
      labelText.setAttribute('paint-order', 'stroke');
      labelText.setAttribute('stroke', 'rgba(0, 0, 0, 0.6)');
      labelText.setAttribute('stroke-width', '2');
      labelText.setAttribute('pointer-events', 'none');
      const t1 = document.createElementNS(svgNS, 'tspan');
      t1.setAttribute('x', x);
      t1.setAttribute('dy', '0');
      t1.textContent = l1 || 'â';
      const t2 = document.createElementNS(svgNS, 'tspan');
      t2.setAttribute('x', x);
      t2.setAttribute('dy', '14');
      t2.textContent = l2 || 'â';
      labelText.appendChild(t1);
      labelText.appendChild(t2);
      parent.appendChild(labelText);
    }

    function findNearestInsertIndex() {
      if (!modulesLayout.length) return null;
      const candidates = [];
      for (let i = 0; i < modulesLayout.length - 1; i++) {
        const left = modulesLayout[i];
        const right = modulesLayout[i + 1];
        const insertIndex = left.walkable && right.walkable
          ? right.corridorIndex
          : left.walkable && !right.walkable
            ? left.corridorIndex + 1
            : !left.walkable && right.walkable
              ? right.corridorIndex
              : null;
        if (insertIndex === null) continue;
        const wallX = left.x + left.width + BULKHEAD_W * 0.5;
        candidates.push({ insertIndex, x: wallX });
      }
      if (!candidates.length) return null;
      let best = candidates[0];
      let bestD = Math.abs(best.x - state.player.x);
      for (const c of candidates) {
        const d = Math.abs(c.x - state.player.x);
        if (d < bestD) {
          best = c;
          bestD = d;
        }
      }
      return best.insertIndex;
    }

    function findNearestRemovableModule() {
      const walkables = modulesLayout.filter((m) => m.walkable && m.moduleRef);
      if (!walkables.length) return null;
      let best = walkables[0];
      let bestD = Math.abs((best.x + best.width * 0.5) - state.player.x);
      for (const m of walkables) {
        const d = Math.abs((m.x + m.width * 0.5) - state.player.x);
        if (d < bestD) {
          best = m;
          bestD = d;
        }
      }
      return best;
    }

    function findCurrentModuleAtPlayer() {
      const x = state.player.x;
      const walkables = modulesLayout.filter((m) => m.walkable && m.moduleRef);
      if (!walkables.length) return null;
      for (const m of walkables) {
        if (x >= m.x && x <= (m.x + m.width)) return m;
      }
      return findNearestRemovableModule();
    }

    function npcBoundsFor(npc) {
      if (npc.level === state.currentLevel && npc.corridor === state.currentCorridor) return state.walkBounds;
      return getCorridorLayout(npc.level, npc.corridor).bounds;
    }

    function updateNpcNavigation(npc) {
      const startKey = corridorKey(npc.level, npc.corridor);
      if (npc.destinationCorridorKey) {
        if (npc.destinationCorridorKey === startKey) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const route = findRoute(startKey, [npc.destinationCorridorKey]);
        if (!route || route.length < 2) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const nextKey = route[1];
        const link = findLinkModule(npc.level, npc.corridor, nextKey);
        if (!link) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const targetX = moduleCenterInCorridor(npc.level, npc.corridor, link.module);
        if (targetX === null || targetX === undefined) {
          npc.destinationCorridorKey = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const dist = targetX - npc.x;
        if (Math.abs(dist) <= 6) {
          const { level: nextLevel, corridor: nextCorridor } = parseCorridorKey(nextKey);
          const backLink = findLinkModule(nextLevel, nextCorridor, startKey);
          const destX = backLink ? moduleCenterInCorridor(nextLevel, nextCorridor, backLink.module) : null;
          const bounds = getCorridorLayout(nextLevel, nextCorridor).bounds;
          npc.level = nextLevel;
          npc.corridor = nextCorridor;
          npc.x = destX != null ? clamp(destX, bounds.minX, bounds.maxX) : bounds.minX + (bounds.maxX - bounds.minX) * 0.5;
          npc.vx = 0;
          npc.mode = 'travel';
          return true;
        }
        npc.vx = Math.sign(dist) * npc.speed * 0.6;
        npc.mode = 'travel';
        return true;
      }

      if (!npc.destinationType) return false;
      const targetType = npc.destinationType;
      const targets = corridorsWithModuleType(targetType);
      if (!targets.length) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      if (targets.includes(startKey)) {
        const targetModule = findModuleByType(npc.level, npc.corridor, targetType);
        const targetX = moduleCenterInCorridor(npc.level, npc.corridor, targetModule);
        if (targetX === null || targetX === undefined) {
          npc.destinationType = null;
          npc.mode = 'idle';
          npc.vx = 0;
          return false;
        }
        const dist = targetX - npc.x;
        if (Math.abs(dist) <= 6) {
          npc.vx = 0;
          npc.destinationType = null;
          npc.mode = 'idle';
          return true;
        }
        npc.vx = Math.sign(dist) * npc.speed * 0.6;
        npc.mode = 'travel';
        return true;
      }

      const route = findRoute(startKey, targets);
      if (!route || route.length < 2) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      const nextKey = route[1];
      const link = findLinkModule(npc.level, npc.corridor, nextKey);
      if (!link) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      const targetX = moduleCenterInCorridor(npc.level, npc.corridor, link.module);
      if (targetX === null || targetX === undefined) {
        npc.destinationType = null;
        npc.mode = 'idle';
        npc.vx = 0;
        return false;
      }

      const dist = targetX - npc.x;
      if (Math.abs(dist) <= 6) {
        const { level: nextLevel, corridor: nextCorridor } = parseCorridorKey(nextKey);
        const backLink = findLinkModule(nextLevel, nextCorridor, startKey);
        const destX = backLink ? moduleCenterInCorridor(nextLevel, nextCorridor, backLink.module) : null;
        const bounds = getCorridorLayout(nextLevel, nextCorridor).bounds;
        npc.level = nextLevel;
        npc.corridor = nextCorridor;
        npc.x = destX != null ? clamp(destX, bounds.minX, bounds.maxX) : bounds.minX + (bounds.maxX - bounds.minX) * 0.5;
        npc.vx = 0;
        npc.mode = 'travel';
        return true;
      }

      npc.vx = Math.sign(dist) * npc.speed * 0.6;
      npc.mode = 'travel';
      return true;
    }

    function updateCamera() {
      const viewWidth = 800;
      const targetX = state.player.x - viewWidth / 2;
      const maxScroll = Math.max(0, corridorEndX - viewWidth);
      state.camera.x = Math.max(0, Math.min(maxScroll, targetX));

      const svg = document.getElementById('gameCanvas');
      svg.setAttribute('viewBox', `${state.camera.x} 0 ${viewWidth} 600`);
    }

    // ============================================================================
    // Input Handling
    // ============================================================================

    function handleLeftPress() {
      state.keys.left = true;
      state.keys.right = false;
      state.player.facing = -1;
    }

    function handleRightPress() {
      state.keys.right = true;
      state.keys.left = false;
      state.player.facing = 1;
    }

    function handleActionPress() {
      if (state.ui.panelOpen) return;

      // Check for nearby station
      for (const station of stations) {
        if (Math.abs(state.player.x - station.interactX) < 50) {
          state.nearStation = station;
          openStationPanel(station);
          return;
        }
      }

      // Check for connection (doorway/elevator)
      const connections = getConnectionsForCorridor(state.currentLevel, state.currentCorridor);
      if (state.player.x < 80 && connections.left) {
        const conn = connections.left;
        moveToLocation(conn.level, conn.corridor);
        return;
      }
      if (state.player.x > corridorEndX - 80 && connections.right) {
        const conn = connections.right;
        moveToLocation(conn.level, conn.corridor);
        return;
      }
      if (connections.up) {
        const conn = connections.up;
        moveToLocation(conn.level, conn.corridor);
        return;
      }
      if (connections.down) {
        const conn = connections.down;
        moveToLocation(conn.level, conn.corridor);
        return;
      }
    }

    const svg = document.getElementById('gameCanvas');

    document.addEventListener('contextmenu', (e) => {
      const t = e.target;
      if (t && (t.id === 'panelInput' || t.id === 'panelTextarea')) return;
      e.preventDefault();
    });

    document.addEventListener('keydown', (e) => {
      if (state.ui.panelOpen) {
        if (e.key === 'Escape') {
          closePanel();
          return;
        }
        const textareaEl = document.getElementById('panelTextarea');
        const inputEl = document.getElementById('panelInput');
        if (inputEl && inputEl.style.display !== 'none' && document.activeElement === inputEl) {
          if (e.key === 'Enter') {
            e.preventDefault();
            const buttons = Array.from(document.querySelectorAll('#panelButtons button'));
            if (buttons[0]) buttons[0].click();
          }
          return;
        }
        if (textareaEl && textareaEl.style.display !== 'none' && document.activeElement === textareaEl) {
          return;
        }
        const buttons = Array.from(document.querySelectorAll('#panelButtons button'));
        if (!buttons.length) return;
        let idx = buttons.indexOf(document.activeElement);
        if (idx === -1 && buttons[0]) {
          buttons[0].focus();
          idx = 0;
        }
        if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
          e.preventDefault();
          const next = buttons[(idx + 1 + buttons.length) % buttons.length];
          next.focus();
          return;
        }
        if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
          e.preventDefault();
          const prev = buttons[(idx - 1 + buttons.length) % buttons.length];
          prev.focus();
          return;
        }
        if (e.key === 'Enter' || e.key === ' ') {
          if (state.ui.justOpenedPanel) {
            e.preventDefault();
            state.ui.justOpenedPanel = false;
            if (buttons[0]) buttons[0].focus();
            return;
          }
          if (document.activeElement && document.activeElement.click) {
            e.preventDefault();
            document.activeElement.click();
          }
          return;
        }
        return;
      }

      if (e.key === 'F10') {
        e.preventDefault();
        openGameMenu();
        return;
      }
      if (e.key === '+') {
        const insertIndex = findNearestInsertIndex();
        if (insertIndex !== null) openInsertModulePanel(insertIndex);
        return;
      }
      if (e.key === '-') {
        const module = findNearestRemovableModule();
        if (module && module.moduleRef) removeModuleByUid(module.moduleRef.uid);
        return;
      }
      if (e.key === 'r' || e.key === 'R') {
        openRenameModulePanel();
        return;
      }
      if (e.key === 'ArrowLeft') handleLeftPress();
      if (e.key === 'ArrowRight') handleRightPress();
      if (e.key === ' ' || e.key === 'Enter') handleActionPress();
    });

    document.addEventListener('keyup', (e) => {
      if (state.ui.panelOpen && state.ui.justOpenedPanel && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        state.ui.justOpenedPanel = false;
        return;
      }

      if (e.key === 'ArrowLeft') state.keys.left = false;
      if (e.key === 'ArrowRight') state.keys.right = false;
    });

    // Pointer controls on the play area (touch + mouse): hold left/right half to move.
    let movementPointerId = null;

    function setMoveFromClientX(clientX) {
      const rect = svg.getBoundingClientRect();
      const relX = clientX - rect.left;
      if (relX < rect.width / 2) {
        state.keys.left = true;
        state.keys.right = false;
        state.player.facing = -1;
      } else {
        state.keys.right = true;
        state.keys.left = false;
        state.player.facing = 1;
      }
    }

    function clearMoveFromPointer() {
      state.keys.left = false;
      state.keys.right = false;
    }

    svg.addEventListener('pointerdown', (e) => {
      if (state.ui.panelOpen) return;
      movementPointerId = e.pointerId;
      svg.setPointerCapture(e.pointerId);
      setMoveFromClientX(e.clientX);
    });

    svg.addEventListener('pointermove', (e) => {
      if (movementPointerId !== e.pointerId) return;
      setMoveFromClientX(e.clientX);
    });

    svg.addEventListener('pointerup', (e) => {
      if (movementPointerId !== e.pointerId) return;
      movementPointerId = null;
      clearMoveFromPointer();
    });

    svg.addEventListener('pointercancel', (e) => {
      if (movementPointerId !== e.pointerId) return;
      movementPointerId = null;
      clearMoveFromPointer();
    });

    svg.addEventListener('pointerleave', () => {
      if (movementPointerId === null) return;
      movementPointerId = null;
      clearMoveFromPointer();
    });

    function bindHoldButton(btn, key) {
      if (!btn) return;
      const down = () => {
        if (key === 'left') handleLeftPress();
        if (key === 'right') handleRightPress();
      };
      const up = () => {
        if (key === 'left') state.keys.left = false;
        if (key === 'right') state.keys.right = false;
      };
      btn.addEventListener('pointerdown', (e) => {
        if (state.ui.panelOpen) return;
        btn.setPointerCapture(e.pointerId);
        down();
      });
      btn.addEventListener('pointerup', (e) => {
        try { btn.releasePointerCapture(e.pointerId); } catch {}
        up();
      });
      btn.addEventListener('pointercancel', up);
      btn.addEventListener('pointerleave', up);
    }

    bindHoldButton(document.getElementById('leftBtn'), 'left');
    bindHoldButton(document.getElementById('rightBtn'), 'right');
    document.getElementById('actionBtn').addEventListener('click', handleActionPress);
    document.getElementById('menuBtn').addEventListener('click', openGameMenu);
    document.getElementById('renameBtn').addEventListener('click', openRenameModulePanel);

    function updateViewportLayout() {
      const hud = document.getElementById('hud');
      const controls = document.getElementById('controls');
      const hudH = hud ? Math.ceil(hud.getBoundingClientRect().height) : 0;
      const controlsH = controls ? Math.ceil(controls.getBoundingClientRect().height) : 0;
      document.documentElement.style.setProperty('--hud-h', `${hudH}px`);
      document.documentElement.style.setProperty('--controls-h', `${controlsH}px`);
      const svgEl = document.getElementById('gameCanvas');
      if (svgEl) {
        const h = Math.max(120, window.innerHeight - hudH - controlsH);
        svgEl.style.height = `${h}px`;
        const w = Math.max(1, svgEl.getBoundingClientRect().width || window.innerWidth);
        const ratio = w / Math.max(1, h);
        const baseRatio = 800 / 600;
        svgEl.setAttribute('preserveAspectRatio', ratio < baseRatio ? 'xMidYMid slice' : 'xMidYMid meet');
      }
    }

    const hudEl = document.getElementById('hud');
    const controlsEl = document.getElementById('controls');
    if (window.ResizeObserver) {
      const ro = new ResizeObserver(() => updateViewportLayout());
      if (hudEl) ro.observe(hudEl);
      if (controlsEl) ro.observe(controlsEl);
    }
    window.addEventListener('resize', () => updateViewportLayout());

    // ============================================================================
    // Game Loop & Physics
    // ============================================================================

    function updatePlayer(dt) {
      const acc = state.player.speed;

      if (state.keys.left) {
        state.player.vx = -acc;
        state.player.facing = -1;
      } else if (state.keys.right) {
        state.player.vx = acc;
        state.player.facing = 1;
      } else {
        state.player.vx = 0;
      }

      // Update walk animation
      const moving = Math.abs(state.player.vx) > 1;
      if (moving) {
        state.anim.walkPhase += state.anim.walkSpeed * dt;
        if (state.anim.walkPhase > Math.PI * 2) {
          state.anim.walkPhase -= Math.PI * 2;
        }
      } else {
        state.anim.walkPhase = 0;
      }

      state.player.x = Math.max(state.walkBounds.minX, Math.min(state.walkBounds.maxX, state.player.x + state.player.vx * dt));
    }

    function updateNPCs(dt) {
      for (const npc of state.npcs) {
        if (npc.onDuty === undefined) npc.onDuty = true;
        if (!Number.isFinite(npc.hunger)) npc.hunger = 0;
        if (!npc.onDuty || npc.paused) continue;
        if (!npc.mode) npc.mode = 'idle';
        if (!Number.isFinite(npc.thinkTimer)) npc.thinkTimer = 0;

        const navActive = updateNpcNavigation(npc);
        const taskActive = updateNpcTasking(npc, dt);

        // Simple idle wandering AI
        if (!navActive && !taskActive) {
          npc.mode = 'idle';
          npc.thinkTimer -= dt;
          
          if (npc.thinkTimer <= 0) {
            // Pick a random wander target occasionally
            if (Math.random() < 0.6 || npc.wanderTarget === null) {
              const bounds = npcBoundsFor(npc);
              const minX = bounds.minX;
              const maxX = bounds.maxX;
              if (maxX > minX) {
                npc.wanderTarget = minX + Math.random() * (maxX - minX);
              } else {
                npc.wanderTarget = minX;
              }
            }
            if (npc.destinationType == null && Math.random() < 0.08) {
              const types = listRoutableModuleTypes();
              if (types.length) {
                npc.destinationType = types[(Math.random() * types.length) | 0];
                npc.wanderTarget = null;
                npc.mode = 'travel';
              }
            }
            if (npc.destinationType == null && npc.destinationCorridorKey == null && Math.random() < 0.12) {
              const corridors = listAllCorridors().filter((k) => k !== corridorKey(npc.level, npc.corridor));
              if (corridors.length) {
                npc.destinationCorridorKey = corridors[(Math.random() * corridors.length) | 0];
                npc.wanderTarget = null;
                npc.mode = 'travel';
              }
            }
            npc.thinkTimer = 2 + Math.random() * 3;
          }

          // Move toward wander target
          if (npc.wanderTarget !== null) {
            const dist = npc.wanderTarget - npc.x;
            if (Math.abs(dist) > 10) {
              npc.vx = (dist > 0 ? 1 : -1) * npc.speed * 0.5;
            } else {
              npc.vx = 0;
              npc.wanderTarget = null;
            }
          } else {
            npc.vx = 0;
          }
        }

        // Move NPC, keep in bounds
        const bounds = npcBoundsFor(npc);
        npc.x = Math.max(bounds.minX, Math.min(bounds.maxX, npc.x + npc.vx * dt));

        const moving = Math.abs(npc.vx) > 1;
        if (moving) {
          npc.walkPhase = (npc.walkPhase || 0) + state.anim.walkSpeed * dt * 0.8;
          if (npc.walkPhase > Math.PI * 2) npc.walkPhase -= Math.PI * 2;
        } else {
          npc.walkPhase = 0;
        }
      }
    }

    // ============================================================================
    // Simulation Helpers
    // ============================================================================

    function clampPercent(value) {
      return clamp(value, 0, 100);
    }

    function currentPowerProfile() {
      return state.powerProfile || 'balanced';
    }

    function computePowerDrain(profile, dt) {
      const profileDrain = profile === 'combat' ? 0.08 : profile === 'survival' ? 0.05 : profile === 'industry' ? 0.07 : 0;
      return (
        0.08 +
        (state.lightsOn ? 0.05 : 0) +
        (state.lifeSupportOn ? 0.12 : 0) +
        (state.hydroponicsOn ? 0.08 : 0) +
        (state.shieldsOn ? 0.12 : 0) +
        (state.engineActive ? 0.3 * Math.max(0, state.throttle) : 0) +
        (state.incidents.fire ? 0.06 : 0) +
        profileDrain
      ) * dt;
    }

    function applyPowerTick(profile, dt) {
      const powerDrain = computePowerDrain(profile, dt);
      state.power = clampPercent(state.power - powerDrain);

      if (!state.incidents.powerTrip && state.power < 100) {
        state.power = clampPercent(state.power + 1.2 * dt);
      }
    }

    function applyOxygenTick(profile, dt) {
      const crewCount = 1 + (Array.isArray(state.npcs) ? state.npcs.length : 0);
      const o2Use = 0.06 * Math.sqrt(Math.max(1, crewCount));
      const o2Gain = state.lifeSupportOn && state.power >= 8 ? 1.1 : 0;
      state.oxygen = clampPercent(state.oxygen + (o2Gain - o2Use) * dt);
    }

    function applyHeatTick(dt) {
      const heatGain =
        (state.engineActive ? (0.2 + 0.8 * Math.max(0, state.throttle)) : 0)
        + (state.lightsOn ? 0.04 : 0)
        + (state.shieldsOn ? 0.12 : 0)
        + (state.incidents.fire ? 0.8 : 0);
      const heatCooling = 0.25 + 0.015 * clampPercent(state.heat);
      state.heat = clampPercent(state.heat + (heatGain - heatCooling) * dt);

      if (state.crewAI && state.crewAI.autoVentHeat && state.heat > 70 && state.power > 10) {
        state.power = clampPercent(state.power - 0.4 * dt);
        state.heat = clampPercent(state.heat - 1.2 * dt);
      }
    }

    function applyFoodTick(dt) {
      if (!Array.isArray(state.npcs)) return;
      const hungerRate = dt / 600;
      for (const npc of state.npcs) {
        if (!npc) continue;
        const current = Number.isFinite(npc.hunger) ? npc.hunger : 0;
        npc.hunger = clamp(current + hungerRate, 0, 2);
      }
    }

    function applyMoraleTick(dt) {
      let moraleDelta = -0.01;
      if (state.oxygen <= 20) moraleDelta -= 0.25;
      if (state.heat >= 78) moraleDelta -= 0.2;
      if ((state.hull / Math.max(1, state.hullMax)) <= 0.4) moraleDelta -= 0.12;
      const hungryCount = countHungryCrew();
      if (hungryCount > 0) moraleDelta -= 0.04 * Math.min(3, hungryCount);
      if (!anyActiveIncident() && state.oxygen >= 60 && state.heat <= 40 && hungryCount === 0) moraleDelta += 0.05;
      const base = safeNumber(state.morale, 0);
      state.morale = clampPercent(base + moraleDelta * dt);
    }

    function applyIncidentDamage(dt) {
      if (state.incidents.breach) {
        const breachRate = state.shieldsOn ? 0.08 : 0.18;
        state.hull = Math.max(0, state.hull - breachRate * dt);
      }
      if (state.incidents.o2Leak) state.oxygen = clampPercent(state.oxygen - 1.2 * dt);
      if (state.incidents.fire) state.heat = clampPercent(state.heat + 1.6 * dt);
      if (state.incidents.powerTrip) state.power = clampPercent(state.power - 0.6 * dt);
      state.hull = clamp(state.hull, 0, state.hullMax);
    }

    function applyTravelTick(dt) {
      if (state.travel && state.travel.active && state.travel.to) {
        const speed = state.engineActive ? (state.throttle * 20 + 5) : 0;
        state.speed = Math.max(0, speed);
        if (speed > 0) {
          state.travel.remaining = Math.max(0, state.travel.remaining - speed * dt);
          const hazard = state.shieldsOn ? 0.6 : 1;
          if (Math.random() < dt * 0.02 * hazard) triggerIncident('powerTrip');
          if (Math.random() < dt * 0.015 * hazard) triggerIncident('o2Leak');
          if (Math.random() < dt * 0.012 * hazard) triggerIncident('fire');
        }
        if (state.travel.remaining <= 0) {
          state.location.system = state.travel.to;
          state.travel = { active: false, from: state.location.system, to: null, remaining: 0, total: 0 };
          state.speed = 0;
          if (Math.random() < 0.6) addAnomaly({ system: currentSystem(), name: 'Signal Echo', kind: 'signal' });
          queueNotification('NAVIGATION', `Arrived at ${state.location.system}.`);
        }
      } else {
        state.speed = 0;
      }
    }

    function applyIncidentTriggers(dt) {
      const lastReset = state.meta && Number.isFinite(state.meta.powerShedAt) ? state.meta.powerShedAt : 0;
      if (state.power < 20 && Date.now() - lastReset > 6000) triggerIncident('powerTrip');
      if (state.oxygen < 15) triggerIncident('o2Leak');
      if (state.heat > 85) triggerIncident('fire');
      if (state.hull < state.hullMax * 0.3) triggerIncident('breach');

      const baseRisk = 0.0006;
      const risk = baseRisk
        + (state.engineActive ? (0.001 + 0.002 * clamp(safeNumber(state.throttle, 0), 0, 1)) : 0)
        + (state.heat >= 80 ? 0.004 : 0)
        + (state.power <= 12 ? 0.004 : 0)
        + (state.morale <= 30 ? 0.006 : 0);
      const scaled = risk * Math.max(0.1, safeNumber(dt, 0.05));
      if (Math.random() < scaled) {
        const kinds = ['powerTrip', 'o2Leak', 'fire', 'breach'].filter((k) => !state.incidents[k]);
        if (kinds.length) {
          const k = kinds[(Math.random() * kinds.length) | 0];
          triggerIncident(k);
        }
      }
    }

    // Fixed timestep game loop (20 FPS like original)
    const FIXED_FPS = 20;
    const STEP = 1 / FIXED_FPS;
    const MAX_CATCHUP_STEPS = 5;
    let lastTs = null;
    let acc = 0;
    let lastRenderTs = 0;

    function systemsTick(dt) {
      const profile = currentPowerProfile();
      applyPowerTick(profile, dt);
      applyOxygenTick(profile, dt);
      applyHeatTick(dt);
      applyFoodTick(dt);
      applyMoraleTick(dt);
      applyIncidentDamage(dt);
      applyTravelTick(dt);
      applyIncidentTriggers(dt);
      crewAutomationTick(dt);
      markDirty();
    }

    function gameLoop(ts) {
      if (lastTs === null) lastTs = ts;
      const deltaMs = Math.min(ts - lastTs, 50);
      lastTs = ts;
      acc += deltaMs / 1000;

      let steps = 0;
      while (acc >= STEP && steps < MAX_CATCHUP_STEPS) {
        updatePlayer(STEP);
        updateNPCs(STEP);
        systemsTick(STEP);
        
        state.sim.saveAcc += STEP;
        if (state.sim.saveAcc >= 10) {
          if (state.sim.dirty) {
            saveGame();
          }
          state.sim.saveAcc = 0;
        }
        
        acc -= STEP;
        steps++;
      }

      const shouldRender = steps > 0 || state.sim.dirty || (ts - lastRenderTs) > 250;
      if (shouldRender) {
        updateCamera();
        renderCorridor();
        updateHUD();
        lastRenderTs = ts;
      }

      requestAnimationFrame(gameLoop);
    }

    // ============================================================================
    // Action Execution & Permission Checking
    // ============================================================================

    function canExecuteAction(action, executor = 'player') {
      // Player can always execute
      if (executor === 'player') return true;

      // Check role requirements
      if (action.requiredRole) {
        const roles = Array.isArray(action.requiredRole) ? action.requiredRole : [action.requiredRole];
        const npc = state.npcs.find(n => n.id === executor);
        if (!npc) return false;
        if (!npcHasRole(npc, roles)) return false;
      }

      return true;
    }

    function executeAction(action, executor = 'player') {
      if (!canExecuteAction(action, executor)) {
        showMessage('ACCESS DENIED', 'Insufficient permissions or missing role.');
        return;
      }
      if (action.playerOnly && executor !== 'player') {
        queueNotification('RESTRICTED ACTION', 'Only the captain can perform that action.');
        return;
      }
      if (typeof action.can === 'function' && !action.can()) {
        if (action.failMessage) showMessage('ACTION', action.failMessage);
        return;
      }
      const runner = executor === 'player' ? action.action : (action.perform || action.action);
      if (typeof runner === 'function') {
        const prevActor = state.ui && state.ui.actionActor ? state.ui.actionActor : 'player';
        if (state.ui) state.ui.actionActor = executor;
        try {
          runner(executor);
        } finally {
          if (state.ui) state.ui.actionActor = prevActor || 'player';
        }
      }
    }

    function openStationPanel(station) {
      const actions = station.getActions(station);
      const buttons = actions.map((action) => {
        let label = action.label;
        if (action.requiredRole) {
          const roles = Array.isArray(action.requiredRole) ? action.requiredRole : [action.requiredRole];
          label += ` [${roles.join('/')}]`;
        }
        return {
          label,
          action: () => {
            closePanel();
            executeAction(action);
          }
        };
      });

      openPanel(station.label.toUpperCase(), `Station: ${station.label}`, buttons);
    }

    // ============================================================================
    // Core Systems & Actions (v1-style loops)
    // ============================================================================

    const ITEM_RECIPES = {
      filter: { scrap: 2 },
      medkit: { scrap: 3 },
      droneParts: { scrap: 4, ingot: 1 },
      rations: { scrap: 1 },
      plating: { ingot: 2 }
    };

    function describeAiBlockers({ maxItems = 6 } = {}) {
      const blockers = state.aiBlockers || {};
      const entries = Object.entries(blockers).filter(([, count]) => Number.isFinite(count) && count > 0);
      if (!entries.length) return 'AI Blockers: None';
      entries.sort((a, b) => b[1] - a[1]);
      const lines = entries.slice(0, maxItems).map(([key, count]) => `${key} (${count})`);
      const extra = entries.length - lines.length;
      return `AI Blockers:\n${lines.join('\n')}${extra > 0 ? `\n+${extra} more` : ''}`;
    }

    function buildAiDebugExport() {
      const blockers = state.aiBlockers || {};
      const crew = Array.isArray(state.npcs) ? state.npcs.map((n) => ({
        id: n.id,
        name: n.name,
        role: npcRole(n),
        onDuty: n.onDuty,
        paused: n.paused,
        task: n.task ? { key: n.task.key, label: n.task.label, targetType: n.task.targetType } : null,
        hunger: n.hunger
      })) : [];
      return {
        timestamp: new Date().toISOString(),
        blockers,
        crew,
        crewAI: state.crewAI,
        incidents: state.incidents,
        inventory: state.inventory,
        powerProfile: state.powerProfile,
        stats: {
          power: state.power,
          oxygen: state.oxygen,
          heat: state.heat,
          hull: state.hull,
          hullMax: state.hullMax,
          morale: state.morale,
          credits: state.credits,
          reputation: state.reputation
        }
      };
    }

    function reportAiBlocker(reason) {
      const key = String(reason || '').trim();
      if (!key) return false;
      if (!state.aiBlockers || typeof state.aiBlockers !== 'object') state.aiBlockers = {};
      if (!state.meta || typeof state.meta !== 'object') state.meta = { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 };
      if (!state.meta.aiBlockerAt || typeof state.meta.aiBlockerAt !== 'object') state.meta.aiBlockerAt = {};
      const now = Date.now();
      const last = state.meta.aiBlockerAt[key] || 0;
      if (now - last < 3000) return false;
      state.meta.aiBlockerAt[key] = now;
      state.aiBlockers[key] = Math.max(0, Math.floor(safeNumber(state.aiBlockers[key], 0))) + 1;
      if (!corridorsWithModuleType('computer').length && state.crewAI && state.crewAI.autoBuild) {
        ensureModuleBuiltIfUnlocked('computer', 'AUTOMATION');
      }
      markDirty();
      return true;
    }

    let AI_ACTIONS_CACHE = null;

    function buildAiActions() {
      const actions = [];
      for (const [type, def] of Object.entries(MODULE_DEFS)) {
        if (!def || !Array.isArray(def.aiActions)) continue;
        for (const action of def.aiActions) {
          if (!action || !action.key) continue;
          actions.push({
            module: type,
            targetType: action.targetType || type,
            ...action
          });
        }
      }
      for (const [itemKey, recipe] of Object.entries(ITEM_RECIPES || {})) {
        if (itemKey === 'plating') continue;
        actions.push({
          key: `fabricator.craft.${itemKey}`,
          label: `Fabricate ${itemKey}`,
          module: 'fabricator',
          targetType: 'fabricator',
          roles: ['engineer', 'tech', 'quartermaster'],
          consumes: { ...recipe },
          produces: { [itemKey]: 1 },
          perform: () => craftItem(itemKey, 1, { respectReserve: true })
        });
      }
      return actions;
    }

    function getAiActions() {
      if (!AI_ACTIONS_CACHE) AI_ACTIONS_CACHE = buildAiActions();
      return AI_ACTIONS_CACHE;
    }

    function aiHasRole(npc, roles) {
      if (!roles || !roles.length) return true;
      if (npcHasRole(npc, roles)) return true;
      const anyRoleAvailable = roles.some((role) => hasCrewRole(role));
      return !anyRoleAvailable;
    }

    function aiHasModule(type) {
      return corridorsWithModuleType(type).length > 0;
    }

    function aiCanRunAction(npc, action) {
      if (!action || !aiHasModule(action.module)) return false;
      if (!aiHasRole(npc, action.roles)) return false;
      const req = action.requires || {};
      if (Number.isFinite(req.power) && state.power < req.power) return false;
      if (req.flags) {
        for (const [flag, val] of Object.entries(req.flags)) {
          if (Boolean(state[flag]) !== Boolean(val)) return false;
        }
      }
      if (typeof req.predicate === 'function' && !req.predicate()) return false;
      return true;
    }

    function aiHasInputs(action) {
      const consumes = action.consumes || {};
      for (const [key, qty] of Object.entries(consumes)) {
        const need = Math.max(0, safeNumber(qty, 0));
        if (!need) continue;
        if (key === 'credits') {
          if (state.credits < need) return false;
        } else if (invAvailableAfterReserve(key) < need) {
          return false;
        }
      }
      return true;
    }

    function shouldDeferDemandToOtherRole(npc, demandKey, actions) {
      if (!npc || !demandKey) return false;
      const candidates = (actions || getAiActions()).filter((a) => a && a.produces && a.produces[demandKey] !== undefined);
      if (!candidates.length) return false;
      const roleSet = new Set();
      for (const action of candidates) {
        if (Array.isArray(action.roles)) {
          for (const role of action.roles) roleSet.add(role);
        }
      }
      if (!roleSet.size) return false;
      const roles = [...roleSet];
      const roleAvailable = roles.some((role) => hasCrewRole(role));
      const npcEligible = roles.some((role) => npcRole(npc) === role);
      return roleAvailable && !npcEligible;
    }

    function resolveDeclarativeDemand(npc, demandKey, visited = new Set()) {
      if (!npc || !demandKey) return false;
      if (visited.has(demandKey)) return false;
      visited.add(demandKey);

      const actions = getAiActions();

      if (String(demandKey).startsWith('flag:')) {
        const flag = String(demandKey).slice(5);
        const setter = actions.find((a) => a && a.setsFlags && a.setsFlags[flag] === true);
        if (setter && aiCanRunAction(npc, setter)) {
          assignNpcTask(npc, { key: setter.key, label: setter.label, targetType: setter.targetType, onComplete: setter.perform });
          return true;
        }
        return false;
      }

      const candidates = actions.filter((a) => a && a.produces && a.produces[demandKey] !== undefined);
      if (!candidates.length) {
        reportAiBlocker(`No producer for ${demandKey}`);
        return false;
      }
      if (shouldDeferDemandToOtherRole(npc, demandKey, actions)) return false;
      candidates.sort((a, b) => (a.priority || 0) - (b.priority || 0));

      let sawMissingModule = false;
      let deferredInput = false;
      for (const action of candidates) {
        if (!aiHasModule(action.module)) {
          sawMissingModule = true;
          continue;
        }
        if (!aiCanRunAction(npc, action)) continue;

        const req = action.requires || {};
        if (req.flags) {
          for (const [flag, val] of Object.entries(req.flags)) {
            if (Boolean(state[flag]) !== Boolean(val)) {
              if (resolveDeclarativeDemand(npc, `flag:${flag}`, visited)) return true;
            }
          }
        }

        const consumes = action.consumes || {};
        let missingResolved = true;
        for (const [key, qty] of Object.entries(consumes)) {
          const need = Math.max(0, safeNumber(qty, 0));
          if (!need) continue;
          if (key === 'credits') {
            if (state.credits < need) {
              if (!resolveDeclarativeDemand(npc, 'credits', visited)) {
                if (shouldDeferDemandToOtherRole(npc, 'credits', actions)) {
                  deferredInput = true;
                  return false;
                }
                missingResolved = false;
                break;
              }
              return true;
            }
          } else if (invAvailableAfterReserve(key) < need) {
            if (!resolveDeclarativeDemand(npc, key, visited)) {
              if (shouldDeferDemandToOtherRole(npc, key, actions)) {
                deferredInput = true;
                return false;
              }
              missingResolved = false;
              break;
            }
            return true;
          }
        }
        if (!missingResolved) continue;
        if (!aiHasInputs(action)) continue;

        assignNpcTask(npc, { key: action.key, label: action.label, targetType: action.targetType, onComplete: action.perform });
        return true;
      }
      if (sawMissingModule && state.crewAI && state.crewAI.autoBuild) {
        const modules = [...new Set(candidates.map((a) => a && a.module).filter(Boolean))];
        for (const mod of modules) {
          if (ensureModuleBuiltIfUnlocked(mod, 'AUTOMATION')) return true;
        }
      }
      if (deferredInput) return false;
      if (sawMissingModule) {
        const modules = [...new Set(candidates.map((a) => a && a.module).filter(Boolean))];
        if (modules.length) reportAiBlocker(`Missing module: ${modules.join(', ')}`);
      }
      reportAiBlocker(`Blocked demand: ${demandKey}`);
      return false;
    }

    function describeInventory() {
      const inv = state.inventory || {};
      const lines = [
        `Ore: ${invGet('ore')}`,
        `Scrap: ${invGet('scrap')}`,
        `Ingots: ${invGet('ingot')}`,
        `Filters: ${invGet('filter')}`,
        `Medkits: ${invGet('medkit')}`,
        `Drone Parts: ${invGet('droneParts')}`,
        `Rations: ${invGet('rations')}`,
        `Credits: ${Math.floor(state.credits)}`
      ];
      return lines.join('\n');
    }

    function shipStatusReport() {
      const lines = [
        `Power: ${Math.round(state.power)}%`,
        `Oxygen: ${Math.round(state.oxygen)}%`,
        `Hull: ${Math.round(state.hull)}/${Math.round(state.hullMax)}`,
        `Heat: ${Math.round(state.heat)}%`,
        `Rations: ${invGet('rations')}`,
        `Morale: ${Math.round(state.morale)}%`,
        `Credits: ${Math.floor(state.credits)}`,
        `Rep: ${Math.floor(state.reputation)}`,
        `Engine: ${state.engineActive ? 'ONLINE' : 'OFFLINE'}`
      ];
      if (state.travel && state.travel.active) {
        lines.push(`Travel: ${state.travel.from} to ${state.travel.to} (${Math.ceil(state.travel.remaining)} AU)`);
      }
      return lines.join('\n');
    }

    function queueNotification(title, description) {
      if (!Array.isArray(state.notifications)) state.notifications = [];
      state.notifications.push({ title: String(title || ''), description: String(description || ''), ts: Date.now() });
      if (state.notifications.length > 30) state.notifications.splice(0, state.notifications.length - 30);
      markDirty();
    }

    function ensureCrewAI() {
      const defaults = {
        enabled: true,
        autoRepair: true,
        autoLife: true,
        autoHydro: true,
        autoRefine: true,
        autoFabricate: true,
        autoContracts: true,
        autoVentHeat: true,
        autoTravel: true,
        autoResearch: true,
        autoBuild: true,
        autoHire: false,
        minCredits: 0,
        targetCrew: 3,
        buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 2 }
      };
      if (!state.crewAI || typeof state.crewAI !== 'object') state.crewAI = { ...defaults };
      for (const k of Object.keys(defaults)) {
        if (state.crewAI[k] === undefined) state.crewAI[k] = defaults[k];
      }
      state.crewAI.autoTravel = !!state.crewAI.autoTravel;
      state.crewAI.autoResearch = !!state.crewAI.autoResearch;
      state.crewAI.autoBuild = !!state.crewAI.autoBuild;
      state.crewAI.autoHire = !!state.crewAI.autoHire;
      state.crewAI.minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI.minCredits, defaults.minCredits)));
      state.crewAI.targetCrew = Math.max(0, Math.min(MAX_CREW, Math.floor(safeNumber(state.crewAI.targetCrew, defaults.targetCrew))));
      if (!state.crewAI.buffers || typeof state.crewAI.buffers !== 'object') state.crewAI.buffers = { ...defaults.buffers };
      for (const k of Object.keys(defaults.buffers)) {
        if (state.crewAI.buffers[k] === undefined) state.crewAI.buffers[k] = defaults.buffers[k];
      }
    }

    function currentSystem() {
      const sys = state.location && typeof state.location === 'object' ? state.location.system : null;
      return typeof sys === 'string' && sys.length ? sys : 'SOL';
    }

    function listDestinations(from) {
      const edges = SYSTEM_GRAPH[from];
      if (!edges || typeof edges !== 'object') return [];
      return Object.keys(edges).sort();
    }

    function distanceBetween(from, to) {
      const edges = SYSTEM_GRAPH[from];
      if (!edges || typeof edges !== 'object') return null;
      const d = edges[to];
      return Number.isFinite(d) ? d : null;
    }

    function findShortestPath(from, to) {
      const start = String(from || '').toUpperCase();
      const goal = String(to || '').toUpperCase();
      if (!start || !goal) return null;
      if (start === goal) return [start];

      const dist = {};
      const prev = {};
      const visited = new Set();
      const nodes = Object.keys(SYSTEM_GRAPH);
      for (const n of nodes) dist[n] = Infinity;
      if (!(start in dist)) dist[start] = Infinity;
      dist[start] = 0;

      while (true) {
        let current = null;
        let best = Infinity;
        for (const n of Object.keys(dist)) {
          if (!visited.has(n) && dist[n] < best) {
            best = dist[n];
            current = n;
          }
        }
        if (!current) break;
        if (current === goal) break;
        visited.add(current);
        const edges = SYSTEM_GRAPH[current] || {};
        for (const [next, w] of Object.entries(edges)) {
          const cand = dist[current] + safeNumber(w, Infinity);
          if (cand < dist[next]) {
            dist[next] = cand;
            prev[next] = current;
          }
        }
      }

      if (!(goal in dist) || dist[goal] === Infinity) return null;
      const path = [];
      let cur = goal;
      while (cur) {
        path.push(cur);
        cur = prev[cur] || null;
      }
      if (path[path.length - 1] !== start) return null;
      path.reverse();
      return path;
    }

    function startTravel(to) {
      const from = currentSystem();
      const dest = String(to || '').toUpperCase();
      const d = distanceBetween(from, dest);
      if (!d) {
        showMessage('NAVIGATION', 'No valid route.');
        return false;
      }
      state.travel = { active: true, from, to: dest, remaining: d, total: d };
      markDirty();
      showMessage('NAVIGATION', `Course plotted: ${from} to ${dest}. Distance: ${d} AU.`);
      return true;
    }

    function startTravelAuto(to, source = 'AUTOPILOT') {
      const from = currentSystem();
      const dest = String(to || '').toUpperCase();
      const d = distanceBetween(from, dest);
      if (!d) return false;
      if (!state.engineActive) state.engineActive = true;
      state.travel = { active: true, from, to: dest, remaining: d, total: d };
      markDirty();
      queueNotification('NAVIGATION', `Course plotted: ${from} to ${dest} (${String(source)}).`);
      return true;
    }

    function cancelTravel() {
      if (!state.travel || !state.travel.active) return false;
      state.travel = { active: false, from: currentSystem(), to: null, remaining: 0, total: 0 };
      markDirty();
      showMessage('NAVIGATION', 'Course cancelled.');
      return true;
    }

    function bestAutoDestination() {
      const sys = currentSystem();
      const destinations = listDestinations(sys);
      return destinations.length ? destinations[0] : sys;
    }

    function ensureAnomaliesArray() {
      if (!Array.isArray(state.anomalies)) state.anomalies = [];
      if (state.anomalies.length > 50) state.anomalies.splice(0, state.anomalies.length - 50);
    }

    function addAnomaly({ system, name, kind }) {
      ensureAnomaliesArray();
      const a = {
        id: 'anom-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
        system: String(system || currentSystem()),
        name: String(name || 'Unknown Signal'),
        kind: String(kind || 'signal'),
        resolved: false,
        ts: Date.now()
      };
      state.anomalies.push(a);
      markDirty();
      return a;
    }

    function rewardFromAnomaly(anomaly) {
      const kind = anomaly && anomaly.kind ? anomaly.kind : 'unknown';
      const r = Math.random();

      const maybeUnlock = (source, preferred) => {
        if (kind === 'vault' && state.blueprints && state.blueprints.recipes && !state.blueprints.recipes.plating) {
          return unlockRecipeBlueprint('plating', source);
        }
        return !!unlockModuleBlueprint(randomLockedModuleType(), source);
      };

      if (kind === 'derelict') {
        invAdd('scrap', 5);
        if (r < 0.55) maybeUnlock('DERELICT', ['drones', 'refinery', 'airlock', 'workshop']);
        return 'Recovered salvage: +5 scrap.';
      }

      if (kind === 'signal') {
        invAdd('ore', 4);
        if (r < 0.55) maybeUnlock('SIGNAL', ['comms', 'shields', 'medbay']);
        return 'Recovered minerals: +4 ore.';
      }

      if (kind === 'vault') {
        invAdd('ingot', 2);
        if (r < 0.7) maybeUnlock('VAULT', ['workshop', 'medbay', 'comms', 'shields']);
        return 'Recovered alloys: +2 ingots.';
      }

      invAdd('scrap', 2);
      if (r < 0.35) maybeUnlock('ANOMALY', null);
      return 'Recovered fragments: +2 scrap.';
    }

    function randomLockedModuleType(preferred = null) {
      const all = Object.keys(MODULE_DEFS).filter((t) => !isModuleUnlocked(t) && !['rear', 'front', 'doorway', 'elevator', 'empty'].includes(t));
      if (!all.length) return null;
      if (Array.isArray(preferred) && preferred.length) {
        const pool = all.filter((t) => preferred.includes(t));
        if (pool.length) return pool[(Math.random() * pool.length) | 0];
      }
      return all[(Math.random() * all.length) | 0];
    }

    function resolveAnomaly(anomaly, showPanel = true) {
      if (!anomaly || anomaly.resolved) return false;
      anomaly.resolved = true;
      const msg = rewardFromAnomaly(anomaly);
      markDirty();
      if (showPanel) showMessage('ANOMALY', `${anomaly.name}\n${msg}`);
      return true;
    }

    function scanForAnomalies(showPanel = true) {
      const sys = currentSystem();
      const messages = [];
      const hasPower = state.power >= 5;
      if (!hasPower) {
        // Emergency low-power sweep to avoid early-game deadlock.
        messages.push('Low power sweep engaged.');
      } else {
        state.power = Math.max(0, state.power - 5);
      }

      const existing = Array.isArray(state.anomalies) ? state.anomalies.filter((a) => a && a.system === sys && !a.resolved) : [];
      if (existing.length) {
        messages.push(`${existing.length} unresolved anomaly/anomalies detected in ${sys}.`);
      }

      const roll = Math.random();
      if (hasPower && roll < 0.6) {
        const kind = roll < 0.25 ? 'vault' : 'derelict';
        const name = kind === 'vault' ? 'Vault Signal' : 'Derelict Beacon';
        addAnomaly({ system: sys, name, kind });
        messages.push(`Signal discovered: ${name}.`);
      }

      // Always yield some salvage so scans are a reliable early-game starter.
      const salvageRoll = Math.random();
      if (salvageRoll < 0.6) {
        invAdd('scrap', 2);
        messages.push('Sweep complete. Recovered 2 scrap.');
      } else if (salvageRoll < 0.9) {
        invAdd('ore', 2);
        messages.push('Sweep complete. Recovered 2 ore.');
      } else {
        invAdd('scrap', 1);
        invAdd('ore', 1);
        messages.push('Sweep complete. Recovered 1 scrap and 1 ore.');
      }

      if (showPanel && messages.length) {
        showMessage('SENSORS', messages.join('\n'));
      }
    }

    function deepScanBlueprint(showPanel = true) {
      if (state.power < 12) {
        if (showPanel) showMessage('SENSORS', 'Need at least 12 power.');
        return false;
      }
      if (!invHas('scrap', 2)) {
        if (showPanel) showMessage('SENSORS', 'Need 2 scrap to calibrate the array.');
        return false;
      }
      state.power = Math.max(0, state.power - 12);
      invTake('scrap', 2);

      const locked = listLockedAdvancedModuleTypes();
      let unlocked = false;
      if (locked.length) {
        const pick = locked[(Math.random() * locked.length) | 0];
        unlocked = unlockModuleBlueprint(pick, 'DEEP SCAN');
      } else if (state.blueprints && state.blueprints.recipes && !state.blueprints.recipes.plating) {
        unlocked = unlockRecipeBlueprint('plating', 'DEEP SCAN');
      }

      if (showPanel) {
        showMessage('SENSORS', unlocked ? 'Blueprint data recovered.' : 'No new signatures found.');
      }
      return unlocked;
    }

    function openAnomalyPanel(anomaly) {
      if (!anomaly) return;
      const sys = currentSystem();
      if (anomaly.system !== sys) {
        showMessage('ANOMALY', `This anomaly is in ${anomaly.system}. Current system: ${sys}.`);
        return;
      }

      const status = anomaly.resolved ? 'RESOLVED' : 'UNRESOLVED';
      const lines = [
        `System: ${anomaly.system}`,
        `Signature: ${anomaly.name}`,
        `Type: ${String(anomaly.kind).toUpperCase()}`,
        `Status: ${status}`
      ];

      const buttons = [];
      if (!anomaly.resolved) {
        buttons.push({
          label: 'Investigate',
          action: () => {
            investigateAnomaly(anomaly, true);
          }
        });
      }
      buttons.push({ label: 'Back', action: openNavigationPanel });
      openPanel('ANOMALY', lines.join('\n'), buttons, { includeCancel: false });
    }

    function investigateAnomaly(anomaly, showPanel = true) {
      if (!anomaly || anomaly.resolved) return false;
      if (state.power < 10) {
        if (showPanel) showMessage('ANOMALY', 'Need at least 10 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 10);
      resolveAnomaly(anomaly, showPanel);
      return true;
    }

    function ensureContracts() {
      if (!state.contract || typeof state.contract !== 'object') state.contract = { available: [], active: null };
      if (!Array.isArray(state.contract.available)) state.contract.available = [];
      if (state.contract.available.length >= 3) return;

      const mk = (id, title, requires, reward) => ({ id, title, requires, reward });
      const base = Date.now().toString(36).slice(-4);
      const pool = [
        mk(`c-${base}-ore`, 'Deliver Ore', { ore: 6 }, { credits: 40, reputation: 2 }),
        mk(`c-${base}-scrap`, 'Deliver Scrap', { scrap: 8 }, { credits: 55, reputation: 2 }),
        mk(`c-${base}-ingot`, 'Deliver Ingots', { ingot: 4 }, { credits: 80, reputation: 3 }),
        mk(`c-${base}-med`, 'Medical Supplies', { medkit: 2 }, { credits: 70, reputation: 4 }),
        mk(`c-${base}-filters`, 'Life Support Filters', { filter: 3 }, { credits: 45, reputation: 3 })
      ];

      while (state.contract.available.length < 3 && pool.length) {
        const pick = pool.splice((Math.random() * pool.length) | 0, 1)[0];
        state.contract.available.push(pick);
      }
      markDirty();
    }

    function contractReady(contract, { respectReserve = false } = {}) {
      if (!contract || !contract.requires || typeof contract.requires !== 'object') return false;
      for (const k of Object.keys(contract.requires)) {
        const need = contract.requires[k];
        if (respectReserve) {
          if (invAvailableAfterReserve(k) < need) return false;
        } else if (invGet(k) < need) {
          return false;
        }
      }
      return true;
    }

    function applyContractCompletion(contract, { respectReserve = false } = {}) {
      if (!contractReady(contract, { respectReserve })) return false;
      for (const k of Object.keys(contract.requires || {})) {
        if (!invTake(k, contract.requires[k])) return false;
      }
      const reward = contract.reward || {};
      state.credits = Math.max(0, safeNumber(state.credits, 0) + safeNumber(reward.credits, 0));
      state.reputation = Math.max(0, safeNumber(state.reputation, 0) + safeNumber(reward.reputation, 0));
      markDirty();
      updateHUD();
      return true;
    }

    function activeContractNeeds() {
      const c = state.contract && state.contract.active ? state.contract.active : null;
      if (!c || !c.requires || typeof c.requires !== 'object') return null;
      const needs = {};
      for (const k of Object.keys(c.requires)) {
        const need = Math.max(0, safeNumber(c.requires[k], 0));
        const have = invAvailableAfterReserve(k);
        const missing = Math.max(0, need - have);
        if (missing > 0) needs[k] = missing;
      }
      return needs;
    }

    function ensureModuleBuiltIfUnlocked(type, source = 'CREW') {
      if (corridorsWithModuleType(type).length) return true;
      if (!isModuleUnlocked(type)) return false;
      if (type !== 'fabricator' && !corridorsWithModuleType('fabricator').length) return false;
      let targetLevel = state.currentLevel;
      let targetCorridor = state.currentCorridor;
      if (String(source) === 'AUTOMATION') {
        const groupKey = moduleGroupForType(type);
        const hub = getAutoBuildHubCorridor();
        if (groupKey && groupKey !== 'hub') {
          const grouped = ensureGroupCorridor(groupKey, hub.level, hub.corridor);
          if (grouped) {
            targetLevel = grouped.level;
            targetCorridor = grouped.corridor;
          } else {
            targetLevel = hub.level;
            targetCorridor = hub.corridor;
          }
        } else {
          targetLevel = hub.level;
          targetCorridor = hub.corridor;
        }
      }
      const modules = getModulesForCorridor(targetLevel, targetCorridor);
      insertModuleAtInCorridor(targetLevel, targetCorridor, modules.length, { type, label: MODULE_DEFS[type] ? MODULE_DEFS[type].label : type });
      queueNotification('FABRICATOR', `${MODULE_DEFS[type] ? MODULE_DEFS[type].label : type} fabricated (${String(source)}).`);
      updateDoorwayLabelsForAll();
      relayoutCorridor();
      updateHUD();
      return true;
    }

    function pickAutoBuildTarget({
      needs,
      wantsScrap,
      wantsOre,
      wantsIngots,
      wantsFilters,
      wantsMedkits,
      wantsDroneParts,
      wantsRations
    }) {
      const has = (type) => corridorsWithModuleType(type).length > 0;
      const canBuild = (type) => isModuleUnlocked(type) && !has(type) && corridorsWithModuleType('fabricator').length > 0;
      const hasSellableSurplus = () => (
        invAvailableAfterReserve('ingot') > 0
        || invAvailableAfterReserve('scrap') > 0
        || invAvailableAfterReserve('ore') > (has('refinery') ? 2 : 0)
        || invAvailableAfterReserve('rations') > 0
      );

      const supplyChainTargetFor = (itemKey, visited = new Set(), depth = 0) => {
        if (!itemKey || depth > 4) return null;
        if (visited.has(itemKey)) return null;
        visited.add(itemKey);

        if (itemKey === 'scrap' || itemKey === 'ore') {
          if (canBuild('sensors')) return 'sensors';
          if (canBuild('drones')) return 'drones';
          return null;
        }

        if (itemKey === 'ingot') {
          if (canBuild('refinery')) return 'refinery';
          return supplyChainTargetFor('ore', visited, depth + 1);
        }

        const recipe = ITEM_RECIPES[itemKey];
        if (recipe) {
          if (canBuild('fabricator')) return 'fabricator';
          for (const [mat, qty] of Object.entries(recipe)) {
            if (invAvailableAfterReserve(mat) < qty) {
              const target = supplyChainTargetFor(mat, visited, depth + 1);
              if (target) return target;
            }
          }
        }

        return null;
      };

      const supplyChainGoal = () => {
        const goals = [];
        if (wantsDroneParts) goals.push('droneParts');
        if (wantsFilters) goals.push('filter');
        if (wantsMedkits) goals.push('medkit');
        if (wantsRations) goals.push('rations');
        if (wantsIngots) goals.push('ingot');
        if (wantsScrap) goals.push('scrap');
        if (wantsOre) goals.push('ore');
        for (const g of goals) {
          const target = supplyChainTargetFor(g);
          if (target && canBuild(target)) return target;
        }
        return null;
      };

      const supplyTarget = supplyChainGoal();
      if (supplyTarget) return supplyTarget;

      if (countHungryCrew() > 0 && canBuild('canteen')) return 'canteen';

      if (state.crewAI.autoHire) {
        const fee = 30;
        if (state.credits < fee && !hasSellableSurplus()) {
          if (canBuild('sensors')) return 'sensors';
          if (canBuild('drones')) return 'drones';
          if (canBuild('cargo')) return 'cargo';
        }
      }

      if (state.crewAI.autoHire && canBuild('quarters')) return 'quarters';
      if (state.crewAI.autoContracts && canBuild('comms')) return 'comms';
      if ((wantsFilters || wantsMedkits || wantsDroneParts || wantsRations) && canBuild('fabricator')) return 'fabricator';
      if ((wantsIngots || wantsDroneParts) && canBuild('refinery')) return 'refinery';
      if ((wantsScrap || wantsOre) && canBuild('sensors')) return 'sensors';
      if ((wantsScrap || wantsOre || state.crewAI.autoRepair) && canBuild('drones')) return 'drones';
      if ((state.hull < state.hullMax * 0.9 || (state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating)) && canBuild('workshop')) return 'workshop';
      if (state.oxygen < 80 && canBuild('life')) return 'life';
      if (invGet('rations') < invReserve('rations') && canBuild('hydro')) return 'hydro';
      if (state.morale < 70 && canBuild('medbay')) return 'medbay';
      if ((state.incidents && (state.incidents.breach || state.incidents.fire)) && canBuild('shields')) return 'shields';
      if ((state.incidents && state.incidents.breach) && canBuild('airlock')) return 'airlock';
      if (state.credits < 20 && canBuild('cargo')) return 'cargo';

      return null;
    }

    function openContractsPanel() {
      ensureContracts();
      const active = state.contract.active;
      const lines = [];
      if (active) {
        lines.push(`ACTIVE: ${active.title}`);
        lines.push(`Requires: ${Object.entries(active.requires || {}).map(([k, v]) => `${k}Ã${v}`).join(', ') || 'â'}`);
        lines.push(`Reward: ${Object.entries(active.reward || {}).map(([k, v]) => `${k}+${v}`).join(', ') || 'â'}`);
        lines.push(contractReady(active) ? 'Status: READY TO COMPLETE' : 'Status: In progress');
      } else {
        lines.push('No active contract.');
      }

      const buttons = [];

      if (active) {
        buttons.push({
          label: contractReady(active) ? 'Transmit Completion' : 'Transmit Status',
          action: () => {
            if (!contractReady(active)) {
              showMessage('COMMS', 'Contract not ready yet.');
              return;
            }
            applyContractCompletion(active);
            state.contract.active = null;
            ensureContracts();
            showMessage('COMMS', 'Contract completed. Payment received.');
          }
        });
        buttons.push({
          label: 'Abandon Contract',
          danger: true,
          action: () => {
            state.contract.active = null;
            markDirty();
            showMessage('COMMS', 'Contract abandoned.');
          }
        });
      } else {
        for (const c of state.contract.available || []) {
          if (!c) continue;
          buttons.push({
            label: `Accept: ${c.title}`,
            action: () => {
              state.contract.active = c;
              state.contract.available = (state.contract.available || []).filter((x) => x && x.id !== c.id);
              markDirty();
              showMessage('COMMS', `Accepted contract: ${c.title}`);
            }
          });
        }
        if (buttons.length === 0) {
          buttons.push({ label: 'No contracts available', action: () => {} });
        }
      }

      openPanel('COMMS â CONTRACTS', lines.join('\n'), [...buttons, { label: 'Back', action: closePanel }], { includeCancel: false });
    }

    function autoManageContracts() {
      ensureContracts();
      if (state.contract.active) {
        if (applyContractCompletion(state.contract.active, { respectReserve: true })) {
          state.contract.active = null;
          ensureContracts();
        }
        return;
      }
      const list = Array.isArray(state.contract.available) ? state.contract.available.filter(Boolean) : [];
      if (list.length) {
        let best = list[0];
        let bestScore = Infinity;
        for (const c of list) {
          let score = 0;
          for (const [k, v] of Object.entries(c.requires || {})) {
            const need = Math.max(0, safeNumber(v, 0));
            const have = invAvailableAfterReserve(k);
            score += Math.max(0, need - have);
          }
          if (score < bestScore) {
            bestScore = score;
            best = c;
          }
        }
        state.contract.active = best;
        state.contract.available = list.filter((x) => x && x.id !== best.id);
        ensureContracts();
      }
    }

    function openCargoTradePanel() {
      const sell = (key, price) => {
        if (!invHas(key, 1)) {
          showMessage('CARGO', `No ${key} to sell.`);
          return;
        }
        invTake(key, 1);
        state.credits += price;
        markDirty();
        updateHUD();
        showMessage('CARGO', `Sold 1 ${key} for ${price} cr.`);
      };
      const buy = (key, price) => {
        if (state.credits < price) {
          showMessage('CARGO', `Need ${price} credits.`);
          return;
        }
        state.credits -= price;
        invAdd(key, 1);
        markDirty();
        updateHUD();
        showMessage('CARGO', `Purchased 1 ${key} for ${price} cr.`);
      };
      openPanel(
        'CARGO TRADE',
        'Buy essentials or sell raw materials for credits.',
        [
          { label: 'Buy Filter (-10 cr)', action: () => buy('filter', 10) },
          { label: 'Buy Medkit (-25 cr)', action: () => buy('medkit', 25) },
          { label: 'Buy Drone Parts (-20 cr)', action: () => buy('droneParts', 20) },
          { label: 'Buy Rations (-8 cr)', action: () => buy('rations', 8) },
          { label: 'Sell Ore (+5 cr)', action: () => sell('ore', 5) },
          { label: 'Sell Scrap (+8 cr)', action: () => sell('scrap', 8) },
          { label: 'Sell Ingots (+15 cr)', action: () => sell('ingot', 15) },
          { label: 'Sell Rations (+4 cr)', action: () => sell('rations', 4) }
        ]
      );
    }

    function buyCargoItem(itemKey, price, { showPanel = false } = {}) {
      if (state.credits < price) {
        if (showPanel) showMessage('CARGO', `Need ${price} credits.`);
        return false;
      }
      state.credits -= price;
      invAdd(itemKey, 1);
      markDirty();
      updateHUD();
      if (showPanel) showMessage('CARGO', `Purchased 1 ${itemKey} for ${price} cr.`);
      return true;
    }

    function sellCargoItem(itemKey, price, { respectReserve = false, minKeep = 0, showPanel = false } = {}) {
      const canSell = respectReserve
        ? canSpendReservedWithMinKeep(itemKey, 1, minKeep)
        : invHas(itemKey, 1);
      if (!canSell) {
        if (showPanel) showMessage('CARGO', `No ${itemKey} to sell.`);
        return false;
      }
      invTake(itemKey, 1);
      state.credits += price;
      markDirty();
      updateHUD();
      if (showPanel) showMessage('CARGO', `Sold 1 ${itemKey} for ${price} cr.`);
      return true;
    }

    function autoSellCargo() {
      if (invGet('ingot') >= 6) {
        invTake('ingot', 2);
        state.credits += 30;
      } else if (invGet('scrap') >= 8) {
        invTake('scrap', 4);
        state.credits += 24;
      }
      markDirty();
    }

    function craftItem(itemKey, qty = 1, { respectReserve = false, showPanel = false } = {}) {
      const recipe = ITEM_RECIPES[itemKey];
      if (!recipe) {
        if (showPanel) showMessage('FABRICATOR', 'Unknown recipe.');
        return false;
      }
      for (const [k, v] of Object.entries(recipe)) {
        const need = v * qty;
        const ok = respectReserve ? canSpendReserved(k, need) : invHas(k, need);
        if (!ok) {
          if (showPanel) showMessage('FABRICATOR', `Need ${need} ${k}.`);
          return false;
        }
      }
      for (const [k, v] of Object.entries(recipe)) invTake(k, v * qty);
      invAdd(itemKey, qty);
      if (showPanel) showMessage('FABRICATOR', `Built ${qty} ${itemKey}.`);
      return true;
    }

    function openFabricatorPanel() {
      const buttons = [
        { label: 'Build Filter (2 scrap)', action: () => craftItem('filter', 1, { showPanel: true }) },
        { label: 'Build Medkit (3 scrap)', action: () => craftItem('medkit', 1, { showPanel: true }) },
        { label: 'Build Drone Parts (4 scrap + 1 ingot)', action: () => craftItem('droneParts', 1, { showPanel: true }) },
        { label: 'Build Rations (1 scrap)', action: () => craftItem('rations', 1, { showPanel: true }) }
      ];
      openPanel('FABRICATOR', 'Select a recipe:', buttons);
    }

    function autoFabricateConsumables() {
      const buffers = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : {};
      if (invGet('filter') < (buffers.filter || 0)) craftItem('filter', 1, { respectReserve: true });
      if (invGet('medkit') < (buffers.medkit || 0)) craftItem('medkit', 1, { respectReserve: true });
      if (invGet('droneParts') < (buffers.droneParts || 0)) craftItem('droneParts', 1, { respectReserve: true });
      if (invGet('rations') < (buffers.rations || 0)) craftItem('rations', 1, { respectReserve: true });
    }

    function refineOre(showPanel = true) {
      if (!invHas('ore', 3)) {
        if (showPanel) showMessage('REFINERY', 'Need 3 ore to refine.');
        return false;
      }
      invTake('ore', 3);
      invAdd('ingot', 1);
      if (showPanel) showMessage('REFINERY', 'Refined 3 ore into 1 ingot.');
      return true;
    }

    function openRefineryPanel(showPanel = true) {
      openPanel('REFINERY', 'Convert ore into ingots.', [
        { label: 'Refine 3 Ore', action: () => refineOre(showPanel) },
        { label: 'Refine 5 Ingots (15 Ore)', action: () => { let ok = true; for (let i = 0; i < 5; i++) ok = refineOre(false) && ok; if (showPanel) showMessage('REFINERY', ok ? 'Refined 5 ingots.' : 'Not enough ore.'); } }
      ]);
    }

    function toggleEngine() {
      state.engineActive = !state.engineActive;
      if (!state.engineActive) {
        state.throttle = 0;
        state.speed = 0;
      }
      markDirty();
    }

    function openThrottlePanel(context = 'NAV') {
      const thr = clamp(safeNumber(state.throttle, 0), 0, 1);
      const pct = Math.round(thr * 100);
      const mk = (p) => ({
        label: p === pct ? `Throttle: ${p}% (current)` : `Throttle: ${p}%`,
        action: () => {
          state.throttle = clamp(p / 100, 0, 1);
          markDirty();
          updateHUD();
          showMessage(context, `Throttle set to ${p}%.`);
        }
      });

      openPanel(
        `${context} â THROTTLE`,
        'Set engine throttle:',
        [mk(0), mk(25), mk(50), mk(75), mk(100), { label: 'Back', action: closePanel }],
        { includeCancel: false }
      );
    }

    function openPowerRoutingPanel(context = 'POWER') {
      const desc = {
        balanced: 'Default behavior. No automatic load shedding.',
        survival: 'Prioritizes life support. Sheds nonessential loads at low power.',
        combat: 'Prioritizes shields and engines. Sheds hydroponics first at low power.',
        industry: 'Prioritizes hydroponics and fabrication support. Sheds shields first at low power.'
      };

      const set = (profile) => {
        state.powerProfile = profile;
        markDirty();
        showMessage(context, `Power routing set to ${profile.toUpperCase()}.`);
      };

      const buttons = [
        { label: state.powerProfile === 'balanced' ? 'BALANCED (current)' : 'BALANCED', action: () => set('balanced') },
        { label: state.powerProfile === 'survival' ? 'SURVIVAL (current)' : 'SURVIVAL', action: () => set('survival') },
        { label: state.powerProfile === 'combat' ? 'COMBAT (current)' : 'COMBAT', action: () => set('combat') },
        { label: state.powerProfile === 'industry' ? 'INDUSTRY (current)' : 'INDUSTRY', action: () => set('industry') },
        { label: 'Back', action: closePanel }
      ];

      openPanel(
        `${context} â POWER ROUTING`,
        `${desc[state.powerProfile] || ''}`,
        buttons,
        { includeCancel: false }
      );
    }

    function autoRoutePower() {
      if (state.power < 25 || state.oxygen < 40) {
        state.powerProfile = 'survival';
      } else if (state.engineActive && state.shieldsOn) {
        state.powerProfile = 'combat';
      } else if (state.hydroponicsOn) {
        state.powerProfile = 'industry';
      } else {
        state.powerProfile = 'balanced';
      }
      markDirty();
    }

    function resetPowerTrip(showPanel = true) {
      const cleared = resolveIncident('powerTrip');
      if (!cleared) return false;
      state.power = Math.max(state.power, 30);
      state.powerProfile = 'survival';
      state.meta.powerShedAt = Date.now();
      markDirty();
      if (showPanel) showMessage('POWER', 'Breakers reset. Emergency routing engaged.');
      return true;
    }

    function toggleLifeSupport() {
      state.lifeSupportOn = !state.lifeSupportOn;
      markDirty();
    }

    function toggleLights() {
      state.lightsOn = !state.lightsOn;
      markDirty();
    }

    function scrubOxygen(showPanel = true) {
      if (!invTake('filter', 1)) {
        if (showPanel) showMessage('LIFE', 'Need 1 filter to cycle scrubbers.');
        return false;
      }
      state.oxygen = Math.min(100, state.oxygen + 25);
      resolveIncident('o2Leak');
      markDirty();
      if (showPanel) showMessage('LIFE', 'Scrubbers cycled. Oxygen restored.');
      return true;
    }

    function emergencyScrubbers(showPanel = true) {
      if (state.power < 8) {
        if (showPanel) showMessage('LIFE', 'Need at least 8 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 8);
      if (invHas('filter', 1)) invTake('filter', 1);
      state.oxygen = Math.min(100, state.oxygen + 35);
      resolveIncident('o2Leak');
      markDirty();
      if (showPanel) showMessage('LIFE', 'Emergency scrubbers activated.');
      return true;
    }

    function toggleHydroponics() {
      state.hydroponicsOn = !state.hydroponicsOn;
      markDirty();
    }

    function harvestHydroponics(showPanel = true) {
      if (!state.hydroponicsOn) {
        if (showPanel) showMessage('HYDRO', 'Hydroponics are offline.');
        return false;
      }
      if (state.power < 4) {
        if (showPanel) showMessage('HYDRO', 'Need at least 4 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 4);
      invAdd('rations', 2);
      markDirty();
      if (showPanel) showMessage('HYDRO', 'Harvest complete: +2 rations.');
      return true;
    }

    function treatInjury(showPanel = true) {
      if (!invTake('medkit', 1)) {
        if (showPanel) showMessage('MEDBAY', 'Need a medkit.');
        return false;
      }
      state.morale = 100;
      markDirty();
      updateHUD();
      if (showPanel) showMessage('MEDBAY', 'Crew treated. Morale improved.');
      return true;
    }

    function restCrew(showPanel = true) {
      if (!invHas('rations', 1)) {
        if (showPanel) showMessage('QUARTERS', 'No rations available.');
        return false;
      }
      invTake('rations', 1);
      state.morale = Math.min(100, state.morale + 22);
      markDirty();
      if (showPanel) showMessage('QUARTERS', 'Crew rested. Morale improved.');
      return true;
    }

    function toggleShields() {
      state.shieldsOn = !state.shieldsOn;
      markDirty();
    }

    function sealBulkheads(showPanel = true) {
      if (!state.incidents.breach) {
        if (showPanel) showMessage('SHIELDS', 'Bulkheads sealed. No breach detected.');
        return false;
      }
      if (state.power < 6) {
        if (showPanel) showMessage('SHIELDS', 'Need at least 6 power.');
        return false;
      }
      state.power = Math.max(0, state.power - 6);
      resolveIncident('breach');
      markDirty();
      if (showPanel) showMessage('SHIELDS', 'Bulkheads sealed. Breach contained.');
      return true;
    }

    function repairHull(showPanel = true) {
      if (!invHas('ingot', 1) && !invHas('scrap', 2)) {
        if (showPanel) showMessage('WORKSHOP', 'Need 1 ingot or 2 scrap for repairs.');
        return false;
      }
      if (invHas('ingot', 1)) invTake('ingot', 1);
      else invTake('scrap', 2);
      state.hull = Math.min(state.hullMax, state.hull + 20);
      resolveIncident('breach');
      markDirty();
      if (showPanel) showMessage('WORKSHOP', 'Hull patched.');
      return true;
    }

    function autoInstallUpgrade() {
      if (state.hullMax >= 160) return;
      if (!invHas('ingot', 2)) return;
      invTake('ingot', 2);
      state.hullMax = Math.min(200, state.hullMax + 10);
      state.hull = Math.min(state.hullMax, state.hull + 10);
      markDirty();
    }

    function installHullPlating(showPanel = true) {
      if (!state.blueprints || !state.blueprints.recipes || !state.blueprints.recipes.plating) {
        if (showPanel) showMessage('WORKSHOP', 'Plating blueprint not unlocked.');
        return false;
      }
      if (!invHas('ingot', 2)) {
        if (showPanel) showMessage('WORKSHOP', 'Need 2 ingots for hull plating.');
        return false;
      }
      invTake('ingot', 2);
      state.hullMax = Math.min(220, state.hullMax + 12);
      state.hull = Math.min(state.hullMax, state.hull + 12);
      markDirty();
      if (showPanel) showMessage('WORKSHOP', 'Hull plating installed.');
      return true;
    }

    function openWorkshopPanel() {
      openPanel('WORKSHOP', 'Install upgrades using ingots.', [
        {
          label: 'Reinforce Hull (2 ingots)',
          action: () => {
            if (!invHas('ingot', 2)) {
              showMessage('WORKSHOP', 'Need 2 ingots.');
              return;
            }
            invTake('ingot', 2);
            state.hullMax = Math.min(200, state.hullMax + 10);
            state.hull = Math.min(state.hullMax, state.hull + 10);
            markDirty();
            showMessage('WORKSHOP', 'Hull reinforcement installed.');
          }
        },
        {
          label: 'Power Cell Upgrade (2 ingots)',
          action: () => {
            if (!invHas('ingot', 2)) {
              showMessage('WORKSHOP', 'Need 2 ingots.');
              return;
            }
            invTake('ingot', 2);
            state.power = Math.min(150, state.power + 15);
            markDirty();
            showMessage('WORKSHOP', 'Power cells upgraded.');
          }
        }
      ]);
    }

    function launchRepairDrone(showPanel = true) {
      if (!invTake('droneParts', 1)) {
        if (showPanel) showMessage('DRONES', 'Need drone parts.');
        return false;
      }
      if (state.power < 6) {
        if (showPanel) showMessage('DRONES', 'Need at least 6 power.');
        invAdd('droneParts', 1);
        return false;
      }
      state.power = Math.max(0, state.power - 6);
      resolveIncident('breach');
      resolveIncident('fire');
      state.hull = Math.min(state.hullMax, state.hull + 12);
      markDirty();
      if (showPanel) showMessage('DRONES', 'Repair drone completed remote fixes.');
      return true;
    }

    function launchSalvageDrone(showPanel = true) {
      if (!invTake('droneParts', 1)) {
        if (showPanel) showMessage('DRONES', 'Need drone parts.');
        return false;
      }
      if (state.power < 6) {
        if (showPanel) showMessage('DRONES', 'Need at least 6 power.');
        invAdd('droneParts', 1);
        return false;
      }
      state.power = Math.max(0, state.power - 6);
      invAdd('scrap', 3);
      if (Math.random() < 0.4) invAdd('ore', 2);
      markDirty();
      if (showPanel) showMessage('DRONES', 'Salvage drone recovered scrap.');
      return true;
    }

    function performEvaRepair(showPanel = true) {
      if (state.oxygen < 10) {
        if (showPanel) showMessage('AIRLOCK', 'Need at least 10 oxygen.');
        return false;
      }
      if (!invHas('scrap', 2)) {
        if (showPanel) showMessage('AIRLOCK', 'Need 2 scrap for EVA patch.');
        return false;
      }
      invTake('scrap', 2);
      state.oxygen = Math.max(0, state.oxygen - 10);
      const risk = Math.random();
      if (risk < 0.2) {
        state.morale = Math.max(0, state.morale - 6);
        if (showPanel) showMessage('AIRLOCK', 'EVA stressful. Morale down.');
      }
      state.hull = Math.min(state.hullMax, state.hull + 25);
      resolveIncident('breach');
      markDirty();
      if (showPanel) showMessage('AIRLOCK', 'External hull patched.');
      return true;
    }

    function openAirlockPanel(showPanel = true) {
      openPanel('AIRLOCK', 'Perform external operations.', [
        { label: 'EVA Repair (2 scrap)', action: () => performEvaRepair(showPanel) }
      ]);
    }

    function openDronePanel(showPanel = true) {
      openPanel('DRONE BAY', 'Deploy a drone for salvage or repairs.', [
        { label: 'Launch Repair Drone (1 part)', action: () => launchRepairDrone(showPanel) },
        { label: 'Launch Salvage Drone (1 part)', action: () => launchSalvageDrone(showPanel) }
      ]);
    }

    function openNavigationPanel() {
      const sys = currentSystem();
      const t = state.travel && typeof state.travel === 'object' ? state.travel : { active: false };
      const thr = clamp(safeNumber(state.throttle, 0), 0, 1);
      const thrPct = Math.round(thr * 100);

      const lines = [];
      lines.push(`System: ${sys}`);
      lines.push(`Engine: ${state.engineActive ? 'ACTIVE' : 'IDLE'}`);
      lines.push(`Throttle: ${thrPct}%`);

      if (t.active && t.to) {
        const rate = Math.max(0, safeNumber(state.speed, 0) / 15000);
        const eta = rate > 0.01 ? Math.ceil(t.remaining / rate) : null;
        lines.push('');
        lines.push(`Course: ${t.from} to ${t.to}`);
        lines.push(`Remaining: ${Math.max(0, Math.round(t.remaining))} AU`);
        lines.push(`ETA: ${eta !== null ? eta + 's' : 'â'}`);
      }

      const localAnoms = Array.isArray(state.anomalies)
        ? state.anomalies.filter((a) => a && !a.resolved && a.system === sys).slice(-3)
        : [];
      if (localAnoms.length) {
        lines.push('');
        lines.push('Anomalies:');
        for (const a of localAnoms) lines.push(`â¢ ${a.name}`);
      }

      const buttons = [];

      buttons.push({
        label: state.engineActive ? 'Toggle Engine (ON)' : 'Toggle Engine (OFF)',
        action: () => {
          state.engineActive = !state.engineActive;
          if (!state.engineActive) state.speed = 0;
          markDirty();
          updateHUD();
          showMessage('NAVIGATION', state.engineActive ? 'Engine activated.' : 'Engine deactivated.');
        }
      });

      buttons.push({ label: 'Set Throttle', action: () => openThrottlePanel('NAVIGATION') });

      if (t.active && t.to) {
        buttons.push({ label: 'Cancel Course', danger: true, action: cancelTravel });
      } else {
        buttons.push({
          label: 'Plot Course',
          action: () => {
            const dests = listDestinations(sys);
            if (dests.length === 0) return showMessage('NAVIGATION', 'No known destinations.');
            openPanel(
              'NAVIGATION',
              `Destinations from ${sys}:`,
              [...dests.map((d) => ({ label: `${sys} to ${d} (${distanceBetween(sys, d)} AU)`, action: () => startTravel(d) })), { label: 'Back', action: openNavigationPanel }],
              { includeCancel: false }
            );
          }
        });
      }

      if (localAnoms.length) {
        for (const a of localAnoms) {
          buttons.push({ label: `Investigate: ${a.name}`, action: () => openAnomalyPanel(a) });
        }
      }

      buttons.push({ label: 'Back', action: closePanel });
      openPanel('NAVIGATION', lines.join('\n'), buttons, { includeCancel: false });
    }

    function toggleShieldsPower() {
      if (!state.shieldsOn) return 0;
      return 0.3;
    }

    function openCrewCommandPanel() {
      const buffers = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : {};
      const minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI && state.crewAI.minCredits, 0)));
      const lines = [
        `Automation: ${state.crewAI.enabled ? 'ON' : 'OFF'}`,
        `Auto Hire: ${state.crewAI.autoHire ? 'ON' : 'OFF'} (target ${state.crewAI.targetCrew})`,
        `Minimum Credits: ${minCredits}`,
        `Buffers: Filters ${buffers.filter || 0}, Medkits ${buffers.medkit || 0}, Parts ${buffers.droneParts || 0}, Rations ${buffers.rations || 0}`
      ];

      const toggle = (k) => {
        state.crewAI[k] = !state.crewAI[k];
        markDirty();
        openCrewCommandPanel();
      };

      const bump = (k, delta) => {
        const v = Math.max(0, Math.floor(safeNumber(buffers[k], 0)) + delta);
        buffers[k] = v;
        state.crewAI.buffers = buffers;
        markDirty();
        openCrewCommandPanel();
      };

      openPanel('CREW COMMAND', lines.join('\n'), [
        { label: state.crewAI.enabled ? 'Disable Automation' : 'Enable Automation', action: () => toggle('enabled') },
        { label: `Auto Repair: ${state.crewAI.autoRepair ? 'ON' : 'OFF'}`, action: () => toggle('autoRepair') },
        { label: `Auto Life Support: ${state.crewAI.autoLife ? 'ON' : 'OFF'}`, action: () => toggle('autoLife') },
        { label: `Auto Hydroponics: ${state.crewAI.autoHydro ? 'ON' : 'OFF'}`, action: () => toggle('autoHydro') },
        { label: `Auto Fabricate: ${state.crewAI.autoFabricate ? 'ON' : 'OFF'}`, action: () => toggle('autoFabricate') },
        { label: `Auto Refine: ${state.crewAI.autoRefine ? 'ON' : 'OFF'}`, action: () => toggle('autoRefine') },
        { label: `Auto Contracts: ${state.crewAI.autoContracts ? 'ON' : 'OFF'}`, action: () => toggle('autoContracts') },
        { label: `Auto Vent Heat: ${state.crewAI.autoVentHeat ? 'ON' : 'OFF'}`, action: () => toggle('autoVentHeat') },
        { label: `Auto Travel: ${state.crewAI.autoTravel ? 'ON' : 'OFF'}`, action: () => toggle('autoTravel') },
        { label: `Auto Research: ${state.crewAI.autoResearch ? 'ON' : 'OFF'}`, action: () => toggle('autoResearch') },
        { label: `Auto Build: ${state.crewAI.autoBuild ? 'ON' : 'OFF'}`, action: () => toggle('autoBuild') },
        { label: `Auto Hire: ${state.crewAI.autoHire ? 'ON' : 'OFF'}`, action: () => toggle('autoHire') },
        { label: 'Target Crew +1', action: () => { state.crewAI.targetCrew = Math.min(MAX_CREW, state.crewAI.targetCrew + 1); markDirty(); openCrewCommandPanel(); } },
        { label: 'Target Crew -1', action: () => { state.crewAI.targetCrew = Math.max(0, state.crewAI.targetCrew - 1); markDirty(); openCrewCommandPanel(); } },
        { label: 'Minimum Credits +10', action: () => { state.crewAI.minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI.minCredits, 0)) + 10); markDirty(); openCrewCommandPanel(); } },
        { label: 'Minimum Credits -10', action: () => { state.crewAI.minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI.minCredits, 0)) - 10); markDirty(); openCrewCommandPanel(); } },
        { label: 'Filters +1', action: () => bump('filter', 1) },
        { label: 'Filters -1', action: () => bump('filter', -1) },
        { label: 'Medkits +1', action: () => bump('medkit', 1) },
        { label: 'Medkits -1', action: () => bump('medkit', -1) },
        { label: 'Drone Parts +1', action: () => bump('droneParts', 1) },
        { label: 'Drone Parts -1', action: () => bump('droneParts', -1) },
        { label: 'Rations +1', action: () => bump('rations', 1) },
        { label: 'Rations -1', action: () => bump('rations', -1) }
      ], { includeCancel: true });
    }

    function incidentLabel(kind) {
      if (kind === 'powerTrip') return 'POWER TRIP';
      if (kind === 'o2Leak') return 'O2 LEAK';
      if (kind === 'fire') return 'FIRE';
      if (kind === 'breach') return 'HULL BREACH';
      return String(kind || '').toUpperCase();
    }

    function anyActiveIncident() {
      const inc = state.incidents || {};
      return !!(inc.powerTrip || inc.o2Leak || inc.fire || inc.breach);
    }

    function resolveIncident(kind) {
      if (!state.incidents || typeof state.incidents !== 'object') return false;
      if (!state.incidents[kind]) return false;
      state.incidents[kind] = false;
      markDirty();
      return true;
    }

    function triggerIncident(kind) {
      if (!state.incidents || typeof state.incidents !== 'object') state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
      if (state.incidents[kind]) return false;
      state.incidents[kind] = true;
      queueNotification('ALERT', incidentLabel(kind));
      markDirty();
      return true;
    }

    function renderPanelButtons(buttonsEl, buttons) {
      buttonsEl.innerHTML = '';
      for (const b of (buttons || [])) {
        const btn = document.createElement('button');
        btn.className = `panel-btn${b.danger ? ' danger' : ''}`;
        btn.textContent = b.label;
        btn.addEventListener('click', () => {
          if (typeof b.action === 'function') b.action();
        });
        buttonsEl.appendChild(btn);
      }
    }

    function showPanel({
      title,
      description,
      buttons = [],
      includeCancel = true,
      cancelLabel = 'Close',
      allowImmediate = false,
      textarea = null,
      input = null
    }) {
      const panel = document.getElementById('interactPanel');
      const titleEl = document.getElementById('panelTitle');
      const descEl = document.getElementById('panelDescription');
      const textareaEl = document.getElementById('panelTextarea');
      const inputEl = document.getElementById('panelInput');
      const buttonsEl = document.getElementById('panelButtons');

      titleEl.textContent = title;
      descEl.textContent = description;

      if (textareaEl) {
        if (textarea) {
          textareaEl.style.display = 'block';
          textareaEl.value = textarea.value || '';
          textareaEl.placeholder = textarea.placeholder || '';
          textareaEl.readOnly = !!textarea.readOnly;
        } else {
          textareaEl.style.display = 'none';
        }
      }

      if (inputEl) {
        if (input) {
          inputEl.style.display = 'block';
          inputEl.value = input.value || '';
          inputEl.placeholder = input.placeholder || '';
          inputEl.readOnly = !!input.readOnly;
        } else {
          inputEl.style.display = 'none';
        }
      }

      renderPanelButtons(buttonsEl, buttons);

      if (includeCancel) {
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'panel-btn';
        cancelBtn.textContent = cancelLabel;
        cancelBtn.addEventListener('click', closePanel);
        buttonsEl.appendChild(cancelBtn);
      }

      panel.style.display = 'block';
      state.ui.panelOpen = true;
      state.ui.justOpenedPanel = !allowImmediate;

      const focusTarget = input ? inputEl : (textarea ? textareaEl : buttonsEl.querySelector('button'));
      if (focusTarget) {
        setTimeout(() => {
          focusTarget.focus();
          if (textarea || input) focusTarget.select();
        }, 0);
      }
    }

    function openPanel(title, description, buttons, { includeCancel = true, allowImmediate = false, cancelLabel = 'Close' } = {}) {
      showPanel({
        title,
        description,
        buttons,
        includeCancel,
        cancelLabel,
        allowImmediate
      });
    }

    function openTextPanel(title, description, value, {
      readOnly = false,
      placeholder = '',
      buttons = [],
      includeCancel = true,
      cancelLabel = 'Close',
      singleLine = false
    } = {}) {
      showPanel({
        title,
        description,
        buttons,
        includeCancel,
        cancelLabel,
        allowImmediate: false,
        textarea: singleLine ? null : {
          value,
          readOnly,
          placeholder
        },
        input: singleLine ? {
          value,
          readOnly,
          placeholder
        } : null
      });
    }

    function openRenameModulePanel() {
      const moduleEntry = findCurrentModuleAtPlayer();
      if (!moduleEntry || !moduleEntry.moduleRef) {
        showMessage('RENAME MODULE', 'No module here to rename.');
        return;
      }

      const moduleRef = moduleEntry.moduleRef;
      const def = MODULE_DEFS[moduleRef.type] || {};
      const baseLabel = moduleRef.label || def.label || moduleRef.type;
      const currentLabel = moduleRef.customLabel || baseLabel;

      openTextPanel(
        'RENAME MODULE',
        `Current: ${currentLabel}\nDefault: ${baseLabel}`,
        currentLabel,
        {
          placeholder: 'Enter a new module name',
          singleLine: true,
          includeCancel: false,
          buttons: [
            {
              label: 'Save',
              action: () => {
                const inputEl = document.getElementById('panelInput');
                const raw = inputEl ? inputEl.value : '';
                const next = String(raw || '').trim();
                moduleRef.customLabel = next.length ? next : null;
                moduleRef.autoLabel = false;
                markDirty();
                relayoutCorridor();
                closePanel();
              }
            },
            {
              label: 'Reset',
              action: () => {
                moduleRef.customLabel = null;
                moduleRef.autoLabel = false;
                markDirty();
                relayoutCorridor();
                closePanel();
              }
            },
            { label: 'Cancel', action: closePanel }
          ]
        }
      );
    }

    async function copyToClipboard(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch {}

      try {
        const textareaEl = document.getElementById('panelTextarea');
        textareaEl.focus();
        textareaEl.select();
        return document.execCommand('copy');
      } catch {
        return false;
      }
    }

    function closePanel() {
      const panel = document.getElementById('interactPanel');
      panel.style.display = 'none';
      state.ui.panelOpen = false;
      state.ui.justOpenedPanel = false;
    }

    function showMessage(title, text) {
      openPanel(title, text, [], { includeCancel: true });
    }

    function openGameMenu() {
      openPanel(
        'GAME MENU',
        'Manage your save data:',
        [
          {
            label: 'New Game',
            danger: true,
            action: () => {
              openPanel(
                'NEW GAME',
                'Start a new game? This will clear the current save.',
                [
                  { label: 'Start New Game', danger: true, action: newGame },
                  { label: 'Back', action: openGameMenu }
                ],
                { includeCancel: false }
              );
            }
          },
          { label: 'Export JSON', action: openExportPanel },
          { label: 'Import JSON', action: openImportPanel },
          { label: 'Exit Game', danger: true, action: () => { window.location.href = 'index.html'; } }
        ],
        { includeCancel: true }
      );
    }

    function newGame() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch {}

      SHIP_LAYOUT = {
        levels: {
          1: {
            name: 'DECK 1',
            corridors: {
              A: {
                name: 'Main Corridor',
                modules: [
                  { type: 'fabricator', label: 'Fabricator', uid: newUid() },
                  { type: 'sensors', label: 'Sensors', uid: newUid() }
                ],
                connections: {}
              }
            }
          }
        }
      };

      state.currentLevel = 1;
      state.currentCorridor = 'A';
      state.player.x = 400;
      state.player.vx = 0;
      state.player.facing = 1;
      state.power = 100;
      state.oxygen = 100;
      state.hull = 100;
      state.hullMax = 100;
      state.heat = 0;
      state.food = 100;
      state.morale = 100;
      state.credits = 0;
      state.reputation = 0;
      state.engineActive = false;
      state.throttle = 0;
      state.speed = 0;
      state.location = { system: 'SOL' };
      state.travel = { active: false, from: 'SOL', to: null, remaining: 0, total: 0 };
      state.powerProfile = 'balanced';
      state.blueprints = { modules: {}, recipes: {} };
      state.anomalies = [];
      state.aiBlockers = {};
      state.inventory = { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 };
      state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
      state.contract = { available: [], active: null };
      state.notifications = [];
      state.lightsOn = true;
      state.lifeSupportOn = true;
      state.hydroponicsOn = false;
      state.shieldsOn = false;
      state.crewAI = { enabled: true, autoRepair: true, autoLife: true, autoHydro: true, autoRefine: true, autoFabricate: true, autoContracts: true, autoVentHeat: true, autoTravel: true, autoResearch: true, autoBuild: true, autoHire: false, minCredits: 0, targetCrew: 3, buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 2 } };
      state.meta = { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 };
      state.anim.walkPhase = 0;
      state.pendingSpawn = null;

      state.npcs = [createNPC('CREW', 'crew', state.currentLevel, state.currentCorridor)];
      state.meta.autoAt = 2;
      state.sim.snap = true;
      ensureBlueprints();
      ensureContracts();
      markDirty();
      relayoutCorridor();
      updateHUD();
      saveGame();

      showMessage('NEW GAME', 'New game started.');
    }

    function openExportPanel() {
      const json = JSON.stringify(getSaveData(), null, 2);
      openTextPanel(
        'EXPORT JSON',
        'Copy this JSON to back up your save:',
        json,
        {
          readOnly: true,
          buttons: [
            {
              label: 'Copy',
              action: async () => {
                const ok = await copyToClipboard(json);
                showMessage('EXPORT JSON', ok ? 'Copied to clipboard.' : 'Copy failed. You can still select and copy manually.');
              }
            }
          ],
          includeCancel: true,
          cancelLabel: 'Close'
        }
      );
    }

    function openImportPanel() {
      openTextPanel(
        'IMPORT JSON',
        'Paste a previously exported JSON save, then tap Import:',
        '',
        {
          readOnly: false,
          placeholder: '{ "v": 2, ... }',
          buttons: [
            {
              label: 'Import',
              danger: true,
              action: () => {
                const raw = document.getElementById('panelTextarea').value;
                importFromJSON(raw);
              }
            }
          ],
          includeCancel: true,
          cancelLabel: 'Cancel'
        }
      );
    }

    function importFromJSON(raw) {
      let loaded;
      try {
        loaded = JSON.parse(raw);
      } catch {
        showMessage('IMPORT JSON', 'Invalid JSON.');
        return;
      }

      if (!loaded || loaded.v !== 2) {
        showMessage('IMPORT JSON', 'Unsupported save format. Please import a JSON exported from this game.');
        return;
      }

      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(loaded));
      } catch {
        showMessage('IMPORT JSON', 'Failed to store the save (storage unavailable).');
        return;
      }

      loadGame();
      relayoutCorridor();
      updateHUD();
      saveGame();

      showMessage('IMPORT JSON', 'Save imported.');
    }

    function updateHUD() {
      const setVal = (id, text) => {
        const el = document.getElementById(id);
        if (el) el.textContent = text;
      };

      setVal('levelText', 'L' + state.currentLevel);
      setVal('corridorText', state.currentCorridor);
      setVal('powerLevel', Math.round(state.power) + '%');
      setVal('oxygenLevel', Math.round(state.oxygen) + '%');
      setVal('hullLevel', Math.round((state.hull / Math.max(1, state.hullMax)) * 100) + '%');
      setVal('heatLevel', Math.round(state.heat) + '%');
      setVal('foodLevel', String(invGet('rations')));
      setVal('moraleLevel', Math.round(state.morale) + '%');
      setVal('creditsLevel', Math.floor(state.credits).toLocaleString());
      setVal('repLevel', Math.floor(state.reputation).toLocaleString());
      setVal('speedLevel', Math.round(state.speed) + ' km/s');
      setVal('crewText', state.npcs.length + 1);
      if (typeof updateViewportLayout === 'function') updateViewportLayout();
    }

    function updateLocationHUD() {
      const corridorDef = getCorridorDef(state.currentLevel, state.currentCorridor);
      if (corridorDef) {
        const label = document.getElementById('levelText');
        if (label) label.textContent = formatLevelLabel(state.currentLevel);
        const corrLabel = document.getElementById('corridorText');
        if (corrLabel) corrLabel.textContent = state.currentCorridor;
      }
    }

    function markDirty() {
      state.sim.dirty = true;
    }

    // ============================================================================
    // Save/Load
    // ============================================================================

    const STORAGE_KEY = 'idlegames-space-explorer-v2';

    function getSaveData() {
      return {
        v: 2,
        shipLayout: SHIP_LAYOUT,
        level: state.currentLevel,
        corridor: state.currentCorridor,
        playerX: state.player.x,
        power: state.power,
        oxygen: state.oxygen,
        hull: state.hull,
        hullMax: state.hullMax,
        heat: state.heat,
        food: state.food,
        morale: state.morale,
        credits: state.credits,
        reputation: state.reputation,
        engineActive: state.engineActive,
        throttle: state.throttle,
        speed: state.speed,
        location: state.location,
        travel: state.travel,
        powerProfile: state.powerProfile,
        blueprints: state.blueprints,
        anomalies: state.anomalies,
        aiBlockers: state.aiBlockers,
        inventory: state.inventory,
        incidents: state.incidents,
        contract: state.contract,
        notifications: state.notifications,
        lightsOn: state.lightsOn,
        lifeSupportOn: state.lifeSupportOn,
        hydroponicsOn: state.hydroponicsOn,
        shieldsOn: state.shieldsOn,
        crewAI: state.crewAI,
        npcs: state.npcs.map(n => ({
          id: n.id,
          name: n.name,
          role: n.role,
          level: n.level,
          corridor: n.corridor,
          x: n.x,
          onDuty: n.onDuty,
          hunger: n.hunger,
          walkPhase: n.walkPhase || 0,
          destinationType: n.destinationType || null,
          destinationCorridorKey: n.destinationCorridorKey || null
        }))
      };
    }

    function saveGame() {
      const data = getSaveData();
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch {}
      state.sim.dirty = false;
    }

    function loadGame() {
      try {
        const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
        if (data.shipLayout && data.shipLayout.levels) SHIP_LAYOUT = data.shipLayout;
        if (data.level) state.currentLevel = data.level;
        if (data.corridor) state.currentCorridor = data.corridor;
        if (data.playerX) state.player.x = data.playerX;
        if (data.power) state.power = data.power;
        if (data.oxygen) state.oxygen = data.oxygen;
        if (data.hull) state.hull = data.hull;
        if (data.hullMax) state.hullMax = data.hullMax;
        if (data.heat !== undefined) state.heat = data.heat;
        if (data.food !== undefined) state.food = data.food;
        if (data.morale !== undefined) state.morale = data.morale;
        if (data.credits !== undefined) state.credits = data.credits;
        if (data.reputation !== undefined) state.reputation = data.reputation;
        if (data.engineActive !== undefined) state.engineActive = data.engineActive;
        if (data.throttle !== undefined) state.throttle = data.throttle;
        if (data.speed !== undefined) state.speed = data.speed;
        if (data.location) state.location = data.location;
        if (data.travel) state.travel = data.travel;
        if (data.powerProfile) state.powerProfile = data.powerProfile;
        if (state.powerProfile === 'life') state.powerProfile = 'survival';
        if (state.powerProfile === 'engine') state.powerProfile = 'combat';
        if (state.powerProfile === 'shields') state.powerProfile = 'combat';
        if (data.blueprints) state.blueprints = data.blueprints;
        if (data.anomalies) state.anomalies = data.anomalies;
        if (data.aiBlockers) state.aiBlockers = data.aiBlockers;
        if (data.inventory) state.inventory = data.inventory;
        if (data.incidents) state.incidents = data.incidents;
        if (data.contract) state.contract = data.contract;
        if (data.notifications) state.notifications = data.notifications;
        if (data.lightsOn !== undefined) state.lightsOn = data.lightsOn;
        if (data.lifeSupportOn !== undefined) state.lifeSupportOn = data.lifeSupportOn;
        if (data.hydroponicsOn !== undefined) state.hydroponicsOn = data.hydroponicsOn;
        if (data.shieldsOn !== undefined) state.shieldsOn = data.shieldsOn;
        if (data.crewAI) state.crewAI = data.crewAI;
        if (Array.isArray(data.npcs)) {
          state.npcs = data.npcs.map(n => ({
            id: n.id || 'npc-' + Math.random().toString(36).slice(2),
            name: n.name || 'CREW',
            role: n.role || inferRoleFromName(n.name || 'CREW'),
            level: n.level || 1,
            corridor: n.corridor || 'A',
            x: n.x || 300,
            y: 490,
            width: 30,
            height: 60,
            speed: 220,
            vx: 0,
            mode: 'idle',
            task: null,
            onDuty: n.onDuty !== undefined ? n.onDuty : true,
            paused: false,
            thinkTimer: 0,
            wanderTarget: null,
            walkPhase: n.walkPhase || 0,
            hunger: Number.isFinite(n.hunger) ? n.hunger : 0,
            destinationType: n.destinationType || null,
            destinationCorridorKey: n.destinationCorridorKey || null,
            log: []
          }));
        }
        if (!state.inventory || typeof state.inventory !== 'object') state.inventory = { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 };
        if (!state.travel || typeof state.travel !== 'object') state.travel = { active: false, from: currentSystem(), to: null, remaining: 0, total: 0 };
        if (!state.incidents || typeof state.incidents !== 'object') state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
        if (!state.contract || typeof state.contract !== 'object') state.contract = { available: [], active: null };
        if (!state.notifications || !Array.isArray(state.notifications)) state.notifications = [];
        if (!state.aiBlockers || typeof state.aiBlockers !== 'object') state.aiBlockers = {};
        if (!state.meta || typeof state.meta !== 'object') state.meta = { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 };
        ensureCrewAI();
        ensureBlueprints();
      } catch {}
    }

    // ============================================================================
    // Initialization
    // ============================================================================

    // ============================================================================
    // NPC System & Roles
    // ============================================================================

    const MAX_CREW = 50;
    const ROLES = ['pilot', 'engineer', 'tech', 'medic', 'quartermaster', 'specialist', 'scientist', 'security', 'crew'];

    function npcRole(npc) {
      if (!npc) return 'crew';
      if (npc.role) return npc.role;
      return inferRoleFromName(npc.name || 'CREW');
    }

    function inferRoleFromName(name) {
      const s = String(name || '').toUpperCase();
      if (s.includes('PILOT')) return 'pilot';
      if (s.includes('MEDIC')) return 'medic';
      if (s.includes('TECH')) return 'tech';
      if (s.includes('SPECIAL')) return 'specialist';
      if (s.includes('ENGINEER')) return 'engineer';
      if (s.includes('QUARTER')) return 'quartermaster';
      if (s.includes('SCIENT')) return 'scientist';
      if (s.includes('SECUR')) return 'security';
      return 'crew';
    }

    function addCrewMember(name = 'CREW') {
      const nm = String(name || 'CREW').toUpperCase();
      const role = inferRoleFromName(nm);
      const npc = createNPC(nm, role, state.currentLevel, state.currentCorridor);
      const x = clamp(state.player.x + 60, state.walkBounds.minX, state.walkBounds.maxX);
      npc.x = x;
      state.npcs.push(npc);
      markDirty();
      return npc;
    }

    function removeCrewMemberById(id) {
      const before = state.npcs.length;
      state.npcs = state.npcs.filter((n) => n && n.id !== id);
      if (state.npcs.length !== before) markDirty();
      return state.npcs.length !== before;
    }

    function createNPC(name, role = 'crew', level = 1, corridor = 'A') {
      return {
        id: 'npc-' + Math.random().toString(36).slice(2),
        name,
        level,
        corridor,
        x: 300 + Math.random() * 100,
        y: 490,
        width: 30,
        height: 60,
        speed: 220,
        vx: 0,
        role,
        mode: 'idle',  // idle | task | travel
        task: null,
        onDuty: true,
        paused: false,
        thinkTimer: 0,
        wanderTarget: null,
        walkPhase: 0,
        hunger: 0,
        destinationType: null,
        destinationCorridorKey: null,
        log: []
      };
    }

    function npcHasRole(npc, required) {
      if (!required || !Array.isArray(required)) return true;
      return required.includes(npcRole(npc));
    }

    function hasCrewRole(role) {
      if (!Array.isArray(state.npcs)) return false;
      return state.npcs.some((n) => n && n.onDuty && !n.paused && npcRole(n) === role);
    }

    function anyOnDutyCrew() {
      if (!Array.isArray(state.npcs)) return false;
      return state.npcs.some((n) => n && n.onDuty && !n.paused);
    }

    function countHungryCrew() {
      if (!Array.isArray(state.npcs)) return 0;
      return state.npcs.filter((n) => n && Number.isFinite(n.hunger) && n.hunger >= 1).length;
    }

    function findNearestHungryCrew() {
      if (!Array.isArray(state.npcs)) return null;
      let best = null;
      let bestD = Infinity;
      for (const n of state.npcs) {
        if (!n || !Number.isFinite(n.hunger) || n.hunger < 1) continue;
        const d = Math.abs(n.x - state.player.x);
        if (d < bestD) {
          bestD = d;
          best = n;
        }
      }
      return best;
    }

    function feedNpc(npc) {
      if (!npc) return false;
      if (!invHas('rations', 1)) return false;
      invTake('rations', 1);
      npc.hunger = Math.max(0, safeNumber(npc.hunger, 0) - 1);
      markDirty();
      return true;
    }

    function stationCenterInCorridor(level, corridor, type) {
      const moduleRef = findModuleByType(level, corridor, type);
      if (!moduleRef) return null;
      return moduleCenterInCorridor(level, corridor, moduleRef);
    }

    function assignNpcTask(npc, { key, label, targetType, duration = 1.5, onComplete }) {
      if (!npc || !targetType) return false;
      npc.task = { key, label, targetType, duration, progress: 0, onComplete };
      npc.destinationType = targetType;
      npc.destinationCorridorKey = null;
      npc.mode = 'travel';
      return true;
    }

    function updateNpcTasking(npc, dt) {
      if (!npc || !npc.task) return false;
      const task = npc.task;
      const targetType = task.targetType;
      if (!targetType) {
        npc.task = null;
        return false;
      }

      if (!corridorsWithModuleType(targetType).length) {
        npc.task = null;
        npc.destinationType = null;
        npc.destinationCorridorKey = null;
        npc.mode = 'idle';
        return false;
      }

      // Ensure destination is set for navigation.
      if (!npc.destinationType) npc.destinationType = targetType;

      // If NPC is in the target corridor, move to station center.
      const center = stationCenterInCorridor(npc.level, npc.corridor, targetType);
      if (center !== null) {
        npc.wanderTarget = center;
        const dist = center - npc.x;
        if (Math.abs(dist) > 8) {
          npc.vx = Math.sign(dist) * npc.speed * 0.5;
        } else {
          npc.vx = 0;
          npc.task.progress += dt;
          if (npc.task.progress >= task.duration) {
            if (typeof task.onComplete === 'function') task.onComplete(npc);
            npc.task = null;
            npc.mode = 'idle';
            npc.destinationType = null;
            npc.destinationCorridorKey = null;
            npc.wanderTarget = null;
            return true;
          }
        }
      }
      return true;
    }

    function crewAutomationTick(dt) {
      if (!anyOnDutyCrew()) return;
      ensureCrewAI();
      if (!state.crewAI || !state.crewAI.enabled) return;
      state.meta.autoAt += dt;
      if (state.meta.autoAt < 2) return;
      state.meta.autoAt = 0;

      ensureContracts();

      const idle = state.npcs.filter((n) => n && n.onDuty && !n.paused && !n.task);
      if (!idle.length) return;
      const hasModule = (type) => corridorsWithModuleType(type).length > 0;
      const needs = activeContractNeeds();
      const buffers = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : {};
      const wantsIngots = (needs && needs.ingot > 0)
        || (state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating && state.hullMax < 150 && invGet('ingot') < 2)
        || invGet('ingot') < invReserve('ingot');
      const wantsFilters = (needs && needs.filter > 0) || invGet('filter') < invReserve('filter');
      const wantsMedkits = (needs && needs.medkit > 0) || invGet('medkit') < invReserve('medkit');
      const wantsDroneParts = (needs && needs.droneParts > 0) || invGet('droneParts') < invReserve('droneParts');
      const wantsRations = invGet('rations') < invReserve('rations');
      const minCredits = Math.max(0, Math.floor(safeNumber(state.crewAI && state.crewAI.minCredits, 0)));
      const wantsCredits = state.credits < minCredits;
      const needsScrapForCraft = (wantsFilters && invGet('scrap') < (ITEM_RECIPES.filter ? ITEM_RECIPES.filter.scrap : 0))
        || (wantsMedkits && invGet('scrap') < (ITEM_RECIPES.medkit ? ITEM_RECIPES.medkit.scrap : 0))
        || (wantsDroneParts && invGet('scrap') < (ITEM_RECIPES.droneParts ? ITEM_RECIPES.droneParts.scrap : 0))
        || (wantsRations && invGet('scrap') < (ITEM_RECIPES.rations ? ITEM_RECIPES.rations.scrap : 0));
      const needsIngotsForCraft = wantsDroneParts && invGet('ingot') < (ITEM_RECIPES.droneParts ? ITEM_RECIPES.droneParts.ingot : 0);
      const wantsScrap = (needs && needs.scrap > 0) || needsScrapForCraft || invGet('scrap') < invReserve('scrap');
      const wantsOre = (needs && needs.ore > 0) || (wantsIngots && invGet('ore') < 3) || (needsIngotsForCraft && invGet('ore') < 3) || invGet('ore') < invReserve('ore');
      const canCraftItem = (itemKey) => {
        const recipe = ITEM_RECIPES[itemKey];
        if (!recipe) return false;
        for (const [k, v] of Object.entries(recipe)) {
          if (!canSpendReserved(k, v)) return false;
        }
        return true;
      };

      const criticalModules = [];
      if (state.crewAI.autoBuild) {
        if (!hasModule('fabricator')) {
          if (ensureModuleBuiltIfUnlocked('fabricator', 'AUTOMATION')) return;
        }
        if (state.power < 35 && !hasModule('power')) criticalModules.push('power');
        if (state.oxygen < 50 && !hasModule('life')) criticalModules.push('life');
        if (invGet('rations') < invReserve('rations') && !hasModule('hydro')) criticalModules.push('hydro');
        if (countHungryCrew() > 0 && !hasModule('canteen')) criticalModules.push('canteen');
        if (state.morale < 45 && !hasModule('medbay')) criticalModules.push('medbay');
      }

      const pilotCritical = () => {
        if (anyActiveIncident()) return true;
        if (state.oxygen < 35) return true;
        if (countHungryCrew() > 0 || invGet('rations') <= 1) return true;
        if (state.power < 30) return true;
        if (state.heat > 80) return true;
        if (state.hull < state.hullMax * 0.5) return true;
        return false;
      };

      const roleNeeds = [];
      const addRole = (role) => { if (!roleNeeds.includes(role)) roleNeeds.push(role); };
      if (state.incidents.fire || state.incidents.breach || state.incidents.powerTrip || state.incidents.o2Leak || state.heat > 75) {
        addRole('engineer');
        addRole('tech');
        addRole('specialist');
      }
      if (state.oxygen < 70) {
        addRole('tech');
        addRole('engineer');
      }
      if (countHungryCrew() > 0 || wantsRations) {
        addRole('specialist');
        addRole('engineer');
        addRole('tech');
      }
      if (wantsScrap || wantsOre || wantsIngots) {
        addRole('scientist');
        addRole('tech');
        addRole('specialist');
        addRole('pilot');
      }
      if (wantsFilters || wantsMedkits || wantsDroneParts || wantsRations) {
        addRole('quartermaster');
        addRole('engineer');
        addRole('tech');
      }
      if (wantsCredits) {
        addRole('quartermaster');
        addRole('pilot');
      }
      if (state.crewAI.autoHire) addRole('quartermaster');
      if (state.crewAI.autoContracts || state.crewAI.autoTravel) addRole('pilot');

      let npc = idle.find((n) => roleNeeds.includes(npcRole(n))) || idle[0];
      if (pilotCritical()) {
        const nonPilot = idle.find((n) => npcRole(n) !== 'pilot');
        if (nonPilot) npc = nonPilot;
      }

      const canRole = (roles) => {
        if (npcHasRole(npc, roles)) return true;
        const required = Array.isArray(roles) ? roles : [roles];
        const anyAvailable = required.some((role) => hasCrewRole(role));
        return !anyAvailable;
      };
      const hasActiveTaskTarget = (type) => {
        if (!type || !Array.isArray(state.npcs)) return false;
        return state.npcs.some((n) => n && n.task && n.task.targetType === type);
      };
      const assignMaterialTask = (material) => {
        if (!material) return false;
        if (canRole(['scientist', 'tech']) && hasModule('sensors')) {
          assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
          return true;
        }
        if (canRole(['specialist', 'pilot']) && hasModule('drones') && invHas('droneParts', 1)) {
          assignNpcTask(npc, { key: 'drones.salvage', label: 'Launch Salvage Drone', targetType: 'drones', onComplete: () => launchSalvageDrone(false) });
          return true;
        }
        return false;
      };
      const assignSupplyTaskFor = (itemKey, visited = new Set()) => {
        if (!itemKey) return false;
        if (resolveDeclarativeDemand(npc, itemKey, visited)) return true;
        if (visited.has(itemKey)) return false;
        visited.add(itemKey);

        if (itemKey === 'scrap' || itemKey === 'ore') {
          return assignMaterialTask(itemKey);
        }

        if (itemKey === 'ingot') {
          const oreNeed = Math.max(0, 3 - invGet('ore'));
          if (oreNeed > 0) {
            return assignSupplyTaskFor('ore', visited);
          }
          if (state.crewAI.autoRefine && canRole(['engineer', 'tech']) && hasModule('refinery')) {
            assignNpcTask(npc, { key: 'refinery.refine', label: 'Refine Ore', targetType: 'refinery', onComplete: () => refineOre(false) });
            return true;
          }
          return false;
        }

        if (itemKey === 'rations') {
          if (state.crewAI.autoHydro && hasModule('hydro')) {
            if (hasActiveTaskTarget('hydro') && countHungryCrew() <= 1) return false;
            if (!state.hydroponicsOn) {
              assignNpcTask(npc, { key: 'hydro.toggle', label: 'Enable Grow Lights', targetType: 'hydro', onComplete: () => toggleHydroponics() });
              return true;
            }
            if (state.power >= 4) {
              assignNpcTask(npc, { key: 'hydro.harvest', label: 'Harvest Crops', targetType: 'hydro', onComplete: () => harvestHydroponics(false) });
              return true;
            }
          }
        }

        if (itemKey === 'filter' || itemKey === 'medkit' || itemKey === 'droneParts' || itemKey === 'rations') {
          const prices = { filter: 10, medkit: 25, droneParts: 20, rations: 8 };
          const recipe = ITEM_RECIPES[itemKey];
          if (recipe) {
            const missing = [];
            for (const [mat, qty] of Object.entries(recipe)) {
              if (invAvailableAfterReserve(mat) < qty) missing.push({ mat, qty });
            }
            if (missing.length) {
              const priority = itemKey === 'droneParts'
                ? ['ingot', 'scrap']
                : ['scrap', 'ingot'];
              missing.sort((a, b) => priority.indexOf(a.mat) - priority.indexOf(b.mat));
              for (const miss of missing) {
                if (assignSupplyTaskFor(miss.mat, visited)) return true;
              }
              return false;
            }
          }

          if (canRole(['quartermaster']) && hasModule('cargo') && state.credits >= prices[itemKey]) {
            const buyKey = `cargo.buy.${itemKey}`;
            assignNpcTask(npc, { key: buyKey, label: `Buy ${itemKey}`, targetType: 'cargo', onComplete: () => buyCargoItem(itemKey, prices[itemKey]) });
            return true;
          }
          if (state.crewAI.autoFabricate && hasModule('fabricator') && canCraftItem(itemKey)) {
            assignNpcTask(npc, { key: 'fabricator.build', label: `Fabricate ${itemKey}`, targetType: 'fabricator', onComplete: () => craftItem(itemKey, 1, { respectReserve: true }) });
            return true;
          }
        }

        reportAiBlocker(`Supply chain missing: ${itemKey}`);
        return false;
      };

      const resolveContractDependencies = () => {
        if (!needs || !Object.keys(needs).length) return false;
        const demandOrder = [];
        const needKeys = Object.keys(needs);
        const enqueue = (key) => { if (!demandOrder.includes(key)) demandOrder.push(key); };
        ['droneParts', 'filter', 'medkit', 'rations', 'ingot', 'scrap', 'ore'].forEach((k) => {
          if (needKeys.includes(k)) enqueue(k);
        });
        for (const key of demandOrder) {
          if (assignSupplyTaskFor(key)) return true;
        }
        return false;
      };

      if (canRole(['quartermaster']) && hasModule('cargo')) {
        if (needs && needs.filter > 0 && state.credits >= 10) {
          assignNpcTask(npc, { key: 'cargo.buy.filter', label: 'Buy Filter', targetType: 'cargo', onComplete: () => buyCargoItem('filter', 10) });
          return;
        }
        if (needs && needs.medkit > 0 && state.credits >= 25) {
          assignNpcTask(npc, { key: 'cargo.buy.medkit', label: 'Buy Medkit', targetType: 'cargo', onComplete: () => buyCargoItem('medkit', 25) });
          return;
        }
        if (needs && needs.droneParts > 0 && state.credits >= 20) {
          assignNpcTask(npc, { key: 'cargo.buy.droneParts', label: 'Buy Drone Parts', targetType: 'cargo', onComplete: () => buyCargoItem('droneParts', 20) });
          return;
        }
        if (needs && needs.rations > 0 && state.credits >= 8) {
          assignNpcTask(npc, { key: 'cargo.buy.rations', label: 'Buy Rations', targetType: 'cargo', onComplete: () => buyCargoItem('rations', 8) });
          return;
        }

        if (invGet('filter') < invReserve('filter') && state.credits >= 10) {
          assignNpcTask(npc, { key: 'cargo.buy.filter', label: 'Buy Filter', targetType: 'cargo', onComplete: () => buyCargoItem('filter', 10) });
          return;
        }
        if (invGet('medkit') < invReserve('medkit') && state.credits >= 25) {
          assignNpcTask(npc, { key: 'cargo.buy.medkit', label: 'Buy Medkit', targetType: 'cargo', onComplete: () => buyCargoItem('medkit', 25) });
          return;
        }
        if (invGet('droneParts') < invReserve('droneParts') && state.credits >= 20) {
          assignNpcTask(npc, { key: 'cargo.buy.droneParts', label: 'Buy Drone Parts', targetType: 'cargo', onComplete: () => buyCargoItem('droneParts', 20) });
          return;
        }
        if (invGet('rations') < invReserve('rations') && state.credits >= 8) {
          assignNpcTask(npc, { key: 'cargo.buy.rations', label: 'Buy Rations', targetType: 'cargo', onComplete: () => buyCargoItem('rations', 8) });
          return;
        }

        const hireFee = 30;
        const wantsHireCredits = !!state.crewAI.autoHire && state.credits < hireFee;
        const wantsPurchaseCredits = !!(
          (((needs && needs.filter > 0) || invGet('filter') < invReserve('filter')) && state.credits < 10)
          || (((needs && needs.medkit > 0) || invGet('medkit') < invReserve('medkit')) && state.credits < 25)
          || (((needs && needs.droneParts > 0) || invGet('droneParts') < invReserve('droneParts')) && state.credits < 20)
          || (((needs && needs.rations > 0) || invGet('rations') < invReserve('rations')) && state.credits < 8)
        );
        if (wantsHireCredits && state.crewAI.autoContracts && !pilotCritical() && canRole(['pilot', 'quartermaster']) && hasModule('cockpit')) {
          if (resolveContractDependencies()) return;
          assignNpcTask(npc, { key: 'cockpit.comms', label: 'Contracts', targetType: 'cockpit', onComplete: () => autoManageContracts() });
          return;
        }
        if (wantsHireCredits || wantsPurchaseCredits) {
          const oreKeep = hasModule('refinery') ? 2 : 0;
          if (canSpendReserved('rations', 1)) {
            assignNpcTask(npc, { key: 'cargo.sell.rations', label: 'Sell Rations', targetType: 'cargo', onComplete: () => sellCargoItem('rations', 4, { respectReserve: true }) });
            return;
          }
          if (canSpendReserved('ingot', 1)) {
            assignNpcTask(npc, { key: 'cargo.sell.ingot', label: 'Sell Ingot', targetType: 'cargo', onComplete: () => sellCargoItem('ingot', 15, { respectReserve: true }) });
            return;
          }
          if (canSpendReserved('scrap', 1)) {
            assignNpcTask(npc, { key: 'cargo.sell.scrap', label: 'Sell Scrap', targetType: 'cargo', onComplete: () => sellCargoItem('scrap', 8, { respectReserve: true }) });
            return;
          }
          if (canSpendReservedWithMinKeep('ore', 1, oreKeep)) {
            assignNpcTask(npc, { key: 'cargo.sell.ore', label: 'Sell Ore', targetType: 'cargo', onComplete: () => sellCargoItem('ore', 5, { respectReserve: true, minKeep: oreKeep }) });
            return;
          }
        }
      }

      if (state.incidents.fire && state.crewAI.autoRepair && canRole(['engineer', 'tech']) && hasModule('engine')) {
        assignNpcTask(npc, { key: 'engine.fire', label: 'Extinguish Fire', targetType: 'engine', onComplete: () => resolveIncident('fire') });
        return;
      }
      if (state.heat > 75 && state.crewAI.autoVentHeat && canRole(['engineer', 'tech']) && hasModule('engine')) {
        assignNpcTask(npc, { key: 'engine.vent', label: 'Vent Heat', targetType: 'engine', onComplete: () => {
          state.power = Math.max(0, state.power - 6);
          state.heat = Math.max(0, state.heat - 25);
          resolveIncident('fire');
          markDirty();
        } });
        return;
      }
      if (state.incidents.powerTrip && state.crewAI.autoRepair && hasModule('power')) {
        assignNpcTask(npc, { key: 'power.repair', label: 'Reset Power', targetType: 'power', onComplete: () => resetPowerTrip(false) });
        return;
      }
      if (state.incidents.o2Leak && state.crewAI.autoLife && hasModule('life')) {
        assignNpcTask(npc, { key: 'life.leak', label: 'Seal O2 Leak', targetType: 'life', onComplete: () => resolveIncident('o2Leak') });
        return;
      }
      if (state.incidents.breach && state.crewAI.autoRepair && canRole(['engineer', 'specialist']) && hasModule('airlock')) {
        assignNpcTask(npc, { key: 'airlock.eva', label: 'EVA Repair', targetType: 'airlock', onComplete: () => performEvaRepair(false) });
        return;
      }
      if (state.incidents.breach && state.crewAI.autoRepair && hasModule('shields')) {
        assignNpcTask(npc, { key: 'shields.bulkhead', label: 'Seal Bulkheads', targetType: 'shields', onComplete: () => sealBulkheads(false) });
        return;
      }
      if ((state.incidents.breach || state.incidents.fire) && state.crewAI.autoRepair && canRole(['engineer', 'specialist']) && hasModule('drones') && invHas('droneParts', 1)) {
        assignNpcTask(npc, { key: 'drones.repair', label: 'Launch Repair Drone', targetType: 'drones', onComplete: () => launchRepairDrone(false) });
        return;
      }
      if (state.hull < state.hullMax * 0.85 && state.crewAI.autoRepair && hasModule('workshop') && (invHas('ingot', 1) || invHas('scrap', 2))) {
        assignNpcTask(npc, { key: 'workshop.repair', label: 'Repair Hull', targetType: 'workshop', onComplete: () => repairHull(false) });
        return;
      }
      if (state.hull < state.hullMax * 0.8 && state.crewAI.autoRepair && canRole(['engineer', 'specialist']) && hasModule('drones') && invHas('droneParts', 1)) {
        assignNpcTask(npc, { key: 'drones.repair', label: 'Launch Repair Drone', targetType: 'drones', onComplete: () => launchRepairDrone(false) });
        return;
      }

      if (state.crewAI.autoBuild && criticalModules.length) {
        const nextModule = criticalModules[0];
        if (ensureModuleBuiltIfUnlocked(nextModule, 'AUTOMATION')) return;
      }

      if (state.morale <= 10) {
        if (hasModule('medbay') && (invHas('medkit', 1) || state.power >= 10)) {
          assignNpcTask(npc, { key: 'med.treat', label: 'Treat Crew', targetType: 'medbay', onComplete: () => treatInjury(false) });
          return;
        }
        if (hasModule('canteen') && invHas('rations', 1)) {
          assignNpcTask(npc, { key: 'canteen.eat', label: 'Eat', targetType: 'canteen', onComplete: () => feedNpc(npc) });
          return;
        }
        if (hasModule('quarters') && invHas('rations', 1)) {
          assignNpcTask(npc, { key: 'quarters.rest', label: 'Rest', targetType: 'quarters', onComplete: () => restCrew(false) });
          return;
        }
        if (state.crewAI.autoBuild) {
          if (ensureModuleBuiltIfUnlocked('medbay', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('canteen', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('hydro', 'AUTOMATION')) return;
        }
      }

      if (state.hull <= state.hullMax * 0.2 && state.crewAI.autoRepair) {
        if (hasModule('shields') && state.incidents.breach) {
          assignNpcTask(npc, { key: 'shields.bulkhead', label: 'Seal Bulkheads', targetType: 'shields', onComplete: () => sealBulkheads(false) });
          return;
        }
        if (hasModule('workshop') && (invHas('ingot', 1) || invHas('scrap', 2))) {
          assignNpcTask(npc, { key: 'workshop.repair', label: 'Repair Hull', targetType: 'workshop', onComplete: () => repairHull(false) });
          return;
        }
        if (hasModule('drones') && invHas('droneParts', 1)) {
          assignNpcTask(npc, { key: 'drones.repair', label: 'Launch Repair Drone', targetType: 'drones', onComplete: () => launchRepairDrone(false) });
          return;
        }
        if (hasModule('airlock') && state.oxygen >= 10) {
          assignNpcTask(npc, { key: 'airlock.eva', label: 'EVA Repair', targetType: 'airlock', onComplete: () => performEvaRepair(false) });
          return;
        }
        if (state.crewAI.autoBuild) {
          if (ensureModuleBuiltIfUnlocked('workshop', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('drones', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('airlock', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('shields', 'AUTOMATION')) return;
        }
      }

      if (state.oxygen < 70 && state.crewAI.autoLife && hasModule('life')) {
        assignNpcTask(npc, { key: 'life.emergency', label: 'Emergency Scrubbers', targetType: 'life', onComplete: () => emergencyScrubbers(false) });
        return;
      }
      if (invGet('rations') < invReserve('rations') && state.crewAI.autoHydro && hasModule('hydro')) {
        if (!hasActiveTaskTarget('hydro') || countHungryCrew() > 1) {
        if (!state.hydroponicsOn) {
          assignNpcTask(npc, { key: 'hydro.toggle', label: 'Enable Grow Lights', targetType: 'hydro', onComplete: () => toggleHydroponics() });
          return;
        }
        if (state.power >= 4) {
          assignNpcTask(npc, { key: 'hydro.harvest', label: 'Harvest Crops', targetType: 'hydro', onComplete: () => harvestHydroponics(false) });
          return;
        }
        }
      }
      if (Number.isFinite(npc.hunger) && npc.hunger >= 1 && hasModule('canteen') && invHas('rations', 1)) {
        assignNpcTask(npc, { key: 'canteen.eat', label: 'Eat', targetType: 'canteen', onComplete: () => feedNpc(npc) });
        return;
      }
      if (state.morale <= 30) {
        if (hasModule('medbay') && (invHas('medkit', 1) || state.power >= 10)) {
          assignNpcTask(npc, { key: 'med.treat', label: 'Treat Crew', targetType: 'medbay', onComplete: () => treatInjury(false) });
          return;
        }
        if (hasModule('quarters') && invHas('rations', 1)) {
          assignNpcTask(npc, { key: 'quarters.rest', label: 'Rest', targetType: 'quarters', onComplete: () => restCrew(false) });
          return;
        }
      }
      if (state.crewAI.autoFabricate || state.crewAI.autoRefine || state.crewAI.autoContracts || state.crewAI.autoBuild) {
        const demandOrder = [];
        const needKeys = needs ? Object.keys(needs) : [];
        const enqueue = (key) => { if (!demandOrder.includes(key)) demandOrder.push(key); };
        ['droneParts', 'filter', 'medkit', 'rations', 'ingot', 'scrap', 'ore'].forEach((k) => {
          if (needKeys.includes(k)) enqueue(k);
        });
        if (wantsDroneParts) enqueue('droneParts');
        if (wantsFilters) enqueue('filter');
        if (wantsMedkits) enqueue('medkit');
        if (wantsRations) enqueue('rations');
        if (wantsIngots) enqueue('ingot');
        if (wantsScrap) enqueue('scrap');
        if (wantsOre) enqueue('ore');

        for (const key of demandOrder) {
          if (assignSupplyTaskFor(key)) return;
        }
      }
      if (state.power < 40 && state.crewAI.autoRepair && hasModule('power')) {
        assignNpcTask(npc, { key: 'power.route', label: 'Route Power', targetType: 'power', onComplete: () => autoRoutePower() });
        return;
      }

      if ((invGet('scrap') < invReserve('scrap') || invGet('ore') < invReserve('ore'))
        && canRole(['scientist', 'tech'])
        && hasModule('sensors')) {
        assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
        return;
      }

      if (state.crewAI.autoFabricate && hasModule('fabricator')) {
        const pickRecipe = () => {
          if (needs && needs.filter > 0 && canCraftItem('filter')) return 'filter';
          if (needs && needs.medkit > 0 && canCraftItem('medkit')) return 'medkit';
          if (needs && needs.droneParts > 0 && canCraftItem('droneParts')) return 'droneParts';
          if (wantsFilters && canCraftItem('filter')) return 'filter';
          if (wantsMedkits && canCraftItem('medkit')) return 'medkit';
          if (wantsDroneParts && canCraftItem('droneParts')) return 'droneParts';
          if (wantsRations && canCraftItem('rations')) return 'rations';
          return null;
        };
        const recipe = pickRecipe();
        if (recipe) {
          assignNpcTask(npc, {
            key: 'fabricator.build',
            label: `Fabricate ${recipe}`,
            targetType: 'fabricator',
            onComplete: () => craftItem(recipe, 1, { respectReserve: true })
          });
          return;
        }
        if (invGet('filter') < (buffers.filter || 0) || invGet('medkit') < (buffers.medkit || 0) || invGet('droneParts') < (buffers.droneParts || 0) || invGet('rations') < (buffers.rations || 0)) {
          const canMakeAny = ['filter', 'medkit', 'droneParts', 'rations'].some((key) => canCraftItem(key));
          if (canMakeAny) {
            assignNpcTask(npc, { key: 'fabricator.build', label: 'Fabricate Consumables', targetType: 'fabricator', onComplete: () => autoFabricateConsumables() });
            return;
          }
        }
      }
      if (state.crewAI.autoRefine && wantsIngots && invGet('ore') >= 3 && canRole(['engineer', 'tech']) && hasModule('refinery')) {
        assignNpcTask(npc, { key: 'refinery.refine', label: 'Refine Ore', targetType: 'refinery', onComplete: () => refineOre(false) });
        return;
      }
      if (state.crewAI.autoHire && hasModule('quarters') && canRole(['quartermaster'])) {
        const fee = 30;
        const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
        const crewCount = npcs.length;
        const target = clamp(Math.floor(safeNumber(state.crewAI.targetCrew, 0)), 0, MAX_CREW);
        if (crewCount > target) {
          const rolePriority = { crew: 0, security: 1, specialist: 2, scientist: 3, tech: 4, engineer: 5, medic: 6, pilot: 7, quartermaster: 8 };
          const qmCount = npcs.filter((n) => npcRole(n) === 'quartermaster').length;
          let candidates = npcs;
          if (qmCount <= 1) candidates = npcs.filter((n) => npcRole(n) !== 'quartermaster');
          if (!candidates.length) candidates = npcs;
          candidates.sort((a, b) => (rolePriority[npcRole(a)] ?? 9) - (rolePriority[npcRole(b)] ?? 9));
          const chosen = candidates[0];
          if (chosen) {
            assignNpcTask(npc, {
              key: 'quarters.transferOut',
              label: 'Transfer Crew Out',
              targetType: 'quarters',
              onComplete: () => {
                removeCrewMemberById(chosen.id);
                updateHUD();
                queueNotification('QUARTERS', `${chosen.name} transferred out (AUTOMATION).`);
              }
            });
            return;
          }
        }
        if (crewCount < target && crewCount < MAX_CREW && state.credits >= fee) {
          const counts = {};
          for (const n of npcs) {
            const r = npcRole(n);
            counts[r] = (counts[r] || 0) + 1;
          }
          const need = (r) => (counts[r] || 0) <= 0;
          let hire = 'CREW';
          if (need('pilot')) hire = 'PILOT';
          else if (need('tech')) hire = 'TECH';
          else if (need('medic')) hire = 'MEDIC';
          else if (need('engineer')) hire = 'ENGINEER';
          else if (need('scientist')) hire = 'SCIENTIST';
          else if (need('quartermaster')) hire = 'QUARTERMASTER';
          else if (need('security')) hire = 'SECURITY';
          else if ((counts.specialist || 0) < Math.max(1, Math.floor(target / 6))) hire = 'SPECIALIST';

          assignNpcTask(npc, {
            key: 'quarters.transferIn',
            label: `Hire ${hire}`,
            targetType: 'quarters',
            onComplete: () => {
              if (state.credits < fee) return;
              state.credits -= fee;
              addCrewMember(hire);
              queueNotification('QUARTERS', `${hire} transferred aboard (AUTOMATION).`);
              updateHUD();
            }
          });
          return;
        }
      }
      if (state.crewAI.autoBuild || state.crewAI.autoResearch) {
        ensureModuleBuiltIfUnlocked('sensors', 'AUTOMATION');
      }
      if (state.crewAI.autoBuild) {
        const buildTarget = pickAutoBuildTarget({
          needs,
          wantsScrap,
          wantsOre,
          wantsIngots,
          wantsFilters,
          wantsMedkits,
          wantsDroneParts,
          wantsRations
        });
        if (buildTarget && ensureModuleBuiltIfUnlocked(buildTarget, 'AUTOMATION')) return;
        const desired = ['drones', 'refinery', 'workshop', 'comms', 'canteen', 'shields', 'medbay', 'airlock'];
        for (const t of desired) {
          if (ensureModuleBuiltIfUnlocked(t, 'AUTOMATION')) break;
        }
      }
      if (state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating && state.hullMax < 150 && invHas('ingot', 2) && hasModule('workshop')) {
        assignNpcTask(npc, { key: 'workshop.plating', label: 'Install Plating', targetType: 'workshop', onComplete: () => installHullPlating(false) });
        return;
      }
      if ((wantsScrap || wantsOre || wantsIngots) && canRole(['scientist', 'tech']) && hasModule('sensors')) {
        assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
        return;
      }
      if ((wantsScrap || wantsOre) && canRole(['specialist', 'pilot']) && hasModule('drones') && invHas('droneParts', 1)) {
        assignNpcTask(npc, { key: 'drones.salvage', label: 'Launch Salvage Drone', targetType: 'drones', onComplete: () => launchSalvageDrone(false) });
        return;
      }
      if (state.crewAI.autoResearch && canRole(['scientist', 'tech']) && hasModule('sensors')) {
        const hasLockedTech = listLockedAdvancedModuleTypes().length > 0 || !(state.blueprints && state.blueprints.recipes && state.blueprints.recipes.plating);
        if (hasLockedTech && state.power >= 12 && invHas('scrap', 2)) {
          assignNpcTask(npc, { key: 'sensors.deepScan', label: 'Deep Scan', targetType: 'sensors', onComplete: () => deepScanBlueprint(false) });
          return;
        }
      }
      if (state.crewAI.autoContracts && canRole(['pilot', 'quartermaster']) && !pilotCritical()) {
        if (resolveContractDependencies()) return;
        if (!state.contract.active || contractReady(state.contract.active)) {
          if (hasModule('comms')) {
            assignNpcTask(npc, { key: 'comms.contracts', label: 'Manage Contracts', targetType: 'comms', onComplete: () => autoManageContracts() });
            return;
          }
          if (hasModule('cockpit')) {
            assignNpcTask(npc, { key: 'cockpit.comms', label: 'Contracts', targetType: 'cockpit', onComplete: () => autoManageContracts() });
            return;
          }
        }
      }
      if ((state.credits <= minCredits || state.reputation <= 0) && state.crewAI.autoContracts && !pilotCritical()) {
        if (resolveContractDependencies()) return;
        if (!state.contract.active || contractReady(state.contract.active)) {
          if (hasModule('comms')) {
            assignNpcTask(npc, { key: 'comms.contracts', label: 'Contracts', targetType: 'comms', onComplete: () => autoManageContracts() });
            return;
          }
          if (hasModule('cockpit')) {
            assignNpcTask(npc, { key: 'cockpit.comms', label: 'Contracts', targetType: 'cockpit', onComplete: () => autoManageContracts() });
            return;
          }
        }
        if (state.crewAI.autoBuild) {
          if (ensureModuleBuiltIfUnlocked('comms', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('cockpit', 'AUTOMATION')) return;
        }
      }
      if (state.credits <= minCredits && state.crewAI.autoBuild) {
        const hasSellable = invAvailableAfterReserve('ingot') > 0
          || invAvailableAfterReserve('scrap') > 0
          || invAvailableAfterReserve('ore') > (hasModule('refinery') ? 2 : 0)
          || invAvailableAfterReserve('rations') > 0;
        if (!hasSellable) {
          if (ensureModuleBuiltIfUnlocked('sensors', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('drones', 'AUTOMATION')) return;
          if (ensureModuleBuiltIfUnlocked('cargo', 'AUTOMATION')) return;
        }
      }
      if (state.crewAI.autoTravel && canRole(['pilot']) && hasModule('engine') && !pilotCritical()) {
        const t = state.travel && typeof state.travel === 'object' ? state.travel : { active: false };
        const safeToTravel = !anyActiveIncident() && state.oxygen >= 20 && state.power >= 12 && state.hull >= Math.max(10, state.hullMax * 0.5);
        if (!t.active && safeToTravel) {
          const sys = currentSystem();
          const unresolved = Array.isArray(state.anomalies)
            ? state.anomalies.filter((a) => a && !a.resolved && typeof a.system === 'string' && a.system.length).map((a) => a.system.toUpperCase())
            : [];
          const targets = [...new Set(unresolved)].filter((s) => s !== sys);
          let destination = null;
          if (targets.length) {
            let best = null;
            let bestDist = Infinity;
            for (const cand of targets) {
              const path = findShortestPath(sys, cand);
              if (!path || path.length < 2) continue;
              let sum = 0;
              for (let i = 0; i < path.length - 1; i++) {
                const w = distanceBetween(path[i], path[i + 1]);
                sum += Number.isFinite(w) ? w : 0;
              }
              if (sum < bestDist) {
                bestDist = sum;
                best = cand;
              }
            }
            destination = best;
          }
          if (!destination) {
            const dests = listDestinations(sys);
            if (dests.length) destination = dests[(Math.random() * dests.length) | 0];
          }
          if (destination && destination !== sys) {
            const path = findShortestPath(sys, destination);
            const nextHop = path && path.length >= 2 ? path[1] : null;
            if (nextHop) {
              assignNpcTask(npc, {
                key: 'cockpit.nav',
                label: `Plot Course ${sys} â ${nextHop}`,
                targetType: 'cockpit',
                onComplete: () => {
                  state.throttle = clamp(Math.max(0.6, safeNumber(state.throttle, 0)), 0, 1);
                  startTravelAuto(nextHop, 'AUTOMATION');
                  updateHUD();
                }
              });
              return;
            }
          }
        }
      }
      if (state.crewAI.autoHydro && canRole(['scientist', 'tech']) && hasModule('sensors')) {
        const localAnoms = Array.isArray(state.anomalies) ? state.anomalies.filter((a) => a && !a.resolved && a.system === currentSystem()) : [];
        if (localAnoms.length) {
          assignNpcTask(npc, { key: 'sensors.scan', label: 'Investigate Anomalies', targetType: 'sensors', onComplete: () => investigateAnomaly(localAnoms[0], false) });
          return;
        }
      }

      const crewCount = Array.isArray(state.npcs) ? state.npcs.filter(Boolean).length : 0;
      const targetCrew = clamp(Math.floor(safeNumber(state.crewAI && state.crewAI.targetCrew, 0)), 0, MAX_CREW);
      const crewTargetUnmet = crewCount !== targetCrew;

      const unmetDemands = (
        anyActiveIncident()
        || criticalModules.length > 0
        || (needs && Object.keys(needs).length > 0)
        || wantsRations
        || wantsFilters
        || wantsMedkits
        || wantsDroneParts
        || wantsIngots
        || wantsScrap
        || wantsOre
        || countHungryCrew() > 0
        || state.morale < 60
        || state.oxygen < 70
        || state.power < 40
        || state.heat > 75
        || state.hull < state.hullMax * 0.9
        || crewTargetUnmet
        || wantsCredits
      );

      if (unmetDemands) {
        const fallbackOrder = ['credits', 'rations', 'filter', 'medkit', 'droneParts', 'ingot', 'scrap', 'ore'];
        const roleDemandMap = {
          quartermaster: ['credits', 'rations', 'filter', 'medkit', 'droneParts', 'ingot', 'scrap', 'ore'],
          pilot: ['credits', 'ore', 'scrap'],
          engineer: ['ingot', 'scrap', 'ore', 'droneParts'],
          tech: ['ingot', 'scrap', 'ore', 'droneParts', 'rations'],
          scientist: ['ore', 'scrap'],
          specialist: ['scrap', 'ore', 'droneParts'],
          medic: ['medkit', 'rations'],
          security: ['scrap', 'ore'],
          crew: ['rations', 'scrap', 'ore']
        };
        const originalNpc = npc;
        for (const candidate of idle) {
          if (!candidate || candidate.task) continue;
          npc = candidate;
          let assigned = false;

          const roleKey = npcRole(candidate);
          const roleOrder = roleDemandMap[roleKey] || fallbackOrder;
          for (const key of roleOrder) {
            if (resolveDeclarativeDemand(npc, key)) {
              assigned = true;
              break;
            }
          }

          if (!assigned) {
            for (const key of fallbackOrder) {
              if (assignSupplyTaskFor(key)) {
                assigned = true;
                break;
              }
            }
          }

          if (!assigned && state.crewAI.autoResearch && canRole(['scientist', 'tech']) && hasModule('sensors')) {
            assignNpcTask(npc, { key: 'sensors.scan', label: 'Sensor Sweep', targetType: 'sensors', onComplete: () => scanForAnomalies(false) });
            assigned = true;
          }
          if (!assigned && canRole(['specialist', 'pilot']) && hasModule('drones') && invHas('droneParts', 1)) {
            assignNpcTask(npc, { key: 'drones.salvage', label: 'Launch Salvage Drone', targetType: 'drones', onComplete: () => launchSalvageDrone(false) });
            assigned = true;
          }
          if (!assigned && state.crewAI.autoFabricate && hasModule('fabricator')) {
            const canMakeAny = ['filter', 'medkit', 'droneParts', 'rations'].some((key) => canCraftItem(key));
            if (canMakeAny) {
              assignNpcTask(npc, { key: 'fabricator.build', label: 'Fabricate Consumables', targetType: 'fabricator', onComplete: () => autoFabricateConsumables() });
              assigned = true;
            }
          }
          if (!assigned && state.crewAI.autoRefine && hasModule('refinery') && invGet('ore') >= 3 && canRole(['engineer', 'tech'])) {
            assignNpcTask(npc, { key: 'refinery.refine', label: 'Refine Ore', targetType: 'refinery', onComplete: () => refineOre(false) });
          }
          if (!assigned) {
            reportAiBlocker(`Idle with unmet demands (${npcRole(candidate)})`);
          }
        }
        npc = originalNpc;
      }
    }

    // ============================================================================
    // Initialization
    // ============================================================================

    loadGame();
    ensureCrewAI();
    ensureBlueprints();
    ensureContracts();
    
    // Add initial crew if save is empty
    if (state.npcs.length === 0) {
      state.npcs.push(createNPC('CREW', 'crew', state.currentLevel, state.currentCorridor));
    }

    relayoutCorridor();
    updateHUD();
    requestAnimationFrame(gameLoop);

    // Save state periodically
    setInterval(() => {
      saveGame();
    }, 2000);

    // Save when the page is backgrounded or closed.
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') saveGame();
    });
    window.addEventListener('beforeunload', () => {
      saveGame();
    });
  </script>

  <script src="assets/js/pwa.js" defer></script>
  <script src="parental.js" defer></script>
</body>
</html>
