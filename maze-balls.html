<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Maze Balls</title>
  <style>
    :root {
      --bg-color: #f8f8fc;
      --text-color: #222;
      --canvas-bg: #fff;
      --button-bg: #e0f7fa;
      --button-text: #00796b;
      --shadow-color: rgba(0,0,0,0.12);
      --shadow-light: rgba(0,0,0,0.08);
      --wall-color: #333;
      --floor-color: #f5f5f5;
    }
    
    [data-theme="light"] {
      --bg-color: #f8f8fc;
      --text-color: #222;
      --canvas-bg: #fff;
      --button-bg: #e0f7fa;
      --button-text: #00796b;
      --shadow-color: rgba(0,0,0,0.12);
      --shadow-light: rgba(0,0,0,0.08);
      --wall-color: #333;
      --floor-color: #f5f5f5;
    }
    
    [data-theme="dark"] {
      --bg-color: #1a1a2e;
      --text-color: #eee;
      --canvas-bg: #16213e;
      --button-bg: #0f3460;
      --button-text: #4fc3f7;
      --shadow-color: rgba(0,0,0,0.5);
      --shadow-light: rgba(0,0,0,0.3);
      --wall-color: #666;
      --floor-color: #2a2a3e;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg-color);
      overflow: hidden;
      transition: background-color 0.3s ease;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      padding: 0.5em;
      box-sizing: border-box;
    }
    
    #controls {
      display: flex;
      align-items: center;
      gap: 1em;
      margin-bottom: 0.3em;
      width: 100%;
      max-width: 600px;
      justify-content: space-between;
    }
    
    #level-info {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      color: var(--text-color);
      transition: color 0.3s ease;
    }
    
    #level {
      font-size: 1.8em;
      font-weight: bold;
      margin: 0;
    }
    
    #timer {
      font-size: 1em;
      margin: 0;
      opacity: 0.8;
    }
    
    #theme-btn {
      font-size: 1em;
      background: var(--button-bg);
      border: none;
      border-radius: 0.5em;
      padding: 0.5em;
      cursor: pointer;
      color: var(--button-text);
      box-shadow: 0 2px 8px var(--shadow-light);
      transition: all 0.3s ease;
      min-width: 2.5em;
      flex-shrink: 0;
    }
    
    #game-canvas {
      display: block;
      margin: 0 auto;
      background: var(--canvas-bg);
      transition: all 0.3s ease;
      touch-action: none;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
    }
    
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .modal.show {
      opacity: 1;
      pointer-events: auto;
    }
    
    .modal-content {
      background: var(--canvas-bg);
      padding: 2em;
      border-radius: 12px;
      text-align: center;
      color: var(--text-color);
      box-shadow: 0 8px 32px var(--shadow-color);
      max-width: 90%;
      max-height: 90%;
      transition: all 0.3s ease;
    }
    
    .modal-content h2 {
      margin: 0 0 1em 0;
      color: var(--text-color);
      font-size: 2em;
    }
    
    .modal-content p {
      margin: 0.5em 0;
      font-size: 1.2em;
      opacity: 0.8;
    }
    
    .modal-content .continue {
      margin-top: 1.5em;
      font-size: 1em;
      opacity: 0.6;
      font-style: italic;
    }
    
    /* Mobile optimizations */
    @media (max-width: 768px) {
      body {
        padding: 0.2em;
      }
      
      #controls {
        margin-bottom: 0.2em;
      }
      
      #level {
        font-size: 1.5em;
      }
      
      #timer {
        font-size: 0.9em;
      }
      
      #theme-btn {
        font-size: 0.9em;
        padding: 0.4em;
      }
      
      .modal-content {
        padding: 1.5em;
      }
      
      .modal-content h2 {
        font-size: 1.5em;
      }
      
      .modal-content p {
        font-size: 1.1em;
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding: 0.1em;
      }
      
      #level {
        font-size: 1.3em;
      }
      
      #timer {
        font-size: 0.8em;
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <div id="level-info">
      <div id="level">Level 1</div>
      <div id="timer">00:00</div>
    </div>
    <button id="theme-btn" title="Toggle theme">🌓</button>
  </div>
  <canvas id="game-canvas"></canvas>
  
  <div id="completion-modal" class="modal">
    <div class="modal-content">
      <h2>Level Complete!</h2>
      <p id="completion-time">Time: 00:00</p>
      <p class="continue">Tap anywhere to continue to next level</p>
    </div>
  </div>

  <script>
    // --- THEME MANAGEMENT ---
    const THEMES = ['system', 'light', 'dark'];
    let currentThemeIndex = 0;
    
    function getSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    
    function applyTheme(theme) {
      if (theme === 'system') {
        const systemTheme = getSystemTheme();
        document.documentElement.setAttribute('data-theme', systemTheme);
      } else {
        document.documentElement.setAttribute('data-theme', theme);
      }
    }
    
    function updateThemeButton() {
      const themeBtn = document.getElementById('theme-btn');
      const theme = THEMES[currentThemeIndex];
      const icons = { system: '🌓', light: '☀️', dark: '🌙' };
      const titles = { 
        system: 'System theme', 
        light: 'Light theme', 
        dark: 'Dark theme' 
      };
      themeBtn.textContent = icons[theme];
      themeBtn.title = titles[theme];
    }
    
    function cycleTheme() {
      currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
      const theme = THEMES[currentThemeIndex];
      applyTheme(theme);
      updateThemeButton();
      localStorage.setItem('maze-balls-theme', theme);
      render();
    }
    
    function initTheme() {
      const savedTheme = localStorage.getItem('maze-balls-theme');
      if (savedTheme && THEMES.includes(savedTheme)) {
        currentThemeIndex = THEMES.indexOf(savedTheme);
      }
      applyTheme(THEMES[currentThemeIndex]);
      updateThemeButton();
      
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        if (THEMES[currentThemeIndex] === 'system') {
          applyTheme('system');
          render();
        }
      });
    }
    
    // --- GAME CONFIG ---
    const MAZE_SIZE = 5;
    const MAX_BALLS = 50;
    const PHYSICS_STEPS = 60; // Physics simulation steps per second
    const DAMPING = 0.99; // Energy loss per frame (reduced friction for longer rolls)
    const WALL_BOUNCE = 0.3; // Wall collision bounce factor
    const BALL_BOUNCE = 0.7; // Ball collision bounce factor
    
    // --- GAME STATE ---
    let currentLevel = 1;
    let startTime = 0;
    let gameTime = 0;
    let gameRunning = false;
    let levelComplete = false;
    let rngSeed = 1;
    
    // Maze and physics
    let maze = [];
    let balls = [];
    let blackHole = { x: 0, y: 0 };
    let cellSize = 0;
    let mazeOffsetX = 0;
    let mazeOffsetY = 0;
    let ballRadius = 0;
    
    // Input
    let isDragging = false;
    let dragBall = null;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let dragOffset = { x: 0, y: 0 }; // Offset for touch drag positioning
    
    // --- CANVAS ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      const isMobile = window.innerWidth <= 768;
      const isVerySmall = window.innerWidth <= 480;
      
      const controlsHeight = isVerySmall ? 40 : (isMobile ? 50 : 60);
      const margin = isVerySmall ? 8 : (isMobile ? 12 : 20);
      const totalUIHeight = controlsHeight + margin * 2;
      
      const sideMargin = isVerySmall ? 8 : (isMobile ? 12 : 20);
      const availableWidth = window.innerWidth - (sideMargin * 2);
      const availableHeight = window.innerHeight - totalUIHeight;
      
      const size = Math.min(availableWidth, availableHeight);
      
      // Store current scale ratio if we have a game in progress
      const oldSize = canvas.width;
      const scaleRatio = oldSize > 0 ? size / oldSize : 1;
      
      canvas.width = size;
      canvas.height = size;
      
      // Scale existing game elements if we have a game in progress
      if (maze.length > 0 && scaleRatio !== 1) {
        scaleGameElements(scaleRatio);
      }
      
      calculateDimensions();
      if (maze.length > 0) {
        render();
      }
    }
    
    function scaleGameElements(scaleRatio) {
      // Scale ball positions
      for (const ball of balls) {
        ball.x *= scaleRatio;
        ball.y *= scaleRatio;
      }
      
      // Scale black hole position
      blackHole.x *= scaleRatio;
      blackHole.y *= scaleRatio;
    }
    
    function calculateDimensions() {
      const oldCellSize = cellSize;
      const oldBallRadius = ballRadius;
      
      cellSize = canvas.width / MAZE_SIZE;
      ballRadius = cellSize / 3; // Double the size (was cellSize / 6)
      mazeOffsetX = 0;
      mazeOffsetY = 0;
      
      // Update ball radius for existing balls if game is in progress
      if (balls.length > 0 && oldBallRadius > 0) {
        const radiusScale = ballRadius / oldBallRadius;
        for (const ball of balls) {
          ball.radius = ball.inHole ? ball.radius : ballRadius;
        }
      }
    }
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // --- SEEDED RANDOM ---
    function seededRandom() {
      rngSeed = (rngSeed * 9301 + 49297) % 233280;
      return rngSeed / 233280;
    }
    
    function setSeed(seed) {
      rngSeed = seed;
    }
    
    // --- MAZE GENERATION ---
    function generateMaze(seed) {
      setSeed(seed);
      
      // Initialize maze with all walls
      maze = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(1));
      
      // Recursive backtracking maze generation
      const stack = [];
      const visited = Array(MAZE_SIZE).fill().map(() => Array(MAZE_SIZE).fill(false));
      
      function getNeighbors(x, y) {
        const neighbors = [];
        const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]]; // N, E, S, W
        
        for (const [dx, dy] of directions) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < MAZE_SIZE && ny >= 0 && ny < MAZE_SIZE && !visited[ny][nx]) {
            neighbors.push([nx, ny, x + dx/2, y + dy/2]);
          }
        }
        return neighbors;
      }
      
      // Start from top-left corner (ensure it's odd coordinates for proper maze)
      let startX = 0;
      let startY = 0;
      maze[startY][startX] = 0;
      visited[startY][startX] = true;
      stack.push([startX, startY]);
      
      while (stack.length > 0) {
        const [x, y] = stack[stack.length - 1];
        const neighbors = getNeighbors(x, y);
        
        if (neighbors.length > 0) {
          const [nx, ny, wallX, wallY] = neighbors[Math.floor(seededRandom() * neighbors.length)];
          maze[wallY][wallX] = 0; // Remove wall between current and next cell
          maze[ny][nx] = 0; // Open the next cell
          visited[ny][nx] = true;
          stack.push([nx, ny]);
        } else {
          stack.pop();
        }
      }
      
      // Ensure we have open spaces for balls and black hole
      for (let y = 0; y < MAZE_SIZE; y++) {
        for (let x = 0; x < MAZE_SIZE; x++) {
          if ((x + y) % 2 === 0) {
            maze[y][x] = 0; // Ensure intersections are open
          }
        }
      }
    }
    
    // --- PHYSICS ---
    class Ball {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.radius = ballRadius;
        this.color = `hsl(${Math.floor(seededRandom() * 360)}, 70%, 60%)`;
        this.inHole = false;
        this.holeProgress = 0;
      }
      
      update(dt) {
        if (this.inHole) {
          this.holeProgress = Math.min(1, this.holeProgress + dt * 3);
          this.radius = ballRadius * (1 - this.holeProgress);
          return;
        }
        
        // Apply damping
        this.vx *= DAMPING;
        this.vy *= DAMPING;
        
        // Update position
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // Wall collision
        this.handleWallCollision();
        
        // Check if ball entered black hole
        const dx = this.x - blackHole.x;
        const dy = this.y - blackHole.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < ballRadius * 0.8 && !this.inHole) {
          this.inHole = true;
          this.holeProgress = 0;
        }
      }
      
      handleWallCollision() {
        const cellX = Math.floor(this.x / cellSize);
        const cellY = Math.floor(this.y / cellSize);
        
        // Check collision with maze walls
        const checkCollision = (mx, my) => {
          if (mx < 0 || mx >= MAZE_SIZE || my < 0 || my >= MAZE_SIZE || maze[my][mx] === 1) {
            return true;
          }
          return false;
        };
        
        // Calculate collision bounds
        const left = this.x - this.radius;
        const right = this.x + this.radius;
        const top = this.y - this.radius;
        const bottom = this.y + this.radius;
        
        // Check horizontal collisions
        if (checkCollision(Math.floor(left / cellSize), cellY) || 
            checkCollision(Math.floor(right / cellSize), cellY)) {
          this.vx *= -WALL_BOUNCE;
          // Push ball away from wall
          if (this.vx > 0) {
            this.x = (Math.floor(left / cellSize) + 1) * cellSize + this.radius;
          } else {
            this.x = Math.floor(right / cellSize) * cellSize - this.radius;
          }
        }
        
        // Check vertical collisions
        if (checkCollision(cellX, Math.floor(top / cellSize)) || 
            checkCollision(cellX, Math.floor(bottom / cellSize))) {
          this.vy *= -WALL_BOUNCE;
          // Push ball away from wall
          if (this.vy > 0) {
            this.y = (Math.floor(top / cellSize) + 1) * cellSize + this.radius;
          } else {
            this.y = Math.floor(bottom / cellSize) * cellSize - this.radius;
          }
        }
        
        // Keep ball within canvas bounds
        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.vx *= -WALL_BOUNCE;
        }
        if (this.x + this.radius > canvas.width) {
          this.x = canvas.width - this.radius;
          this.vx *= -WALL_BOUNCE;
        }
        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy *= -WALL_BOUNCE;
        }
        if (this.y + this.radius > canvas.height) {
          this.y = canvas.height - this.radius;
          this.vy *= -WALL_BOUNCE;
        }
      }
      
      collideWith(other) {
        if (this.inHole || other.inHole) return;
        
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = this.radius + other.radius;
        
        if (distance < minDistance && distance > 0) {
          // Normalize collision vector
          const nx = dx / distance;
          const ny = dy / distance;
          
          // Separate balls
          const overlap = minDistance - distance;
          const separateX = nx * overlap * 0.5;
          const separateY = ny * overlap * 0.5;
          
          this.x -= separateX;
          this.y -= separateY;
          other.x += separateX;
          other.y += separateY;
          
          // Calculate relative velocity
          const relativeVelX = other.vx - this.vx;
          const relativeVelY = other.vy - this.vy;
          
          // Calculate relative velocity along collision normal
          const velAlongNormal = relativeVelX * nx + relativeVelY * ny;
          
          // Don't resolve if velocities are separating
          if (velAlongNormal > 0) return;
          
          // Calculate restitution (bounce)
          const restitution = BALL_BOUNCE;
          
          // Calculate impulse scalar
          const impulse = -(1 + restitution) * velAlongNormal / 2; // Assuming equal mass
          
          // Apply impulse
          this.vx -= impulse * nx;
          this.vy -= impulse * ny;
          other.vx += impulse * nx;
          other.vy += impulse * ny;
        }
      }
    }
    
    // --- GAME LOGIC ---
    function initLevel(level) {
      currentLevel = level;
      setSeed(level);
      generateMaze(level);
      
      balls = [];
      levelComplete = false;
      
      // Find open spaces for balls and black hole
      const openSpaces = [];
      for (let y = 0; y < MAZE_SIZE; y++) {
        for (let x = 0; x < MAZE_SIZE; x++) {
          if (maze[y][x] === 0) {
            openSpaces.push({ x: x * cellSize + cellSize / 2, y: y * cellSize + cellSize / 2 });
          }
        }
      }
      
      // Place black hole
      const holeIndex = Math.floor(seededRandom() * openSpaces.length);
      blackHole = openSpaces.splice(holeIndex, 1)[0];
      
      // Place balls
      const ballCount = Math.min(currentLevel, MAX_BALLS);
      for (let i = 0; i < ballCount; i++) {
        if (openSpaces.length > 0) {
          const ballIndex = Math.floor(seededRandom() * openSpaces.length);
          const pos = openSpaces.splice(ballIndex, 1)[0];
          balls.push(new Ball(pos.x, pos.y));
        }
      }
      
      // Start timer
      startTime = Date.now();
      gameTime = 0;
      gameRunning = true;
      
      updateDisplay();
    }
    
    function updateDisplay() {
      document.getElementById('level').textContent = `Level ${currentLevel}`;
      
      if (gameRunning && !levelComplete) {
        gameTime = Date.now() - startTime;
      }
      
      const minutes = Math.floor(gameTime / 60000);
      const seconds = Math.floor((gameTime % 60000) / 1000);
      document.getElementById('timer').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    function checkLevelComplete() {
      if (levelComplete) return;
      
      const allInHole = balls.every(ball => ball.inHole && ball.holeProgress >= 1);
      if (allInHole) {
        levelComplete = true;
        gameRunning = false;
        showCompletionModal();
      }
    }
    
    function showCompletionModal() {
      const modal = document.getElementById('completion-modal');
      const timeDisplay = document.getElementById('completion-time');
      
      const minutes = Math.floor(gameTime / 60000);
      const seconds = Math.floor((gameTime % 60000) / 1000);
      timeDisplay.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      
      modal.classList.add('show');
    }
    
    function hideCompletionModal() {
      const modal = document.getElementById('completion-modal');
      modal.classList.remove('show');
    }
    
    function nextLevel() {
      hideCompletionModal();
      initLevel(currentLevel + 1);
    }
    
    // --- RENDERING ---
    function getThemeColors() {
      const style = getComputedStyle(document.documentElement);
      return {
        wall: style.getPropertyValue('--wall-color').trim(),
        floor: style.getPropertyValue('--floor-color').trim(),
        canvas: style.getPropertyValue('--canvas-bg').trim()
      };
    }
    
    function render() {
      const colors = getThemeColors();
      
      // Clear canvas
      ctx.fillStyle = colors.canvas;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw maze
      ctx.fillStyle = colors.wall;
      for (let y = 0; y < MAZE_SIZE; y++) {
        for (let x = 0; x < MAZE_SIZE; x++) {
          if (maze[y][x] === 1) {
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
      }
      
      // Draw black hole
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(blackHole.x, blackHole.y, ballRadius * 1.2, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw black hole glow
      const gradient = ctx.createRadialGradient(blackHole.x, blackHole.y, 0, blackHole.x, blackHole.y, ballRadius * 2);
      gradient.addColorStop(0, 'rgba(0,0,0,0.8)');
      gradient.addColorStop(0.5, 'rgba(0,0,0,0.3)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(blackHole.x, blackHole.y, ballRadius * 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw balls
      for (const ball of balls) {
        if (ball.radius <= 0) continue;
        
        ctx.fillStyle = ball.color;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add ball highlight
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.arc(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // --- PHYSICS UPDATE ---
    let lastTime = 0;
    function gameLoop(currentTime) {
      const dt = Math.min((currentTime - lastTime) / 1000, 1/30); // Cap at 30fps for stability
      lastTime = currentTime;
      
      if (gameRunning) {
        // Update balls
        for (const ball of balls) {
          ball.update(dt);
        }
        
        // Handle ball-ball collisions
        for (let i = 0; i < balls.length; i++) {
          for (let j = i + 1; j < balls.length; j++) {
            balls[i].collideWith(balls[j]);
          }
        }
        
        checkLevelComplete();
        updateDisplay();
      }
      
      render();
      requestAnimationFrame(gameLoop);
    }
    
    // --- INPUT HANDLING ---
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: (clientX - rect.left) * (canvas.width / rect.width),
        y: (clientY - rect.top) * (canvas.height / rect.height)
      };
    }
    
    function findBallAt(x, y) {
      for (const ball of balls) {
        if (ball.inHole) continue;
        const dx = x - ball.x;
        const dy = y - ball.y;
        if (dx * dx + dy * dy <= ball.radius * ball.radius) {
          return ball;
        }
      }
      return null;
    }
    
    function handleStart(e) {
      e.preventDefault();
      
      const pos = getEventPos(e);
      const isTouch = e.touches && e.touches.length > 0;
      
      // For touch, find ball within a larger area to make it easier to grab
      const searchRadius = isTouch ? ballRadius * 3 : ballRadius;
      let ball = null;
      
      for (const b of balls) {
        if (b.inHole) continue;
        const dx = pos.x - b.x;
        const dy = pos.y - b.y;
        if (dx * dx + dy * dy <= searchRadius * searchRadius) {
          ball = b;
          break;
        }
      }
      
      if (ball) {
        isDragging = true;
        dragBall = ball;
        lastMouseX = pos.x;
        lastMouseY = pos.y;
        
        if (isTouch) {
          // For touch, offset the ball above the finger
          const touchOffset = ballRadius * 3; // Adjust this value to change how far above finger
          dragOffset.x = 0;
          dragOffset.y = -touchOffset;
        } else {
          // For mouse, center on the ball
          dragOffset.x = 0;
          dragOffset.y = 0;
        }
      }
    }
    
    function handleMove(e) {
      e.preventDefault();
      
      if (!isDragging || !dragBall) return;
      
      const pos = getEventPos(e);
      
      // Calculate target position with offset
      const targetX = pos.x + dragOffset.x;
      const targetY = pos.y + dragOffset.y;
      
      // Calculate how much to move the ball toward the target
      const dx = targetX - dragBall.x;
      const dy = targetY - dragBall.y;
      
      // Apply force proportional to distance from target
      const force = 400; // Adjust this to change responsiveness
      const maxForce = 800; // Cap maximum force
      
      let forceX = dx * force * 0.016;
      let forceY = dy * force * 0.016;
      
      // Cap the force to prevent excessive speeds
      const forceMagnitude = Math.sqrt(forceX * forceX + forceY * forceY);
      if (forceMagnitude > maxForce * 0.016) {
        const scale = (maxForce * 0.016) / forceMagnitude;
        forceX *= scale;
        forceY *= scale;
      }
      
      dragBall.vx += forceX;
      dragBall.vy += forceY;
      
      lastMouseX = pos.x;
      lastMouseY = pos.y;
    }
    
    function handleEnd(e) {
      e.preventDefault();
      isDragging = false;
      dragBall = null;
      dragOffset = { x: 0, y: 0 };
    }
    
    // Canvas input events
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });
    
    // Modal click handler
    document.getElementById('completion-modal').addEventListener('click', nextLevel);
    
    // Theme button
    document.getElementById('theme-btn').addEventListener('click', cycleTheme);
    
    // --- INITIALIZATION ---
    function init() {
      initTheme();
      initLevel(1);
      requestAnimationFrame(gameLoop);
    }
    
    init();
  </script>
</body>
</html>
