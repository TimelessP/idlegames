<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Explorer · Idle Games</title>
  <link rel="icon" type="image/svg+xml" href="assets/appicons/icon.svg">
  <link rel="apple-touch-icon" href="assets/appicons/icon-192.png">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #0a0e27;
      --panel: #1a1e3f;
      --text: #e0e0ff;
      --accent: #00d4ff;
      --warning: #ff6b35;
      --success: #4ecdc4;
      --hull: #3d4466;
      --wall: #2a2e4a;

      --hud-h: 56px;
      --controls-h: 78px;
    }

    body {
      font-family: 'Courier New', monospace;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      height: 100vh;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    #gameCanvas {
      position: fixed;
      left: 0;
      right: 0;
      top: var(--hud-h);
      bottom: var(--controls-h);
      width: 100%;
      height: calc(100vh - var(--hud-h) - var(--controls-h));
      background: var(--bg);
      display: block;
      touch-action: none;
    }

    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: auto;
      min-height: var(--hud-h);
      background: rgba(26, 30, 63, 0.9);
      padding: calc(8px + env(safe-area-inset-top, 0px)) calc(20px + env(safe-area-inset-right, 0px)) 8px calc(20px + env(safe-area-inset-left, 0px));
      display: flex;
      justify-content: flex-start;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px 16px;
      border-bottom: 2px solid var(--accent);
      font-size: 14px;
      z-index: 100;
    }

    .hud-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 6px;
      transition: all 0.2s;
      touch-action: manipulation;
      line-height: 1;
    }

    .hud-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .hud-section {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      row-gap: 6px;
    }

    .hud-controls {
      flex: 0 0 auto;
      gap: 10px;
    }

    .hud-stats {
      flex: 1 1 520px;
      justify-content: flex-end;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-value {
      color: var(--accent);
      font-weight: bold;
    }

    .status-item.optional {
      display: flex;
    }

    @media (max-width: 700px) {
      .status-item.optional {
        display: none;
      }
    }

    #controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: var(--controls-h);
      background: rgba(26, 30, 63, 0.9);
      padding: 10px;
      border-top: 2px solid var(--accent);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      z-index: 100;
    }

    .control-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 80px;
      touch-action: manipulation;
    }

    .control-btn:hover {
      background: var(--accent);
      color: var(--bg);
      transform: translateY(-2px);
    }

    .control-btn:active {
      transform: translateY(0);
    }

    .control-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    #interactPrompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.95);
      border: 2px solid var(--accent);
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      display: none;
      z-index: 200;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    #interactPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(26, 30, 63, 0.98);
      border: 3px solid var(--accent);
      padding: 30px;
      border-radius: 8px;
      max-width: 500px;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
      display: none;
      z-index: 300;
    }

    #interactPanel h2 {
      color: var(--accent);
      margin-bottom: 15px;
    }

    #interactPanel p {
      line-height: 1.6;
      margin-bottom: 20px;
      white-space: pre-line;
    }

    #panelTextarea {
      width: 100%;
      min-height: 180px;
      max-height: 45vh;
      background: rgba(10, 14, 39, 0.9);
      color: var(--text);
      border: 2px solid var(--accent);
      border-radius: 6px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      resize: vertical;
      margin-bottom: 18px;
      outline: none;
    }

    .panel-btn {
      background: var(--panel);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 10px 20px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
      border-radius: 4px;
      margin-right: 10px;
      transition: all 0.2s;
    }

    .panel-btn:hover {
      background: var(--accent);
      color: var(--bg);
    }

    .panel-btn.danger {
      border-color: var(--warning);
    }

    .panel-btn.danger:hover {
      background: var(--warning);
    }

    @media (max-width: 600px) {
      #hud {
        font-size: 12px;
        padding: calc(8px + env(safe-area-inset-top, 0px)) calc(10px + env(safe-area-inset-right, 0px)) 8px calc(10px + env(safe-area-inset-left, 0px));
      }

      .hud-section {
        gap: 10px;
      }

      #controls {
        padding: 10px;
      }

      .control-btn {
        padding: 10px 16px;
        font-size: 14px;
        min-width: 60px;
      }

      #interactPanel {
        max-width: 90%;
        padding: 20px;
      }

      .hud-btn {
        padding: 8px 10px;
        font-size: 13px;
      }
    }

    @media (orientation: landscape) and (max-height: 520px) {
      :root {
        --hud-h: 46px;
        --controls-h: 62px;
      }

      #hud {
        font-size: 12px;
        padding: 6px 10px;
      }

      .control-btn {
        padding: 8px 12px;
        font-size: 14px;
        min-width: 60px;
      }
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="hud-section hud-controls">
      <button class="hud-btn" id="menuBtn" aria-label="Game menu">☰ MENU</button>
      <button class="hud-btn" id="alertsBtn" aria-label="Alerts">⚠ ALERTS</button>
    </div>
    <div class="hud-section hud-stats">
      <div class="status-item">
        <span>POWER:</span>
        <span class="status-value" id="powerLevel">100%</span>
      </div>
      <div class="status-item">
        <span>OXYGEN:</span>
        <span class="status-value" id="oxygenLevel">100%</span>
      </div>
      <div class="status-item">
        <span>HULL:</span>
        <span class="status-value" id="hullLevel">100%</span>
      </div>
      <div class="status-item">
        <span>HEAT:</span>
        <span class="status-value" id="heatLevel">0%</span>
      </div>
      <div class="status-item">
        <span>SPEED:</span>
        <span class="status-value" id="speedLevel">0 km/s</span>
      </div>
      <div class="status-item">
        <span>CREDITS:</span>
        <span class="status-value" id="creditsLevel">0 cr</span>
      </div>
      <div class="status-item">
        <span>LOCATION:</span>
        <span class="status-value" id="locationText">CARGO BAY</span>
      </div>
      <div class="status-item optional">
        <span>FOOD:</span>
        <span class="status-value" id="foodLevel">100%</span>
      </div>
      <div class="status-item optional">
        <span>MORALE:</span>
        <span class="status-value" id="moraleLevel">100%</span>
      </div>
      <div class="status-item">
        <span>CREW:</span>
        <span class="status-value" id="crewText">—</span>
      </div>
    </div>
  </div>

  <svg id="gameCanvas" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet">
    <!-- Game will be rendered here -->
  </svg>

  <div id="controls">
    <button class="control-btn" id="leftBtn">← LEFT</button>
    <button class="control-btn" id="actionBtn">⚡ ACTION</button>
    <button class="control-btn" id="rightBtn">RIGHT →</button>
  </div>

  <div id="interactPrompt">
    Press ACTION to interact
  </div>

  <div id="interactPanel">
    <h2 id="panelTitle">Station</h2>
    <p id="panelDescription">Description</p>
    <textarea id="panelTextarea" spellcheck="false" autocapitalize="off" autocomplete="off" style="display:none"></textarea>
    <div id="panelButtons"></div>
  </div>

  <script type="module">
    const STORAGE_KEY_V2 = 'idlegames-space-explorer-v2';
    const STORAGE_KEY_LEGACY = 'idlegames-space-explorer';

    const CAPTAIN_NAME = 'CAPTAIN';

    const MAX_CREW = 50;

    const CREW_ROLES = ['pilot', 'tech', 'medic', 'specialist', 'engineer', 'quartermaster', 'scientist', 'security', 'crew'];

    // Basic modules are always fabricatable so the player can never get stuck.
    // Sensors is included so anomaly/blueprint progression is always reachable.
    const BASIC_MODULE_TYPES = new Set(['cargo', 'power', 'engine', 'cockpit', 'fabricator', 'life', 'hydro', 'quarters', 'sensors', 'computer']);

    const SYSTEM_GRAPH = {
      SOL: { EOS: 240, VEGA: 420, KITE: 180 },
      EOS: { SOL: 240, GAIA: 190, VEGA: 260 },
      VEGA: { SOL: 420, EOS: 260, DRIFT: 310 },
      KITE: { SOL: 180, DRIFT: 260 },
      GAIA: { EOS: 190, DRIFT: 340 },
      DRIFT: { VEGA: 310, KITE: 260, GAIA: 340 }
    };

    // Game State
    const state = {
      // Movement uses pixels/second (dt-based), not pixels/frame.
      // Walking pace is tuned for a casual, menu-driven loop.
      player: { x: 400, y: 490, width: 30, height: 60, speed: 260, vx: 0 },
      camera: { x: 0 },
      ship: { width: 2400, height: 600 },
      power: 100,
      oxygen: 100,
      hull: 100,
      hullMax: 100,
      heat: 0,
      food: 100,
      morale: 100,
      credits: 0,
      reputation: 0,
      speed: 0,
      engineActive: false,
      throttle: 0,
      location: { system: 'SOL' },
      travel: { active: false, from: 'SOL', to: null, remaining: 0, total: 0 },
      powerProfile: 'balanced',
      blueprints: { modules: {}, recipes: {} },
      anomalies: [],
      lightsOn: true,
      shieldsOn: false,
      lifeSupportOn: true,
      hydroponicsOn: false,
      cargoLoaded: true,
      inventory: { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 },
      incidents: { powerTrip: false, o2Leak: false, fire: false, breach: false },
      contract: { available: [], active: null },
      events: { queue: [], active: null },
      notifications: [],
      ui: { panelOpen: false, actionActor: 'player' },
      meta: { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 },
      crewAI: {
        enabled: true,
        autoTravel: true,
        autoResearch: true,
        autoBuild: true,
        autoContracts: true,
        autoVentHeat: true,
        autoHire: false,
        targetCrew: 8,
        buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 1 }
      },
      keys: { left: false, right: false },
      nearStation: null,
      facing: 1,
      anim: { walkPhase: 0 },
      sim: { drainAcc: 0, snap: true, saveAcc: 0, dirty: true },
      starfield: { seed: (Math.random() * 0xffffffff) >>> 0, driftX: 0, height: 600, stars: [] },
      // Support zero, one, or many NPCs.
      npcs: [
        {
          id: 'npc-1',
          name: 'ENSIGN',
          role: 'tech',
          x: 320,
          y: 490,
          width: 28,
          height: 58,
          speed: 220,
          vx: 0,
          facing: 1,
          anim: { walkPhase: 0 },
          mode: 'idle', // idle | task
          task: null,
          thinkAcc: 0,
          idleAcc: 0,
          wanderTargetX: null,
          cooldownAcc: 0,
          onDuty: true,
          paused: false,
          following: false,
          log: []
        }
      ],
      nearNpc: null,
      talkingNpcId: null
    };

    ensureBlueprints();

    function ensureCrewAI() {
      const defaults = {
        enabled: true,
        autoTravel: true,
        autoResearch: true,
        autoBuild: true,
        autoContracts: true,
        autoVentHeat: true,
        autoHire: false,
        targetCrew: 8,
        buffers: { ore: 0, scrap: 4, ingot: 4, filter: 1, medkit: 1, droneParts: 1, rations: 1 }
      };
      if (!state.crewAI || typeof state.crewAI !== 'object') state.crewAI = { ...defaults };

      for (const k of Object.keys(defaults)) {
        if (state.crewAI[k] === undefined) state.crewAI[k] = defaults[k];
      }

      state.crewAI.enabled = !!state.crewAI.enabled;
      state.crewAI.autoTravel = !!state.crewAI.autoTravel;
      state.crewAI.autoResearch = !!state.crewAI.autoResearch;
      state.crewAI.autoBuild = !!state.crewAI.autoBuild;
      state.crewAI.autoContracts = !!state.crewAI.autoContracts;
      state.crewAI.autoVentHeat = !!state.crewAI.autoVentHeat;
      state.crewAI.autoHire = !!state.crewAI.autoHire;
      state.crewAI.targetCrew = Math.max(0, Math.min(MAX_CREW, Math.floor(safeNumber(state.crewAI.targetCrew, defaults.targetCrew))));

      if (!state.crewAI.buffers || typeof state.crewAI.buffers !== 'object') state.crewAI.buffers = { ...defaults.buffers };
      for (const k of Object.keys(defaults.buffers)) {
        if (state.crewAI.buffers[k] === undefined) state.crewAI.buffers[k] = defaults.buffers[k];
        state.crewAI.buffers[k] = Math.max(0, Math.floor(safeNumber(state.crewAI.buffers[k], defaults.buffers[k])));
      }
    }

    ensureCrewAI();

    function syncHudHeight() {
      const hud = document.getElementById('hud');
      if (!hud) return;
      const h = Math.ceil(hud.getBoundingClientRect().height);
      if (h > 0) document.documentElement.style.setProperty('--hud-h', h + 'px');
    }

    // Keep the game canvas from hiding behind a wrapped HUD.
    requestAnimationFrame(syncHudHeight);
    window.addEventListener('resize', () => requestAnimationFrame(syncHudHeight));
    window.addEventListener('orientationchange', () => requestAnimationFrame(syncHudHeight));
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => requestAnimationFrame(syncHudHeight)).catch(() => {});
    }

    function getViewMetrics() {
      const viewWidth = 800;
      const shipHeight = 600;

      // Expand vertical viewBox in portrait (or any tall layout) so the world scene
      // includes the letterboxed space above/below the ship.
      const svgEl = document.getElementById('gameCanvas');
      const rect = svgEl.getBoundingClientRect();
      const aspect = rect.width > 0 ? (rect.height / rect.width) : (shipHeight / viewWidth);
      const expandedHeight = viewWidth * aspect;
      const viewHeight = Math.max(shipHeight, expandedHeight);
      const viewY = (shipHeight - viewHeight) / 2;

      return { viewWidth, viewHeight, viewY };
    }

    const css = getComputedStyle(document.documentElement);
    const C = {
      bg: css.getPropertyValue('--bg').trim(),
      panel: css.getPropertyValue('--panel').trim(),
      text: css.getPropertyValue('--text').trim(),
      accent: css.getPropertyValue('--accent').trim(),
      warning: css.getPropertyValue('--warning').trim(),
      success: css.getPropertyValue('--success').trim(),
      hull: css.getPropertyValue('--hull').trim(),
      wall: css.getPropertyValue('--wall').trim()
    };

    function newUid() {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
      return 'm_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
    }

    function safeNumber(v, fallback) {
      return Number.isFinite(v) ? v : fallback;
    }

    function clamp(v, lo, hi) {
      return Math.max(lo, Math.min(hi, v));
    }

    function moduleCount(type) {
      const mods = Array.isArray(state.modules) ? state.modules : [];
      let n = 0;
      for (const m of mods) {
        if (m && m.type === type) n++;
      }
      return n;
    }

    function countCoreModulesByType(type) {
      const mods = Array.isArray(state.coreModules) ? state.coreModules : [];
      let n = 0;
      for (const m of mods) {
        if (m && m.type === type) n++;
      }
      return n;
    }

    function hasModule(type) {
      return moduleCount(type) > 0;
    }

    function ensureBlueprints() {
      if (!state.blueprints || typeof state.blueprints !== 'object') {
        state.blueprints = { modules: {}, recipes: {} };
      }
      if (!state.blueprints.modules || typeof state.blueprints.modules !== 'object') state.blueprints.modules = {};
      if (!state.blueprints.recipes || typeof state.blueprints.recipes !== 'object') state.blueprints.recipes = {};

      for (const t of BASIC_MODULE_TYPES) state.blueprints.modules[t] = true;
      state.blueprints.recipes.plating = state.blueprints.recipes.plating !== undefined ? !!state.blueprints.recipes.plating : false;
    }

    function isModuleUnlocked(type) {
      if (BASIC_MODULE_TYPES.has(type)) return true;
      ensureBlueprints();
      return !!state.blueprints.modules[type];
    }

    function unlockModuleBlueprint(type, source = 'UNKNOWN') {
      ensureBlueprints();
      if (!MODULE_DEFS[type]) return false;
      if (isEndcapType(type)) return false;
      if (state.blueprints.modules[type]) return false;
      state.blueprints.modules[type] = true;
      queueNotification('BLUEPRINT ACQUIRED', `${MODULE_DEFS[type].label} blueprint unlocked (${String(source)}).`);
      markDirty();
      return true;
    }

    function unlockRecipeBlueprint(key, source = 'UNKNOWN') {
      ensureBlueprints();
      if (state.blueprints.recipes[key]) return false;
      state.blueprints.recipes[key] = true;
      queueNotification('BLUEPRINT ACQUIRED', `${String(key).toUpperCase()} blueprint unlocked (${String(source)}).`);
      markDirty();
      return true;
    }

    function listAdvancedModuleTypes() {
      const out = [];
      for (const t of Object.keys(MODULE_DEFS)) {
        if (isEndcapType(t)) continue;
        if (BASIC_MODULE_TYPES.has(t)) continue;
        out.push(t);
      }
      return out;
    }

    function listLockedAdvancedModuleTypes() {
      return listAdvancedModuleTypes().filter((t) => !isModuleUnlocked(t));
    }

    function unlockRandomLockedAdvancedModuleBlueprint(source, preferredPool = null) {
      const locked = listLockedAdvancedModuleTypes();
      if (!locked.length) return null;

      let pool = locked;
      if (Array.isArray(preferredPool) && preferredPool.length) {
        const preferredLocked = preferredPool.filter((t) => locked.includes(t));
        if (preferredLocked.length) pool = preferredLocked;
      }

      const pick = pool[(Math.random() * pool.length) | 0];
      const ok = unlockModuleBlueprint(pick, source);
      return ok ? pick : null;
    }

    function currentSystem() {
      const sys = state.location && typeof state.location === 'object' ? state.location.system : null;
      return typeof sys === 'string' && sys.length ? sys : 'SOL';
    }

    function listDestinations(from) {
      const edges = SYSTEM_GRAPH[from];
      if (!edges || typeof edges !== 'object') return [];
      return Object.keys(edges).sort();
    }

    function distanceBetween(from, to) {
      const edges = SYSTEM_GRAPH[from];
      if (!edges || typeof edges !== 'object') return null;
      const d = edges[to];
      return Number.isFinite(d) ? d : null;
    }

    function findShortestPath(from, to) {
      const start = String(from || '').toUpperCase();
      const goal = String(to || '').toUpperCase();
      if (!start || !goal) return null;
      if (start === goal) return [start];

      const dist = {};
      const prev = {};
      const visited = new Set();
      const nodes = Object.keys(SYSTEM_GRAPH);
      for (const n of nodes) dist[n] = Infinity;
      if (!(start in dist)) dist[start] = Infinity;
      dist[start] = 0;

      while (true) {
        let u = null;
        let best = Infinity;
        for (const n of Object.keys(dist)) {
          if (visited.has(n)) continue;
          const d = dist[n];
          if (d < best) {
            best = d;
            u = n;
          }
        }

        if (!u || best === Infinity) break;
        if (u === goal) break;
        visited.add(u);

        const edges = SYSTEM_GRAPH[u];
        if (!edges || typeof edges !== 'object') continue;
        for (const [v, w] of Object.entries(edges)) {
          const weight = Number.isFinite(w) ? w : null;
          if (weight === null) continue;
          const alt = dist[u] + weight;
          if (!(v in dist)) dist[v] = Infinity;
          if (alt < dist[v]) {
            dist[v] = alt;
            prev[v] = u;
          }
        }
      }

      if (!(goal in dist) || dist[goal] === Infinity) return null;
      const path = [];
      let cur = goal;
      while (cur) {
        path.push(cur);
        if (cur === start) break;
        cur = prev[cur];
      }
      if (path[path.length - 1] !== start) return null;
      path.reverse();
      return path;
    }

    function startTravelAuto(to, source = 'AUTOPILOT') {
      const from = currentSystem();
      const dest = String(to || '').toUpperCase();
      const d = distanceBetween(from, dest);
      if (!d) return false;
      state.travel = { active: true, from, to: dest, remaining: d, total: d };
      markDirty();
      queueNotification('NAVIGATION', `Course plotted: ${from} → ${dest} (${String(source)}).`);
      return true;
    }

    function fmtNeed(what, need, have, unit = '') {
      const n = Math.max(0, safeNumber(need, 0));
      const h = Math.max(0, safeNumber(have, 0));
      const u = unit ? String(unit) : '';
      return `Need ${n}${u} ${what} (have ${Math.floor(h)}${u}).`;
    }

    function fmtNeedInv(key, need) {
      return fmtNeed(String(key).toUpperCase(), need, invGet(key));
    }

    function fmtNeedPower(need) {
      return fmtNeed('POWER', need, Math.round(state.power), '%');
    }

    function fmtNeedOxygen(need) {
      return fmtNeed('OXYGEN', need, Math.round(state.oxygen), '%');
    }

    function fmtNeedCredits(need) {
      return fmtNeed('CREDITS', need, Math.floor(state.credits));
    }

    function ensureNpcsArray() {
      if (!Array.isArray(state.npcs)) state.npcs = [];
    }

    function inferRoleFromName(name) {
      const s = String(name || '').toUpperCase();
      if (s.includes('PILOT')) return 'pilot';
      if (s.includes('MEDIC')) return 'medic';
      if (s.includes('TECH')) return 'tech';
      if (s.includes('SPECIAL')) return 'specialist';
      if (s.includes('ENGINEER')) return 'engineer';
      if (s.includes('QUARTER')) return 'quartermaster';
      if (s.includes('SCIENT')) return 'scientist';
      if (s.includes('SECUR')) return 'security';
      return 'crew';
    }

    function roleLabel(role) {
      const r = String(role || '').toLowerCase();
      if (r === 'pilot') return 'PILOT';
      if (r === 'tech') return 'TECH';
      if (r === 'medic') return 'MEDIC';
      if (r === 'specialist') return 'SPECIALIST';
      if (r === 'engineer') return 'ENGINEER';
      if (r === 'quartermaster') return 'QUARTERMASTER';
      if (r === 'scientist') return 'SCIENTIST';
      if (r === 'security') return 'SECURITY';
      return 'CREW';
    }

    function openCrewCommandPanel() {
      ensureCrewAI();
      const crewCount = Array.isArray(state.npcs) ? state.npcs.filter(Boolean).length : 0;
      const lines = [
        `Crew: ${crewCount}/${MAX_CREW}`,
        `Automation: ${state.crewAI.enabled ? 'ON' : 'OFF'}`,
        '',
        `Auto Contracts: ${state.crewAI.autoContracts ? 'ON' : 'OFF'}`,
        `Auto Research: ${state.crewAI.autoResearch ? 'ON' : 'OFF'}`,
        `Auto Build: ${state.crewAI.autoBuild ? 'ON' : 'OFF'}`,
        `Auto Travel: ${state.crewAI.autoTravel ? 'ON' : 'OFF'}`,
        `Auto Vent Heat: ${state.crewAI.autoVentHeat ? 'ON' : 'OFF'}`,
        `Auto Hire: ${state.crewAI.autoHire ? 'ON' : 'OFF'} (target ${state.crewAI.targetCrew})`
      ];

      const toggle = (k) => {
        ensureCrewAI();
        state.crewAI[k] = !state.crewAI[k];
        markDirty();
        openCrewCommandPanel();
      };

      const buttons = [
        { label: state.crewAI.enabled ? 'Automation: ON' : 'Automation: OFF', action: () => toggle('enabled') },
        { label: state.crewAI.autoContracts ? 'Auto Contracts: ON' : 'Auto Contracts: OFF', action: () => toggle('autoContracts') },
        { label: state.crewAI.autoResearch ? 'Auto Research: ON' : 'Auto Research: OFF', action: () => toggle('autoResearch') },
        { label: state.crewAI.autoBuild ? 'Auto Build: ON' : 'Auto Build: OFF', action: () => toggle('autoBuild') },
        { label: state.crewAI.autoTravel ? 'Auto Travel: ON' : 'Auto Travel: OFF', action: () => toggle('autoTravel') },
        { label: state.crewAI.autoVentHeat ? 'Auto Vent Heat: ON' : 'Auto Vent Heat: OFF', action: () => toggle('autoVentHeat') },
        { label: state.crewAI.autoHire ? 'Auto Hire: ON' : 'Auto Hire: OFF', action: () => toggle('autoHire') },
        {
          label: `Set Hire Target (current ${state.crewAI.targetCrew})`,
          action: () => {
            const opts = [0, 4, 8, 12, 20, 30, 40, 50].map((n) => ({
              label: n === state.crewAI.targetCrew ? `Target ${n} (current)` : `Target ${n}`,
              action: () => {
                state.crewAI.targetCrew = n;
                markDirty();
                openCrewCommandPanel();
              }
            }));
            openPanel('CREW COMMAND', 'Set automated hiring target crew size:', [...opts, { label: 'Back', action: openCrewCommandPanel }], { includeCancel: false });
          }
        },
        {
          label: 'Assign Roles',
          action: () => {
            const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
            if (!npcs.length) return showMessage('CREW COMMAND', 'No crew available.');
            openPanel(
              'ASSIGN ROLES',
              'Select a crew member:',
              [
                ...npcs.map((n) => ({
                  label: `${n.name} — ${roleLabel(npcRole(n))}`,
                  action: () => {
                    const current = npcRole(n);
                    const roleButtons = CREW_ROLES.filter((r) => r !== 'crew').map((r) => ({
                      label: r === current ? `${roleLabel(r)} (current)` : roleLabel(r),
                      action: () => {
                        n.role = r;
                        markDirty();
                        updateCrewHUD();
                        openCrewCommandPanel();
                      }
                    }));
                    roleButtons.push({ label: 'Back', action: openCrewCommandPanel });
                    openPanel('ASSIGN ROLE', `${n.name}: choose a role`, roleButtons, { includeCancel: false });
                  }
                })),
                { label: 'Back', action: openCrewCommandPanel }
              ],
              { includeCancel: false }
            );
          }
        },
        { label: 'Back', action: closePanel }
      ];

      openPanel('CREW COMMAND', lines.join('\n'), buttons, { includeCancel: false });
    }

    function addCrewMember(name = 'CREW') {
      ensureNpcsArray();
      const id = 'npc-' + newUid();
      const x = clamp(state.player && Number.isFinite(state.player.x) ? state.player.x - 80 : 320, state.walkBounds.minX, state.walkBounds.maxX);
      const nm = String(name || 'CREW').toUpperCase();
      const npc = {
        id,
        name: nm,
        role: inferRoleFromName(nm),
        x,
        y: 490,
        width: 28,
        height: 58,
        speed: 220,
        vx: 0,
        facing: 1,
        anim: { walkPhase: 0 },
        mode: 'idle',
        task: null,
        thinkAcc: 0,
        idleAcc: 0,
        wanderTargetX: null,
        cooldownAcc: 0,
        onDuty: true,
        paused: false,
        following: false,
        log: []
      };
      state.npcs.push(npc);
      markDirty();
      updateCrewHUD();
      return npc;
    }

    function removeCrewMemberById(id) {
      ensureNpcsArray();
      const before = state.npcs.length;
      state.npcs = state.npcs.filter((n) => n && n.id !== id);
      if (state.nearNpc && state.nearNpc.id === id) state.nearNpc = null;
      if (state.talkingNpcId === id) state.talkingNpcId = null;
      const changed = state.npcs.length !== before;
      if (changed) {
        markDirty();
        updateCrewHUD();
      }
      return changed;
    }

    function invGet(key) {
      const inv = state.inventory;
      if (!inv || typeof inv !== 'object') return 0;
      const v = inv[key];
      return Number.isFinite(v) ? v : 0;
    }

    function invHas(key, qty = 1) {
      return invGet(key) >= qty;
    }

    function invAdd(key, qty = 1) {
      if (!state.inventory || typeof state.inventory !== 'object') state.inventory = {};
      state.inventory[key] = Math.max(0, invGet(key) + qty);
      markDirty();
    }

    function invTake(key, qty = 1) {
      if (!invHas(key, qty)) return false;
      state.inventory[key] = Math.max(0, invGet(key) - qty);
      markDirty();
      return true;
    }

    function invReserve(key) {
      ensureCrewAI();
      const buf = state.crewAI && state.crewAI.buffers && typeof state.crewAI.buffers === 'object' ? state.crewAI.buffers : null;
      const v = buf ? buf[key] : 0;
      return Math.max(0, Math.floor(safeNumber(v, 0)));
    }

    function invAvailableAfterReserve(key) {
      return Math.max(0, invGet(key) - invReserve(key));
    }

    function canSpendReserved(key, qty) {
      return invAvailableAfterReserve(key) >= Math.max(0, safeNumber(qty, 0));
    }

    function describeInventory() {
      const inv = state.inventory || {};
      const lines = [
        `Ore: ${invGet('ore')}`,
        `Scrap: ${invGet('scrap')}`,
        `Ingots: ${invGet('ingot')}`,
        `Filters: ${invGet('filter')}`,
        `Medkits: ${invGet('medkit')}`,
        `Drone Parts: ${invGet('droneParts')}`,
        `Rations: ${invGet('rations')}`,
        '',
        `Credits: ${Math.floor(state.credits)}`,
        `Reputation: ${Math.floor(state.reputation)}`
      ];
      return lines.join('\n');
    }

    function contractReady(contract, { respectReserve = false } = {}) {
      if (!contract || !contract.requires || typeof contract.requires !== 'object') return false;
      for (const k of Object.keys(contract.requires)) {
        const need = Math.max(0, safeNumber(contract.requires[k], 0));
        const have = respectReserve ? invAvailableAfterReserve(k) : invGet(k);
        if (need > 0 && have < need) return false;
      }
      return true;
    }

    function applyContractCompletion(contract, { respectReserve = false } = {}) {
      if (!contractReady(contract, { respectReserve })) return false;
      if (respectReserve) {
        for (const k of Object.keys(contract.requires || {})) {
          const need = Math.max(0, safeNumber(contract.requires[k], 0));
          if (need <= 0) continue;
          const after = invGet(k) - need;
          if (after < invReserve(k)) return false;
        }
      }
      for (const k of Object.keys(contract.requires || {})) {
        const need = Math.max(0, safeNumber(contract.requires[k], 0));
        if (need > 0) invTake(k, need);
      }
      const reward = contract.reward || {};
      state.credits = Math.max(0, safeNumber(state.credits, 0) + safeNumber(reward.credits, 0));
      state.reputation = Math.max(0, safeNumber(state.reputation, 0) + safeNumber(reward.reputation, 0));
      markDirty();
      updateHUD();
      return true;
    }

    function ensureContracts() {
      if (!state.contract || typeof state.contract !== 'object') state.contract = { available: [], active: null };
      if (!Array.isArray(state.contract.available)) state.contract.available = [];
      if (state.contract.available.length >= 3) return;

      const mk = (id, title, requires, reward) => ({ id, title, requires, reward });
      const base = Date.now().toString(36).slice(-4);
      const pool = [
        mk('c-' + base + '-ore', 'Deliver Ore', { ore: 6 }, { credits: 40, reputation: 2 }),
        mk('c-' + base + '-scrap', 'Deliver Scrap', { scrap: 8 }, { credits: 55, reputation: 2 }),
        mk('c-' + base + '-ingot', 'Deliver Ingots', { ingot: 4 }, { credits: 80, reputation: 3 }),
        mk('c-' + base + '-med', 'Medical Supplies', { medkit: 2 }, { credits: 70, reputation: 4 }),
        mk('c-' + base + '-filters', 'Life Support Filters', { filter: 3 }, { credits: 45, reputation: 3 })
      ];

      while (state.contract.available.length < 3 && pool.length) {
        const i = (Math.random() * pool.length) | 0;
        state.contract.available.push(pool.splice(i, 1)[0]);
      }
      markDirty();
    }

    function openContractsPanel() {
      ensureContracts();
      const active = state.contract.active;
      const lines = [];
      if (active) {
        lines.push(`ACTIVE: ${active.title}`);
        lines.push(`Requires: ${Object.entries(active.requires || {}).map(([k, v]) => `${k}×${v}`).join(', ') || '—'}`);
        lines.push(`Reward: ${Object.entries(active.reward || {}).map(([k, v]) => `${k}+${v}`).join(', ') || '—'}`);
        lines.push(contractReady(active) ? 'Status: READY TO COMPLETE' : 'Status: In progress');
      } else {
        lines.push('No active contract.');
      }

      const buttons = [];

      if (active) {
        buttons.push({
          label: contractReady(active) ? 'Transmit Completion' : 'Transmit Status',
          action: () => {
            if (!contractReady(active)) {
              showMessage('COMMS', 'Contract not ready yet.');
              return;
            }
            applyContractCompletion(active);
            state.contract.active = null;
            ensureContracts();
            showMessage('COMMS', 'Contract completed. Payment received.');
          }
        });
        buttons.push({
          label: 'Abandon Contract',
          danger: true,
          action: () => {
            state.contract.active = null;
            markDirty();
            showMessage('COMMS', 'Contract abandoned.');
          }
        });
      } else {
        for (const c of state.contract.available || []) {
          if (!c) continue;
          buttons.push({
            label: `Accept: ${c.title}`,
            action: () => {
              state.contract.active = c;
              state.contract.available = (state.contract.available || []).filter((x) => x && x.id !== c.id);
              markDirty();
              showMessage('COMMS', `Accepted contract: ${c.title}`);
            }
          });
        }
        if (buttons.length === 0) {
          buttons.push({ label: 'No contracts available', action: () => {} });
        }
      }

      openPanel('COMMS — CONTRACTS', lines.join('\n'), [...buttons, { label: 'Back', action: closePanel }], { includeCancel: false });
    }

    function openThrottlePanel(context = 'NAV') {
      const thr = clamp(safeNumber(state.throttle, 0), 0, 1);
      const pct = Math.round(thr * 100);
      const mk = (p) => ({
        label: p === pct ? `Throttle: ${p}% (current)` : `Throttle: ${p}%`,
        action: () => {
          state.throttle = clamp(p / 100, 0, 1);
          markDirty();
          updateHUD();
          showMessage(context, `Throttle set to ${p}%.`);
        }
      });

      openPanel(
        `${context} — THROTTLE`,
        'Set engine throttle:',
        [mk(0), mk(25), mk(50), mk(75), mk(100), { label: 'Back', action: closePanel }],
        { includeCancel: false }
      );
    }

    function openPowerRoutingPanel(context = 'POWER') {
      const desc = {
        balanced: 'Default behavior. No automatic load shedding.',
        survival: 'Prioritizes life support. Sheds nonessential loads at low power.',
        combat: 'Prioritizes shields and engines. Sheds hydroponics first at low power.',
        industry: 'Prioritizes hydroponics and fabrication support. Sheds shields first at low power.'
      };

      const set = (profile) => {
        state.powerProfile = profile;
        markDirty();
        showMessage(context, `Power routing set to ${profile.toUpperCase()}.`);
      };

      const buttons = [
        { label: state.powerProfile === 'balanced' ? 'BALANCED (current)' : 'BALANCED', action: () => set('balanced') },
        { label: state.powerProfile === 'survival' ? 'SURVIVAL (current)' : 'SURVIVAL', action: () => set('survival') },
        { label: state.powerProfile === 'combat' ? 'COMBAT (current)' : 'COMBAT', action: () => set('combat') },
        { label: state.powerProfile === 'industry' ? 'INDUSTRY (current)' : 'INDUSTRY', action: () => set('industry') },
        { label: 'Back', action: closePanel }
      ];

      openPanel(
        `${context} — POWER ROUTING`,
        `${desc[state.powerProfile] || ''}`,
        buttons,
        { includeCancel: false }
      );
    }

    function ensureAnomaliesArray() {
      if (!Array.isArray(state.anomalies)) state.anomalies = [];
      if (state.anomalies.length > 50) state.anomalies.splice(0, state.anomalies.length - 50);
    }

    function addAnomaly({ system, name, kind }) {
      ensureAnomaliesArray();
      const a = {
        id: newUid(),
        system: (system || currentSystem()).toUpperCase(),
        name: String(name || 'ANOMALY'),
        kind: String(kind || 'unknown'),
        resolved: false
      };
      state.anomalies.push(a);
      markDirty();
      return a;
    }

    function rewardFromAnomaly(anomaly) {
      const kind = anomaly && anomaly.kind ? anomaly.kind : 'unknown';
      const r = Math.random();

      // If we still have locked tech, anomalies can unlock it.
      const maybeUnlock = (source, preferred) => {
        // Vaults prioritize the plating recipe if it's still locked.
        if (kind === 'vault' && !state.blueprints.recipes.plating) {
          return unlockRecipeBlueprint('plating', source);
        }
        return !!unlockRandomLockedAdvancedModuleBlueprint(source, preferred);
      };

      if (kind === 'derelict') {
        invAdd('scrap', 5);
        if (r < 0.55) maybeUnlock('DERELICT', ['drones', 'refinery', 'airlock', 'workshop']);
        return 'Recovered salvage: +5 scrap.';
      }

      if (kind === 'signal') {
        invAdd('ore', 4);
        if (r < 0.55) maybeUnlock('SIGNAL', ['comms', 'shields', 'medbay']);
        return 'Recovered minerals: +4 ore.';
      }

      if (kind === 'vault') {
        invAdd('ingot', 2);
        if (r < 0.7) maybeUnlock('VAULT', ['workshop', 'medbay', 'comms', 'shields']);
        return 'Recovered alloys: +2 ingots.';
      }

      invAdd('scrap', 2);
      if (r < 0.35) maybeUnlock('ANOMALY', null);
      return 'Recovered fragments: +2 scrap.';
    }

    function openAnomalyPanel(anomaly) {
      if (!anomaly) return;
      const sys = currentSystem();
      if (anomaly.system !== sys) {
        showMessage('ANOMALY', `This anomaly is in ${anomaly.system}. Current system: ${sys}.`);
        return;
      }

      const status = anomaly.resolved ? 'RESOLVED' : 'UNRESOLVED';
      const lines = [
        `System: ${anomaly.system}`,
        `Signature: ${anomaly.name}`,
        `Type: ${String(anomaly.kind).toUpperCase()}`,
        `Status: ${status}`
      ];

      const buttons = [];
      if (!anomaly.resolved) {
        buttons.push({
          label: 'Investigate',
          action: () => {
            if (state.power < 10) return showMessage('ANOMALY', fmtNeedPower(10));
            state.power = Math.max(0, state.power - 10);
            anomaly.resolved = true;
            const msg = rewardFromAnomaly(anomaly);
            ensureContracts();
            updateHUD();
            markDirty();
            showMessage('ANOMALY', msg);
          }
        });
      }
      buttons.push({ label: 'Back', action: openNavigationPanel });
      openPanel('ANOMALY', lines.join('\n'), buttons, { includeCancel: false });
    }

    function startTravel(to) {
      const from = currentSystem();
      const dest = String(to || '').toUpperCase();
      const d = distanceBetween(from, dest);
      if (!d) {
        showMessage('NAVIGATION', 'No valid route.');
        return;
      }
      state.travel = { active: true, from, to: dest, remaining: d, total: d };
      markDirty();
      showMessage('NAVIGATION', `Course plotted: ${from} → ${dest}. Distance: ${d} AU.`);
    }

    function cancelTravel() {
      if (!state.travel || !state.travel.active) {
        showMessage('NAVIGATION', 'No active course to cancel.');
        return;
      }
      state.travel = { active: false, from: currentSystem(), to: null, remaining: 0, total: 0 };
      markDirty();
      showMessage('NAVIGATION', 'Course cancelled.');
    }

    function openNavigationPanel() {
      const sys = currentSystem();
      const t = state.travel && typeof state.travel === 'object' ? state.travel : { active: false };
      const thr = clamp(safeNumber(state.throttle, 0), 0, 1);
      const thrPct = Math.round(thr * 100);

      const lines = [];
      lines.push(`System: ${sys}`);
      lines.push(`Engine: ${state.engineActive ? 'ACTIVE' : 'IDLE'}`);
      lines.push(`Throttle: ${thrPct}%`);

      if (t.active && t.to) {
        const rate = Math.max(0, safeNumber(state.speed, 0) / 15000);
        const eta = rate > 0.01 ? Math.ceil(t.remaining / rate) : null;
        lines.push('');
        lines.push(`Course: ${t.from} → ${t.to}`);
        lines.push(`Remaining: ${Math.max(0, Math.round(t.remaining))} AU`);
        lines.push(`ETA: ${eta !== null ? eta + 's' : '—'}`);
      }

      const localAnoms = Array.isArray(state.anomalies)
        ? state.anomalies.filter((a) => a && !a.resolved && a.system === sys).slice(-3)
        : [];
      if (localAnoms.length) {
        lines.push('');
        lines.push('Anomalies:');
        for (const a of localAnoms) lines.push(`• ${a.name}`);
      }

      const buttons = [];

      if (hasModule('engine')) {
        buttons.push({
          label: state.engineActive ? 'Toggle Engine (ON)' : 'Toggle Engine (OFF)',
          action: () => {
            state.engineActive = !state.engineActive;
            if (!state.engineActive) state.speed = 0;
            markDirty();
            updateHUD();
            showMessage('NAVIGATION', state.engineActive ? 'Engine activated.' : 'Engine deactivated.');
          }
        });
      } else {
        buttons.push({ label: 'No engine installed', action: () => showMessage('NAVIGATION', 'An engine module is required for travel.') });
      }

      buttons.push({ label: 'Set Throttle', action: () => openThrottlePanel('NAVIGATION') });

      if (t.active && t.to) {
        buttons.push({ label: 'Cancel Course', danger: true, action: cancelTravel });
      } else {
        buttons.push({
          label: 'Plot Course',
          action: () => {
            const dests = listDestinations(sys);
            if (dests.length === 0) return showMessage('NAVIGATION', 'No known destinations.');
            openPanel(
              'NAVIGATION',
              `Destinations from ${sys}:`,
              [...dests.map((d) => ({ label: `${sys} → ${d} (${distanceBetween(sys, d)} AU)`, action: () => startTravel(d) })), { label: 'Back', action: openNavigationPanel }],
              { includeCancel: false }
            );
          }
        });
      }

      if (localAnoms.length) {
        for (const a of localAnoms) {
          buttons.push({ label: `Investigate: ${a.name}`, action: () => openAnomalyPanel(a) });
        }
      }

      buttons.push({ label: 'Back', action: closePanel });
      openPanel('NAVIGATION', lines.join('\n'), buttons, { includeCancel: false });
    }

    function incidentLabel(kind) {
      if (kind === 'powerTrip') return 'POWER TRIP';
      if (kind === 'o2Leak') return 'O2 LEAK';
      if (kind === 'fire') return 'FIRE';
      if (kind === 'breach') return 'HULL BREACH';
      return kind.toUpperCase();
    }

    function anyActiveIncident() {
      const inc = state.incidents;
      if (!inc) return false;
      return !!(inc.powerTrip || inc.o2Leak || inc.fire || inc.breach);
    }

    function resolveIncident(kind) {
      if (!state.incidents || typeof state.incidents !== 'object') return false;
      if (!state.incidents[kind]) return false;
      state.incidents[kind] = false;
      markDirty();
      return true;
    }

    function triggerIncident(kind) {
      if (!state.incidents || typeof state.incidents !== 'object') state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
      if (state.incidents[kind]) return false;
      state.incidents[kind] = true;
      markDirty();
      return true;
    }

    function getSaveData() {
      return {
        v: 2,
        savedAt: Date.now(),
        coreModules: state.coreModules,
        nav: {
          system: currentSystem(),
          throttle: clamp(safeNumber(state.throttle, 0), 0, 1),
          travel: state.travel && typeof state.travel === 'object'
            ? {
                active: !!state.travel.active,
                from: typeof state.travel.from === 'string' && state.travel.from.length ? state.travel.from : currentSystem(),
                to: typeof state.travel.to === 'string' && state.travel.to.length ? state.travel.to : null,
                remaining: Math.max(0, safeNumber(state.travel.remaining, 0)),
                total: Math.max(0, safeNumber(state.travel.total, 0))
              }
            : { active: false, from: currentSystem(), to: null, remaining: 0, total: 0 },
          powerProfile: typeof state.powerProfile === 'string' ? state.powerProfile : 'balanced'
        },
        blueprints: state.blueprints,
        anomalies: state.anomalies,
        player: {
          x: state.player.x,
          facing: state.facing
        },
        npcs: Array.isArray(state.npcs)
          ? state.npcs.map((n) => ({
              id: n.id,
              name: n.name,
              role: n.role,
              x: n.x,
              facing: n.facing,
              onDuty: !!n.onDuty,
              following: !!n.following,
              task: n.task ? { key: n.task.key || null, stationId: n.task.stationId || null, label: n.task.label || null } : null,
              log: Array.isArray(n.log)
                ? n.log
                  .filter((e) => e && typeof e === 'object')
                  .slice(-5)
                  .map((e) => ({ ts: safeNumber(e.ts, Date.now()), text: String(e.text || '') }))
                : []
            }))
          : [],
        crewAI: state.crewAI,
        resources: {
          power: state.power,
          oxygen: state.oxygen,
          hull: state.hull,
          hullMax: state.hullMax,
          heat: state.heat,
          food: state.food,
          morale: state.morale,
          credits: state.credits,
          reputation: state.reputation,
          speed: state.speed,
          engineActive: state.engineActive,
          lightsOn: state.lightsOn,
          shieldsOn: state.shieldsOn,
          lifeSupportOn: state.lifeSupportOn,
          hydroponicsOn: state.hydroponicsOn
        },
        inventory: state.inventory,
        incidents: state.incidents,
        contract: state.contract,
        anim: {
          walkPhase: state.anim.walkPhase
        },
        starfield: {
          seed: state.starfield.seed,
          driftX: state.starfield.driftX,
          height: state.starfield.height
        }
      };
    }

    function saveGame() {
      const saveData = getSaveData();

      try {
        localStorage.setItem(STORAGE_KEY_V2, JSON.stringify(saveData));
      } catch (e) {
        // Ignore quota / private mode issues.
      }

      state.sim.dirty = false;
      state.sim.saveAcc = 0;
    }

    function markDirty() {
      state.sim.dirty = true;
    }

    function normalizeCoreModules(modules) {
      if (!Array.isArray(modules) || modules.length === 0) return defaultModules();
      return modules
        .filter((m) => m && typeof m === 'object')
        .map((m) => ({
          uid: typeof m.uid === 'string' && m.uid.length ? m.uid : newUid(),
          type: typeof m.type === 'string' && MODULE_DEFS[m.type] ? m.type : 'cargo'
        }))
        .filter((m) => !isEndcapType(m.type));
    }

    function loadGame() {
      // Prefer v2, fall back to legacy.
      const rawV2 = localStorage.getItem(STORAGE_KEY_V2);
      if (rawV2) {
        try {
          const loaded = JSON.parse(rawV2);
          if (loaded && loaded.v === 2) {
            if (loaded.coreModules) {
              state.coreModules = normalizeCoreModules(loaded.coreModules);
            }

            if (loaded.player && typeof loaded.player === 'object') {
              state.player.x = safeNumber(loaded.player.x, state.player.x);
              state.facing = loaded.player.facing === -1 ? -1 : 1;
            }

            if (Array.isArray(loaded.npcs)) {
              state.npcs = loaded.npcs
                .filter((n) => n && typeof n === 'object')
                .map((n, idx) => {
                  const id = typeof n.id === 'string' && n.id ? n.id : `npc-${idx + 1}`;
                  const name = typeof n.name === 'string' && n.name ? n.name : 'CREW';
                  const role = typeof n.role === 'string' && n.role ? n.role : inferRoleFromName(name);
                  const x = safeNumber(n.x, 320);
                  const facing = n.facing === -1 ? -1 : 1;
                  const onDuty = n.onDuty !== undefined ? !!n.onDuty : true;
                  const following = n.following !== undefined ? !!n.following : false;
                  const task = n.task && typeof n.task === 'object'
                    ? { key: n.task.key || null, stationId: n.task.stationId || null, label: n.task.label || null }
                    : null;
                  const log = Array.isArray(n.log)
                    ? n.log
                      .filter((e) => e && typeof e === 'object')
                      .slice(-5)
                      .map((e) => ({ ts: safeNumber(e.ts, Date.now()), text: String(e.text || '') }))
                    : [];

                  return {
                    id,
                    name,
                    role,
                    x,
                    y: 490,
                    width: 28,
                    height: 58,
                    speed: 220,
                    vx: 0,
                    facing,
                    anim: { walkPhase: 0 },
                    mode: task ? 'task' : 'idle',
                    task,
                    thinkAcc: 0,
                    idleAcc: 0,
                    wanderTargetX: null,
                    cooldownAcc: 0,
                    onDuty,
                    paused: false,
                    following,
                    log
                  };
                });
            }

            if (loaded.resources && typeof loaded.resources === 'object') {
              state.power = Math.max(0, Math.min(150, safeNumber(loaded.resources.power, state.power)));
              state.oxygen = Math.max(0, Math.min(100, safeNumber(loaded.resources.oxygen, state.oxygen)));
              state.hullMax = Math.max(50, Math.min(200, safeNumber(loaded.resources.hullMax, state.hullMax)));
              state.hull = Math.max(0, Math.min(state.hullMax, safeNumber(loaded.resources.hull, state.hull)));
              state.heat = Math.max(0, Math.min(100, safeNumber(loaded.resources.heat, state.heat)));
              state.food = Math.max(0, Math.min(100, safeNumber(loaded.resources.food, state.food)));
              state.morale = Math.max(0, Math.min(100, safeNumber(loaded.resources.morale, state.morale)));
              state.credits = Math.max(0, safeNumber(loaded.resources.credits, state.credits));
              state.reputation = Math.max(0, safeNumber(loaded.resources.reputation, state.reputation));
              state.speed = Math.max(0, safeNumber(loaded.resources.speed, state.speed));
              state.engineActive = !!loaded.resources.engineActive;
              state.lightsOn = loaded.resources.lightsOn !== undefined ? !!loaded.resources.lightsOn : state.lightsOn;
              state.shieldsOn = loaded.resources.shieldsOn !== undefined ? !!loaded.resources.shieldsOn : state.shieldsOn;
              state.lifeSupportOn = loaded.resources.lifeSupportOn !== undefined ? !!loaded.resources.lifeSupportOn : state.lifeSupportOn;
              state.hydroponicsOn = loaded.resources.hydroponicsOn !== undefined ? !!loaded.resources.hydroponicsOn : state.hydroponicsOn;
            }

            if (loaded.nav && typeof loaded.nav === 'object') {
              const sys = loaded.nav.system;
              state.location = { system: (typeof sys === 'string' && sys.length ? sys : 'SOL').toUpperCase() };
              state.throttle = clamp(safeNumber(loaded.nav.throttle, state.throttle), 0, 1);
              state.powerProfile = typeof loaded.nav.powerProfile === 'string' ? loaded.nav.powerProfile : state.powerProfile;

              if (loaded.nav.travel && typeof loaded.nav.travel === 'object') {
                const t = loaded.nav.travel;
                state.travel = {
                  active: !!t.active,
                  from: (typeof t.from === 'string' && t.from.length ? t.from : currentSystem()).toUpperCase(),
                  to: typeof t.to === 'string' && t.to.length ? t.to.toUpperCase() : null,
                  remaining: Math.max(0, safeNumber(t.remaining, 0)),
                  total: Math.max(0, safeNumber(t.total, 0))
                };
              }
            }

            if (loaded.blueprints && typeof loaded.blueprints === 'object') {
              state.blueprints = loaded.blueprints;
            }
            ensureBlueprints();

            if (loaded.crewAI && typeof loaded.crewAI === 'object') {
              state.crewAI = loaded.crewAI;
            }
            ensureCrewAI();

            if (Array.isArray(loaded.anomalies)) {
              state.anomalies = loaded.anomalies
                .filter((a) => a && typeof a === 'object')
                .slice(0, 50)
                .map((a) => ({
                  id: typeof a.id === 'string' && a.id ? a.id : newUid(),
                  system: typeof a.system === 'string' && a.system ? a.system.toUpperCase() : currentSystem(),
                  name: typeof a.name === 'string' && a.name ? a.name : 'ANOMALY',
                  kind: typeof a.kind === 'string' && a.kind ? a.kind : 'unknown',
                  resolved: !!a.resolved
                }));
            }

            if (loaded.inventory && typeof loaded.inventory === 'object') {
              const inv = loaded.inventory;
              state.inventory = {
                ore: Math.max(0, safeNumber(inv.ore, state.inventory.ore)),
                scrap: Math.max(0, safeNumber(inv.scrap, state.inventory.scrap)),
                ingot: Math.max(0, safeNumber(inv.ingot, state.inventory.ingot)),
                filter: Math.max(0, safeNumber(inv.filter, state.inventory.filter)),
                medkit: Math.max(0, safeNumber(inv.medkit, state.inventory.medkit)),
                droneParts: Math.max(0, safeNumber(inv.droneParts, state.inventory.droneParts)),
                rations: Math.max(0, safeNumber(inv.rations, state.inventory.rations))
              };
            }

            if (loaded.incidents && typeof loaded.incidents === 'object') {
              state.incidents = {
                powerTrip: !!loaded.incidents.powerTrip,
                o2Leak: !!loaded.incidents.o2Leak,
                fire: !!loaded.incidents.fire,
                breach: !!loaded.incidents.breach
              };
            }

            if (loaded.contract && typeof loaded.contract === 'object') {
              const c = loaded.contract;
              const avail = Array.isArray(c.available) ? c.available : [];
              state.contract = {
                available: avail.filter((x) => x && typeof x === 'object').slice(0, 6),
                active: c.active && typeof c.active === 'object' ? c.active : null
              };
            }

            if (loaded.anim && typeof loaded.anim === 'object') {
              state.anim.walkPhase = safeNumber(loaded.anim.walkPhase, state.anim.walkPhase);
            }

            if (loaded.starfield && typeof loaded.starfield === 'object') {
              const seed = loaded.starfield.seed;
              if (Number.isInteger(seed) && seed >= 0) state.starfield.seed = seed >>> 0;
              state.starfield.driftX = safeNumber(loaded.starfield.driftX, state.starfield.driftX);
              state.starfield.height = safeNumber(loaded.starfield.height, state.starfield.height);
            }

            state.sim.snap = true;
            return true;
          }
        } catch (e) {
          // ignore
        }
      }

      const rawLegacy = localStorage.getItem(STORAGE_KEY_LEGACY);
      if (rawLegacy) {
        try {
          const loaded = JSON.parse(rawLegacy);
          if (loaded && typeof loaded === 'object') {
            if (Array.isArray(loaded.modules) && loaded.modules.length > 0) {
              state.coreModules = normalizeCoreModules(loaded.modules);
            }
            state.player.x = safeNumber(loaded.playerX, state.player.x);
            state.power = safeNumber(loaded.power, state.power);
            state.oxygen = safeNumber(loaded.oxygen, state.oxygen);
            state.speed = safeNumber(loaded.speed, state.speed);
            state.engineActive = !!loaded.engineActive;
            state.lightsOn = loaded.lightsOn !== undefined ? !!loaded.lightsOn : state.lightsOn;
            state.sim.snap = true;
            return true;
          }
        } catch (e) {
          // ignore
        }
      }

      return false;
    }

    function mulberry32(seed) {
      let t = seed >>> 0;
      return function rand() {
        t += 0x6D2B79F5;
        let x = Math.imul(t ^ (t >>> 15), 1 | t);
        x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      };
    }

    function defaultModules() {
      return [
        { uid: newUid(), type: 'cargo' },
        { uid: newUid(), type: 'power' },
        { uid: newUid(), type: 'fabricator' },
        { uid: newUid(), type: 'engine' },
        { uid: newUid(), type: 'cockpit' },
        { uid: newUid(), type: 'computer' }
      ];
    }

    const END_CAPS = {
      rear: { uid: 'endcap-rear', type: 'rearcap' },
      front: { uid: 'endcap-front', type: 'nosecap' }
    };

    // Interior layout scale: halve each module width while keeping station/equipment sizes unchanged.
    const MODULE_WIDTH_SCALE = 0.5;

    function isEndcapType(type) {
      return type === 'rearcap' || type === 'nosecap';
    }

    function withEndcaps(coreModules) {
      // Never allow endcaps inside the editable list.
      const cleaned = (coreModules || []).filter((m) => m && !isEndcapType(m.type));
      return [END_CAPS.rear, ...cleaned, END_CAPS.front];
    }

    const MODULE_DEFS = {
      rearcap: {
        label: 'Rockets',
        width: 260,
        walkable: false
      },
      nosecap: {
        label: 'Nose',
        width: 260,
        walkable: false
      },
      cargo: {
        label: 'Cargo Bay',
        width: 560,
        station: { width: 110, height: 120, y: 400 },
        actions: () => [
          { key: 'cargo.inventory', label: 'View Inventory', action: () => showMessage('INVENTORY', describeInventory()) },
          {
            key: 'cargo.trade',
            label: 'Trade (Sell / Buy)',
            action: () => {
              const buy = [
                { key: 'filter', label: 'Buy Filter (10 cr)', cost: 10 },
                { key: 'medkit', label: 'Buy Medkit (25 cr)', cost: 25 },
                { key: 'droneParts', label: 'Buy Drone Parts (20 cr)', cost: 20 }
              ];
              const sell = [
                { key: 'ore', label: 'Sell Ore (3 cr each)', value: 3 },
                { key: 'scrap', label: 'Sell Scrap (5 cr each)', value: 5 },
                { key: 'ingot', label: 'Sell Ingots (10 cr each)', value: 10 }
              ];

              openPanel(
                'CARGO — TRADE',
                `Credits: ${Math.floor(state.credits)}\n\nSell materials or buy essentials:`,
                [
                  ...sell.map((s) => ({
                    label: `${s.label} (You have ${invGet(s.key)})`,
                    action: () => {
                      if (!invHas(s.key, 1)) {
                        showMessage('TRADE', 'Nothing to sell.');
                        return;
                      }
                      invTake(s.key, 1);
                      state.credits += s.value;
                      markDirty();
                      showMessage('TRADE', `Sold 1 ${s.key}.`);
                    }
                  })),
                  ...buy.map((b) => ({
                    label: `${b.label} (You have ${Math.floor(state.credits)} cr)`,
                    action: () => {
                      if (state.credits < b.cost) {
                        showMessage('TRADE', fmtNeedCredits(b.cost));
                        return;
                      }
                      state.credits -= b.cost;
                      invAdd(b.key, 1);
                      markDirty();
                      showMessage('TRADE', `Purchased 1 ${b.key}.`);
                    }
                  })),
                  { label: 'Back', action: closePanel }
                ],
                { includeCancel: false }
              );
            }
          },
          { label: 'Check Cargo', action: () => showMessage('CARGO STATUS', 'Cargo holds are secure. Storage racks online.') },
          { label: 'Eject Pod', danger: true, action: () => showMessage('CARGO EJECTION', 'Ejection disabled: safety interlocks engaged.') }
        ]
      },
      power: {
        label: 'Power Core',
        width: 520,
        station: { width: 130, height: 120, y: 400 },
        actions: () => [
          { key: 'power.status', label: 'Check Status', action: () => showMessage('POWER CORE', `Current output: ${state.power}%\nReactor stable. All systems nominal.`) },
          {
            key: 'power.reset',
            label: state.incidents.powerTrip ? 'Reset Breakers' : 'Reset Breakers (OK)',
            action: () => {
              if (!state.incidents.powerTrip) {
                showMessage('POWER CORE', 'No power trip detected.');
                return;
              }
              resolveIncident('powerTrip');
              showMessage('POWER CORE', 'Breakers reset. Power distribution restored.');
            }
          },
          {
            key: 'power.boost',
            label: 'Boost Power',
            action: () => {
              state.power = Math.min(150, state.power + 25);
              updateHUD();
              markDirty();
              showMessage('POWER BOOST', 'Power output increased to ' + state.power + '%');
            }
          },
          {
            key: 'power.toggleLights',
            label: 'Toggle Lights',
            action: () => {
              state.lightsOn = !state.lightsOn;
              renderShip();
              markDirty();
              showMessage('LIGHTS', state.lightsOn ? 'Lights ON' : 'Lights OFF');
            }
          },
          {
            key: 'power.routing',
            label: 'Power Routing',
            action: () => openPowerRoutingPanel('POWER CORE')
          }
        ]
      },
      engine: {
        label: 'Engine Room',
        width: 600,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'engine.status',
            label: 'Engine Status',
            action: () => {
              const thr = Math.round(clamp(state.throttle || 0, 0, 1) * 100);
              showMessage('ENGINE STATUS', `Current speed: ${state.speed.toLocaleString()} km/s\nEngine: ${state.engineActive ? 'ACTIVE' : 'IDLE'}\nThrottle: ${thr}%\nFuel: Optimal`);
            }
          },
          {
            key: 'engine.toggle',
            label: 'Toggle Engine',
            action: () => {
              state.engineActive = !state.engineActive;
              if (!state.engineActive) state.speed = 0;
              updateHUD();
              renderShip();
              markDirty();
              showMessage('ENGINE', state.engineActive ? 'Engine ACTIVATED' : 'Engine DEACTIVATED');
            }
          },
          {
            key: 'engine.throttle',
            label: 'Set Throttle',
            action: () => openThrottlePanel('ENGINE')
          },
          {
            key: 'engine.vent',
            label: 'Vent Heat',
            requiredRole: ['engineer', 'tech'],
            action: () => {
              const before = state.heat;
              state.heat = Math.max(0, state.heat - 25);
              if (state.incidents.fire && state.heat <= 40) resolveIncident('fire');
              updateHUD();
              markDirty();
              showMessage('ENGINE', before === state.heat ? 'Thermal stable.' : 'Thermal venting complete.');
            }
          },
          { key: 'engine.diagnostics', label: 'Diagnostics', action: () => showMessage('DIAGNOSTICS', 'Running full system check...\n\n✓ Thruster array: OK\n✓ Fuel lines: OK\n✓ Coolant: OK') }
        ]
      },
      cockpit: {
        label: 'Cockpit',
        width: 620,
        station: { width: 160, height: 120, y: 400 },
        actions: () => [
          {
            key: 'cockpit.status',
            label: 'Ship Status',
            action: () => {
              const inc = [];
              if (state.incidents.powerTrip) inc.push('POWER TRIP');
              if (state.incidents.o2Leak) inc.push('O2 LEAK');
              if (state.incidents.fire) inc.push('FIRE');
              if (state.incidents.breach) inc.push('HULL BREACH');
              const line = inc.length ? inc.join(', ') : 'None';
              showMessage('SHIP STATUS', `Incidents: ${line}\n\nPower: ${Math.round(state.power)}%\nOxygen: ${Math.round(state.oxygen)}%\nHull: ${Math.round((state.hull / Math.max(1, state.hullMax)) * 100)}%\nHeat: ${Math.round(state.heat)}%\nFood: ${Math.round(state.food)}%\nMorale: ${Math.round(state.morale)}%`);
            }
          },
          { key: 'cockpit.nav', label: 'Navigation', action: openNavigationPanel },
          { key: 'cockpit.power', label: 'Power Routing', action: () => openPowerRoutingPanel('COCKPIT') },
          { key: 'cockpit.command', label: 'Crew Command', action: openCrewCommandPanel },
          { key: 'cockpit.comms', label: 'Open Comms (Contracts)', action: openContractsPanel }
        ]
      },
      life: {
        label: 'Life Support',
        width: 520,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'life.toggle',
            label: state.lifeSupportOn ? 'Life Support: ON' : 'Life Support: OFF',
            action: () => {
              state.lifeSupportOn = !state.lifeSupportOn;
              markDirty();
              showMessage('LIFE SUPPORT', state.lifeSupportOn ? 'Scrubbers engaged.' : 'Scrubbers offline.');
            }
          },
          {
            key: 'life.emergency',
            label: `Emergency Scrubbers (Power ${Math.round(state.power)}% / 12%)`,
            action: () => {
              if (state.power < 12) {
                showMessage('LIFE SUPPORT', fmtNeedPower(12));
                return;
              }
              state.power = Math.max(0, state.power - 12);
              state.oxygen = clamp(state.oxygen + 18, 0, 100);
              if (state.incidents.o2Leak) resolveIncident('o2Leak');
              updateHUD();
              markDirty();
              showMessage('LIFE SUPPORT', 'Emergency scrub cycle complete.');
            }
          },
          {
            key: 'life.seal',
            label: state.incidents.o2Leak ? 'Seal O2 Leak' : 'Seal O2 Leak (OK)',
            action: () => {
              if (!state.incidents.o2Leak) {
                showMessage('LIFE SUPPORT', 'No leak detected.');
                return;
              }
              resolveIncident('o2Leak');
              showMessage('LIFE SUPPORT', 'Leak sealed. Atmosphere stabilizing.');
            }
          }
        ]
      },
      hydro: {
        label: 'Hydroponics',
        width: 560,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'hydro.toggle',
            label: state.hydroponicsOn ? 'Grow Lights: ON' : 'Grow Lights: OFF',
            action: () => {
              state.hydroponicsOn = !state.hydroponicsOn;
              markDirty();
              showMessage('HYDROPONICS', state.hydroponicsOn ? 'Growth cycle started.' : 'Growth cycle paused.');
            }
          },
          {
            key: 'hydro.harvest',
            label: `Harvest Rations (Power ${Math.round(state.power)}% / 6%)`,
            action: () => {
              if (state.power < 6) {
                showMessage('HYDROPONICS', fmtNeedPower(6));
                return;
              }
              state.power = Math.max(0, state.power - 6);
              invAdd('rations', 2);
              state.food = clamp(state.food + 8, 0, 100);
              updateHUD();
              showMessage('HYDROPONICS', 'Harvest complete: +2 rations.');
            }
          }
        ]
      },
      medbay: {
        label: 'Medbay',
        width: 520,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'med.treat',
            label: `Treat Crew (Medkits ${invGet('medkit')} / 1 OR Power ${Math.round(state.power)}% / 10%)`,
            action: () => {
              if (invHas('medkit', 1)) {
                invTake('medkit', 1);
                state.morale = clamp(state.morale + 22, 0, 100);
                updateHUD();
                showMessage('MEDBAY', 'Treatment administered. Morale improved.');
                return;
              }
              if (state.power < 10) {
                showMessage('MEDBAY', `No medkits available. ${fmtNeedPower(10)}`);
                return;
              }
              state.power = Math.max(0, state.power - 10);
              state.morale = clamp(state.morale + 14, 0, 100);
              updateHUD();
              markDirty();
              showMessage('MEDBAY', 'Emergency care delivered.');
            }
          }
        ]
      },
      comms: {
        label: 'Comms Array',
        width: 520,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          { key: 'comms.contracts', requiredRole: ['pilot', 'quartermaster'], label: 'Contracts', action: openContractsPanel },
          {
            key: 'comms.broadcast',
            label: 'Broadcast Status',
            action: () => showMessage('COMMS', `Beacon online. Credits: ${Math.floor(state.credits)}\nReputation: ${Math.floor(state.reputation)}`)
          }
        ]
      },
      sensors: {
        label: 'Sensors Lab',
        width: 560,
        station: { width: 160, height: 120, y: 400 },
        actions: () => [
          {
            key: 'sensors.investigate',
            requiredRole: ['scientist', 'tech'],
            label: `Investigate Local Anomaly (Power ${Math.round(state.power)}% / 10%)`,
            action: () => {
              const sys = currentSystem();
              const a = Array.isArray(state.anomalies)
                ? [...state.anomalies].reverse().find((x) => x && !x.resolved && x.system === sys)
                : null;
              if (!a) {
                showMessage('SENSORS', 'No unresolved anomalies detected in this system.');
                return;
              }
              if (state.power < 10) {
                showMessage('SENSORS', fmtNeedPower(10));
                return;
              }
              state.power = Math.max(0, state.power - 10);
              a.resolved = true;
              const msg = rewardFromAnomaly(a);
              ensureContracts();
              updateHUD();
              markDirty();
              showMessage('ANOMALY', msg);
            }
          },
          {
            key: 'sensors.scan',
            requiredRole: ['scientist', 'tech'],
            label: `Scan (Loot) (Power ${Math.round(state.power)}% / 8%)`,
            action: () => {
              if (state.power < 8) {
                showMessage('SENSORS', fmtNeedPower(8));
                return;
              }
              state.power = Math.max(0, state.power - 8);
              const r = Math.random();
              if (r < 0.45) {
                invAdd('ore', 2);
                showMessage('SENSORS', 'Scan result: asteroid fragments. +2 ore.');
              } else if (r < 0.85) {
                invAdd('scrap', 3);
                showMessage('SENSORS', 'Scan result: derelict debris. +3 scrap.');
              } else {
                invAdd('ingot', 1);
                showMessage('SENSORS', 'Scan result: intact alloy cache. +1 ingot.');
              }

              // Rare: discover a persistent anomaly in the current system.
              if (Math.random() < 0.18) {
                const kinds = ['derelict', 'signal', 'vault'];
                const kind = kinds[(Math.random() * kinds.length) | 0];
                const name = kind === 'derelict' ? 'DERELICT HULK' : (kind === 'signal' ? 'ODD SIGNAL' : 'SEALED VAULT');
                const a = addAnomaly({ system: currentSystem(), name, kind });
                queueNotification('ANOMALY DETECTED', `${a.name} registered in ${a.system}.`);
              }

              // Very rare: unlock a random advanced module blueprint.
              if (Math.random() < 0.10) {
                const unlockedType = unlockRandomLockedAdvancedModuleBlueprint('SCAN', ['comms', 'shields', 'refinery', 'drones', 'airlock', 'workshop', 'medbay']);
                if (!unlockedType && !state.blueprints.recipes.plating && Math.random() < 0.40) {
                  unlockRecipeBlueprint('plating', 'SCAN');
                }
              }

              updateHUD();
              ensureContracts();
            }
          },
          {
            key: 'sensors.deepScan',
            requiredRole: ['scientist', 'tech'],
            label: `Deep Scan (Blueprint) (Power ${Math.round(state.power)}% / 12%, Scrap ${invGet('scrap')} / 2)`,
            action: () => {
              const locked = listLockedAdvancedModuleTypes();
              if (!locked.length && state.blueprints.recipes.plating) {
                showMessage('SENSORS', 'No locked blueprints detected.');
                return;
              }
              if (state.power < 12) {
                showMessage('SENSORS', fmtNeedPower(12));
                return;
              }
              if (!invHas('scrap', 2)) {
                showMessage('SENSORS', fmtNeedInv('scrap', 2));
                return;
              }

              state.power = Math.max(0, state.power - 12);
              invTake('scrap', 2);

              // If plating is still locked, occasionally uncover it here too.
              if (!state.blueprints.recipes.plating && Math.random() < 0.25) {
                unlockRecipeBlueprint('plating', 'DEEP SCAN');
                showMessage('SENSORS', 'Deep scan complete. Blueprint data recovered: HULL PLATING.');
              } else {
                const pool = ['refinery', 'drones', 'airlock', 'workshop', 'medbay', 'shields', 'comms'];
                const unlockedType = unlockRandomLockedAdvancedModuleBlueprint('DEEP SCAN', pool);
                if (unlockedType) {
                  const lbl = MODULE_DEFS[unlockedType] ? MODULE_DEFS[unlockedType].label : unlockedType;
                  showMessage('SENSORS', `Deep scan complete. Blueprint data recovered: ${lbl}.`);
                } else {
                  showMessage('SENSORS', 'Deep scan complete. No new blueprint data found.');
                }
              }

              updateHUD();
              ensureContracts();
            }
          }
        ]
      },
      shields: {
        label: 'Shields',
        width: 520,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'shields.toggle',
            label: state.shieldsOn ? 'Shields: ON' : 'Shields: OFF',
            action: () => {
              state.shieldsOn = !state.shieldsOn;
              markDirty();
              showMessage('SHIELDS', state.shieldsOn ? 'Deflectors online.' : 'Deflectors offline.');
            }
          },
          {
            key: 'shields.bulkhead',
            label: state.incidents.breach ? 'Seal Bulkheads' : 'Seal Bulkheads (OK)',
            action: () => {
              if (!state.incidents.breach) {
                showMessage('SHIELDS', 'No breach detected.');
                return;
              }
              if (state.power < 15) {
                showMessage('SHIELDS', fmtNeedPower(15));
                return;
              }
              state.power = Math.max(0, state.power - 15);
              resolveIncident('breach');
              state.hull = clamp(state.hull + 6, 0, state.hullMax);
              updateHUD();
              showMessage('SHIELDS', 'Bulkheads sealed. Hull stabilized.');
            }
          }
        ]
      },
      refinery: {
        label: 'Refinery',
        width: 560,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'refinery.refine',
            requiredRole: ['engineer', 'tech'],
            label: `Refine Ore (Ore ${invGet('ore')} / 2, Power ${Math.round(state.power)}%)`,
            action: () => {
              const ore = invGet('ore');
              const batches = Math.floor(ore / 2);
              if (batches <= 0) {
                showMessage('REFINERY', fmtNeedInv('ore', 2));
                return;
              }
              const cost = Math.min(25, 4 + batches * 2);
              if (state.power < cost) {
                showMessage('REFINERY', fmtNeedPower(cost));
                return;
              }
              state.power = Math.max(0, state.power - cost);
              invTake('ore', batches * 2);
              invAdd('ingot', batches);
              updateHUD();
              showMessage('REFINERY', `Refined ${batches * 2} ore into ${batches} ingots.`);
            }
          }
        ]
      },
      drones: {
        label: 'Drone Bay',
        width: 560,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'drones.repair',
            requiredRole: ['engineer', 'specialist'],
            label: `Launch Repair Drone (Parts ${invGet('droneParts')} / 1, Power ${Math.round(state.power)}% / 10%)`,
            action: () => {
              if (state.power < 10) {
                showMessage('DRONES', fmtNeedPower(10));
                return;
              }
              if (!invHas('droneParts', 1)) {
                showMessage('DRONES', fmtNeedInv('droneParts', 1));
                return;
              }
              state.power = Math.max(0, state.power - 10);
              invTake('droneParts', 1);
              state.hull = clamp(state.hull + 18, 0, state.hullMax);
              resolveIncident('breach');
              resolveIncident('fire');
              updateHUD();
              showMessage('DRONES', 'Drone repair complete.');
            }
          },
          {
            key: 'drones.salvage',
            requiredRole: ['specialist', 'pilot'],
            label: `Launch Salvage Drone (Power ${Math.round(state.power)}% / 10%)`,
            action: () => {
              if (state.power < 10) {
                showMessage('DRONES', fmtNeedPower(10));
                return;
              }
              state.power = Math.max(0, state.power - 10);
              const r = Math.random();
              if (r < 0.6) {
                invAdd('scrap', 4);
                showMessage('DRONES', 'Salvage recovered: +4 scrap.');
              } else {
                invAdd('ore', 3);
                showMessage('DRONES', 'Salvage recovered: +3 ore.');
              }
              ensureContracts();
              updateHUD();
            }
          }
        ]
      },
      airlock: {
        label: 'Airlock',
        width: 520,
        station: { width: 140, height: 120, y: 400 },
        actions: () => [
          {
            key: 'airlock.eva',
            label: `EVA Patch Hull (Oxygen ${Math.round(state.oxygen)}% / 12%)`,
            requiredRole: ['engineer', 'specialist'],
            action: () => {
              if (state.hull >= state.hullMax && !state.incidents.breach) {
                showMessage('AIRLOCK', 'No hull work required.');
                return;
              }
              if (state.oxygen < 12) {
                showMessage('AIRLOCK', fmtNeedOxygen(12));
                return;
              }
              state.oxygen = Math.max(0, state.oxygen - 12);
              state.morale = clamp(state.morale - 6, 0, 100);
              state.hull = clamp(state.hull + 22, 0, state.hullMax);
              resolveIncident('breach');
              updateHUD();
              markDirty();
              showMessage('AIRLOCK', 'EVA complete. Hull patched.');
            }
          }
        ]
      },
      workshop: {
        label: 'Workshop',
        width: 560,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'workshop.plating',
            label: `Install Hull Plating (+10 max hull) (Ingots ${invGet('ingot')} / 2)`,
            action: () => {
              ensureBlueprints();
              if (!state.blueprints.recipes.plating) {
                showMessage('WORKSHOP', 'Blueprint required: HULL PLATING. (Find anomalies to unlock.)');
                return;
              }
              if (state.hullMax >= 150) {
                showMessage('WORKSHOP', 'Hull plating already at maximum.');
                return;
              }
              if (!invHas('ingot', 2)) {
                showMessage('WORKSHOP', fmtNeedInv('ingot', 2));
                return;
              }
              invTake('ingot', 2);
              state.hullMax += 10;
              state.hull = clamp(state.hull + 10, 0, state.hullMax);
              updateHUD();
              showMessage('WORKSHOP', 'Plating installed.');
            }
          }
        ]
      },
      quarters: {
        label: 'Crew Quarters',
        width: 520,
        station: { width: 150, height: 120, y: 400 },
        actions: () => [
          {
            key: 'quarters.transferIn',
            label: 'Transfer Crew IN (Hire)',
            playerOnly: true,
            action: () => {
              const maxCrew = MAX_CREW;
              const crewCount = Array.isArray(state.npcs) ? state.npcs.length : 0;
              if (crewCount >= maxCrew) {
                showMessage('QUARTERS', `Crew capacity reached (${maxCrew}).`);
                return;
              }

              const fee = 30;
              const candidates = ['CREW', 'TECH', 'MEDIC', 'PILOT', 'ENGINEER', 'SCIENTIST', 'QUARTERMASTER', 'SECURITY', 'SPECIALIST'];
              openPanel(
                'TRANSFER CREW IN',
                `Select a crew member to transfer in.\n\nTransport fee: ${fee} credits (you have ${Math.floor(state.credits)}).`,
                [
                  ...candidates.map((name) => ({
                    label: `Hire ${name} (${Math.floor(state.credits)}/${fee} cr)`,
                    action: () => {
                      if (state.credits < fee) {
                        showMessage('QUARTERS', fmtNeedCredits(fee));
                        return;
                      }
                      state.credits -= fee;
                      addCrewMember(name);
                      updateHUD();
                      showMessage('QUARTERS', `${name} transferred aboard.`);
                    }
                  })),
                  { label: 'Back', action: closePanel }
                ],
                { includeCancel: false }
              );
            }
          },
          {
            key: 'quarters.transferOut',
            label: 'Transfer Crew OUT (Dismiss)',
            requiredRole: ['quartermaster'],
            action: () => {
              const actor = state.ui && state.ui.actionActor ? state.ui.actionActor : 'player';
              const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
              if (npcs.length === 0) {
                if (actor === 'player') showMessage('QUARTERS', 'No crew to transfer out.');
                else queueNotification('QUARTERS', 'No crew to transfer out (AUTOMATION).');
                return;
              }

              // Automation: pick a reasonable candidate and transfer them out without opening UI.
              if (actor !== 'player') {
                const qCount = npcs.filter((n) => npcRole(n) === 'quartermaster').length;
                let candidates = npcs;
                if (qCount <= 1) {
                  candidates = npcs.filter((n) => npcRole(n) !== 'quartermaster');
                }
                if (!candidates.length) candidates = npcs;

                const rolePriority = {
                  crew: 0,
                  security: 1,
                  specialist: 2,
                  scientist: 3,
                  tech: 4,
                  engineer: 5,
                  medic: 6,
                  pilot: 7,
                  quartermaster: 8
                };

                const score = (n) => {
                  const r = npcRole(n);
                  const pri = rolePriority[r] !== undefined ? rolePriority[r] : 9;
                  const duty = n.onDuty ? 1 : 0; // prefer dismissing standby first
                  const following = n.following ? 1 : 0;
                  return pri * 10 + duty * 3 + following;
                };

                candidates.sort((a, b) => score(a) - score(b));
                const chosen = candidates[0];
                if (!chosen) return;
                removeCrewMemberById(chosen.id);
                markDirty();
                updateHUD();
                queueNotification('QUARTERS', `${chosen.name} transferred out (AUTOMATION).`);
                return;
              }

              openPanel(
                'TRANSFER CREW OUT',
                'Select a crew member to transfer out:',
                [
                  ...npcs.map((n) => ({
                    label: `Dismiss ${n.name}`,
                    danger: true,
                    action: () => {
                      removeCrewMemberById(n.id);
                      showMessage('QUARTERS', `${n.name} transferred out.`);
                    }
                  })),
                  { label: 'Back', action: closePanel }
                ],
                { includeCancel: false }
              );
            }
          },
          {
            key: 'quarters.rest',
            label: `Rest (Rations ${invGet('rations')} / 1 OR Food ${Math.round(state.food)}% / 6%)`,
            action: () => {
              const canEat = state.food >= 6 || invHas('rations', 1);
              if (!canEat) {
                showMessage('QUARTERS', `No rations available. Need 6% FOOD (have ${Math.round(state.food)}%).`);
                return;
              }
              if (invHas('rations', 1)) {
                invTake('rations', 1);
              } else {
                state.food = Math.max(0, state.food - 6);
              }
              state.morale = clamp(state.morale + 22, 0, 100);
              updateHUD();
              markDirty();
              showMessage('QUARTERS', 'Crew rested. Morale improved.');
            }
          }
        ]
      },
      fabricator: {
        label: 'Fabricator',
        width: 560,
        station: { width: 160, height: 120, y: 400 },
        actions: (station) => {
          const craftActions = [
            {
              key: 'fab.filter',
              hidden: true,
              label: `Print Filter (Ingots ${invGet('ingot')} / 1)`,
              action: () => {
                if (!invHas('ingot', 1)) return showMessage('FABRICATOR', fmtNeedInv('ingot', 1));
                invTake('ingot', 1);
                invAdd('filter', 1);
                showMessage('FABRICATOR', 'Filter fabricated.');
              }
            },
            {
              key: 'fab.medkit',
              hidden: true,
              label: `Print Medkit (Ingots ${invGet('ingot')} / 1, Scrap ${invGet('scrap')} / 1)`,
              action: () => {
                if (!invHas('ingot', 1) || !invHas('scrap', 1)) return showMessage('FABRICATOR', `Need materials. ${fmtNeedInv('ingot', 1)} ${fmtNeedInv('scrap', 1)}`);
                invTake('ingot', 1);
                invTake('scrap', 1);
                invAdd('medkit', 1);
                showMessage('FABRICATOR', 'Medkit fabricated.');
              }
            },
            {
              key: 'fab.droneParts',
              hidden: true,
              label: `Assemble Drone Parts (Scrap ${invGet('scrap')} / 2)`,
              action: () => {
                if (!invHas('scrap', 2)) return showMessage('FABRICATOR', fmtNeedInv('scrap', 2));
                invTake('scrap', 2);
                invAdd('droneParts', 1);
                showMessage('FABRICATOR', 'Drone parts assembled.');
              }
            }
          ];

          return [
            {
              label: 'Add Module',
              action: () => openFabricatorAddPanel(station.moduleUid)
            },
            {
              label: 'Remove Module',
              danger: true,
              action: () => openFabricatorRemovePanel(station.moduleUid)
            },
            {
              key: 'fab.craft',
              label: 'Fabricate Items',
              action: () => {
                const opts = craftActions.map((a) => ({
                  label: a.label,
                  action: () => executeAction(a, station, 'player')
                }));
                openPanel('FABRICATOR', 'Select an item to fabricate:', [...opts, { label: 'Back', action: () => openStationActionsPanel(station) }], { includeCancel: false });
              }
            },
            {
              label: 'Status',
              action: () => showMessage('FABRICATOR STATUS', `Available modules: ${state.modules.length}\nHull integrity: Stable\nPrinter arrays: Online`)
            },
            ...craftActions
          ];
        }
      },
      computer: {
        label: 'Ship Computer',
        width: 520,
        station: { width: 160, height: 120, y: 400 },
        actions: (station) => [
          { key: 'computer.open', label: 'Open Ship Computer', action: () => openShipComputerPanel(station) }
        ]
      }
    };

    state.coreModules = defaultModules();
    state.modules = withEndcaps(state.coreModules);
    state.modulesLayout = [];
    state.stations = [];
    state.walkBounds = { minX: 50, maxX: 750 };

    function computeModuleDisplayNames(modules) {
      const counts = new Map();
      const out = new Map();
      for (const m of modules) {
        const def = MODULE_DEFS[m.type];
        const base = def ? def.label : m.type;
        const n = (counts.get(base) || 0) + 1;
        counts.set(base, n);
        out.set(m.uid, n > 1 ? `${base} ${n}` : base);
      }
      return out;
    }

    function relayoutShip() {
      state.modules = withEndcaps(state.coreModules);

      const nameByUid = computeModuleDisplayNames(state.modules);

      const layout = [];
      let x = 0;
      for (const m of state.modules) {
        const def = MODULE_DEFS[m.type] || { label: m.type, width: 520, station: { width: 120, height: 120, y: 400 }, walkable: true };
        const w = def.width * MODULE_WIDTH_SCALE;
        layout.push({
          uid: m.uid,
          type: m.type,
          name: nameByUid.get(m.uid) || def.label,
          x,
          width: w,
          walkable: def.walkable !== false
        });
        x += w;
      }

      state.modulesLayout = layout;
      state.ship.width = Math.max(800, x);
      state.stations = buildStations(layout);

      // Compute walkable bounds (exclude endcaps).
      const firstWalkable = layout.find((m) => m.walkable);
      const lastWalkable = [...layout].reverse().find((m) => m.walkable);
      const minX = firstWalkable ? (firstWalkable.x + 50) : 50;
      const maxX = lastWalkable ? (lastWalkable.x + lastWalkable.width - 50) : (state.ship.width - 50);
      state.walkBounds = { minX, maxX };

      // Keep the player on the ship.
      state.player.x = Math.max(state.walkBounds.minX, Math.min(state.walkBounds.maxX, state.player.x));
      state.player.vx = 0;
      state.sim.snap = true;
      markDirty();

      renderShip();
      initStarfield();
      checkNearStation();
      updateLocationHUD();
      updateCamera();
      updateStarfield();
    }

    function buildStations(layout) {
      const stations = [];
      for (const module of layout) {
        const def = MODULE_DEFS[module.type];
        if (!def || !def.station) continue;
        const st = def.station;
        const interactX = module.x + module.width * 0.5;
        stations.push({
          id: `${module.uid}::station`,
          type: module.type,
          moduleUid: module.uid,
          name: module.name,
          x: interactX - st.width / 2,
          y: st.y,
          width: st.width,
          height: st.height,
          interactX,
          getActions: (station) => (def.actions ? def.actions(station) : [])
        });
      }
      return stations;
    }

    // SVG Elements
    const svg = document.getElementById('gameCanvas');

    // Background starfield (drawn behind the ship)
    const starsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    starsGroup.id = 'starsGroup';
    starsGroup.setAttribute('pointer-events', 'none');
    svg.appendChild(starsGroup);

    const shipGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    shipGroup.id = 'shipGroup';
    svg.appendChild(shipGroup);

    const npcsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    npcsGroup.id = 'npcsGroup';
    svg.appendChild(npcsGroup);

    const playerRect = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    playerRect.id = 'player';
    svg.appendChild(playerRect);

    // Initialize (load first, then layout/render)
    loadGame();
    ensureContracts();
    relayoutShip();
    renderPlayer();
    updateHUD();
    saveGame();

    function initStarfield(force = false) {
      const STAR_COUNT = 70;
      const viewWidth = 800;
      const viewHeight = 600;

      // If our vertical distribution target changed, rebuild.
      if (!force && state.starfield.height !== viewHeight) {
        force = true;
      }

      if (!force && state.starfield.stars.length) {
        // Update anchors for new ship width (world extents).
        for (const s of state.starfield.stars) {
          s.baseX = s.u * state.ship.width;
        }
        return;
      }

      const rand = mulberry32(state.starfield.seed);
      state.starfield.stars = [];
      starsGroup.innerHTML = '';
      state.starfield.height = viewHeight;

      const layers = [0.15, 0.28, 0.45];
      for (let i = 0; i < STAR_COUNT; i++) {
        const u = rand();
        const uY = rand();
        const r = 0.6 + rand() * 1.8;
        const opacity = 0.25 + rand() * 0.6;
        const layer = layers[(rand() * layers.length) | 0];
        const el = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        el.setAttribute('r', r.toFixed(2));
        el.setAttribute('fill', `rgba(255, 255, 255, ${opacity.toFixed(3)})`);
        starsGroup.appendChild(el);

        state.starfield.stars.push({ u, uY, baseX: u * state.ship.width, r, opacity, layer, el });
      }
    }

    function updateStarfield() {
      // World-extent starfield: stars are anchored across the full ship width.
      // To avoid gaps near the ends (or after ship length changes), we wrap each star
      // by choosing the nearest periodic copy to the current camera center.
      const viewWidth = 800;
      const camX = state.camera.x;
      const driftX = state.starfield.driftX;
      const period = Math.max(viewWidth, state.ship.width);
      const center = camX + viewWidth * 0.5;

      const { viewHeight, viewY } = getViewMetrics();

      const mod = (n, m) => ((n % m) + m) % m;

      for (const s of state.starfield.stars) {
        // Parallax: move slower than the ship (smaller layer => slower motion).
        const x = s.baseX + (1 - s.layer) * camX - s.layer * driftX;
        const wrapped = mod(x, period);
        const candidates = [wrapped - period, wrapped, wrapped + period];

        let best = candidates[0];
        let bestDist = Math.abs(best - center);
        for (let i = 1; i < candidates.length; i++) {
          const d = Math.abs(candidates[i] - center);
          if (d < bestDist) {
            bestDist = d;
            best = candidates[i];
          }
        }

        s.el.setAttribute('cx', best.toFixed(2));

        // Fill the current viewport height (including extra portrait space).
        const cy = viewY + (s.uY * viewHeight);
        s.el.setAttribute('cy', cy.toFixed(2));
      }
    }

    // Render Ship Interior
    function renderShip() {
      shipGroup.innerHTML = '';

      const svgNS = 'http://www.w3.org/2000/svg';
      const defs = document.createElementNS(svgNS, 'defs');
      shipGroup.appendChild(defs);

      const rearCap = state.modulesLayout.find((m) => m.type === 'rearcap');
      const noseCap = state.modulesLayout.find((m) => m.type === 'nosecap');

      // Keep interior geometry out of the endcaps.
      // The bulkhead divider wall consumes 20px at the boundary.
      const tubeStartX = rearCap ? (rearCap.x + rearCap.width + 20) : 0;
      // The nose cone tapers starting a bit into the nosecap module.
      // Keep the straight tube ceiling/floor ending at the cone base.
      const tubeEndX = noseCap ? (noseCap.x + 40) : state.ship.width;

      // Starfield is rendered in starsGroup (persistent + parallax)

      // Back wall per module (distant z-order) with window cutouts.
      const wallFillLit = 'rgb(56, 46, 28)';
      const wallFillDark = 'rgb(14, 22, 62)';
      const wallFill = state.lightsOn ? wallFillLit : wallFillDark;
      const wallFrame = state.lightsOn ? 'rgba(255, 220, 160, 0.35)' : 'rgba(120, 160, 255, 0.25)';

      for (const module of state.modulesLayout) {
        if (!module.walkable) continue;
        const wallStartX = module.x;
        const wallEndX = Math.min(module.x + module.width, tubeEndX);
        const wallW = wallEndX - wallStartX;
        if (wallW < 160) continue;

        const wallY = 80;
        const wallH = 440;
        const clampNum = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

        // Fit windows into the available wall width, evenly spaced and centered.
        let winCount = wallW >= 240 ? 2 : 1;
        let gap = winCount > 1 ? clampNum(wallW * 0.08, 16, 40) : 0;
        let sidePad = clampNum(wallW * 0.10, 18, 46);
        let winW = (wallW - sidePad * 2 - gap * (winCount - 1)) / winCount;

        // If the module is too narrow for two windows, fall back to one.
        if (winCount > 1 && winW < 70) {
          winCount = 1;
          gap = 0;
          winW = wallW - sidePad * 2;
        }

        winW = clampNum(winW, 60, 140);
        const usedW = (winCount * winW) + (gap * (winCount - 1));
        const startOffset = (wallW - usedW) / 2;
        const winXs = Array.from({ length: winCount }, (_, i) => wallStartX + startOffset + i * (winW + gap));
        const winH = 170;
        const winY = 160;
        const winRX = 14;

        const maskId = `wallmask-${module.uid}`;
        const mask = document.createElementNS(svgNS, 'mask');
        mask.id = maskId;
        mask.setAttribute('maskUnits', 'userSpaceOnUse');
        mask.setAttribute('x', wallStartX);
        mask.setAttribute('y', wallY);
        mask.setAttribute('width', wallW);
        mask.setAttribute('height', wallH);

        const maskBase = document.createElementNS(svgNS, 'rect');
        maskBase.setAttribute('x', wallStartX);
        maskBase.setAttribute('y', wallY);
        maskBase.setAttribute('width', wallW);
        maskBase.setAttribute('height', wallH);
        maskBase.setAttribute('fill', 'white');
        mask.appendChild(maskBase);

        for (const wx of winXs) {
          const hole = document.createElementNS(svgNS, 'rect');
          hole.setAttribute('x', wx);
          hole.setAttribute('y', winY);
          hole.setAttribute('width', winW);
          hole.setAttribute('height', winH);
          hole.setAttribute('rx', winRX);
          hole.setAttribute('ry', winRX);
          hole.setAttribute('fill', 'black');
          mask.appendChild(hole);
        }

        defs.appendChild(mask);

        const wall = document.createElementNS(svgNS, 'rect');
        wall.setAttribute('x', wallStartX);
        wall.setAttribute('y', wallY);
        wall.setAttribute('width', wallW);
        wall.setAttribute('height', wallH);
        wall.setAttribute('fill', wallFill);
        wall.setAttribute('mask', `url(#${maskId})`);
        shipGroup.appendChild(wall);

        // Window frames (so the cutouts read clearly)
        for (const wx of winXs) {
          const frame = document.createElementNS(svgNS, 'rect');
          frame.setAttribute('x', wx);
          frame.setAttribute('y', winY);
          frame.setAttribute('width', winW);
          frame.setAttribute('height', winH);
          frame.setAttribute('rx', winRX);
          frame.setAttribute('ry', winRX);
          frame.setAttribute('fill', 'none');
          frame.setAttribute('stroke', wallFrame);
          frame.setAttribute('stroke-width', 3);
          shipGroup.appendChild(frame);
        }
      }

      // Floor
      const floor = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      floor.setAttribute('x', tubeStartX);
      floor.setAttribute('y', 520);
      floor.setAttribute('width', Math.max(0, tubeEndX - tubeStartX));
      floor.setAttribute('height', 80);
      floor.setAttribute('fill', C.hull);
      shipGroup.appendChild(floor);

      // Floor panels
      for (let x = tubeStartX; x < tubeEndX; x += 100) {
        const panelW = Math.min(95, tubeEndX - x);
        if (panelW <= 0) break;
        const panel = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        panel.setAttribute('x', x);
        panel.setAttribute('y', 520);
        panel.setAttribute('width', panelW);
        panel.setAttribute('height', 80);
        panel.setAttribute('fill', 'none');
        panel.setAttribute('stroke', C.wall);
        panel.setAttribute('stroke-width', 2);
        shipGroup.appendChild(panel);
      }

      // Ceiling
      const ceiling = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      ceiling.setAttribute('x', tubeStartX);
      ceiling.setAttribute('y', 0);
      ceiling.setAttribute('width', Math.max(0, tubeEndX - tubeStartX));
      ceiling.setAttribute('height', 80);
      ceiling.setAttribute('fill', C.hull);
      shipGroup.appendChild(ceiling);

      // Ceiling lights
      if (state.lightsOn) {
        const ceilingLightFill = 'rgb(255, 214, 130)';
        for (let x = tubeStartX + 100; x < tubeEndX; x += 200) {
          const light = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          light.setAttribute('x', x - 20);
          light.setAttribute('y', 70);
          light.setAttribute('width', 40);
          light.setAttribute('height', 10);
          light.setAttribute('fill', ceilingLightFill);
          light.setAttribute('opacity', 0.9);
          shipGroup.appendChild(light);
        }
      }

      // Room labels
      for (const module of state.modulesLayout) {
        const roomLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        roomLabel.setAttribute('x', module.x + module.width / 2);
        roomLabel.setAttribute('y', 120);
        roomLabel.setAttribute('text-anchor', 'middle');
        roomLabel.setAttribute('fill', C.text);
        roomLabel.setAttribute('opacity', 0.35);
        roomLabel.setAttribute('font-size', '20');
        roomLabel.textContent = module.name.toUpperCase();
        shipGroup.appendChild(roomLabel);
      }

      // Render each station
      state.stations.forEach(station => {
        renderStation(station);
      });

      // Add divider walls between modules
      for (let i = 0; i < state.modulesLayout.length - 1; i++) {
        const left = state.modulesLayout[i];
        const right = state.modulesLayout[i + 1];
        const x = left.x + left.width;
        const hasDoor = left.walkable && right.walkable;

        const wall = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        wall.setAttribute('x', x);
        wall.setAttribute('y', 80);
        wall.setAttribute('width', 20);
        wall.setAttribute('height', 440);
        wall.setAttribute('fill', C.wall);
        shipGroup.appendChild(wall);

        if (hasDoor) {
          // Door in wall (walkable-to-walkable)
          const door = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          door.setAttribute('x', x + 2);
          door.setAttribute('y', 380);
          door.setAttribute('width', 16);
          door.setAttribute('height', 140);
          door.setAttribute('fill', C.hull);
          door.setAttribute('stroke', C.accent);
          door.setAttribute('stroke-width', 2);
          shipGroup.appendChild(door);
        } else {
          // Sealed bulkhead (endcap boundary)
          const seal = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          seal.setAttribute('x', x + 3);
          seal.setAttribute('y', 360);
          seal.setAttribute('width', 14);
          seal.setAttribute('height', 160);
          seal.setAttribute('fill', C.hull);
          seal.setAttribute('stroke', C.warning);
          seal.setAttribute('stroke-width', 2);
          seal.setAttribute('opacity', 0.95);
          shipGroup.appendChild(seal);

          const stripe = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          const sx = x + 4;
          const sy = 365;
          const w = 12;
          const h = 150;
          stripe.setAttribute('d', `M ${sx} ${sy + 10} L ${sx + w} ${sy} M ${sx} ${sy + 35} L ${sx + w} ${sy + 25} M ${sx} ${sy + 60} L ${sx + w} ${sy + 50} M ${sx} ${sy + 85} L ${sx + w} ${sy + 75} M ${sx} ${sy + 110} L ${sx + w} ${sy + 100} M ${sx} ${sy + 135} L ${sx + w} ${sy + 125}`);
          stripe.setAttribute('stroke', C.warning);
          stripe.setAttribute('stroke-width', 2);
          stripe.setAttribute('opacity', 0.9);
          shipGroup.appendChild(stripe);
        }
      }

      // Rear rockets visual (non-walkable)
      const rear = rearCap;
      if (rear) {
        // Rear mounting structure (so thrusters attach to something).
        const mountX = rear.x + rear.width - 52;
        const mount = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        mount.setAttribute('x', mountX);
        mount.setAttribute('y', 90);
        mount.setAttribute('width', 44);
        mount.setAttribute('height', 420);
        mount.setAttribute('rx', 10);
        mount.setAttribute('ry', 10);
        mount.setAttribute('fill', C.wall);
        mount.setAttribute('stroke', C.accent);
        mount.setAttribute('stroke-width', 2);
        mount.setAttribute('opacity', 0.95);
        shipGroup.appendChild(mount);

        for (let i = 0; i < 6; i++) {
          const bolt = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          bolt.setAttribute('cx', (mountX + 10 + (i % 2) * 24).toFixed(2));
          bolt.setAttribute('cy', (120 + Math.floor(i / 2) * 130).toFixed(2));
          bolt.setAttribute('r', '3.2');
          bolt.setAttribute('fill', C.hull);
          bolt.setAttribute('opacity', 0.95);
          shipGroup.appendChild(bolt);
        }

        const thrusterX = rear.x + 22;
        for (let i = 0; i < 3; i++) {
          const cy = 160 + i * 110 + 35;

          const strut = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          strut.setAttribute('d', `M ${mountX} ${cy} L ${thrusterX + 40} ${cy - 18} L ${thrusterX + 40} ${cy + 18} Z`);
          strut.setAttribute('fill', C.wall);
          strut.setAttribute('stroke', C.accent);
          strut.setAttribute('stroke-width', 2);
          strut.setAttribute('opacity', 0.9);
          shipGroup.appendChild(strut);

          const nozzle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          nozzle.setAttribute('x', thrusterX);
          nozzle.setAttribute('y', 160 + i * 110);
          nozzle.setAttribute('width', 40);
          nozzle.setAttribute('height', 70);
          nozzle.setAttribute('fill', C.hull);
          nozzle.setAttribute('stroke', C.warning);
          nozzle.setAttribute('stroke-width', 2);
          shipGroup.appendChild(nozzle);

          if (state.engineActive) {
            const flame = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            const fx = thrusterX;
            const fy = 160 + i * 110 + 35;
            flame.setAttribute('points', `${fx},${fy} ${fx - 55},${fy - 18} ${fx - 65},${fy} ${fx - 55},${fy + 18}`);
            flame.setAttribute('fill', C.warning);
            flame.setAttribute('opacity', 0.75);
            shipGroup.appendChild(flame);
          }
        }
      }

      // Front nose cone visual (non-walkable)
      const nose = noseCap;
      if (nose) {
        const tipX = nose.x + nose.width - 10;
        const cone = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        cone.setAttribute('points', `${nose.x + 40},80 ${tipX},220 ${tipX},380 ${nose.x + 40},520`);
        cone.setAttribute('fill', C.hull);
        cone.setAttribute('stroke', C.accent);
        cone.setAttribute('stroke-width', 2);
        cone.setAttribute('opacity', 0.9);
        shipGroup.appendChild(cone);

        const window = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
        window.setAttribute('cx', nose.x + nose.width * 0.62);
        window.setAttribute('cy', 260);
        window.setAttribute('rx', 30);
        window.setAttribute('ry', 45);
        window.setAttribute('fill', 'rgba(0, 100, 200, 0.25)');
        window.setAttribute('stroke', C.accent);
        window.setAttribute('stroke-width', 2);
        shipGroup.appendChild(window);
      }
    }

    function renderStation(station) {
      const svgNS = 'http://www.w3.org/2000/svg';
      const group = document.createElementNS(svgNS, 'g');

      const x = station.x;
      const y = station.y;
      const w = station.width;
      const h = station.height;
      const pad = Math.max(8, Math.min(12, Math.floor(Math.min(w, h) * 0.10)));

      const mk = (name, attrs = {}) => {
        const el = document.createElementNS(svgNS, name);
        for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
        return el;
      };

      const clipId = `station-clip-${station.id}`;
      const defs = mk('defs');
      const clip = mk('clipPath', { id: clipId });
      clip.appendChild(mk('rect', { x, y, width: w, height: h, rx: 10, ry: 10 }));
      defs.appendChild(clip);
      group.appendChild(defs);

      // Shadow + console frame
      group.appendChild(mk('rect', { x: x + 3, y: y + 4, width: w, height: h, rx: 10, ry: 10, fill: 'rgba(0,0,0,0.28)' }));
      group.appendChild(mk('rect', { x, y, width: w, height: h, rx: 10, ry: 10, fill: C.panel, stroke: C.accent, 'stroke-width': 2 }));

      // Inner bezel
      const innerX = x + pad;
      const innerY = y + pad;
      const innerW = w - pad * 2;
      const innerH = h - pad * 2;
      group.appendChild(mk('rect', { x: innerX, y: innerY, width: innerW, height: innerH, rx: 8, ry: 8, fill: C.hull, opacity: 0.55 }));

      // Bottom keys/controls strip
      const keysH = Math.max(18, Math.min(28, Math.floor(innerH * 0.24)));
      const keysY = innerY + innerH - keysH;
      group.appendChild(mk('rect', { x: innerX + 3, y: keysY, width: innerW - 6, height: keysH - 3, rx: 6, ry: 6, fill: C.wall, opacity: 0.9 }));

      const keyCount = Math.max(4, Math.min(7, Math.floor(innerW / 26)));
      for (let i = 0; i < keyCount; i++) {
        const kw = Math.max(10, Math.floor((innerW - 18) / keyCount) - 4);
        const kx = innerX + 10 + i * (kw + 6);
        group.appendChild(mk('rect', { x: kx, y: keysY + 7, width: kw, height: 8, rx: 2, ry: 2, fill: C.panel, opacity: 0.95 }));
      }

      // Status light
      const statusOk = (() => {
        if (station.type === 'power') return !state.incidents.powerTrip;
        if (station.type === 'life') return !state.incidents.o2Leak;
        if (station.type === 'engine') return !state.incidents.fire;
        if (station.type === 'shields') return !state.incidents.breach;
        return true;
      })();
      group.appendChild(mk('circle', {
        cx: (x + 12).toFixed(2),
        cy: (y + 12).toFixed(2),
        r: 5,
        fill: statusOk ? C.success : 'rgb(255, 85, 85)',
        opacity: state.lightsOn ? 0.95 : 0.55
      }));

      // Draw station art clipped to the console.
      const art = mk('g', { 'clip-path': `url(#${clipId})` });
      group.appendChild(art);

      const screenX = innerX + 10;
      const screenY = innerY + 10;
      const screenW = innerW - 20;
      const screenH = Math.max(10, keysY - screenY - 10);

      const addGauge = ({ gx, gy, gw, gh, pct, color }) => {
        const p = clamp(safeNumber(pct, 0), 0, 1);
        art.appendChild(mk('rect', { x: gx, y: gy, width: gw, height: gh, rx: 3, ry: 3, fill: 'rgba(0,0,0,0.35)' }));
        art.appendChild(mk('rect', { x: gx + 1, y: gy + 1, width: Math.max(0, (gw - 2) * p), height: Math.max(0, gh - 2), rx: 2, ry: 2, fill: color, opacity: state.lightsOn ? 0.9 : 0.55 }));
      };

      // Shared screen backing
      art.appendChild(mk('rect', { x: screenX, y: screenY, width: screenW, height: screenH, rx: 8, ry: 8, fill: 'rgba(20, 30, 60, 0.55)', stroke: 'rgba(255,255,255,0.18)', 'stroke-width': 1 }));

      if (station.type === 'cargo') {
        // Racks + crates
        const rackY = screenY + 10;
        const rackH = screenH - 20;
        art.appendChild(mk('rect', { x: screenX + 6, y: rackY, width: screenW - 12, height: rackH, rx: 6, ry: 6, fill: 'rgba(0,0,0,0.18)', stroke: 'rgba(255,255,255,0.12)', 'stroke-width': 1 }));
        const boxes = 3;
        for (let i = 0; i < boxes; i++) {
          const bx = screenX + 16 + i * ((screenW - 40) / boxes);
          const bw = Math.max(16, Math.min(28, (screenW - 60) / boxes));
          art.appendChild(mk('rect', { x: bx, y: rackY + 16, width: bw, height: rackH - 32, rx: 4, ry: 4, fill: C.warning, opacity: 0.85, stroke: 'rgba(0,0,0,0.35)', 'stroke-width': 1 }));
          art.appendChild(mk('path', { d: `M ${bx + 4} ${rackY + 24} L ${bx + bw - 4} ${rackY + 24} M ${bx + 4} ${rackY + 34} L ${bx + bw - 4} ${rackY + 34}`,
            stroke: 'rgba(0,0,0,0.35)', 'stroke-width': 2, opacity: 0.6 }));
        }
      } else if (station.type === 'power') {
        // Core + rings + output gauge
        const cx = screenX + screenW * 0.38;
        const cy = screenY + screenH * 0.52;
        const r0 = Math.min(22, Math.max(16, Math.min(screenW, screenH) * 0.22));
        art.appendChild(mk('circle', { cx, cy, r: r0, fill: C.accent, opacity: state.lightsOn ? 0.65 : 0.35 }));
        for (let i = 1; i <= 3; i++) {
          art.appendChild(mk('circle', { cx, cy, r: r0 + i * 10, fill: 'none', stroke: C.accent, 'stroke-width': 1, opacity: 0.22 }));
        }
        const powerPct = clamp(state.power / 150, 0, 1);
        addGauge({ gx: screenX + screenW * 0.58, gy: screenY + 18, gw: screenW * 0.34, gh: 10, pct: powerPct, color: C.accent });
        if (state.incidents.powerTrip) {
          art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.60} ${screenY + 46} L ${screenX + screenW * 0.92} ${screenY + 46}`,
            stroke: 'rgb(255, 85, 85)', 'stroke-width': 3, opacity: 0.85 }));
          art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.60} ${screenY + 56} L ${screenX + screenW * 0.92} ${screenY + 56}`,
            stroke: 'rgb(255, 85, 85)', 'stroke-width': 3, opacity: 0.55 }));
        }
      } else if (station.type === 'engine') {
        // Vents + heat/throttle gauges
        const thr = clamp(safeNumber(state.throttle, 0), 0, 1);
        const heat = clamp(state.heat / 100, 0, 1);

        const ventY = screenY + 14;
        for (let i = 0; i < 5; i++) {
          const vx = screenX + 12 + i * ((screenW - 24) / 5);
          art.appendChild(mk('rect', { x: vx, y: ventY, width: 8, height: screenH - 40, rx: 3, ry: 3, fill: 'rgba(255,255,255,0.10)' }));
        }
        addGauge({ gx: screenX + 12, gy: screenY + screenH - 20, gw: screenW - 24, gh: 9, pct: thr, color: C.warning });
        addGauge({ gx: screenX + 12, gy: screenY + screenH - 32, gw: screenW - 24, gh: 9, pct: heat, color: heat > 0.8 ? 'rgb(255, 85, 85)' : C.warning });
        if (state.engineActive) {
          const flameX = screenX + screenW * 0.80;
          const flameY = screenY + screenH * 0.58;
          art.appendChild(mk('polygon', { points: `${flameX},${flameY} ${flameX - 18},${flameY - 14} ${flameX - 24},${flameY} ${flameX - 18},${flameY + 14}`,
            fill: C.warning, opacity: 0.75 }));
        }
      } else if (station.type === 'cockpit') {
        // Viewport + nav grid
        art.appendChild(mk('rect', { x: screenX + 10, y: screenY + 10, width: screenW - 20, height: screenH * 0.52, rx: 7, ry: 7, fill: 'rgba(0, 110, 220, 0.22)', stroke: 'rgba(180,220,255,0.25)', 'stroke-width': 1 }));
        for (let i = 0; i < 6; i++) {
          const gy = screenY + 18 + i * 10;
          art.appendChild(mk('path', { d: `M ${screenX + 16} ${gy} L ${screenX + screenW - 16} ${gy}`,
            stroke: 'rgba(180,220,255,0.16)', 'stroke-width': 1 }));
        }
        for (let i = 0; i < 5; i++) {
          const gx = screenX + 20 + i * 18;
          art.appendChild(mk('path', { d: `M ${gx} ${screenY + 16} L ${gx} ${screenY + screenH * 0.52}`,
            stroke: 'rgba(180,220,255,0.10)', 'stroke-width': 1 }));
        }
      } else if (station.type === 'fabricator') {
        // Printer frame + bed + gantry
        art.appendChild(mk('rect', { x: screenX + 10, y: screenY + 10, width: screenW - 20, height: screenH - 20, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(255,255,255,0.15)', 'stroke-width': 1 }));
        const bedY = screenY + screenH - 34;
        art.appendChild(mk('rect', { x: screenX + 18, y: bedY, width: screenW - 36, height: 14, rx: 4, ry: 4, fill: C.panel, opacity: 0.95 }));
        art.appendChild(mk('rect', { x: screenX + 18, y: screenY + 20, width: screenW - 36, height: 8, rx: 4, ry: 4, fill: C.wall, opacity: 0.9 }));
        const nx = screenX + screenW * 0.52;
        art.appendChild(mk('polygon', { points: `${nx - 7},${screenY + 30} ${nx + 7},${screenY + 30} ${nx + 3},${screenY + 48} ${nx - 3},${screenY + 48}`,
          fill: C.accent, opacity: state.lightsOn ? 0.85 : 0.45 }));
        art.appendChild(mk('rect', { x: nx - 12, y: bedY - 8, width: 24, height: 10, rx: 2, ry: 2, fill: C.success, opacity: 0.75 }));
      } else if (station.type === 'life') {
        // Fan + oxygen gauge
        const cx = screenX + screenW * 0.32;
        const cy = screenY + screenH * 0.52;
        const r = Math.min(22, Math.max(16, Math.min(screenW, screenH) * 0.20));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 1 }));
        for (let i = 0; i < 4; i++) {
          const a = (i * Math.PI) / 2;
          const x1 = cx + Math.cos(a) * 2;
          const y1 = cy + Math.sin(a) * 2;
          const x2 = cx + Math.cos(a + 0.55) * r * 0.95;
          const y2 = cy + Math.sin(a + 0.55) * r * 0.95;
          art.appendChild(mk('path', { d: `M ${cx} ${cy} L ${x2} ${y2}`,
            stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 3, 'stroke-linecap': 'round', opacity: 0.75 }));
          art.appendChild(mk('circle', { cx: x1, cy: y1, r: 2.4, fill: 'rgba(255,255,255,0.35)' }));
        }
        addGauge({ gx: screenX + screenW * 0.55, gy: screenY + 24, gw: screenW * 0.36, gh: 10, pct: clamp(state.oxygen / 100, 0, 1), color: state.incidents.o2Leak ? 'rgb(255, 85, 85)' : C.success });
        if (state.incidents.o2Leak) {
          art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.56} ${screenY + 48} L ${screenX + screenW * 0.90} ${screenY + 48}`,
            stroke: 'rgb(255, 85, 85)', 'stroke-width': 3, opacity: 0.85 }));
        }
      } else if (station.type === 'hydro') {
        // Grow light + planter
        const glow = state.hydroponicsOn ? 'rgba(60, 255, 140, 0.28)' : 'rgba(255,255,255,0.10)';
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 16, width: screenW - 24, height: 10, rx: 5, ry: 5, fill: glow, opacity: 0.9 }));
        const bedY = screenY + screenH - 34;
        art.appendChild(mk('rect', { x: screenX + 14, y: bedY, width: screenW - 28, height: 16, rx: 6, ry: 6, fill: 'rgba(80,50,20,0.55)', stroke: 'rgba(255,255,255,0.12)', 'stroke-width': 1 }));
        for (let i = 0; i < 5; i++) {
          const lx = screenX + 22 + i * ((screenW - 44) / 5);
          const stemH = 18 + (i % 2) * 8;
          art.appendChild(mk('path', { d: `M ${lx} ${bedY} L ${lx} ${bedY - stemH}`,
            stroke: 'rgba(60, 255, 140, 0.55)', 'stroke-width': 3, 'stroke-linecap': 'round', opacity: state.hydroponicsOn ? 0.95 : 0.55 }));
          art.appendChild(mk('circle', { cx: lx + 4, cy: bedY - stemH + 4, r: 4, fill: 'rgba(60, 255, 140, 0.45)', opacity: state.hydroponicsOn ? 0.9 : 0.45 }));
        }
      } else if (station.type === 'medbay') {
        // Cross + heartbeat
        const cx = screenX + screenW * 0.30;
        const cy = screenY + screenH * 0.50;
        art.appendChild(mk('rect', { x: cx - 18, y: cy - 6, width: 36, height: 12, rx: 3, ry: 3, fill: C.success, opacity: 0.65 }));
        art.appendChild(mk('rect', { x: cx - 6, y: cy - 18, width: 12, height: 36, rx: 3, ry: 3, fill: C.success, opacity: 0.65 }));
        const hx0 = screenX + screenW * 0.52;
        const hy = screenY + screenH * 0.58;
        art.appendChild(mk('path', {
          d: `M ${hx0} ${hy} L ${hx0 + 10} ${hy} L ${hx0 + 16} ${hy - 10} L ${hx0 + 24} ${hy + 12} L ${hx0 + 34} ${hy} L ${hx0 + 62} ${hy}`,
          fill: 'none',
          stroke: 'rgba(180,220,255,0.55)',
          'stroke-width': 2,
          opacity: 0.85
        }));
      } else if (station.type === 'comms') {
        // Dish + signal waves
        const bx = screenX + screenW * 0.32;
        const by = screenY + screenH * 0.64;
        art.appendChild(mk('path', { d: `M ${bx - 18} ${by} Q ${bx} ${by - 26} ${bx + 18} ${by} Q ${bx} ${by + 10} ${bx - 18} ${by} Z`,
          fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 1 }));
        art.appendChild(mk('path', { d: `M ${bx} ${by} L ${bx} ${by + 18}`, stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 2, 'stroke-linecap': 'round' }));
        for (let i = 1; i <= 3; i++) {
          const r = 10 + i * 8;
          art.appendChild(mk('path', { d: `M ${bx + 20} ${by - 12} A ${r} ${r} 0 0 1 ${bx + 20} ${by + 12}`,
            fill: 'none', stroke: 'rgba(180,220,255,0.35)', 'stroke-width': 2, opacity: 0.7 }));
        }
      } else if (station.type === 'sensors') {
        // Radar scope
        const cx = screenX + screenW * 0.40;
        const cy = screenY + screenH * 0.54;
        const r = Math.min(26, Math.max(18, Math.min(screenW, screenH) * 0.24));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(0,0,0,0.25)', stroke: 'rgba(180,220,255,0.28)', 'stroke-width': 1 }));
        art.appendChild(mk('circle', { cx, cy, r: r * 0.66, fill: 'none', stroke: 'rgba(180,220,255,0.18)', 'stroke-width': 1 }));
        art.appendChild(mk('path', { d: `M ${cx - r} ${cy} L ${cx + r} ${cy} M ${cx} ${cy - r} L ${cx} ${cy + r}`,
          stroke: 'rgba(180,220,255,0.16)', 'stroke-width': 1 }));
        const unresolved = (Array.isArray(state.anomalies) ? state.anomalies.filter((a) => a && !a.resolved && a.system === currentSystem()).length : 0);
        if (unresolved > 0) {
          art.appendChild(mk('circle', { cx: cx + r * 0.35, cy: cy - r * 0.18, r: 3.4, fill: C.warning, opacity: 0.85 }));
        }
      } else if (station.type === 'shields') {
        // Hex grid + glow if enabled
        const glow = state.shieldsOn ? 'rgba(0, 160, 255, 0.18)' : 'rgba(255,255,255,0.06)';
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 12, width: screenW - 24, height: screenH - 24, rx: 8, ry: 8, fill: glow, opacity: 0.9 }));
        const gx0 = screenX + 22;
        const gy0 = screenY + 22;
        const gw = screenW - 44;
        const gh = screenH - 44;
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 4; c++) {
            const cx = gx0 + c * (gw / 4) + (r % 2) * 6;
            const cy = gy0 + r * (gh / 3);
            art.appendChild(mk('path', { d: `M ${cx} ${cy} l 6 -4 l 6 4 l 0 8 l -6 4 l -6 -4 Z`,
              fill: 'none', stroke: 'rgba(180,220,255,0.18)', 'stroke-width': 1, opacity: state.shieldsOn ? 0.7 : 0.4 }));
          }
        }
      } else if (station.type === 'refinery') {
        // Furnace + ingot chute
        const fx = screenX + screenW * 0.28;
        const fy = screenY + screenH * 0.50;
        art.appendChild(mk('rect', { x: fx - 20, y: fy - 22, width: 40, height: 44, rx: 6, ry: 6, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(255,255,255,0.18)', 'stroke-width': 1 }));
        art.appendChild(mk('rect', { x: fx - 10, y: fy - 10, width: 20, height: 20, rx: 4, ry: 4, fill: C.warning, opacity: 0.55 }));
        const ore = invGet('ore');
        const ing = invGet('ingot');
        addGauge({ gx: screenX + screenW * 0.52, gy: screenY + 18, gw: screenW * 0.38, gh: 10, pct: clamp(ore / 10, 0, 1), color: C.warning });
        addGauge({ gx: screenX + screenW * 0.52, gy: screenY + 32, gw: screenW * 0.38, gh: 10, pct: clamp(ing / 10, 0, 1), color: C.success });
      } else if (station.type === 'drones') {
        // Launch bay + drone silhouette
        art.appendChild(mk('rect', { x: screenX + 14, y: screenY + 18, width: screenW - 28, height: screenH - 36, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(255,255,255,0.14)', 'stroke-width': 1 }));
        const dx = screenX + screenW * 0.50;
        const dy = screenY + screenH * 0.50;
        art.appendChild(mk('path', { d: `M ${dx - 16} ${dy} L ${dx} ${dy - 10} L ${dx + 16} ${dy} L ${dx} ${dy + 10} Z`,
          fill: 'rgba(180,220,255,0.35)', opacity: 0.9 }));
        art.appendChild(mk('circle', { cx: dx - 20, cy: dy, r: 4, fill: 'rgba(180,220,255,0.25)' }));
        art.appendChild(mk('circle', { cx: dx + 20, cy: dy, r: 4, fill: 'rgba(180,220,255,0.25)' }));
      } else if (station.type === 'airlock') {
        // Hatch wheel
        const cx = screenX + screenW * 0.50;
        const cy = screenY + screenH * 0.54;
        const r = Math.min(24, Math.max(18, Math.min(screenW, screenH) * 0.22));
        art.appendChild(mk('circle', { cx, cy, r, fill: 'rgba(0,0,0,0.20)', stroke: 'rgba(255,255,255,0.25)', 'stroke-width': 2 }));
        art.appendChild(mk('circle', { cx, cy, r: r * 0.35, fill: 'rgba(255,255,255,0.10)' }));
        for (let i = 0; i < 6; i++) {
          const a = (i * Math.PI) / 3;
          art.appendChild(mk('path', { d: `M ${cx} ${cy} L ${(cx + Math.cos(a) * r).toFixed(2)} ${(cy + Math.sin(a) * r).toFixed(2)}`,
            stroke: 'rgba(255,255,255,0.22)', 'stroke-width': 2, opacity: 0.85 }));
        }
      } else if (station.type === 'workshop') {
        // Tools + plating
        const tx = screenX + screenW * 0.32;
        const ty = screenY + screenH * 0.52;
        art.appendChild(mk('path', { d: `M ${tx - 10} ${ty - 14} L ${tx + 8} ${ty + 4} L ${tx + 4} ${ty + 8} L ${tx - 14} ${ty - 10} Z`,
          fill: 'rgba(180,220,255,0.24)', opacity: 0.9 }));
        art.appendChild(mk('rect', { x: screenX + screenW * 0.56, y: screenY + 22, width: screenW * 0.32, height: screenH * 0.40, rx: 6, ry: 6, fill: 'rgba(255,255,255,0.08)', stroke: 'rgba(255,255,255,0.18)', 'stroke-width': 1 }));
        for (let i = 0; i < 4; i++) {
          const yy = screenY + 30 + i * 10;
          art.appendChild(mk('path', { d: `M ${screenX + screenW * 0.58} ${yy} L ${screenX + screenW * 0.86} ${yy}`,
            stroke: 'rgba(180,220,255,0.14)', 'stroke-width': 1 }));
        }
      } else if (station.type === 'quarters') {
        // Bunks
        const bx = screenX + 16;
        const by = screenY + 18;
        const bw = Math.max(28, Math.min(44, (screenW - 40) / 2));
        const bh = Math.max(16, Math.floor((screenH - 34) / 2));
        for (let r = 0; r < 2; r++) {
          for (let c = 0; c < 2; c++) {
            const xx = bx + c * (bw + 10);
            const yy = by + r * (bh + 10);
            art.appendChild(mk('rect', { x: xx, y: yy, width: bw, height: bh, rx: 6, ry: 6, fill: 'rgba(255,255,255,0.10)', stroke: 'rgba(255,255,255,0.16)', 'stroke-width': 1 }));
            art.appendChild(mk('rect', { x: xx + 6, y: yy + 6, width: 10, height: 8, rx: 3, ry: 3, fill: 'rgba(180,220,255,0.25)' }));
          }
        }
      } else if (station.type === 'computer') {
        // Terminal + knowledge panes
        art.appendChild(mk('rect', { x: screenX + 12, y: screenY + 14, width: screenW - 24, height: screenH - 28, rx: 8, ry: 8, fill: 'rgba(0,0,0,0.22)', stroke: 'rgba(180,220,255,0.20)', 'stroke-width': 1 }));

        const paneW = (screenW - 38) / 2;
        const paneH = screenH - 44;
        const leftX = screenX + 18;
        const topY = screenY + 22;
        const rightX = leftX + paneW + 10;

        art.appendChild(mk('rect', { x: leftX, y: topY, width: paneW, height: paneH, rx: 6, ry: 6, fill: 'rgba(20, 30, 60, 0.55)', stroke: 'rgba(255,255,255,0.10)', 'stroke-width': 1 }));
        art.appendChild(mk('rect', { x: rightX, y: topY, width: paneW, height: paneH, rx: 6, ry: 6, fill: 'rgba(20, 30, 60, 0.55)', stroke: 'rgba(255,255,255,0.10)', 'stroke-width': 1 }));

        for (let i = 0; i < 6; i++) {
          const yy = topY + 10 + i * 10;
          art.appendChild(mk('path', { d: `M ${leftX + 10} ${yy} L ${leftX + paneW - 10} ${yy}`,
            stroke: 'rgba(180,220,255,0.14)', 'stroke-width': 1 }));
        }
        for (let i = 0; i < 6; i++) {
          const yy = topY + 10 + i * 10;
          art.appendChild(mk('path', { d: `M ${rightX + 10} ${yy} L ${rightX + paneW - 10} ${yy}`,
            stroke: 'rgba(180,220,255,0.12)', 'stroke-width': 1 }));
        }

        // Small cursor
        art.appendChild(mk('rect', { x: rightX + 10, y: topY + paneH - 16, width: 10, height: 2, fill: C.accent, opacity: state.lightsOn ? 0.85 : 0.55 }));
      }

      // Station label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', station.x + station.width / 2);
      label.setAttribute('y', station.y - 10);
      label.setAttribute('text-anchor', 'middle');
      label.setAttribute('fill', C.accent);
      label.setAttribute('font-size', '14');
      label.textContent = station.name.toUpperCase();
      group.appendChild(label);

      shipGroup.appendChild(group);
    }

    function renderPlayer({ x = state.player.x, vx = state.player.vx, walkPhase = state.anim.walkPhase } = {}) {
      playerRect.innerHTML = '';

      const moving = Math.abs(vx) > 1;
      const walk = walkPhase;
      const dir = state.facing || 1;

      // Legs (simple walk cycle)
      const hipY = state.player.y - 4;
      const hipBaseX = x;
      const legSpread = 7;
      const thighLen = 18;
      const shinLen = 16;
      // (Per-leg swing/lift computed in addLeg)

      const legs = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      legs.setAttribute('stroke', C.text);
      legs.setAttribute('stroke-width', 3);
      legs.setAttribute('stroke-linecap', 'round');

      function addLeg(sideSign) {
        const phase = walk + (sideSign > 0 ? Math.PI : 0);
        const s = moving ? Math.sin(phase) * 8 : 0;
        const l = moving ? Math.max(0, Math.sin(phase)) * 6 : 0;

        const hipX = hipBaseX + sideSign * legSpread;
        const kneeX = hipX + s * 0.6 * dir;
        const kneeY = hipY + thighLen - l * 0.4;
        const footX = hipX + s * 1.0 * dir;
        const footY = hipY + thighLen + shinLen - l;

        const legPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        legPath.setAttribute('d', `M ${hipX} ${hipY} L ${kneeX} ${kneeY} L ${footX} ${footY}`);
        legPath.setAttribute('opacity', sideSign > 0 ? 0.95 : 0.85);
        legs.appendChild(legPath);

        const foot = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        foot.setAttribute('d', `M ${footX - 7} ${footY} L ${footX + 9} ${footY}`);
        foot.setAttribute('stroke', C.success);
        foot.setAttribute('stroke-width', 4);
        foot.setAttribute('opacity', 0.9);
        legs.appendChild(foot);
      }

      addLeg(-1);
      addLeg(1);
      playerRect.appendChild(legs);

      // Player body
      const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      body.setAttribute('x', x - state.player.width / 2);
      body.setAttribute('y', state.player.y - state.player.height);
      body.setAttribute('width', state.player.width);
      body.setAttribute('height', state.player.height);
      body.setAttribute('fill', C.success);
      body.setAttribute('stroke', C.text);
      body.setAttribute('stroke-width', 2);
      playerRect.appendChild(body);

      // Player head
      const head = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      head.setAttribute('cx', x);
      head.setAttribute('cy', state.player.y - state.player.height - 10);
      head.setAttribute('r', 15);
      head.setAttribute('fill', C.text);
      head.setAttribute('stroke', C.success);
      head.setAttribute('stroke-width', 2);
      playerRect.appendChild(head);

      // Visor
      const visor = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      visor.setAttribute('x', x - 8);
      visor.setAttribute('y', state.player.y - state.player.height - 15);
      visor.setAttribute('width', 16);
      visor.setAttribute('height', 6);
      visor.setAttribute('fill', C.accent);
      playerRect.appendChild(visor);

      // Name tag
      const tag = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      tag.setAttribute('x', x);
      tag.setAttribute('y', state.player.y - state.player.height - 30);
      tag.setAttribute('text-anchor', 'middle');
      tag.setAttribute('fill', 'rgba(255,255,255,0.55)');
      tag.setAttribute('font-size', '12');
      tag.textContent = CAPTAIN_NAME;
      playerRect.appendChild(tag);
    }

    function updateCamera(playerX = state.player.x) {
      const { viewWidth, viewHeight, viewY } = getViewMetrics();
      const targetX = playerX - viewWidth / 2;
      const maxScroll = state.ship.width - viewWidth;
      state.camera.x = Math.max(0, Math.min(maxScroll, targetX));

      svg.setAttribute('viewBox', `${state.camera.x} ${viewY} ${viewWidth} ${viewHeight}`);
    }

    function checkNearStation() {
      let near = null;
      for (const station of state.stations) {
        if (Math.abs(state.player.x - station.interactX) < 50) {
          near = station;
          break;
        }
      }

      if (near !== state.nearStation) {
        state.nearStation = near;
        updateInteractPrompt();
        updateLocationHUD();
      }
    }

    function closestNpcToCaptain(maxDist = 60) {
      if (!Array.isArray(state.npcs) || state.npcs.length === 0) return null;
      let best = null;
      let bestD = Infinity;
      for (const n of state.npcs) {
        if (!n) continue;
        const d = Math.abs(state.player.x - n.x);
        if (d < bestD) {
          bestD = d;
          best = n;
        }
      }
      if (best && bestD <= maxDist) return best;
      return null;
    }

    function checkNearNpc() {
      const near = closestNpcToCaptain(60);
      if (near !== state.nearNpc) {
        state.nearNpc = near;
        updateInteractPrompt();
      }
    }

    function updateInteractPrompt() {
      const prompt = document.getElementById('interactPrompt');
      if (state.nearStation || state.nearNpc) {
        prompt.style.display = 'block';
        const npcDist = state.nearNpc ? Math.abs(state.player.x - state.nearNpc.x) : Infinity;
        const stDist = state.nearStation ? Math.abs(state.player.x - state.nearStation.interactX) : Infinity;
        prompt.textContent = npcDist <= stDist ? 'Press ACTION to talk' : 'Press ACTION to interact';
      } else {
        prompt.style.display = 'none';
      }
    }

    function updateLocationHUD() {
      const locationText = document.getElementById('locationText');
      if (state.nearStation) {
        locationText.textContent = state.nearStation.name.toUpperCase();
      } else {
        const module = state.modulesLayout.find((m) => state.player.x >= m.x && state.player.x < (m.x + m.width));
        locationText.textContent = (module ? module.name : 'SHIP').toUpperCase();
      }
    }

    function updateHUD() {
      const setVal = (id, text, { warn = false, good = false } = {}) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.textContent = text;
        el.style.color = warn ? C.warning : (good ? C.success : C.accent);
      };

      setVal('powerLevel', Math.round(state.power) + '%', { warn: state.power <= 15, good: state.power >= 100 });
      setVal('oxygenLevel', Math.round(state.oxygen) + '%', { warn: state.oxygen <= 20, good: state.oxygen >= 80 });

      const hullPct = state.hullMax > 0 ? (state.hull / state.hullMax) * 100 : 0;
      setVal('hullLevel', `${Math.round(hullPct)}%`, { warn: hullPct <= 30, good: hullPct >= 90 });
      setVal('heatLevel', Math.round(state.heat) + '%', { warn: state.heat >= 80, good: state.heat <= 20 });

      setVal('foodLevel', Math.round(state.food) + '%', { warn: state.food <= 20, good: state.food >= 70 });
      setVal('moraleLevel', Math.round(state.morale) + '%', { warn: state.morale <= 25, good: state.morale >= 75 });

      document.getElementById('speedLevel').textContent = state.speed.toLocaleString() + ' km/s';
      setVal('creditsLevel', `${Math.floor(state.credits).toLocaleString()} cr`);
    }

    function taskLabel(task) {
      if (!task) return 'IDLE';
      return task.label || task.key || 'TASK';
    }

    function updateCrewHUD() {
      const crewText = document.getElementById('crewText');
      if (!crewText) return;
      const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
      crewText.textContent = String(npcs.length);
    }

    function npcDutyLabel(npc) {
      if (!npc) return '—';
      if (npc.following) return 'FOLLOWING';
      if (!npc.onDuty) return 'STANDBY';
      return npc.task ? 'WORKING' : 'ON DUTY';
    }

    function fmtDateTime(ts) {
      const d = new Date(Math.max(0, safeNumber(ts, Date.now())));
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    function npcById(id) {
      if (!id || !Array.isArray(state.npcs)) return null;
      return state.npcs.find((n) => n && n.id === id) || null;
    }

    function pushNpcLog(npcId, text) {
      const npc = npcById(npcId);
      if (!npc) return;
      if (!Array.isArray(npc.log)) npc.log = [];
      npc.log.push({ ts: Date.now(), text: String(text || '') });
      if (npc.log.length > 5) npc.log.splice(0, npc.log.length - 5);
      markDirty();
    }

    function openNpcMenu(npc) {
      if (!npc) return;
      state.talkingNpcId = npc.id;
      npc.paused = true;
      npc.vx = 0;
      npc.wanderTargetX = null;

      const taskLine = npc.task ? `${taskLabel(npc.task)}${npc.task.key ? ' (' + npc.task.key + ')' : ''}` : 'None';
      const desc = `Crew member: ${npc.name}\nStatus: ${npcDutyLabel(npc)}\nCurrent task: ${taskLine}`;

      const buttons = [
        {
          label: 'Recent Activity',
          action: () => {
            const entries = Array.isArray(npc.log) ? [...npc.log].slice(-5).reverse() : [];
            const lines = entries.length
              ? entries.map((e) => `${fmtDateTime(e.ts)} — ${String(e.text || '')}`).join('\n')
              : 'No recent activity.';
            openPanel(
              `${npc.name} — ACTIVITY`,
              lines,
              [{ label: 'Back', action: () => openNpcMenu(npc) }],
              { includeCancel: false }
            );
          }
        },
        { label: 'Assign Order', action: () => openNpcAssignMenu(npc) }
      ];

      if (!npc.following) {
        buttons.unshift({
          label: 'Follow Me',
          action: () => {
            npc.following = true;
            npc.onDuty = true;
            npc.task = null;
            npc.mode = 'idle';
            npc.wanderTargetX = null;
            pushNpcLog(npc.id, 'Now following the captain.');
            updateCrewHUD();
            markDirty();
            openNpcMenu(npc);
          }
        });
      } else {
        buttons.unshift({
          label: 'Stop Following',
          danger: true,
          action: () => {
            npc.following = false;
            npc.cooldownAcc = 0.4;
            pushNpcLog(npc.id, 'Stopped following the captain.');
            updateCrewHUD();
            markDirty();
            openNpcMenu(npc);
          }
        });
      }

      if (npc.onDuty) {
        buttons.push({
          label: 'Stand Down (Standby)',
          danger: true,
          action: () => {
            npc.onDuty = false;
            npc.following = false;
            npc.task = null;
            npc.mode = 'idle';
            pushNpcLog(npc.id, 'Stood down to standby.');
            updateCrewHUD();
            markDirty();
            openNpcMenu(npc);
          }
        });
      } else {
        buttons.push({
          label: 'Return to Duty',
          action: () => {
            npc.onDuty = true;
            npc.cooldownAcc = 0.4;
            pushNpcLog(npc.id, 'Returned to duty.');
            updateCrewHUD();
            markDirty();
            openNpcMenu(npc);
          }
        });
      }

      if (npc.task) {
        buttons.push({
          label: 'Cancel Current Task',
          danger: true,
          action: () => {
            npc.task = null;
            npc.mode = 'idle';
            npc.wanderTargetX = null;
            npc.cooldownAcc = 0.6;
            pushNpcLog(npc.id, 'Current task cancelled.');
            updateCrewHUD();
            markDirty();
            openNpcMenu(npc);
          }
        });
      }

      openPanel(`${npc.name}`, desc, buttons, { includeCancel: true, cancelLabel: 'End Conversation' });
    }

    function openNpcAssignMenu(npc) {
      if (!npc) return;
      const options = [];

      const powerStation = stationByType('power');
      const engineStation = stationByType('engine');
      const lifeStation = stationByType('life');
      const hydroStation = stationByType('hydro');
      const medStation = stationByType('medbay');
      const dronesStation = stationByType('drones');
      const airlockStation = stationByType('airlock');
      const shieldsStation = stationByType('shields');
      const sensorsStation = stationByType('sensors');
      const commsStation = stationByType('comms');
      const refineryStation = stationByType('refinery');
      const workshopStation = stationByType('workshop');
      const quartersStation = stationByType('quarters');

      if (powerStation) {
        options.push({ label: 'Boost Power', key: 'power.boost', stationId: powerStation.id });
        options.push({ label: state.incidents.powerTrip ? 'Reset Breakers' : 'Reset Breakers (OK)', key: 'power.reset', stationId: powerStation.id });
        options.push({ label: state.lightsOn ? 'Lights OFF' : 'Lights ON', key: 'power.toggleLights', stationId: powerStation.id });
      }
      if (engineStation) {
        options.push({ label: state.engineActive ? 'Disable Engine' : 'Enable Engine', key: 'engine.toggle', stationId: engineStation.id });
        options.push({ label: 'Vent Heat', key: 'engine.vent', stationId: engineStation.id });
      }

      if (lifeStation) {
        options.push({ label: state.lifeSupportOn ? 'Life Support OFF' : 'Life Support ON', key: 'life.toggle', stationId: lifeStation.id });
        options.push({ label: 'Emergency Scrubbers', key: 'life.emergency', stationId: lifeStation.id });
        options.push({ label: state.incidents.o2Leak ? 'Seal O2 Leak' : 'Seal O2 Leak (OK)', key: 'life.seal', stationId: lifeStation.id });
      }

      if (hydroStation) {
        options.push({ label: state.hydroponicsOn ? 'Grow Lights OFF' : 'Grow Lights ON', key: 'hydro.toggle', stationId: hydroStation.id });
        options.push({ label: 'Harvest Rations', key: 'hydro.harvest', stationId: hydroStation.id });
      }

      if (medStation) {
        options.push({ label: 'Treat Crew', key: 'med.treat', stationId: medStation.id });
      }

      if (dronesStation) {
        options.push({ label: 'Launch Repair Drone', key: 'drones.repair', stationId: dronesStation.id });
        options.push({ label: 'Launch Salvage Drone', key: 'drones.salvage', stationId: dronesStation.id });
      }

      if (airlockStation) {
        options.push({ label: 'EVA Patch Hull', key: 'airlock.eva', stationId: airlockStation.id });
      }

      if (shieldsStation) {
        options.push({ label: state.shieldsOn ? 'Shields OFF' : 'Shields ON', key: 'shields.toggle', stationId: shieldsStation.id });
        options.push({ label: state.incidents.breach ? 'Seal Bulkheads' : 'Seal Bulkheads (OK)', key: 'shields.bulkhead', stationId: shieldsStation.id });
      }

      if (sensorsStation) {
        options.push({ label: 'Scan (Loot)', key: 'sensors.scan', stationId: sensorsStation.id });
      }

      if (commsStation) {
        options.push({ label: 'Open Contracts', key: 'comms.contracts', stationId: commsStation.id });
      }

      if (refineryStation) {
        options.push({ label: 'Refine Ore', key: 'refinery.refine', stationId: refineryStation.id });
      }

      if (workshopStation) {
        options.push({ label: 'Install Hull Plating', key: 'workshop.plating', stationId: workshopStation.id });
      }

      if (quartersStation) {
        options.push({ label: 'Rest', key: 'quarters.rest', stationId: quartersStation.id });
      }

      openPanel(
        `${npc.name} — ORDERS`,
        'Select an order:',
        [
          ...options.map((o) => ({
            label: 'Order: ' + o.label,
            action: () => {
              npc.onDuty = true;
              npc.following = false;
              npc.task = { key: o.key, stationId: o.stationId, label: o.label };
              npc.mode = 'task';
              npc.paused = false;
              npc.cooldownAcc = 0;
              pushNpcLog(npc.id, `Ordered: ${o.label}`);
              updateCrewHUD();
              markDirty();
              closePanel();
            }
          })),
          { label: 'Back', action: () => openNpcMenu(npc) }
        ],
        { includeCancel: false }
      );
    }

    function openPanel(title, description, buttons, { includeCancel = true, cancelLabel = 'Cancel' } = {}) {
      // Prevent NPC/background actions from interrupting the player.
      // Player is allowed to replace the current panel (nested menus).
      if (state.ui.actionActor !== 'player') {
        queueNotification(title, description);
        return;
      }

      const panel = document.getElementById('interactPanel');
      const titleEl = document.getElementById('panelTitle');
      const descEl = document.getElementById('panelDescription');
      const textareaEl = document.getElementById('panelTextarea');
      const buttonsEl = document.getElementById('panelButtons');

      titleEl.textContent = title;
      descEl.textContent = description;
      textareaEl.style.display = 'none';
      textareaEl.value = '';
      textareaEl.readOnly = true;
      buttonsEl.innerHTML = '';

      for (const b of buttons || []) {
        const btn = document.createElement('button');
        btn.className = 'panel-btn' + (b.danger ? ' danger' : '');
        btn.textContent = b.label;
        btn.addEventListener('click', () => {
          if (typeof b.action === 'function') b.action();
        });
        buttonsEl.appendChild(btn);
      }

      if (includeCancel) {
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'panel-btn';
        cancelBtn.textContent = cancelLabel;
        cancelBtn.addEventListener('click', closePanel);
        buttonsEl.appendChild(cancelBtn);
      }

      panel.style.display = 'block';
      state.ui.panelOpen = true;

      // Keyboard UX: focus the first button so Enter/Space works immediately.
      const firstBtn = buttonsEl.querySelector('button');
      if (firstBtn) {
        requestAnimationFrame(() => {
          try { firstBtn.focus(); } catch {}
        });
      }
    }

    function openShipComputerPanel(station, { tab = null } = {}) {
      const openRoot = () => {
        openPanel(
          'SHIP COMPUTER',
          'Select a section:',
          [
            { label: 'Knowledge Base', action: () => openComputerKnowledgeBaseRoot(station) },
            { label: 'Statistics', action: () => openComputerStatsRoot(station) },
            { label: 'Notifications', action: () => openComputerNotificationsRoot(station) },
            { label: 'Back', action: closePanel }
          ],
          { includeCancel: false }
        );
      };

      if (tab === 'kb') return openComputerKnowledgeBaseRoot(station);
      if (tab === 'stats') return openComputerStatsRoot(station);
      openRoot();
    }

    function openComputerNotificationsRoot(station) {
      const notes = Array.isArray(state.notifications) ? [...state.notifications] : [];
      const latest = notes.slice(-12).reverse();

      const lines = [];
      lines.push('Non-actionable log entries (NPC output, background info).');
      lines.push('Actionable alerts remain under ⚠ ALERTS.');
      lines.push('');
      lines.push(`Stored: ${notes.length}/50`);
      lines.push('');

      if (!latest.length) {
        lines.push('No notifications.');
      } else {
        for (const n of latest) {
          const when = fmtDateTime(n.ts);
          lines.push(`• ${when} — ${n.title}`);
        }
      }

      const buttons = [];
      for (const n of latest) {
        buttons.push({
          label: `${fmtDateTime(n.ts)} — ${n.title}`,
          action: () => {
            openPanel(
              `NOTICE — ${n.title}`,
              `${fmtDateTime(n.ts)}\n\n${String(n.description || '')}`,
              [
                { label: 'Back', action: () => openComputerNotificationsRoot(station) }
              ],
              { includeCancel: false }
            );
          }
        });
      }

      if (notes.length) {
        buttons.push({
          label: 'Clear Notifications',
          danger: true,
          action: () => {
            state.notifications = [];
            markDirty();
            openComputerNotificationsRoot(station);
          }
        });
      }

      buttons.push({ label: 'Back', action: () => openShipComputerPanel(station) });

      openPanel('NOTIFICATIONS', lines.join('\n'), buttons, { includeCancel: false });
    }

    function openComputerKnowledgeBaseRoot(station) {
      const intro = [
        'Onboard reference (terse).',
        'Notes:',
        '• Crew roles gate some actions for NPCs and automation.',
        '• The CAPTAIN can perform any action directly.',
        ''
      ].join('\n');

      openPanel(
        'KNOWLEDGE BASE',
        intro + 'Choose a topic:',
        [
          { label: 'Crew Roles', action: () => openComputerKnowledgeBaseCrewRoot(station) },
          { label: 'Role Gates (What needs who)', action: () => openComputerKnowledgeBaseRoleGates(station) },
          { label: 'Back', action: () => openShipComputerPanel(station) }
        ],
        { includeCancel: false }
      );
    }

    function openComputerKnowledgeBaseCrewRoot(station) {
      const roles = [
        { key: 'crew', label: 'Crew (Generalist)' },
        { key: 'tech', label: 'Tech' },
        { key: 'engineer', label: 'Engineer' },
        { key: 'scientist', label: 'Scientist' },
        { key: 'pilot', label: 'Pilot' },
        { key: 'quartermaster', label: 'Quartermaster' },
        { key: 'medic', label: 'Medic' },
        { key: 'specialist', label: 'Specialist' },
        { key: 'security', label: 'Security' }
      ];

      openPanel(
        'KNOWLEDGE BASE — CREW ROLES',
        'Select a role to view details:',
        [
          ...roles.map((r) => ({ label: r.label, action: () => openComputerKnowledgeBaseRole(station, r.key) })),
          { label: 'Back', action: () => openComputerKnowledgeBaseRoot(station) }
        ],
        { includeCancel: false }
      );
    }

    function openComputerKnowledgeBaseRole(station, role) {
      const r = String(role || 'crew').toLowerCase();
      const head = `${roleLabel(r)}\n`;

      const lines = [];
      if (r === 'crew') {
        lines.push('Generalist. Can follow orders and handle ungated actions.');
        lines.push('Good as extra hands when you already have specialists.');
      } else if (r === 'tech') {
        lines.push('Versatile systems operator.');
        lines.push('Common gates: VENT HEAT, REFINING, SENSORS actions.');
      } else if (r === 'engineer') {
        lines.push('Ship maintenance and heavy systems.');
        lines.push('Common gates: VENT HEAT, REFINING, REPAIR DRONES.');
      } else if (r === 'scientist') {
        lines.push('Exploration and anomaly work.');
        lines.push('Common gates: SENSORS actions (scan / investigate / deep scan).');
      } else if (r === 'pilot') {
        lines.push('Navigation and contract handling.');
        lines.push('Common gates: COMMUNICATIONS contracts, SALVAGE DRONES.');
      } else if (r === 'quartermaster') {
        lines.push('Logistics and trade/contracts support.');
        lines.push('Common gates: COMMUNICATIONS contracts.');
        lines.push('Also pairs well with automated supply buffers.');
      } else if (r === 'medic') {
        lines.push('Crew care and morale support.');
        lines.push('Medbay treatment uses power or medkits.');
      } else if (r === 'specialist') {
        lines.push('Operational specialist for drones and field tasks.');
        lines.push('Common gates: DRONE repairs, DRONE salvage (also needs PILOT for salvage).');
      } else if (r === 'security') {
        lines.push('Shipboard security.');
        lines.push('Currently limited use, but a solid “future-proof” hire.');
      }

      lines.push('');
      lines.push('Tip: automation can act as “any qualified on-duty crew”.');

      openPanel(
        `ROLE — ${roleLabel(r)}`,
        head + lines.join('\n'),
        [{ label: 'Back', action: () => openComputerKnowledgeBaseCrewRoot(station) }],
        { includeCancel: false }
      );
    }

    function openComputerKnowledgeBaseRoleGates(station) {
      const items = [
        { label: 'Engine: Vent Heat', req: 'ENGINEER/TECH', note: 'Reduces HEAT; helps resolve FIRE when cooled.' },
        { label: 'Airlock: EVA Patch Hull', req: 'ENGINEER/SPECIALIST', note: 'Spends OXYGEN to patch hull and resolve HULL BREACH.' },
        { label: 'Refinery: Refine Ore', req: 'ENGINEER/TECH', note: 'Turns ORE → INGOTS using POWER.' },
        { label: 'Sensors: Scan / Investigate / Deep Scan', req: 'SCIENTIST/TECH', note: 'Loot + anomalies + blueprints.' },
        { label: 'Comms: Contracts', req: 'PILOT/QUARTERMASTER', note: 'Pick/complete contracts and reputation.' },
        { label: 'Drones: Repair Drone', req: 'ENGINEER/SPECIALIST', note: 'Repairs hull/incidents using parts + power.' },
        { label: 'Drones: Salvage Drone', req: 'SPECIALIST/PILOT', note: 'Loots scrap/ore using power.' }
      ];

      const text = [
        'These are the main role-gated actions (NPCs / automation).',
        'The CAPTAIN can always do them manually.',
        '',
        ...items.map((i) => `• ${i.label}\n  Requires: ${i.req}\n  ${i.note}`)
      ].join('\n');

      openPanel(
        'KNOWLEDGE BASE — ROLE GATES',
        text,
        [{ label: 'Back', action: () => openComputerKnowledgeBaseRoot(station) }],
        { includeCancel: false }
      );
    }

    function openComputerStatsRoot(station) {
      const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
      const crewCount = npcs.length;
      const sys = currentSystem();
      const inc = [];
      if (state.incidents.powerTrip) inc.push('POWER TRIP');
      if (state.incidents.o2Leak) inc.push('O2 LEAK');
      if (state.incidents.fire) inc.push('FIRE');
      if (state.incidents.breach) inc.push('HULL BREACH');
      const incLine = inc.length ? inc.join(', ') : 'None';

      const summary = [
        `Location: ${sys}`,
        `Incidents: ${incLine}`,
        `Crew: ${crewCount}/${MAX_CREW}`,
        `Credits: ${Math.floor(state.credits)}  Reputation: ${Math.floor(state.reputation)}`,
        ''
      ].join('\n');

      openPanel(
        'STATISTICS',
        summary + 'Choose a drill-down:',
        [
          { label: 'Ship Systems', action: () => openComputerStatsSystems(station) },
          { label: 'Inventory', action: () => openComputerStatsInventory(station) },
          { label: 'Crew', action: () => openComputerStatsCrew(station) },
          { label: 'Modules', action: () => openComputerStatsModules(station) },
          { label: 'Automation', action: () => openComputerStatsAutomation(station) },
          { label: 'Back', action: () => openShipComputerPanel(station) }
        ],
        { includeCancel: false }
      );
    }

    function openComputerStatsSystems(station) {
      const thr = Math.round(clamp(safeNumber(state.throttle, 0), 0, 1) * 100);
      const hullPct = state.hullMax > 0 ? (state.hull / state.hullMax) * 100 : 0;
      const lines = [
        `Power: ${Math.round(state.power)}%`,
        `Oxygen: ${Math.round(state.oxygen)}%`,
        `Hull: ${Math.round(hullPct)}% (${Math.round(state.hull)}/${Math.round(state.hullMax)})`,
        `Heat: ${Math.round(state.heat)}%`,
        `Food: ${Math.round(state.food)}%`,
        `Morale: ${Math.round(state.morale)}%`,
        `Engine: ${state.engineActive ? 'ACTIVE' : 'IDLE'}  Throttle: ${thr}%`,
        `Speed: ${state.speed.toLocaleString()} km/s`,
        '',
        `Lights: ${state.lightsOn ? 'ON' : 'OFF'}`,
        `Life Support: ${state.lifeSupportOn ? 'ON' : 'OFF'}`,
        `Hydroponics: ${state.hydroponicsOn ? 'ON' : 'OFF'}`,
        `Shields: ${state.shieldsOn ? 'ON' : 'OFF'}`
      ];

      openPanel('STATS — SHIP SYSTEMS', lines.join('\n'), [{ label: 'Back', action: () => openComputerStatsRoot(station) }], { includeCancel: false });
    }

    function openComputerStatsInventory(station) {
      const keys = ['ore', 'scrap', 'ingot', 'filter', 'medkit', 'droneParts', 'rations'];
      const lines = ['Totals (and Available after buffers/reserves):', ''];
      for (const k of keys) {
        const total = invGet(k);
        const avail = typeof invAvailableAfterReserve === 'function' ? invAvailableAfterReserve(k) : total;
        lines.push(`${String(k).toUpperCase()}: ${total}${avail !== total ? ` (avail ${avail})` : ''}`);
      }
      openPanel('STATS — INVENTORY', lines.join('\n'), [{ label: 'Back', action: () => openComputerStatsRoot(station) }], { includeCancel: false });
    }

    function openComputerStatsCrew(station) {
      const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
      const counts = {};
      let onDuty = 0;
      let following = 0;
      for (const n of npcs) {
        const r = npcRole(n);
        counts[r] = (counts[r] || 0) + 1;
        if (n.onDuty && !n.paused) onDuty++;
        if (n.following) following++;
      }

      const lines = [
        `Crew total: ${npcs.length}/${MAX_CREW}`,
        `On duty: ${onDuty}`,
        `Following: ${following}`,
        '',
        'By role:'
      ];

      const roleKeys = [...new Set(Object.keys(counts))].sort();
      for (const r of roleKeys) lines.push(`${roleLabel(r)}: ${counts[r]}`);

      lines.push('', 'Roster:');
      for (const n of npcs.slice(0, 14)) {
        lines.push(`• ${n.name} — ${roleLabel(npcRole(n))} — ${npcDutyLabel(n)}`);
      }
      if (npcs.length > 14) lines.push(`• …and ${npcs.length - 14} more`);

      openPanel('STATS — CREW', lines.join('\n'), [{ label: 'Back', action: () => openComputerStatsRoot(station) }], { includeCancel: false });
    }

    function openComputerStatsModules(station) {
      const mods = Array.isArray(state.modulesLayout) ? state.modulesLayout : [];
      const counts = {};
      for (const m of mods) {
        if (!m) continue;
        const t = String(m.type || 'unknown');
        if (isEndcapType(t)) continue;
        counts[t] = (counts[t] || 0) + 1;
      }

      const lines = ['Installed modules (core):', ''];
      const types = Object.keys(counts).sort((a, b) => {
        const la = MODULE_DEFS[a] ? MODULE_DEFS[a].label : a;
        const lb = MODULE_DEFS[b] ? MODULE_DEFS[b].label : b;
        return la.localeCompare(lb);
      });
      for (const t of types) {
        const label = MODULE_DEFS[t] ? MODULE_DEFS[t].label : t;
        lines.push(`${label}: ${counts[t]}`);
      }

      lines.push('', 'Layout:');
      for (const m of mods.slice(0, 12)) lines.push(`• ${m.name}`);
      if (mods.length > 12) lines.push(`• …and ${mods.length - 12} more`);

      openPanel('STATS — MODULES', lines.join('\n'), [{ label: 'Back', action: () => openComputerStatsRoot(station) }], { includeCancel: false });
    }

    function openComputerStatsAutomation(station) {
      ensureCrewAI();
      const b = state.crewAI && state.crewAI.buffers ? state.crewAI.buffers : {};
      const lines = [
        `Automation: ${state.crewAI.enabled ? 'ON' : 'OFF'}`,
        `Auto Travel: ${state.crewAI.autoTravel ? 'ON' : 'OFF'}`,
        `Auto Contracts: ${state.crewAI.autoContracts ? 'ON' : 'OFF'}`,
        `Auto Research: ${state.crewAI.autoResearch ? 'ON' : 'OFF'}`,
        `Auto Build: ${state.crewAI.autoBuild ? 'ON' : 'OFF'}`,
        `Auto Vent Heat: ${state.crewAI.autoVentHeat ? 'ON' : 'OFF'}`,
        `Auto Hire: ${state.crewAI.autoHire ? 'ON' : 'OFF'} (target ${state.crewAI.targetCrew})`,
        '',
        'Buffers (reserved):',
        `ORE ${Math.floor(safeNumber(b.ore, 0))}, SCRAP ${Math.floor(safeNumber(b.scrap, 0))}, INGOT ${Math.floor(safeNumber(b.ingot, 0))}`,
        `FILTER ${Math.floor(safeNumber(b.filter, 0))}, MEDKIT ${Math.floor(safeNumber(b.medkit, 0))}, PARTS ${Math.floor(safeNumber(b.droneParts, 0))}, RATIONS ${Math.floor(safeNumber(b.rations, 0))}`
      ];

      openPanel('STATS — AUTOMATION', lines.join('\n'), [{ label: 'Back', action: () => openComputerStatsRoot(station) }], { includeCancel: false });
    }

    function showMessage(title, description) {
      // NPC/background actions must never steal the player's modal flow.
      // Route their output to the Ship Computer's Notifications instead.
      const actor = state && state.ui ? state.ui.actionActor : 'player';
      if (actor && actor !== 'player') {
        queueNotification(title, description);
        return;
      }
      openPanel(title, description, [{ label: 'Close', action: closePanel }], { includeCancel: false });
    }

    function queueNotification(title, description) {
      if (!state.notifications) state.notifications = [];
      state.notifications.push({ ts: Date.now(), title: String(title || 'NOTICE'), description: String(description || '') });
      if (state.notifications.length > 50) state.notifications.splice(0, state.notifications.length - 50);
      updateAlertsButton();
      markDirty();
    }

    function queueEvent(evt) {
      if (!state.events) state.events = { queue: [], active: null };
      if (!Array.isArray(state.events.queue)) state.events.queue = [];
      state.events.queue.push({ ...evt, ts: Date.now() });
      if (state.events.queue.length > 20) state.events.queue.splice(0, state.events.queue.length - 20);
      updateAlertsButton();
      markDirty();
    }

    function pendingAlertsCount() {
      const n2 = state.events && Array.isArray(state.events.queue) ? state.events.queue.length : 0;
      return n2;
    }

    function updateAlertsButton() {
      const btn = document.getElementById('alertsBtn');
      if (!btn) return;
      const n = pendingAlertsCount();
      btn.textContent = n > 0 ? `⚠ ALERTS (${n})` : '⚠ ALERTS';
      btn.style.borderColor = n > 0 ? C.warning : C.accent;
    }

    function openAlertsPanel() {
      const evts = state.events && Array.isArray(state.events.queue) ? [...state.events.queue].slice(-5).reverse() : [];

      const lines = [];
      lines.push('Actionable alerts only.');
      lines.push('');

      if (evts.length) {
        lines.push('EVENTS:');
        for (const e of evts) lines.push(`• ${e.title}`);
      } else {
        lines.push('No actionable alerts.');
      }

      const buttons = [];

      if (evts.length) {
        buttons.push({
          label: 'Resolve Latest Event',
          action: () => {
            const e = state.events.queue.pop();
            updateAlertsButton();
            if (e) openEventPanel(e);
            else openAlertsPanel();
          }
        });
      }

      buttons.push({ label: 'Close', action: closePanel });
      openPanel('ALERTS', lines.join('\n'), buttons, { includeCancel: false });
    }

    function openEventPanel(e) {
      if (!e) return openAlertsPanel();
      const title = e.title || 'EVENT';
      const desc = e.description || '';
      const choices = Array.isArray(e.choices) ? e.choices : [];
      const buttons = choices.map((c) => ({
        label: c.label,
        danger: !!c.danger,
        action: () => {
          try { if (typeof c.apply === 'function') c.apply(); } catch {}
          updateHUD();
          updateCrewHUD();
          updateAlertsButton();
          showMessage(title, c.result || 'Done.');
        }
      }));
      buttons.push({ label: 'Back to Alerts', action: openAlertsPanel });
      openPanel(title, desc, buttons, { includeCancel: false });
    }

    function onActionExecuted(meta) {
      // If the player does the NPC's current job, the NPC should immediately stand down.
      if (!Array.isArray(state.npcs) || state.npcs.length === 0) return;

      // Record NPC activity for the conversation "Recent Activity" view.
      if (meta && meta.actor && meta.actor !== 'player' && meta.actor !== 'npc-auto') {
        const npc = npcById(meta.actor);
        if (npc) {
          const st = meta.stationId ? (state.stations || []).find((s) => s && s.id === meta.stationId) : null;
          const where = st && st.name ? ` @ ${st.name}` : '';
          const what = meta.label || meta.key || 'ACTION';
          pushNpcLog(npc.id, `${what}${where}`);
        }
      }

      for (const npc of state.npcs) {
        if (!npc || !npc.task) continue;
        if (npc.task.key && meta && meta.key && npc.task.key !== meta.key) continue;
        if (npc.task.stationId && meta && meta.stationId && npc.task.stationId !== meta.stationId) continue;
        npc.task = null;
        npc.mode = 'idle';
        npc.wanderTargetX = null;
        npc.idleAcc = 0;
        npc.cooldownAcc = 0.6;
      }
      updateCrewHUD();
    }

    function executeAction(action, station, actor = 'player') {
      if (!action || typeof action.action !== 'function') return;

      if (action.playerOnly && actor !== 'player') {
        queueNotification('RESTRICTED ACTION', 'Only the captain can perform that action.');
        return;
      }

      if (!actorMeetsRoleRequirement(actor, action.requiredRole)) {
        const need = formatRequiredRoles(action.requiredRole);
        if (actor === 'npc-auto') {
          queueNotification('SKILL REQUIRED', `Automation needs: ${need}.`);
        } else {
          const npc = Array.isArray(state.npcs) ? state.npcs.find((n) => n && n.id === actor) : null;
          const who = npc ? npc.name : 'CREW';
          queueNotification('SKILL REQUIRED', `${who} lacks required skill: ${need}.`);
        }
        return;
      }

      const prevActor = state.ui.actionActor;
      state.ui.actionActor = actor || 'player';
      try {
        action.action();
      } finally {
        state.ui.actionActor = prevActor || 'player';
      }

      onActionExecuted({
        actor,
        key: action.key || null,
        label: action.label || null,
        stationId: station && station.id ? station.id : null,
        moduleUid: station && station.moduleUid ? station.moduleUid : null
      });
    }

    function openTextPanel(title, description, value, {
      readOnly = true,
      placeholder = '',
      buttons = [],
      includeCancel = true,
      cancelLabel = 'Close'
    } = {}) {
      openPanel(title, description, buttons, { includeCancel, cancelLabel });
      const textareaEl = document.getElementById('panelTextarea');
      textareaEl.style.display = 'block';
      textareaEl.readOnly = !!readOnly;
      textareaEl.placeholder = placeholder;
      textareaEl.value = value || '';
      requestAnimationFrame(() => {
        try { textareaEl.focus(); textareaEl.select(); } catch {}
      });
    }

    async function copyToClipboard(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch {
        // ignore
      }

      try {
        const textareaEl = document.getElementById('panelTextarea');
        textareaEl.focus();
        textareaEl.select();
        return document.execCommand('copy');
      } catch {
        return false;
      }
    }

    function openGameMenu() {
      openPanel(
        'GAME MENU',
        'Manage your save data:',
        [
          {
            label: 'New Game',
            danger: true,
            action: () => {
              openPanel(
                'NEW GAME',
                'Start a new game? This will clear the current save.',
                [
                  { label: 'Start New Game', danger: true, action: newGame },
                  { label: 'Back', action: openGameMenu }
                ],
                { includeCancel: false }
              );
            }
          },
          { label: 'Export JSON', action: openExportPanel },
          { label: 'Import JSON', action: openImportPanel },
          { label: 'Exit Game', danger: true, action: () => { window.location.href = 'index.html'; } }
        ],
        { includeCancel: true, cancelLabel: 'Close' }
      );
    }

    function newGame() {
      try {
        localStorage.removeItem(STORAGE_KEY_V2);
        localStorage.removeItem(STORAGE_KEY_LEGACY);
      } catch {
        // ignore
      }

      // Minimal starting ship: Fabricator only (endcaps auto-attached).
      state.coreModules = [
        { uid: newUid(), type: 'cargo' },
        { uid: newUid(), type: 'power' },
        { uid: newUid(), type: 'engine' },
        { uid: newUid(), type: 'life' },
        { uid: newUid(), type: 'hydro' },
        { uid: newUid(), type: 'quarters' },
        { uid: newUid(), type: 'computer' },
        { uid: newUid(), type: 'fabricator' },
        { uid: newUid(), type: 'cockpit' }
      ];
      state.player.x = 400;
      state.facing = 1;
      state.player.vx = 0;

      state.power = 100;
      state.oxygen = 100;
      state.hullMax = 100;
      state.hull = 100;
      state.heat = 0;
      state.food = 100;
      state.morale = 100;
      state.credits = 0;
      state.reputation = 0;
      state.speed = 0;
      state.engineActive = false;
      state.throttle = 0;
      state.location = { system: 'SOL' };
      state.travel = { active: false, from: 'SOL', to: null, remaining: 0, total: 0 };
      state.powerProfile = 'balanced';
      state.anomalies = [];
      state.blueprints = { modules: {}, recipes: {} };
      ensureBlueprints();
      state.lightsOn = true;
      state.shieldsOn = false;
      state.lifeSupportOn = true;
      state.hydroponicsOn = false;
      state.inventory = { ore: 0, scrap: 0, ingot: 0, filter: 1, medkit: 0, droneParts: 0, rations: 0 };
      state.incidents = { powerTrip: false, o2Leak: false, fire: false, breach: false };
      state.contract = { available: [], active: null };
      state.events = { queue: [], active: null };
      state.notifications = [];
      updateAlertsButton();

      state.meta = { inventoryAcc: 0, powerShedAt: 0, autoAt: 0 };

      state.anim.walkPhase = 0;
      state.starfield.seed = (Math.random() * 0xffffffff) >>> 0;
      state.starfield.driftX = 0;
      state.starfield.stars = [];

      state.nearNpc = null;
      state.talkingNpcId = null;
      state.npcs = [
        {
          id: 'npc-1',
          name: 'ENSIGN',
          role: 'tech',
          x: 320,
          y: 490,
          width: 28,
          height: 58,
          speed: 220,
          vx: 0,
          facing: 1,
          anim: { walkPhase: 0 },
          mode: 'idle',
          task: null,
          thinkAcc: 0,
          idleAcc: 0,
          wanderTargetX: null,
          cooldownAcc: 0,
          onDuty: true,
          paused: false,
          following: false
        }
      ];

      state.sim.snap = true;
      markDirty();

      relayoutShip();
      renderShip();
      initStarfield(true);
      updateHUD();
      updateCamera();
      updateStarfield();
      checkNearStation();
      checkNearNpc();
      updateLocationHUD();
      updateCrewHUD();
      saveGame();

      showMessage('NEW GAME', 'New game started.');
    }

    function openExportPanel() {
      const json = JSON.stringify(getSaveData(), null, 2);
      openTextPanel(
        'EXPORT JSON',
        'Copy this JSON to back up your save:',
        json,
        {
          readOnly: true,
          buttons: [
            {
              label: 'Copy',
              action: async () => {
                const ok = await copyToClipboard(json);
                showMessage('EXPORT JSON', ok ? 'Copied to clipboard.' : 'Copy failed. You can still select and copy manually.');
              }
            }
          ],
          includeCancel: true,
          cancelLabel: 'Close'
        }
      );
    }

    function openImportPanel() {
      openTextPanel(
        'IMPORT JSON',
        'Paste a previously exported JSON save, then tap Import:',
        '',
        {
          readOnly: false,
          placeholder: '{ "v": 2, ... }',
          buttons: [
            {
              label: 'Import',
              danger: true,
              action: () => {
                const raw = document.getElementById('panelTextarea').value;
                importFromJSON(raw);
              }
            }
          ],
          includeCancel: true,
          cancelLabel: 'Cancel'
        }
      );
    }

    function importFromJSON(raw) {
      let loaded;
      try {
        loaded = JSON.parse(raw);
      } catch (e) {
        showMessage('IMPORT JSON', 'Invalid JSON.');
        return;
      }

      if (!loaded || loaded.v !== 2) {
        showMessage('IMPORT JSON', 'Unsupported save format. Please import a JSON exported from this game.');
        return;
      }

      try {
        localStorage.setItem(STORAGE_KEY_V2, JSON.stringify(loaded));
      } catch (e) {
        showMessage('IMPORT JSON', 'Failed to store the save (storage unavailable).');
        return;
      }

      // Reload runtime state from storage.
      loadGame();
      relayoutShip();
      renderShip();
      initStarfield(true);
      updateHUD();
      updateCamera();
      updateStarfield();
      checkNearStation();
      updateLocationHUD();
      saveGame();

      showMessage('IMPORT JSON', 'Save imported.');
    }

    function moduleIndexByUid(uid) {
      return state.coreModules.findIndex((m) => m.uid === uid);
    }

    function moduleWidthForType(type) {
      const def = MODULE_DEFS[type];
      return (def ? def.width : 520) * MODULE_WIDTH_SCALE;
    }

    function insertModuleAt(index, type) {
      if (isEndcapType(type)) {
        showMessage('FABRICATOR', 'Rockets and Nose are always present and cannot be fabricated.');
        return;
      }
      const newModule = { uid: newUid(), type };
      const layoutBefore = state.modulesLayout;
      const combinedIndex = Math.max(0, Math.min(layoutBefore.length - 1, index + 1));
      const insertionX = layoutBefore[combinedIndex] ? layoutBefore[combinedIndex].x : 0;
      const insertedWidth = moduleWidthForType(type);

      if (state.player.x >= insertionX) {
        state.player.x += insertedWidth;
      }

      state.coreModules.splice(index, 0, newModule);
      relayoutShip();
      markDirty();
      saveGame();
    }

    function removeModuleByUid(uid) {
      if (uid === END_CAPS.rear.uid || uid === END_CAPS.front.uid) {
        showMessage('FABRICATOR', 'End modules cannot be removed.');
        return;
      }

      if (state.coreModules.length <= 1) {
        showMessage('FABRICATOR', 'Cannot remove the last module.');
        return;
      }

      const idx = moduleIndexByUid(uid);
      if (idx < 0) return;

      const layoutBefore = state.modulesLayout;
      const removedLayout = layoutBefore.find((m) => m.uid === uid);
      if (removedLayout) {
        const removedStart = removedLayout.x;
        const removedEnd = removedLayout.x + removedLayout.width;

        if (state.player.x >= removedEnd) {
          state.player.x -= removedLayout.width;
        } else if (state.player.x >= removedStart && state.player.x < removedEnd) {
          state.player.x = Math.max(50, removedStart - 30);
        }
      }

      state.coreModules.splice(idx, 1);
      relayoutShip();
      markDirty();
      saveGame();
    }

    function openFabricatorAddPanel(fabricatorUid) {
      const types = Object.keys(MODULE_DEFS)
        .filter((t) => !isEndcapType(t))
        .sort((a, b) => {
          const la = MODULE_DEFS[a] ? MODULE_DEFS[a].label : a;
          const lb = MODULE_DEFS[b] ? MODULE_DEFS[b].label : b;
          return la.localeCompare(lb);
        });

      const unlockedCount = types.reduce((n, t) => n + (isModuleUnlocked(t) ? 1 : 0), 0);

      openPanel(
        'FABRICATOR',
        `Select a module to fabricate:\nUnlocked: ${unlockedCount}/${types.length}\n\nLocked modules require blueprints (find anomalies / scan).`,
        types.map((t) => {
          const label = MODULE_DEFS[t] ? MODULE_DEFS[t].label : t;
          const count = countCoreModulesByType(t);
          const labelWithCount = `${label} (${count})`;
          const unlocked = isModuleUnlocked(t);
          return {
            label: unlocked ? `Fabricate ${labelWithCount}` : `Fabricate ${labelWithCount} [LOCKED]`,
            action: () => {
              if (!unlocked) {
                showMessage('FABRICATOR', `Blueprint required: ${label}.`);
                return;
              }
              openFabricatorAddPositionPanel(fabricatorUid, t);
            }
          };
        })
      );
    }

    function openFabricatorAddPositionPanel(fabricatorUid, type) {
      const idx = moduleIndexByUid(fabricatorUid);
      if (idx < 0) return;
      const label = MODULE_DEFS[type] ? MODULE_DEFS[type].label : type;

      if (!isModuleUnlocked(type)) {
        showMessage('FABRICATOR', `Blueprint required: ${label}.`);
        return;
      }

      openPanel(
        'FABRICATOR',
        `Install ${label} where?`,
        [
          { label: 'Install to LEFT', action: () => { insertModuleAt(idx, type); showMessage('FABRICATOR', `${label} installed to the left.`); } },
          { label: 'Install to RIGHT', action: () => { insertModuleAt(idx + 1, type); showMessage('FABRICATOR', `${label} installed to the right.`); } }
        ]
      );
    }

    function openFabricatorRemovePanel(fabricatorUid) {
      const removable = state.modulesLayout.filter((m) => m.uid !== fabricatorUid && m.walkable);
      if (removable.length === 0) {
        showMessage('FABRICATOR', 'No other modules available to remove.');
        return;
      }

      openPanel(
        'FABRICATOR',
        'Select a module to remove:',
        removable.map((m) => ({
          label: 'Remove ' + m.name,
          danger: true,
          action: () => {
            removeModuleByUid(m.uid);
            showMessage('FABRICATOR', m.name + ' removed.');
          }
        }))
      );
    }

    function openStationActionsPanel(station) {
      if (!station) return;
      const actions = station.getActions ? station.getActions(station) : [];
      const visible = (actions || []).filter((a) => a && !a.hidden);
      const wrapped = visible.map((a) => {
        const fn = a.action;
        return {
          ...a,
          action: () => executeAction({ ...a, action: fn }, station, 'player')
        };
      });
      openPanel(station.name.toUpperCase(), 'Select an action:', wrapped, { includeCancel: true });
    }

    function interact() {
      const npcDist = state.nearNpc ? Math.abs(state.player.x - state.nearNpc.x) : Infinity;
      const stDist = state.nearStation ? Math.abs(state.player.x - state.nearStation.interactX) : Infinity;
      if (npcDist <= stDist && state.nearNpc) {
        openNpcMenu(state.nearNpc);
        return;
      }

      if (!state.nearStation) return;

      // The Ship Computer has its own dedicated menu (KB/Stats/Notifications).
      if (state.nearStation.type === 'computer') {
        openShipComputerPanel(state.nearStation);
        return;
      }

      openStationActionsPanel(state.nearStation);
    }

    function closePanel() {
      document.getElementById('interactPanel').style.display = 'none';
      state.ui.panelOpen = false;
      updateAlertsButton();

      if (state.talkingNpcId) {
        const npc = Array.isArray(state.npcs) ? state.npcs.find((n) => n && n.id === state.talkingNpcId) : null;
        if (npc) npc.paused = false;
        state.talkingNpcId = null;
        updateCrewHUD();
      }
    }

    window.closePanel = closePanel;

    // Game Loop
    const FIXED_FPS = 20;
    const STEP = 1 / FIXED_FPS;
    const MAX_CATCHUP_STEPS = 5;
    let lastTs = null;
    let acc = 0;

    const prev = {
      x: state.player.x,
      vx: state.player.vx,
      walkPhase: state.anim.walkPhase,
      npcs: Object.create(null)
    };

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function ensurePrevNpc(id, npc) {
      if (!prev.npcs[id]) {
        prev.npcs[id] = { x: npc.x, vx: npc.vx, walkPhase: npc.anim ? npc.anim.walkPhase : 0 };
      }
      return prev.npcs[id];
    }

    function stationByType(type) {
      return state.stations.find((s) => s.type === type);
    }

    function findActionByKey(station, key) {
      if (!station || !station.getActions || !key) return null;
      const actions = station.getActions(station) || [];
      return actions.find((a) => a && a.key === key) || null;
    }

    function npcRole(npc) {
      if (!npc) return 'crew';
      if (typeof npc.role === 'string' && npc.role) return npc.role;
      return inferRoleFromName(npc.name);
    }

    function formatRequiredRoles(requiredRole) {
      if (!requiredRole) return '';
      const roles = Array.isArray(requiredRole) ? requiredRole : [requiredRole];
      return roles.map((r) => roleLabel(r)).join('/');
    }

    function actorMeetsRoleRequirement(actor, requiredRole) {
      if (!requiredRole) return true;
      const req = Array.isArray(requiredRole) ? requiredRole : [requiredRole];
      if (actor === 'player') return true;

      // Automation means "any qualified on-duty crew exists".
      if (actor === 'npc-auto') {
        return req.some((r) => hasCrewRole(r));
      }

      if (!Array.isArray(state.npcs)) return false;
      const npc = state.npcs.find((n) => n && n.id === actor);
      if (!npc) return false;
      return req.includes(npcRole(npc));
    }

    function hasCrewRole(role) {
      if (!Array.isArray(state.npcs)) return false;
      return state.npcs.some((n) => n && n.onDuty && !n.paused && npcRole(n) === role);
    }

    function anyOnDutyCrew() {
      if (!Array.isArray(state.npcs)) return false;
      return state.npcs.some((n) => n && n.onDuty && !n.paused);
    }

    function activeContractNeeds() {
      const c = state.contract && state.contract.active ? state.contract.active : null;
      if (!c || !c.requires || typeof c.requires !== 'object') return null;
      const needs = {};
      for (const k of Object.keys(c.requires)) {
        const need = Math.max(0, safeNumber(c.requires[k], 0));
        const have = invAvailableAfterReserve(k);
        const missing = Math.max(0, need - have);
        if (missing > 0) needs[k] = missing;
      }
      return needs;
    }

    function ensureModuleBuiltIfUnlocked(type, source = 'CREW') {
      if (hasModule(type)) return true;
      if (!isModuleUnlocked(type)) return false;
      if (!hasModule('fabricator')) return false;
      // Add near the end of the core list.
      insertModuleAt(state.coreModules.length, type);
      queueNotification('FABRICATOR', `${MODULE_DEFS[type] ? MODULE_DEFS[type].label : type} fabricated (${String(source)}).`);
      return true;
    }

    function crewAutomationTick() {
      // A small "brain" that makes progress even if nobody is physically at the station yet.
      if (!anyOnDutyCrew()) return;
      ensureCrewAI();
      if (!state.crewAI.enabled) return;
      const now = Date.now();
      if (safeNumber(state.meta.autoAt, 0) + 1200 > now) return;
      state.meta.autoAt = now;

      ensureContracts();

      // Basic supply-chain automation: keep a small ingot buffer so contracts/repairs don't stall.
      if (state.crewAI.autoBuild || state.crewAI.autoContracts || state.crewAI.autoResearch) {
        const ingots = invGet('ingot');
        const ore = invGet('ore');

        // If we're low on ore, do a quick loot scan (requires SCIENTIST/TECH).
        if (ingots < 4 && ore < 2 && hasModule('sensors') && state.power >= 8) {
          const st = stationByType('sensors');
          const a = st ? findActionByKey(st, 'sensors.scan') : null;
          if (st && a) executeAction(a, st, 'npc-auto');
        }

        // If we have ore, refine it (requires ENGINEER/TECH).
        if (ingots < 6 && ore >= 2 && hasModule('refinery') && state.power >= 10) {
          const st = stationByType('refinery');
          const a = st ? findActionByKey(st, 'refinery.refine') : null;
          if (st && a) executeAction(a, st, 'npc-auto');
        }
      }

      // Quartermaster: manage crew size toward a target roster.
      if (state.crewAI.autoHire) {
        const fee = 30;
        const npcs = Array.isArray(state.npcs) ? state.npcs.filter(Boolean) : [];
        const crewCount = npcs.length;
        const target = clamp(Math.floor(safeNumber(state.crewAI.targetCrew, 0)), 0, MAX_CREW);

        // If we're above target, transfer crew out (requires QUARTERMASTER + quarters).
        if (crewCount > target && hasModule('quarters')) {
          const st = stationByType('quarters');
          const a = st ? findActionByKey(st, 'quarters.transferOut') : null;
          if (st && a) {
            executeAction(a, st, 'npc-auto');
            return;
          }
        }

        if (crewCount < target && crewCount < MAX_CREW && state.credits >= fee) {
          const counts = {};
          for (const n of npcs) {
            const r = npcRole(n);
            counts[r] = (counts[r] || 0) + 1;
          }
          const need = (r) => (counts[r] || 0) <= 0;
          let hire = 'CREW';
          if (need('pilot')) hire = 'PILOT';
          else if (need('tech')) hire = 'TECH';
          else if (need('medic')) hire = 'MEDIC';
          else if (need('engineer')) hire = 'ENGINEER';
          else if (need('scientist')) hire = 'SCIENTIST';
          else if (need('quartermaster')) hire = 'QUARTERMASTER';
          else if (need('security')) hire = 'SECURITY';
          else if ((counts.specialist || 0) < Math.max(1, Math.floor(target / 6))) hire = 'SPECIALIST';

          state.credits -= fee;
          addCrewMember(hire);
          queueNotification('QUARTERS', `${hire} transferred aboard (AUTOMATION).`);
          updateHUD();
        }
      }

      if (state.crewAI.autoBuild || state.crewAI.autoResearch) {
        // Ensure we can always do research/scans.
        ensureModuleBuiltIfUnlocked('sensors', 'AUTOMATION');
      }

      if (state.crewAI.autoBuild) {
        // If we have new blueprints, install modules to expand capabilities.
        const desired = ['drones', 'refinery', 'workshop', 'comms', 'shields', 'medbay', 'airlock'];
        for (const t of desired) {
          if (ensureModuleBuiltIfUnlocked(t, 'AUTOMATION')) {
            // Only do one install per automation tick.
            break;
          }
        }
      }

      // Pilot: manage contracts.
      if (state.crewAI.autoContracts && hasCrewRole('pilot')) {
        const active = state.contract && state.contract.active ? state.contract.active : null;
        if (active) {
          if (contractReady(active, { respectReserve: true })) {
            applyContractCompletion(active, { respectReserve: true });
            state.contract.active = null;
            ensureContracts();
            queueNotification('CONTRACT', 'Contract completed (AUTOMATION).');
          }
        } else {
          const list = Array.isArray(state.contract.available) ? state.contract.available.filter(Boolean) : [];
          if (list.length) {
            // Choose the contract that's closest to ready.
            let best = list[0];
            let bestScore = Infinity;
            for (const c of list) {
              let score = 0;
              for (const [k, v] of Object.entries(c.requires || {})) {
                const need = Math.max(0, safeNumber(v, 0));
                const have = invAvailableAfterReserve(k);
                score += Math.max(0, need - have);
              }
              if (score < bestScore) {
                bestScore = score;
                best = c;
              }
            }
            state.contract.active = best;
            state.contract.available = (state.contract.available || []).filter((x) => x && x.id !== best.id);
            markDirty();
            queueNotification('CONTRACT', `Accepted: ${best.title} (AUTOMATION).`);
          }
        }
      }

      // Pilot: travel toward the nearest unresolved anomaly (or roam).
      if (state.crewAI.autoTravel && hasCrewRole('pilot')) {
        const t = state.travel && typeof state.travel === 'object' ? state.travel : { active: false };
        const safeToTravel = !anyActiveIncident() && state.oxygen >= 20 && state.power >= 12 && state.hull >= Math.max(10, state.hullMax * 0.5);
        if (!t.active && safeToTravel && hasModule('engine')) {
          const sys = currentSystem();
          const unresolved = Array.isArray(state.anomalies)
            ? state.anomalies.filter((a) => a && !a.resolved && typeof a.system === 'string' && a.system.length).map((a) => a.system.toUpperCase())
            : [];
          const targets = [...new Set(unresolved)].filter((s) => s !== sys);

          let destination = null;
          if (targets.length) {
            let best = null;
            let bestDist = Infinity;
            for (const cand of targets) {
              const path = findShortestPath(sys, cand);
              if (!path || path.length < 2) continue;
              // Estimate distance by summing edge weights along the path.
              let sum = 0;
              for (let i = 0; i < path.length - 1; i++) {
                const w = distanceBetween(path[i], path[i + 1]);
                sum += Number.isFinite(w) ? w : 0;
              }
              if (sum < bestDist) {
                bestDist = sum;
                best = cand;
              }
            }
            destination = best;
          }

          if (!destination) {
            const dests = listDestinations(sys);
            if (dests.length) destination = dests[(Math.random() * dests.length) | 0];
          }

          if (destination && destination !== sys) {
            const path = findShortestPath(sys, destination);
            const nextHop = path && path.length >= 2 ? path[1] : null;
            if (nextHop) {
              if (!state.engineActive) {
                state.engineActive = true;
                queueNotification('NAVIGATION', 'Engine activated (AUTOMATION).');
              }
              state.throttle = clamp(Math.max(0.6, safeNumber(state.throttle, 0)), 0, 1);
              startTravelAuto(nextHop, 'AUTOMATION');
              updateHUD();
            }
          }
        }
      }

      // Tech: if anything is locked, run blueprint research when we can afford it.
      if (state.crewAI.autoResearch) {
        const hasLockedTech = listLockedAdvancedModuleTypes().length > 0 || !state.blueprints.recipes.plating;
        if (hasLockedTech && hasModule('sensors') && state.power >= 12 && invHas('scrap', 2)) {
          const st = stationByType('sensors');
          const a = st ? findActionByKey(st, 'sensors.deepScan') : null;
          if (st && a) executeAction(a, st, 'npc-auto');
        }
      }
    }

    function pickNpcTask(npc) {
      if (!npc || !npc.onDuty || npc.following) return null;
      const role = npcRole(npc);
      const powerStation = stationByType('power');
      const engineStation = stationByType('engine');
      const lifeStation = stationByType('life');
      const hydroStation = stationByType('hydro');
      const medStation = stationByType('medbay');
      const dronesStation = stationByType('drones');
      const airlockStation = stationByType('airlock');
      const shieldsStation = stationByType('shields');
      const sensorsStation = stationByType('sensors');
      const refineryStation = stationByType('refinery');
      const workshopStation = stationByType('workshop');
      const fabStation = stationByType('fabricator');

      const needs = activeContractNeeds();
      const wantsIngots = (needs && needs.ingot > 0)
        || (state.blueprints.recipes.plating && state.hullMax < 150 && invGet('ingot') < 2)
        || invGet('ingot') < 4;
      const wantsMedkits = (needs && needs.medkit > 0) || (role === 'medic' && invGet('medkit') < 1 && invGet('scrap') >= 1);
      const wantsFilters = (needs && needs.filter > 0) || (invGet('filter') < 1);
      const wantsScrap = (needs && needs.scrap > 0) || invGet('scrap') < 6;
      const wantsOre = (needs && needs.ore > 0) || (wantsIngots && invGet('ore') < 4);
      const autoVentHeat = !!(state.crewAI && state.crewAI.autoVentHeat);

      // Emergencies first.
      if (engineStation) {
        const vent = findActionByKey(engineStation, 'engine.vent');
        if (vent && actorMeetsRoleRequirement(npc.id, vent.requiredRole)) {
          if (state.incidents.fire) {
            return { key: 'engine.vent', stationId: engineStation.id, label: 'Vent Heat' };
          }
          // Keep heat below the point where it starts damaging hull.
          if (autoVentHeat && safeNumber(state.heat, 0) >= 85) {
            return { key: 'engine.vent', stationId: engineStation.id, label: 'Vent Heat' };
          }
        }
      }

      if (state.incidents.breach) {
        if (shieldsStation && findActionByKey(shieldsStation, 'shields.bulkhead') && state.power >= 15) {
          return { key: 'shields.bulkhead', stationId: shieldsStation.id, label: 'Seal Bulkheads' };
        }
        if (dronesStation) {
          const act = findActionByKey(dronesStation, 'drones.repair');
          if (act && actorMeetsRoleRequirement(npc.id, act.requiredRole) && invHas('droneParts', 1)) {
            return { key: 'drones.repair', stationId: dronesStation.id, label: 'Repair Drone' };
          }
        }
        if (airlockStation) {
          const act = findActionByKey(airlockStation, 'airlock.eva');
          if (act && actorMeetsRoleRequirement(npc.id, act.requiredRole) && state.oxygen >= 12) {
            return { key: 'airlock.eva', stationId: airlockStation.id, label: 'EVA Patch' };
          }
        }
      }

      if (state.incidents.o2Leak && lifeStation && findActionByKey(lifeStation, 'life.seal')) {
        return { key: 'life.seal', stationId: lifeStation.id, label: 'Seal O2 Leak' };
      }

      if (state.incidents.powerTrip && powerStation && findActionByKey(powerStation, 'power.reset')) {
        return { key: 'power.reset', stationId: powerStation.id, label: 'Reset Breakers' };
      }

      // Heat management: vent before overheating becomes a hull problem.
      if (engineStation) {
        const vent = findActionByKey(engineStation, 'engine.vent');
        if (autoVentHeat && vent && actorMeetsRoleRequirement(npc.id, vent.requiredRole) && safeNumber(state.heat, 0) >= 78) {
          return { key: 'engine.vent', stationId: engineStation.id, label: 'Vent Heat' };
        }
      }

      // Survival maintenance.
      if (state.oxygen <= 28 && lifeStation) {
        if (!state.lifeSupportOn && findActionByKey(lifeStation, 'life.toggle')) {
          return { key: 'life.toggle', stationId: lifeStation.id, label: 'Enable Life Support' };
        }
        if (findActionByKey(lifeStation, 'life.emergency') && state.power >= 12) {
          return { key: 'life.emergency', stationId: lifeStation.id, label: 'Emergency Scrubbers' };
        }
      }

      if (state.food <= 28 && hydroStation) {
        if (!state.hydroponicsOn && findActionByKey(hydroStation, 'hydro.toggle')) {
          return { key: 'hydro.toggle', stationId: hydroStation.id, label: 'Enable Hydroponics' };
        }
        if (findActionByKey(hydroStation, 'hydro.harvest') && state.power >= 6) {
          return { key: 'hydro.harvest', stationId: hydroStation.id, label: 'Harvest Rations' };
        }
      }

      if (state.morale <= 30) {
        if (medStation && findActionByKey(medStation, 'med.treat') && (invHas('medkit', 1) || state.power >= 10)) {
          return { key: 'med.treat', stationId: medStation.id, label: 'Treat Crew' };
        }
        const quartersStation = stationByType('quarters');
        if (quartersStation && findActionByKey(quartersStation, 'quarters.rest') && (invHas('rations', 1) || state.food >= 6)) {
          return { key: 'quarters.rest', stationId: quartersStation.id, label: 'Rest' };
        }
      }

      if ((state.hull / Math.max(1, state.hullMax)) <= 0.65) {
        if (dronesStation) {
          const act = findActionByKey(dronesStation, 'drones.repair');
          if (act && actorMeetsRoleRequirement(npc.id, act.requiredRole) && invHas('droneParts', 1)) {
            return { key: 'drones.repair', stationId: dronesStation.id, label: 'Repair Hull' };
          }
        }
      }

      // Hysteresis on lights to avoid flapping.
      if (powerStation && state.lightsOn && state.power <= 18) {
        if (findActionByKey(powerStation, 'power.toggleLights')) {
          return { key: 'power.toggleLights', stationId: powerStation.id, label: 'Turn Lights OFF' };
        }
      }
      if (powerStation && !state.lightsOn && state.power >= 70) {
        if (findActionByKey(powerStation, 'power.toggleLights')) {
          return { key: 'power.toggleLights', stationId: powerStation.id, label: 'Turn Lights ON' };
        }
      }

      if (engineStation && state.engineActive && state.power <= 10) {
        if (findActionByKey(engineStation, 'engine.toggle')) {
          return { key: 'engine.toggle', stationId: engineStation.id, label: 'Disable Engine' };
        }
      }

      if (powerStation && state.power <= 55) {
        if (findActionByKey(powerStation, 'power.boost')) {
          return { key: 'power.boost', stationId: powerStation.id, label: 'Boost Power' };
        }
      }

      // Progress: investigate anomalies in the current system.
      if (sensorsStation) {
        const act = findActionByKey(sensorsStation, 'sensors.investigate');
        const sys = currentSystem();
        const hasLocalAnom = Array.isArray(state.anomalies)
          ? state.anomalies.some((a) => a && !a.resolved && a.system === sys)
          : false;
        if (act && actorMeetsRoleRequirement(npc.id, act.requiredRole) && hasLocalAnom && state.power >= 10) {
          return { key: 'sensors.investigate', stationId: sensorsStation.id, label: 'Investigate Anomaly' };
        }
      }

      // Tech: actively work the blueprint tree.
      if ((role === 'tech' || role === 'scientist') && sensorsStation && findActionByKey(sensorsStation, 'sensors.deepScan')) {
        const hasLockedTech = listLockedAdvancedModuleTypes().length > 0 || !state.blueprints.recipes.plating;
        if (hasLockedTech && state.power >= 12 && invHas('scrap', 2)) {
          return { key: 'sensors.deepScan', stationId: sensorsStation.id, label: 'Deep Scan' };
        }
      }

      // Production chain: refine ore into ingots.
      if (refineryStation && findActionByKey(refineryStation, 'refinery.refine')) {
        if ((role === 'engineer' || role === 'tech') && invGet('ore') >= 2 && wantsIngots) {
          return { key: 'refinery.refine', stationId: refineryStation.id, label: 'Refine Ore' };
        }
      }

      // Workshop: plating upgrades when available.
      if (workshopStation && findActionByKey(workshopStation, 'workshop.plating')) {
        if (state.blueprints.recipes.plating && state.hullMax < 150 && invHas('ingot', 2)) {
          return { key: 'workshop.plating', stationId: workshopStation.id, label: 'Install Plating' };
        }
      }

      // Fabricator: keep essentials stocked + satisfy contracts.
      if (fabStation) {
        if (wantsFilters && findActionByKey(fabStation, 'fab.filter') && canSpendReserved('ingot', 1)) {
          return { key: 'fab.filter', stationId: fabStation.id, label: 'Print Filter' };
        }
        if (wantsMedkits && findActionByKey(fabStation, 'fab.medkit') && canSpendReserved('ingot', 1) && canSpendReserved('scrap', 1)) {
          return { key: 'fab.medkit', stationId: fabStation.id, label: 'Print Medkit' };
        }
        if ((state.hull / Math.max(1, state.hullMax)) <= 0.7 && findActionByKey(fabStation, 'fab.droneParts') && canSpendReserved('scrap', 2)) {
          return { key: 'fab.droneParts', stationId: fabStation.id, label: 'Assemble Drone Parts' };
        }
      }

      // Gather raw resources.
      if (dronesStation && findActionByKey(dronesStation, 'drones.salvage')) {
        if ((role === 'specialist' || role === 'pilot') && state.power >= 10 && (wantsScrap || wantsOre)) {
          return { key: 'drones.salvage', stationId: dronesStation.id, label: 'Salvage' };
        }
      }

      if (sensorsStation && findActionByKey(sensorsStation, 'sensors.scan')) {
        if ((role === 'scientist' || role === 'tech') && state.power >= 8 && (wantsScrap || wantsOre || wantsIngots)) {
          return { key: 'sensors.scan', stationId: sensorsStation.id, label: 'Scan (Loot)' };
        }
      }

      return null;
    }

    function updateNpcTasking(npc, dt) {
      if (!npc || npc.paused || npc.following) return;
      npc.thinkAcc = (npc.thinkAcc || 0) + dt;
      npc.cooldownAcc = Math.max(0, (npc.cooldownAcc || 0) - dt);

      if (npc.task) {
        // Task may become invalid if modules are removed.
        const st = state.stations.find((s) => s.id === npc.task.stationId);
        const act = st ? findActionByKey(st, npc.task.key) : null;
        if (!st || !act || !actorMeetsRoleRequirement(npc.id, act.requiredRole)) {
          if (st && act && !actorMeetsRoleRequirement(npc.id, act.requiredRole)) {
            const now = Date.now();
            if (safeNumber(npc.skillWarnAt, 0) + 5000 < now) {
              npc.skillWarnAt = now;
              queueNotification('SKILL REQUIRED', `${npc.name} cannot perform: ${act.label || npc.task.label || npc.task.key}. Need ${formatRequiredRoles(act.requiredRole)}.`);
            }
          }
          npc.task = null;
          npc.mode = 'idle';
          npc.wanderTargetX = null;
          npc.cooldownAcc = 0.8;
        }
      }

      if (!npc.task && npc.thinkAcc >= 0.9 && npc.cooldownAcc <= 0) {
        npc.thinkAcc = 0;
        const task = pickNpcTask(npc);
        if (task) {
          npc.task = task;
          npc.mode = 'task';
          npc.wanderTargetX = null;
          npc.idleAcc = 0;
          updateCrewHUD();
        }
      }
    }

    function updateNpcMovementAndWork(npc, dt) {
      if (!npc || npc.paused) {
        if (npc) npc.vx = 0;
        return;
      }
      const beforeX = npc.x;
      let targetX = null;

      if (npc.following) {
        const gap = 70;
        targetX = state.player.x - gap * (state.facing || 1);
      }

      if (npc.task) {
        const st = state.stations.find((s) => s.id === npc.task.stationId);
        if (st) targetX = st.interactX;
      }

      if (targetX === null) {
        // Wander around when idle.
        npc.idleAcc = (npc.idleAcc || 0) + dt;
        if (npc.wanderTargetX === null || npc.idleAcc >= 3.5) {
          npc.idleAcc = 0;
          const span = Math.max(180, (state.walkBounds.maxX - state.walkBounds.minX) * 0.18);
          const base = npc.x;
          const rx = (Math.random() * 2 - 1) * span;
          npc.wanderTargetX = Math.max(state.walkBounds.minX, Math.min(state.walkBounds.maxX, base + rx));
        }
        targetX = npc.wanderTargetX;
        npc.mode = 'idle';
      }

      if (npc.following) {
        npc.mode = 'follow';
      }

      const dx = targetX - npc.x;
      const within = Math.abs(dx) < 8;
      let vx = 0;
      if (!within) {
        vx = Math.sign(dx) * npc.speed;
        npc.facing = vx < 0 ? -1 : 1;
      } else {
        vx = 0;
      }

      npc.x += vx * dt;
      npc.x = Math.max(state.walkBounds.minX, Math.min(state.walkBounds.maxX, npc.x));
      npc.vx = (npc.x - beforeX) / Math.max(1e-6, dt);

      const moved = Math.abs(npc.x - beforeX) > 0.001;
      if (moved) {
        const speedNorm = Math.min(1, Math.abs(npc.vx) / npc.speed);
        const walkRate = 10 + 6 * speedNorm;
        npc.anim.walkPhase += walkRate * dt;
      } else {
        const damp = Math.max(0, 1 - dt * 6);
        npc.anim.walkPhase *= damp;
      }

      // If at the station, perform the work.
      if (npc.task && within) {
        const st = state.stations.find((s) => s.id === npc.task.stationId);
        const action = st ? findActionByKey(st, npc.task.key) : null;
        if (st && action) {
          executeAction(action, st, npc.id);
        }
        npc.task = null;
        npc.mode = 'idle';
        npc.wanderTargetX = null;
        npc.cooldownAcc = 0.8;
        updateCrewHUD();
      }
    }

    function simulateNPCs(dt) {
      if (!Array.isArray(state.npcs) || state.npcs.length === 0) return;
      for (const npc of state.npcs) {
        if (!npc) continue;
        const p = ensurePrevNpc(npc.id, npc);
        p.x = npc.x;
        p.vx = npc.vx;
        p.walkPhase = npc.anim ? npc.anim.walkPhase : 0;

        updateNpcTasking(npc, dt);
        updateNpcMovementAndWork(npc, dt);
      }
    }

    function systemsTick() {
      // 1-second tick for ship systems + survival loops.
      const crewCount = 1 + (Array.isArray(state.npcs) ? state.npcs.length : 0);

      // Crew automation (contracts, blueprints, ship growth).
      crewAutomationTick();

      const hasPower = hasModule('power');
      const hasLife = hasModule('life');
      const hasHydro = hasModule('hydro');
      const hasShields = hasModule('shields');
      const engineCount = moduleCount('engine');
      const maxSpeed = engineCount > 0 ? 15000 * engineCount : 0;
      const throttle = clamp(safeNumber(state.throttle, 0), 0, 1);

      // Speed ramps toward throttle target (no instant jumps).
      {
        const targetSpeed = (state.engineActive && maxSpeed > 0) ? (maxSpeed * throttle) : 0;
        const maxDelta = state.engineActive ? (2500 + 4000 * throttle) : 9000;
        const delta = targetSpeed - safeNumber(state.speed, 0);
        if (Math.abs(delta) <= maxDelta) state.speed = targetSpeed;
        else state.speed = safeNumber(state.speed, 0) + Math.sign(delta) * maxDelta;
        state.speed = Math.max(0, state.speed);
      }

      // Power routing (simple load shedding under low power).
      {
        const profile = typeof state.powerProfile === 'string' ? state.powerProfile : 'balanced';
        const lowPower = state.power <= 8;
        if (lowPower && profile !== 'balanced') {
          let changed = false;
          if (profile === 'survival') {
            if (!state.lifeSupportOn) { state.lifeSupportOn = true; changed = true; }
            if (state.hydroponicsOn) { state.hydroponicsOn = false; changed = true; }
            if (hasShields && state.shieldsOn) { state.shieldsOn = false; changed = true; }
          } else if (profile === 'combat') {
            if (state.hydroponicsOn) { state.hydroponicsOn = false; changed = true; }
          } else if (profile === 'industry') {
            if (hasShields && state.shieldsOn) { state.shieldsOn = false; changed = true; }
          }

          const now = Date.now();
          if (changed && safeNumber(state.meta.powerShedAt, 0) + 5000 < now) {
            state.meta.powerShedAt = now;
            queueNotification('POWER ROUTING', `Automatic load shedding engaged (${profile.toUpperCase()}).`);
          }
        }
      }

      // Power model: generation from Power Core, drains from running systems.
      // Tuned to avoid "constant emergency" play.
      let powerGen = hasPower ? 4.2 : 0;
      if (state.incidents.powerTrip) powerGen *= 0.35;

      const drainBase = 0.35;
      const drainLights = state.lightsOn ? 0.25 : 0;
      const drainEngine = (state.engineActive && maxSpeed > 0) ? (0.25 + 0.95 * throttle) : 0;
      const drainShields = (hasShields && state.shieldsOn) ? 0.85 : 0;
      const drainLife = (hasLife && state.lifeSupportOn) ? 0.75 : 0;
      const drainHydro = (hasHydro && state.hydroponicsOn) ? 0.55 : 0;

      const totalDrain = drainBase + drainLights + drainEngine + drainShields + drainLife + drainHydro;
      state.power = clamp(state.power + powerGen - totalDrain, 0, 150);

      // Oxygen: crew consumes; life support replenishes when powered.
      // Sublinear scaling so large crews don't become a tax.
      let o2Use = 0.06 * Math.sqrt(Math.max(1, crewCount));
      if (state.incidents.o2Leak) o2Use += 2.2;
      let o2Gain = 0;
      if (hasLife && state.lifeSupportOn && state.power >= 8) o2Gain = 1.1;
      state.oxygen = clamp(state.oxygen + o2Gain - o2Use, 0, 100);

      // Food: crew consumes; hydroponics replenishes when powered.
      let foodUse = 0.05 * Math.sqrt(Math.max(1, crewCount));
      let foodGain = 0;
      if (hasHydro && state.hydroponicsOn && state.power >= 10) foodGain = 0.55;
      state.food = clamp(state.food + foodGain - foodUse, 0, 100);

      // Heat: systems add heat; cooling scales with current heat.
      // Previous tuning required near-max throttle to see heat rise, so heat looked "stuck" at 0.
      let heatGain = 0;
      if (state.engineActive && maxSpeed > 0) heatGain += 0.2 + 0.8 * throttle;
      if (hasShields && state.shieldsOn) heatGain += 0.12;
      if (state.incidents.fire) heatGain += 3.8;

      const baseCooling = 0.25;
      const coolingFactor = 0.015;
      const heatCooling = baseCooling + coolingFactor * clamp(safeNumber(state.heat, 0), 0, 100);
      state.heat = clamp(state.heat + heatGain - heatCooling, 0, 100);

      // Hull: incidents and overheating cause damage.
      let hullDamage = 0.01;
      if (state.engineActive && maxSpeed > 0) hullDamage += 0.01 + 0.035 * throttle;
      if (state.incidents.breach) hullDamage += (hasShields && state.shieldsOn) ? 0.35 : 0.9;
      if (state.heat >= 85) hullDamage += 0.25;
      state.hull = clamp(state.hull - hullDamage, 0, state.hullMax);

      // Travel progression + events.
      if (state.travel && state.travel.active && state.travel.to) {
        const traveling = state.engineActive && state.speed > 0 && throttle > 0.01;
        if (traveling) {
          const rate = Math.max(0, state.speed / 15000); // AU/sec at 15,000 km/s
          state.travel.remaining = Math.max(0, safeNumber(state.travel.remaining, 0) - rate);
          markDirty();

          const eventChance = 0.0025 + (throttle >= 0.8 ? 0.0015 : 0) + (state.reputation <= 0 ? 0.001 : 0);
          const canQueue = state.events && Array.isArray(state.events.queue) ? state.events.queue.length < 20 : true;
          if (canQueue && Math.random() < eventChance) {
            const roll = Math.random();

            if (roll < 0.45) {
              queueEvent({
                title: 'PIRATE INTERCEPT',
                description: 'A pirate skiff drops out of the dark.\n\n“Transponder looks expensive. Pay, or we take it.”',
                choices: [
                  {
                    label: 'Pay 30 credits',
                    apply: () => {
                      if (state.credits >= 30) {
                        state.credits -= 30;
                      } else {
                        state.hull = clamp(state.hull - 6, 0, state.hullMax);
                        state.morale = clamp(state.morale - 6, 0, 100);
                      }
                    },
                    result: state.credits >= 30 ? 'Payment transmitted. The skiff disengages.' : 'Not enough credits. They rake the hull and flee.'
                  },
                  {
                    label: 'Run',
                    apply: () => {
                      state.throttle = 1;
                      state.heat = clamp(state.heat + 14, 0, 100);
                      state.hull = clamp(state.hull - 4, 0, state.hullMax);
                    },
                    result: 'You burn hard. The pirate loses the lock, but the ship takes strain.'
                  },
                  {
                    label: hasShields ? 'Fight (use shields)' : 'Fight',
                    danger: true,
                    apply: () => {
                      const hasDefense = hasShields && state.shieldsOn;
                      const dmg = hasDefense ? 3 : 7;
                      state.power = Math.max(0, state.power - (hasDefense ? 10 : 6));
                      state.hull = clamp(state.hull - dmg, 0, state.hullMax);
                      state.credits = Math.max(0, state.credits + 25);
                      invAdd('scrap', 2);
                    },
                    result: 'The skiff breaks off. You salvage fragments (+2 scrap) and shake loose a bounty (+25 credits).'
                  }
                ]
              });
            } else if (roll < 0.82) {
              queueEvent({
                title: 'ION STORM',
                description: 'Sensors spike. A roiling ion storm swallows the route.\n\nSystems begin to arc and scream.',
                choices: [
                  {
                    label: hasShields ? 'Raise Shields' : 'Raise Shields (no shields)',
                    apply: () => {
                      if (hasShields) {
                        state.shieldsOn = true;
                        state.power = Math.max(0, state.power - 12);
                        state.heat = clamp(state.heat + 8, 0, 100);
                      } else {
                        state.hull = clamp(state.hull - 7, 0, state.hullMax);
                        state.heat = clamp(state.heat + 10, 0, 100);
                      }
                    },
                    result: hasShields ? 'Deflectors hold. Heat rises, but the hull stays intact.' : 'No deflectors. The storm bites the hull.'
                  },
                  {
                    label: 'Power Down Nonessentials',
                    apply: () => {
                      state.lightsOn = false;
                      state.hydroponicsOn = false;
                      state.heat = clamp(state.heat + 6, 0, 100);
                      state.hull = clamp(state.hull - 3, 0, state.hullMax);
                    },
                    result: 'You dump loads and ride the edge. Minor hull scarring.'
                  },
                  {
                    label: 'Ride it out',
                    danger: true,
                    apply: () => {
                      state.heat = clamp(state.heat + 14, 0, 100);
                      state.hull = clamp(state.hull - 8, 0, state.hullMax);
                      state.morale = clamp(state.morale - 8, 0, 100);
                    },
                    result: 'The storm passes. The ship does not come out unmarked.'
                  }
                ]
              });
            } else {
              const destSys = state.travel && state.travel.to ? String(state.travel.to).toUpperCase() : currentSystem();
              const kinds = ['derelict', 'signal', 'vault'];
              const kind = kinds[(Math.random() * kinds.length) | 0];
              const name = kind === 'derelict' ? 'DERELICT HULK' : (kind === 'signal' ? 'ODD SIGNAL' : 'SEALED VAULT');
              const a = addAnomaly({ system: destSys, name, kind });
              queueEvent({
                title: 'ANOMALY ON COURSE',
                description: `Long-range sensors tag a signature drifting near ${destSys}.\n\n${a.name} added to nav markers.`,
                choices: [
                  {
                    label: 'Mark and Continue',
                    apply: () => {},
                    result: 'Marker set.'
                  },
                  {
                    label: 'Divert (adds +40 AU)',
                    apply: () => {
                      if (state.travel && state.travel.active) {
                        state.travel.remaining = safeNumber(state.travel.remaining, 0) + 40;
                        state.travel.total = safeNumber(state.travel.total, 0) + 40;
                      }
                      state.power = Math.max(0, state.power - 8);
                      state.morale = clamp(state.morale + 2, 0, 100);
                    },
                    result: 'You adjust course and lose time, but the crew’s curiosity is satisfied.'
                  }
                ]
              });
            }
          }
        }

        if (safeNumber(state.travel.remaining, 0) <= 0) {
          const dest = String(state.travel.to).toUpperCase();
          state.location = { system: dest };
          state.travel = { active: false, from: dest, to: null, remaining: 0, total: 0 };
          queueNotification('ARRIVAL', `Arrived in system: ${dest}.`);
          ensureContracts();
          markDirty();
        }
      }

      // Morale: responds to scarcity and danger; very slow decay (idle-friendly).
      let moraleDelta = -0.05;
      if (state.oxygen <= 20) moraleDelta -= 0.9;
      if (state.food <= 18) moraleDelta -= 0.7;
      if (state.heat >= 78) moraleDelta -= 0.6;
      if (state.hull / Math.max(1, state.hullMax) <= 0.4) moraleDelta -= 0.35;
      if (!anyActiveIncident() && state.oxygen >= 60 && state.food >= 60 && state.heat <= 40) moraleDelta += 0.08;
      state.morale = clamp(state.morale + moraleDelta, 0, 100);

      // Random incidents (kept subtle; no popups).
      // Risk rises with low morale, high heat, low power, and while traveling.
      const baseRisk = 0.0006;
      const risk = baseRisk
        + (state.engineActive ? (0.001 + 0.002 * throttle) : 0)
        + (state.heat >= 80 ? 0.004 : 0)
        + (state.power <= 12 ? 0.004 : 0)
        + (state.morale <= 30 ? 0.006 : 0);

      if (Math.random() < risk) {
        const kinds = ['powerTrip', 'o2Leak', 'fire', 'breach'].filter((k) => !state.incidents[k]);
        if (kinds.length) {
          const k = kinds[(Math.random() * kinds.length) | 0];
          triggerIncident(k);
        }
      }

      updateHUD();
    }

    function simulateStep(dt) {
      // Capture previous state for interpolation.
      prev.x = state.player.x;
      prev.vx = state.player.vx;
      prev.walkPhase = state.anim.walkPhase;

      // Move player (dt-based)
      const beforeX = state.player.x;
      let vx = 0;
      if (state.keys.left) {
        vx -= state.player.speed;
        state.facing = -1;
      }
      if (state.keys.right) {
        vx += state.player.speed;
        state.facing = 1;
      }
      state.player.x += vx * dt;
      state.player.x = Math.max(state.walkBounds.minX, Math.min(state.walkBounds.maxX, state.player.x));
      state.player.vx = (state.player.x - beforeX) / Math.max(1e-6, dt);

      const movedX = Math.abs(state.player.x - beforeX) > 0.001;
      if (movedX) markDirty();

      const moved = Math.abs(state.player.x - beforeX) > 0.001;
      if (moved) {
        const speedNorm = Math.min(1, Math.abs(state.player.vx) / state.player.speed);
        const walkRate = 10 + 6 * speedNorm; // rad/sec
        state.anim.walkPhase += walkRate * dt;
      } else {
        const damp = Math.max(0, 1 - dt * 6);
        state.anim.walkPhase *= damp;
      }

      // Time-based resource drain
      state.sim.drainAcc += dt;
      let drained = false;
      while (state.sim.drainAcc >= 1) {
        state.sim.drainAcc -= 1;
        systemsTick();
        drained = true;
      }
      if (drained) markDirty();

      // NPCs (autonomous crew)
      simulateNPCs(dt);

      // Engine-driven star drift (subtle parallax motion even when not walking).
      // Keep it gentle so it feels like forward motion without being distracting.
      const driftSpeed = state.engineActive ? (10 + 55 * clamp(safeNumber(state.throttle, 0), 0, 1)) : 0; // px/sec
      state.starfield.driftX += driftSpeed * dt;
      if (driftSpeed) markDirty();

      // Autosave while dirty (so closing the tab resumes accurately).
      state.sim.saveAcc += dt;
      if (state.sim.dirty && state.sim.saveAcc >= 1) {
        saveGame();
      }

      return { drained };
    }

    function gameLoop(ts) {
      if (lastTs === null) {
        lastTs = ts;
      }

      // Clamp to avoid huge jumps after tab/background.
      const frameDt = Math.min(0.25, (ts - lastTs) / 1000);
      lastTs = ts;
      acc += frameDt;

      if (state.sim.snap) {
        // If something teleported (layout change/load), don't interpolate a huge jump.
        prev.x = state.player.x;
        prev.vx = state.player.vx;
        prev.walkPhase = state.anim.walkPhase;
        acc = 0;
        state.sim.snap = false;
      }

      // Fixed-step sim at 20 FPS.
      let drained = false;
      let steps = 0;
      while (acc >= STEP && steps < MAX_CATCHUP_STEPS) {
        const r = simulateStep(STEP);
        drained = drained || r.drained;
        acc -= STEP;
        steps++;
      }
      if (steps === MAX_CATCHUP_STEPS) acc = 0;

      // Interpolate visuals between prev and current state.
      const alpha = Math.max(0, Math.min(1, acc / STEP));
      const renderX = lerp(prev.x, state.player.x, alpha);
      const renderVx = lerp(prev.vx, state.player.vx, alpha);
      const renderWalk = lerp(prev.walkPhase, state.anim.walkPhase, alpha);

      updateCamera(renderX);
      updateStarfield();
      renderPlayer({ x: renderX, vx: renderVx, walkPhase: renderWalk });
      renderNPCs(alpha);
      checkNearStation();
      checkNearNpc();
      if (drained) updateHUD();
      updateCrewHUD();

      requestAnimationFrame(gameLoop);
    }

    // Controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const actionBtn = document.getElementById('actionBtn');
    const menuBtn = document.getElementById('menuBtn');
    const alertsBtn = document.getElementById('alertsBtn');

    function bindHoldButton(btn, key) {
      btn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        state.keys[key] = true;
        try { btn.setPointerCapture(e.pointerId); } catch {}
      });
      const stop = (e) => {
        if (e && e.preventDefault) e.preventDefault();
        state.keys[key] = false;
      };
      btn.addEventListener('pointerup', stop);
      btn.addEventListener('pointercancel', stop);
      btn.addEventListener('pointerleave', stop);
    }

    bindHoldButton(leftBtn, 'left');
    bindHoldButton(rightBtn, 'right');
    actionBtn.addEventListener('click', interact);
    menuBtn.addEventListener('click', openGameMenu);
    if (alertsBtn) alertsBtn.addEventListener('click', openAlertsPanel);

    // Pointer controls on the play area (touch + mouse): hold left/right half to move.
    let movementPointerId = null;

    function setMoveFromClientX(clientX) {
      const rect = svg.getBoundingClientRect();
      const x = clientX - rect.left;
      const goLeft = x < rect.width * 0.5;
      state.keys.left = goLeft;
      state.keys.right = !goLeft;
    }

    function clearMoveFromPointer() {
      state.keys.left = false;
      state.keys.right = false;
      movementPointerId = null;
    }

    svg.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'mouse' && e.button !== 0) return;
      movementPointerId = e.pointerId;
      try { svg.setPointerCapture(movementPointerId); } catch {}
      setMoveFromClientX(e.clientX);
    });

    svg.addEventListener('pointermove', (e) => {
      if (movementPointerId !== e.pointerId) return;
      setMoveFromClientX(e.clientX);
    });

    svg.addEventListener('pointerup', (e) => {
      if (movementPointerId !== e.pointerId) return;
      try { svg.releasePointerCapture(movementPointerId); } catch {}
      clearMoveFromPointer();
    });

    svg.addEventListener('pointercancel', (e) => {
      if (movementPointerId !== e.pointerId) return;
      clearMoveFromPointer();
    });

    svg.addEventListener('pointerleave', () => {
      if (movementPointerId === null) return;
      clearMoveFromPointer();
    });

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      const panel = document.getElementById('interactPanel');
      const panelOpen = panel && panel.style.display === 'block';
      if (panelOpen) {
        const textareaEl = document.getElementById('panelTextarea');
        if (textareaEl && textareaEl.style.display === 'block' && document.activeElement === textareaEl) {
          if (e.key === 'Escape') {
            e.preventDefault();
            closePanel();
          }
          // Allow normal text editing keys (arrows, enter, etc.) while editing JSON.
          return;
        }
        const buttons = Array.from(panel.querySelectorAll('button.panel-btn'));
        const active = document.activeElement;
        const idx = buttons.indexOf(active);

        if (e.key === 'Escape') {
          e.preventDefault();
          closePanel();
          return;
        }

        if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          if (!buttons.length) return;
          const next = idx >= 0 ? (idx - 1 + buttons.length) % buttons.length : 0;
          try { buttons[next].focus(); } catch {}
          return;
        }

        if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
          e.preventDefault();
          if (!buttons.length) return;
          const next = idx >= 0 ? (idx + 1) % buttons.length : 0;
          try { buttons[next].focus(); } catch {}
          return;
        }

        if (e.key === ' ' || e.key === 'Enter') {
          // Explicitly click the focused button (don’t let global bindings steal it).
          if (active && active instanceof HTMLButtonElement && panel.contains(active)) {
            e.preventDefault();
            active.click();
            return;
          }
          return;
        }

        // While the panel is open, ignore movement/action keys.
        return;
      }

      if (e.key === 'ArrowLeft' || e.key === 'a') state.keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') state.keys.right = true;
      if (e.key === ' ' || e.key === 'e' || e.key === 'Enter') {
        e.preventDefault();
        interact();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') state.keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') state.keys.right = false;
    });

    // Disable long-press context menus on the game surface + controls.
    document.addEventListener('contextmenu', (e) => {
      const t = e.target;
      if (!(t instanceof Element)) return;
      if (t.closest('#gameCanvas') || t.closest('#controls')) {
        e.preventDefault();
      }
    });

    // Start game (dt + capped FPS)
    requestAnimationFrame(gameLoop);

    // Save state periodically
    setInterval(() => {
      saveGame();
    }, 2000);

    // Save when the page is backgrounded or closed.
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') saveGame();
    });
    window.addEventListener('beforeunload', () => {
      saveGame();
    });

    function renderNPCs(alpha) {
      npcsGroup.innerHTML = '';
      if (!Array.isArray(state.npcs) || state.npcs.length === 0) return;

      for (const npc of state.npcs) {
        if (!npc) continue;
        const p = prev.npcs[npc.id] || { x: npc.x, vx: npc.vx, walkPhase: npc.anim ? npc.anim.walkPhase : 0 };
        const x = lerp(p.x, npc.x, alpha);
        const vx = lerp(p.vx, npc.vx, alpha);
        const walkPhase = lerp(p.walkPhase, npc.anim.walkPhase, alpha);

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

        const moving = Math.abs(vx) > 1;
        const walk = walkPhase;
        const dir = npc.facing || 1;

        const hipY = npc.y - 4;
        const hipBaseX = x;
        const legSpread = 6;
        const thighLen = 17;
        const shinLen = 15;

        const legs = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        legs.setAttribute('stroke', C.text);
        legs.setAttribute('stroke-width', 3);
        legs.setAttribute('stroke-linecap', 'round');

        function addLeg(sideSign) {
          const phase = walk + (sideSign > 0 ? Math.PI : 0);
          const s = moving ? Math.sin(phase) * 7 : 0;
          const l = moving ? Math.max(0, Math.sin(phase)) * 5 : 0;

          const hipX = hipBaseX + sideSign * legSpread;
          const kneeX = hipX + s * 0.6 * dir;
          const kneeY = hipY + thighLen - l * 0.4;
          const footX = hipX + s * 1.0 * dir;
          const footY = hipY + thighLen + shinLen - l;

          const legPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          legPath.setAttribute('d', `M ${hipX} ${hipY} L ${kneeX} ${kneeY} L ${footX} ${footY}`);
          legPath.setAttribute('opacity', sideSign > 0 ? 0.9 : 0.8);
          legs.appendChild(legPath);

          const foot = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          foot.setAttribute('d', `M ${footX - 6} ${footY} L ${footX + 8} ${footY}`);
          foot.setAttribute('stroke', C.accent);
          foot.setAttribute('stroke-width', 4);
          foot.setAttribute('opacity', 0.9);
          legs.appendChild(foot);
        }

        addLeg(-1);
        addLeg(1);
        g.appendChild(legs);

        const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        body.setAttribute('x', x - npc.width / 2);
        body.setAttribute('y', npc.y - npc.height);
        body.setAttribute('width', npc.width);
        body.setAttribute('height', npc.height);
        body.setAttribute('fill', 'rgb(120, 180, 255)');
        body.setAttribute('stroke', C.text);
        body.setAttribute('stroke-width', 2);
        body.setAttribute('opacity', 0.95);
        g.appendChild(body);

        const head = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        head.setAttribute('cx', x);
        head.setAttribute('cy', npc.y - npc.height - 10);
        head.setAttribute('r', 14);
        head.setAttribute('fill', C.text);
        head.setAttribute('stroke', 'rgb(120, 180, 255)');
        head.setAttribute('stroke-width', 2);
        g.appendChild(head);

        const visor = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        visor.setAttribute('x', x - 8);
        visor.setAttribute('y', npc.y - npc.height - 15);
        visor.setAttribute('width', 16);
        visor.setAttribute('height', 6);
        visor.setAttribute('fill', C.accent);
        g.appendChild(visor);

        // Overhead label: name / role / task (one per line)
        const role = roleLabel(npcRole(npc));
        const task = npc.following ? 'FOLLOWING' : (npc.task ? taskLabel(npc.task) : 'IDLE');
        const lines = [String(npc.name || 'CREW'), role, String(task || 'IDLE')];

        const fontSize = 11;
        const lineH = 12;
        const tag = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        tag.setAttribute('x', x);
        tag.setAttribute('y', npc.y - npc.height - 30 - (lines.length - 1) * lineH);
        tag.setAttribute('text-anchor', 'middle');
        tag.setAttribute('fill', 'rgba(255,255,255,0.62)');
        tag.setAttribute('font-size', String(fontSize));
        tag.setAttribute('font-weight', '600');

        for (let i = 0; i < lines.length; i++) {
          const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          tspan.setAttribute('x', x);
          tspan.setAttribute('dy', i === 0 ? '0' : String(lineH));
          tspan.setAttribute('font-weight', i === 0 ? '700' : '600');
          tspan.textContent = lines[i];
          tag.appendChild(tspan);
        }

        g.appendChild(tag);

        npcsGroup.appendChild(g);
      }
    }
  </script>

  <script src="parental.js" defer></script>
  <script src="assets/js/pwa.js" type="module"></script>
</body>
</html>
