<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fit the Shapes</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f8f8fc;
      overflow: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #score {
      font-size: 2em;
      margin-bottom: 0.5em;
      color: #222;
      text-align: center;
    }
    #diamond-btn {
      font-size: 1em;
      margin-bottom: 1em;
      background: #e0f7fa;
      border: none;
      border-radius: 0.5em;
      padding: 0.5em 1em;
      cursor: pointer;
      color: #00796b;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    #diamond-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    #game-canvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      border-radius: 1em;
      box-shadow: 0 2px 16px rgba(0,0,0,0.12);
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <button id="diamond-btn">Buy Diamond Shape (10 pts)</button>
  <canvas id="game-canvas"></canvas>
  <script>
    // --- CONFIG ---
    const GRID_SIZE = 10;
    const CELL_SIZE = 40; // Will be scaled
    const SHAPE_COLORS = ["#ff5252", "#ffd600", "#40c4ff", "#69f0ae", "#ff4081", "#7c4dff", "#ffab40", "#00bfae"];
    const DIAMOND_COLOR = "#e0f7fa";
    const LAVA_COLOR = "#ff3d00";
    const COOLED_LAVA_COLOR = "#8d6e63"; // Brown color for cooled lava
    const DIAMOND_COST = 10;
    const SHAPES = [
      // I
      [[0,0],[1,0],[2,0],[3,0]],
      // O
      [[0,0],[1,0],[0,1],[1,1]],
      // T
      [[1,0],[0,1],[1,1],[2,1]],
      // S
      [[1,0],[2,0],[0,1],[1,1]],
      // Z
      [[0,0],[1,0],[1,1],[2,1]],
      // J
      [[0,0],[0,1],[1,1],[2,1]],
      // L
      [[2,0],[0,1],[1,1],[2,1]]
    ];
    // --- STATE ---
    let score = 0;
    let diamonds = 0;
    let grid = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(null));
    let availableShapes = [];
    let draggingShape = null;
    let dragOffset = {x:0, y:0};
    let dragPos = {x:0, y:0};
    let rngSeed = 12345;
    const SHAPES_AREA_ROWS = 4; // Reserve 4 grid rows for available shapes area
    let highestScore = 0;
let diamondsBought = 0;
let piecesPlaced = 0;
let lavaPlaced = 0;
let gameOver = false;
let peakScore = 0;
    // --- UTILS ---
    function seededRandom() {
      // xorshift
      rngSeed ^= rngSeed << 13;
      rngSeed ^= rngSeed >> 17;
      rngSeed ^= rngSeed << 5;
      return Math.abs(rngSeed) % 10000 / 10000;
    }
    function rotateShape(blocks, rot) {
      // rot: 0=0°, 1=90°, 2=180°, 3=270°
      let newBlocks = blocks.map(b => ({x:b.x, y:b.y}));
      for (let r=0; r<rot; r++) {
        // Rotate 90° clockwise around (0,0)
        newBlocks = newBlocks.map(b => ({x: b.y, y: -b.x}));
        // Normalize to top-left
        let minX = Math.min(...newBlocks.map(b=>b.x));
        let minY = Math.min(...newBlocks.map(b=>b.y));
        newBlocks = newBlocks.map(b => ({x: b.x-minX, y: b.y-minY}));
      }
      return newBlocks;
    }
    function pickShape(isDiamond=false, isLava=false) {
      const idx = Math.floor(seededRandom()*SHAPES.length);
      const rot = Math.floor(seededRandom()*4); // 0,1,2,3
      let blocks = rotateShape(SHAPES[idx].map(([x,y])=>({x,y})), rot);
      let color;
      if (isDiamond) {
        color = DIAMOND_COLOR;
      } else if (isLava) {
        color = LAVA_COLOR;
      } else {
        color = SHAPE_COLORS[Math.floor(seededRandom()*SHAPE_COLORS.length)];
      }
      return {
        blocks,
        color,
        isDiamond,
        isLava,
        rot
      };
    }
    function refillShapes() {
      while (availableShapes.length < 3) {
        const rand = seededRandom();
        if (rand < 0.125) {
          // 1 in 8 chance for diamond
          availableShapes.push(pickShape(true, false));
        } else if (rand < 0.25) {
          // 1 in 8 chance for lava (next 1/8)
          availableShapes.push(pickShape(false, true));
        } else {
          // Normal piece
          availableShapes.push(pickShape(false, false));
        }
      }
    }
    function updateScoreDisplay() {
      if (score > peakScore) peakScore = score;
      document.getElementById('score').textContent = `Score: ${score}`;
      document.getElementById('diamond-btn').disabled = score < DIAMOND_COST;
    }
    // --- CANVAS ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      const size = Math.min(window.innerWidth, window.innerHeight) * 0.8;
      canvas.width = size;
      canvas.height = size;
      // Only render if game is initialized (availableShapes exist)
      if (availableShapes.length > 0) {
        render();
      }
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    // Calculate cell size so grid and shapes fit vertically
    function getCellSize() {
      // Reserve space for grid, margin, and fixed shapes area
      // 1 cell margin above, SHAPES_AREA_ROWS cells for shapes area, 1 cell margin below
      return canvas.height / (GRID_SIZE + SHAPES_AREA_ROWS + 2);
    }
    function getShapeBoundingBox(shape) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const block of shape.blocks) {
        minX = Math.min(minX, block.x);
        minY = Math.min(minY, block.y);
        maxX = Math.max(maxX, block.x);
        maxY = Math.max(maxY, block.y);
      }
      return {minX, minY, maxX, maxY};
    }
    // --- DRAW ---
    function drawGrid() {
  const cell = getCellSize();
  const gridWidth = cell * GRID_SIZE;
  const gridHeight = cell * GRID_SIZE;
  // Center grid horizontally, add top margin
  const gridX = (canvas.width - gridWidth) / 2;
  const gridY = cell * 1.0; // 1 cell margin at top
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Draw grid
      ctx.save();
      ctx.translate(gridX, gridY);
      for (let y=0; y<GRID_SIZE; y++) {
        for (let x=0; x<GRID_SIZE; x++) {
          ctx.strokeStyle = '#bbb';
          ctx.lineWidth = 2;
          ctx.strokeRect(x*cell, y*cell, cell, cell);
          if (grid[y][x]) {
            ctx.fillStyle = grid[y][x].color;
            ctx.fillRect(x*cell+2, y*cell+2, cell-4, cell-4);
            if (grid[y][x].isDiamond) {
              ctx.strokeStyle = '#00bcd4';
              ctx.lineWidth = 3;
              ctx.strokeRect(x*cell+6, y*cell+6, cell-12, cell-12);
            } else if (grid[y][x].isLava) {
              // Lava effect: glowing border
              ctx.strokeStyle = '#ff8a50';
              ctx.lineWidth = 3;
              ctx.strokeRect(x*cell+6, y*cell+6, cell-12, cell-12);
            } else if (grid[y][x].isCooledLava) {
              // Cooled lava effect: darker border
              ctx.strokeStyle = '#5d4037';
              ctx.lineWidth = 2;
              ctx.strokeRect(x*cell+8, y*cell+8, cell-16, cell-16);
            }
          }
        }
      }
      ctx.restore();
    }
    function drawAvailableShapes() {
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      // Fixed area for shapes below grid
      const y0 = cell * (GRID_SIZE + 1.5); // 1.5 cells below grid
      const shapesAreaWidth = gridWidth;
      const shapeSpacing = shapesAreaWidth / 3;
      for (let i=0; i<availableShapes.length; i++) {
        const shape = availableShapes[i];
        const box = getShapeBoundingBox(shape);
        // Center each shape horizontally and vertically in its third of the fixed area
        const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
        const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
        for (const block of shape.blocks) {
          ctx.fillStyle = shape.color;
          ctx.fillRect(x0+(block.x-box.minX)*cell, yCenter+(block.y-box.minY)*cell, cell-4, cell-4);
          if (shape.isDiamond) {
            ctx.strokeStyle = '#00bcd4';
            ctx.lineWidth = 3;
            ctx.strokeRect(x0+(block.x-box.minX)*cell+6, yCenter+(block.y-box.minY)*cell+6, cell-12, cell-12);
          } else if (shape.isLava) {
            ctx.strokeStyle = '#ff8a50';
            ctx.lineWidth = 3;
            ctx.strokeRect(x0+(block.x-box.minX)*cell+6, yCenter+(block.y-box.minY)*cell+6, cell-12, cell-12);
          }
        }
      }
    }
    function drawDraggingShape() {
      if (!draggingShape) return;
      const cell = getCellSize();
      const box = draggingShape.box || getShapeBoundingBox(draggingShape);
      const minX = box.minX;
      const minY = box.minY;
      for (const block of draggingShape.blocks) {
        ctx.fillStyle = draggingShape.color;
        ctx.globalAlpha = 0.7;
        ctx.fillRect(
          dragPos.x + (block.x-minX)*cell,
          dragPos.y + (block.y-minY)*cell,
          cell-4, cell-4
        );
        ctx.globalAlpha = 1;
        if (draggingShape.isDiamond) {
          ctx.strokeStyle = '#00bcd4';
          ctx.lineWidth = 3;
          ctx.strokeRect(
            dragPos.x + (block.x-minX)*cell+6,
            dragPos.y + (block.y-minY)*cell+6,
            cell-12, cell-12
          );
        } else if (draggingShape.isLava) {
          ctx.strokeStyle = '#ff8a50';
          ctx.lineWidth = 3;
          ctx.strokeRect(
            dragPos.x + (block.x-minX)*cell+6,
            dragPos.y + (block.y-minY)*cell+6,
            cell-12, cell-12
          );
        }
      }
    }
    let coinAnim = null;
// let shakeAnim = null;
let freeCoinAnims = null;
function animateCoin(fromX, fromY) {
  const start = Date.now();
  const duration = 700;
  const endX = canvas.width/2;
  const endY = 0;
  coinAnim = {fromX, fromY, endX, endY, start, duration};
  requestAnimationFrame(render);
}

function animateFreeCoins(fromX, fromY) {
  // Use a single animation instance for all coins, matching diamond buy
  const start = Date.now();
  const duration = 700;
  const coins = [];
  for (let i=0; i<10; i++) {
    const angle = (-1.2 + 2.4*Math.random());
    const speed = 1 + 0.7*(Math.random()-0.5);
    coins.push({
      duration: duration * speed,
      angle,
    });
  }
  freeCoinAnims = {
    start,
    fromX,
    fromY,
    toX: canvas.width/2,
    toY: 0,
    coins
  };
  requestAnimationFrame(render);
}

function renderFreeCoinAnims() {
  if (!freeCoinAnims) return;
  const now = Date.now();
  let stillAnimating = false;
  for (const coin of freeCoinAnims.coins) {
    const t = Math.min(1, (now-freeCoinAnims.start)/coin.duration);
    if (t < 1) stillAnimating = true;
    const ease = 1 - Math.pow(1-t,3);
    const x = freeCoinAnims.fromX + (freeCoinAnims.toX-freeCoinAnims.fromX)*ease + Math.sin(coin.angle)*120*(1-t);
    const y = freeCoinAnims.fromY + (freeCoinAnims.toY-freeCoinAnims.fromY)*ease + Math.sin(coin.angle)*60*(1-t);
    ctx.save();
    ctx.font = `${canvas.height/24}px serif`;
    ctx.globalAlpha = 0.7 + 0.3*(1-t);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('🪙', x, y);
    ctx.restore();
  }
  if (!stillAnimating) {
    freeCoinAnims = null;
  }
  return stillAnimating;
}
function renderCoinAnim() {
  if (!coinAnim) return;
  const now = Date.now();
  const t = Math.min(1, (now-coinAnim.start)/coinAnim.duration);
  // Ease out cubic
  const ease = 1 - Math.pow(1-t,3);
  const x = coinAnim.fromX + (coinAnim.endX-coinAnim.fromX)*ease;
  const y = coinAnim.fromY + (coinAnim.endY-coinAnim.fromY)*ease;
  ctx.save();
  ctx.font = `${canvas.height/18}px serif`;
  ctx.globalAlpha = 0.7 + 0.3*(1-t);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('🪙', x, y);
  ctx.restore();
  if (t >= 1) {
    coinAnim = null;
  }
  return t < 1;
}
let diamondCoinAnims = [];
function animateDiamondCoins(toX, toY) {
  diamondCoinAnims = [];
  const start = Date.now();
  const duration = 700;
  for (let i=0; i<10; i++) {
    const angle = (-1.2 + 2.4*Math.random()); // much wider arc offset
    const speed = 1 + 0.7*(Math.random()-0.5); // greater speed variation
    diamondCoinAnims.push({
      start,
      duration: duration * speed,
      fromX: canvas.width/2,
      fromY: 0,
      toX,
      toY,
      angle,
    });
  }
  requestAnimationFrame(render);
}
function renderDiamondCoinAnims() {
  if (!diamondCoinAnims.length) return;
  const now = Date.now();
  let stillAnimating = false;
  for (const anim of diamondCoinAnims) {
    const t = Math.min(1, (now-anim.start)/anim.duration);
    if (t < 1) stillAnimating = true;
    // Arc trajectory
    const ease = 1 - Math.pow(1-t,3);
    const x = anim.fromX + (anim.toX-anim.fromX)*ease + Math.sin(anim.angle)*120*(1-t);
    const y = anim.fromY + (anim.toY-anim.fromY)*ease + Math.sin(anim.angle)*60*(1-t);
    ctx.save();
    ctx.font = `${canvas.height/24}px serif`;
    ctx.globalAlpha = 0.7 + 0.3*(1-t);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('🪙', x, y);
    ctx.restore();
  }
  if (!stillAnimating) {
    diamondCoinAnims = [];
  }
  return stillAnimating;
}
    function resetGame() {
  score = 0;
  peakScore = 0;
  diamonds = 0;
  diamondsBought = 0;
  piecesPlaced = 0;
  lavaPlaced = 0;
  grid = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(null));
  availableShapes = [];
  draggingShape = null;
  dragOffset = {x:0, y:0};
  dragPos = {x:0, y:0};
  rngSeed = Math.floor(Math.random()*100000);
  gameOver = false;
  refillShapes();
  updateScoreDisplay();
  render();
}
    function canAnyShapeFit() {
  // Only count non-diamond and non-lava shapes for fit check
  for (const shape of availableShapes) {
    if (shape.isDiamond || shape.isLava) continue;
    for (let gy=0; gy<GRID_SIZE; gy++) {
      for (let gx=0; gx<GRID_SIZE; gx++) {
        if (canPlace(shape, gx, gy)) return true;
      }
    }
  }
  return false;
}
    function hasDiamondAvailable() {
  return availableShapes.some(shape => shape.isDiamond);
}
    function hasLavaAvailable() {
  return availableShapes.some(shape => shape.isLava);
}
    function checkGameEnd() {
  // End only if no non-special shapes can fit, no diamonds or lava available, and not enough score to buy a diamond
  if (!canAnyShapeFit() && !hasDiamondAvailable() && !hasLavaAvailable() && score < DIAMOND_COST) {
    gameOver = true;
    if (score > highestScore) highestScore = score;
    render();
  }
}
    function placeShape(shape, gx, gy) {
      // Find center of placed piece for coin animation
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      const gridY = cell * 1.0;
      let sumX = 0, sumY = 0;
      for (const block of shape.blocks) {
        const x = gx+block.x, y = gy+block.y;
        // Place the piece first (lava becomes cooled when placed)
        if (shape.isLava) {
          grid[y][x] = {color: COOLED_LAVA_COLOR, isDiamond: false, isLava: false, isCooledLava: true};
        } else {
          grid[y][x] = {color: shape.color, isDiamond: shape.isDiamond, isLava: shape.isLava};
        }
        sumX += gridX + x*cell + cell/2;
        sumY += gridY + y*cell + cell/2;
      }
      
      // If it's a lava piece, burn adjacent cells (including diagonals)
      if (shape.isLava) {
        for (const block of shape.blocks) {
          const bx = gx+block.x, by = gy+block.y;
          // Check all 8 adjacent cells (including diagonals)
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue; // Skip the lava piece itself (now cooled)
              const adjX = bx + dx, adjY = by + dy;
              if (adjX >= 0 && adjX < GRID_SIZE && adjY >= 0 && adjY < GRID_SIZE) {
                // Only burn if it's not the lava piece we just placed
                let isLavaPiece = false;
                for (const lavaBlock of shape.blocks) {
                  if (adjX === gx + lavaBlock.x && adjY === gy + lavaBlock.y) {
                    isLavaPiece = true;
                    break;
                  }
                }
                if (!isLavaPiece) {
                  grid[adjY][adjX] = null; // Burn the adjacent cell
                }
              }
            }
          }
        }
      }
      
      piecesPlaced++;
      if (shape.isLava) {
        lavaPlaced++;
      }
      // Animate coin from piece center
      animateCoin(sumX/shape.blocks.length, sumY/shape.blocks.length);
      // Clear rows/cols
      // First, find all full rows and columns before clearing anything
      let fullRows = [];
      let fullCols = [];
      for (let y=0; y<GRID_SIZE; y++) {
        if (grid[y].every(cell=>cell)) fullRows.push(y);
      }
      for (let x=0; x<GRID_SIZE; x++) {
        if (grid.every(row=>row[x])) fullCols.push(x);
      }
      // If both a row and column are cleared, trigger free coins animation only
      if (fullRows.length > 0 && fullCols.length > 0) {
        // Accumulate all intersection points
        let sumX = 0, sumY = 0, count = 0;
        for (const y of fullRows) {
          for (const x of fullCols) {
            sumX += gridX + x*cell + cell/2;
            sumY += gridY + y*cell + cell/2;
            count++;
          }
        }
        // Animate coins from average intersection center
        if (count > 0) {
          animateFreeCoins(sumX/count, sumY/count);
        }
        score += 10; // Free coins
      }
      // Now clear all full rows
      for (const y of fullRows) {
        for (let x=0; x<GRID_SIZE; x++) grid[y][x]=null;
      }
      // Now clear all full columns
      for (const x of fullCols) {
        for (let y=0; y<GRID_SIZE; y++) grid[y][x]=null;
      }
      let cleared = fullRows.length + fullCols.length;
      score += cleared*5 + 1;
      updateScoreDisplay();
      // Don't check game end here - wait until after refill
    }
    function renderGameOver() {
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#222';
  ctx.textAlign = 'center';
  ctx.font = `bold ${canvas.height/14}px sans-serif`;
  ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - canvas.height/10);
  ctx.font = `${canvas.height/28}px sans-serif`;
  ctx.fillText(`Peak Score: ${peakScore}`, canvas.width/2, canvas.height/2);
  ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + canvas.height/18);
  ctx.fillText(`Diamonds Bought: ${diamondsBought}`, canvas.width/2, canvas.height/2 + canvas.height/9);
  ctx.fillText(`Lava Pieces Placed: ${lavaPlaced}`, canvas.width/2, canvas.height/2 + canvas.height/7.2);
  ctx.fillText(`Pieces Placed: ${piecesPlaced}`, canvas.width/2, canvas.height/2 + canvas.height/6);
  ctx.font = `bold ${canvas.height/32}px sans-serif`;
  ctx.fillText('Click anywhere to start a new game', canvas.width/2, canvas.height/2 + canvas.height/4);
  ctx.restore();
}
    function render() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  drawAvailableShapes();
  drawDraggingShape();
  const coinAnimating = renderCoinAnim();
  const diamondAnimating = renderDiamondCoinAnims();
  const freeAnimating = renderFreeCoinAnims();
  if (gameOver) renderGameOver();
  
  // Continue animation loop if any animation is still running
  if (coinAnimating || diamondAnimating || freeAnimating) {
    requestAnimationFrame(render);
  }
    }
    // --- GAME LOGIC ---
    function canPlace(shape, gx, gy) {
      for (const block of shape.blocks) {
        const x = gx+block.x, y = gy+block.y;
        if (x<0||x>=GRID_SIZE||y<0||y>=GRID_SIZE) return false;
        if (!shape.isDiamond && !shape.isLava && grid[y][x]) return false;
        // Lava pieces can be placed on occupied cells, but diamonds cannot be placed on lava
        if (shape.isDiamond && grid[y][x] && grid[y][x].isLava) return false;
      }
      return true;
    }
    // --- DRAG & DROP ---
    canvas.addEventListener('mousedown', e => {
  if (gameOver) {
    resetGame();
    return;
  }
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      const y0 = cell * (GRID_SIZE + 1.5);
      const shapesAreaWidth = gridWidth;
      const shapeSpacing = shapesAreaWidth / 3;
      for (let i=0; i<availableShapes.length; i++) {
        const shape = availableShapes[i];
        const box = getShapeBoundingBox(shape);
        const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
        const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
        // Use bounding box for hit detection
        const shapeLeft = x0;
        const shapeTop = yCenter;
        const shapeRight = x0 + (box.maxX-box.minX+1)*cell;
        const shapeBottom = yCenter + (box.maxY-box.minY+1)*cell;
        if (mx > shapeLeft && mx < shapeRight && my > shapeTop && my < shapeBottom) {
          draggingShape = shape;
          dragOffset.x = mx - shapeLeft;
          dragOffset.y = my - shapeTop;
          dragPos.x = mx - dragOffset.x;
          dragPos.y = my - dragOffset.y;
          draggingShape.startX = x0;
          draggingShape.startY = yCenter;
          draggingShape.box = box;
          availableShapes.splice(i,1);
          render();
          return;
        }
      }
    });
    canvas.addEventListener('mousemove', e => {
  if (!draggingShape) return;
  const rect = canvas.getBoundingClientRect();
  dragPos.x = e.clientX - rect.left - dragOffset.x;
  dragPos.y = e.clientY - rect.top - dragOffset.y;
  render();
    });
    canvas.addEventListener('mouseup', e => {
      if (!draggingShape) return;
  const cell = getCellSize();
  const gridWidth = cell * GRID_SIZE;
  const gridX = (canvas.width - gridWidth) / 2;
  const gridY = cell * 1.0; // match drawGrid
  const box = draggingShape.box || getShapeBoundingBox(draggingShape);
  // Use dragOffset to calculate drop position
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const gx = Math.round((mx - dragOffset.x - gridX)/cell - box.minX);
  const gy = Math.round((my - dragOffset.y - gridY)/cell - box.minY);
      if (canPlace(draggingShape, gx, gy)) {
        placeShape(draggingShape, gx, gy);
        draggingShape = null;
        refillShapes();
        checkGameEnd(); // Check game end after refilling shapes
        render();
      } else {
        availableShapes.push(draggingShape);
        draggingShape = null;
        render();
      }
    });
    // --- DIAMOND BUY ---
    document.getElementById('diamond-btn').onclick = () => {
      if (score >= DIAMOND_COST) {
        score -= DIAMOND_COST;
        diamonds++;
        diamondsBought++;
        // Replace a non-diamond shape
        for (let i=0; i<availableShapes.length; i++) {
          if (!availableShapes[i].isDiamond && !availableShapes[i].isLava) {
            availableShapes[i] = pickShape(true, false);
            // Animate coins to new diamond piece
            // Find diamond piece's center
            const cell = getCellSize();
            const gridWidth = cell * GRID_SIZE;
            const gridX = (canvas.width - gridWidth) / 2;
            const y0 = cell * (GRID_SIZE + 1.5);
            const shapesAreaWidth = gridWidth;
            const shapeSpacing = shapesAreaWidth / 3;
            const shape = availableShapes[i];
            const box = getShapeBoundingBox(shape);
            const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
            const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
            let sumX = 0, sumY = 0;
            for (const block of shape.blocks) {
              sumX += x0 + (block.x-box.minX)*cell + cell/2;
              sumY += yCenter + (block.y-box.minY)*cell + cell/2;
            }
            const pieceCenterX = sumX/shape.blocks.length;
            const pieceCenterY = sumY/shape.blocks.length;
            animateDiamondCoins(pieceCenterX, pieceCenterY);
            break;
          }
        }
        updateScoreDisplay();
        render();
        checkGameEnd(); // Check game end after buying diamond
      }
    };
    // --- INIT ---
    refillShapes();
    updateScoreDisplay();
    render();
  </script>
</body>
</html>
