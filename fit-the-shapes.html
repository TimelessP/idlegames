<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Fit the Shapes</title>
  <style>
    :root {
      --bg-color: #f8f8fc;
      --text-color: #222;
      --canvas-bg: #fff;
      --button-bg: #e0f7fa;
      --button-text: #00796b;
      --shadow-color: rgba(0,0,0,0.12);
      --shadow-light: rgba(0,0,0,0.08);
    }
    
    [data-theme="light"] {
      --bg-color: #f8f8fc;
      --text-color: #222;
      --canvas-bg: #fff;
      --button-bg: #e0f7fa;
      --button-text: #00796b;
      --shadow-color: rgba(0,0,0,0.12);
      --shadow-light: rgba(0,0,0,0.08);
    }
    
    [data-theme="dark"] {
      --bg-color: #1a1a2e;
      --text-color: #eee;
      --canvas-bg: #16213e;
      --button-bg: #0f3460;
      --button-text: #4fc3f7;
      --shadow-color: rgba(0,0,0,0.5);
      --shadow-light: rgba(0,0,0,0.3);
    }
    
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg-color);
      overflow: hidden;
      transition: background-color 0.3s ease;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      padding: 0.5em;
      box-sizing: border-box;
    }
    #controls {
      display: flex;
      align-items: center;
      gap: 1em;
      margin-bottom: 0.3em;
      width: 100%;
      max-width: 600px;
      justify-content: space-between;
    }
    #score {
      font-size: 2em;
      color: var(--text-color);
      text-align: center;
      transition: color 0.3s ease;
    }
    #diamond-btn, #theme-btn {
      font-size: 1em;
      margin-bottom: 0.3em;
      background: var(--button-bg);
      border: none;
      border-radius: 0.5em;
      padding: 0.5em 1em;
      cursor: pointer;
      color: var(--button-text);
      box-shadow: 0 2px 8px var(--shadow-light);
      transition: all 0.3s ease;
      max-width: 300px;
      width: 100%;
    }
    #diamond-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    #theme-btn {
      margin-bottom: 0;
      padding: 0.5em;
      min-width: 2.5em;
      width: auto;
      flex-shrink: 0;
    }
    #game-canvas {
      display: block;
      margin: 0 auto;
      background: var(--canvas-bg);
      border-radius: 1em;
      box-shadow: 0 2px 16px var(--shadow-color);
      transition: all 0.3s ease;
      touch-action: none; /* Prevent default touch behaviors */
    }
    
    /* Mobile optimizations */
    @media (max-width: 768px) {
      body {
        padding: 0.25em;
      }
      
      #controls {
        margin-bottom: 0.2em;
      }
      
      #score {
        font-size: 1.5em;
      }
      
      #diamond-btn {
        font-size: 0.9em;
        padding: 0.4em 0.8em;
        margin-bottom: 0.2em;
      }
      
      #theme-btn {
        padding: 0.4em;
        font-size: 0.9em;
      }
      
      #game-canvas {
        border-radius: 0.5em;
        box-shadow: 0 1px 8px var(--shadow-color);
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding: 0.1em;
      }
      
      #score {
        font-size: 1.2em;
      }
      
      #diamond-btn {
        font-size: 0.8em;
        padding: 0.3em 0.6em;
      }
      
      #game-canvas {
        border-radius: 0.25em;
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <div id="score">Score: 0</div>
    <button id="theme-btn" title="Toggle theme">üåì</button>
  </div>
  <button id="diamond-btn">Buy Diamond Shape (10 pts)</button>
  <canvas id="game-canvas"></canvas>
  <script>
    // --- CONFIG ---
    const GRID_SIZE = 10;
    const CELL_SIZE = 40; // Will be scaled
    const SHAPE_COLORS = ["#ff5252", "#ffd600", "#40c4ff", "#69f0ae", "#ff4081", "#7c4dff", "#ffab40", "#00bfae"];
    const DIAMOND_COLOR_LIGHT = "#e0f7fa";
    const DIAMOND_COLOR_DARK = "#4fc3f7";
    const LAVA_COLOR = "#ff3d00";
    const COOLED_LAVA_COLOR = "#8d6e63"; // Brown color for cooled lava
    const DIAMOND_COST = 10;
    const SHAPES = [
      // I
      [[0,0],[1,0],[2,0],[3,0]],
      // O
      [[0,0],[1,0],[0,1],[1,1]],
      // T
      [[1,0],[0,1],[1,1],[2,1]],
      // S
      [[1,0],[2,0],[0,1],[1,1]],
      // Z
      [[0,0],[1,0],[1,1],[2,1]],
      // J
      [[0,0],[0,1],[1,1],[2,1]],
      // L
      [[2,0],[0,1],[1,1],[2,1]]
    ];
    
    // --- THEME MANAGEMENT ---
    const THEMES = ['system', 'light', 'dark'];
    let currentThemeIndex = 0;
    
    function getSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    
    function applyTheme(theme) {
      if (theme === 'system') {
        // Detect system preference and apply it
        const systemTheme = getSystemTheme();
        document.documentElement.setAttribute('data-theme', systemTheme);
      } else {
        document.documentElement.setAttribute('data-theme', theme);
      }
    }
    
    function updateThemeButton() {
      const themeBtn = document.getElementById('theme-btn');
      const theme = THEMES[currentThemeIndex];
      const icons = { system: 'üåì', light: '‚òÄÔ∏è', dark: 'üåô' };
      const titles = { 
        system: 'System theme', 
        light: 'Light theme', 
        dark: 'Dark theme' 
      };
      themeBtn.textContent = icons[theme];
      themeBtn.title = titles[theme];
    }
    
    function cycleTheme() {
      currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
      const theme = THEMES[currentThemeIndex];
      applyTheme(theme);
      updateThemeButton();
      localStorage.setItem('theme', theme);
      
      // Update diamond colors in existing shapes and grid
      const newDiamondColor = getDiamondColor();
      for (const shape of availableShapes) {
        if (shape.isDiamond) {
          shape.color = newDiamondColor;
        }
      }
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] && grid[y][x].isDiamond) {
            grid[y][x].color = newDiamondColor;
          }
        }
      }
      render();
    }
    
    function initTheme() {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme && THEMES.includes(savedTheme)) {
        currentThemeIndex = THEMES.indexOf(savedTheme);
      }
      applyTheme(THEMES[currentThemeIndex]);
      updateThemeButton();
      
      // Listen for system theme changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        // Only update if we're in system mode
        if (THEMES[currentThemeIndex] === 'system') {
          applyTheme('system');
          // Update diamond colors for system theme change
          const newDiamondColor = getDiamondColor();
          for (const shape of availableShapes) {
            if (shape.isDiamond) {
              shape.color = newDiamondColor;
            }
          }
          for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
              if (grid[y][x] && grid[y][x].isDiamond) {
                grid[y][x].color = newDiamondColor;
              }
            }
          }
          render();
        }
      });
    }
    
    function getDiamondColor() {
      const currentTheme = THEMES[currentThemeIndex];
      if (currentTheme === 'dark') {
        return DIAMOND_COLOR_DARK;
      } else if (currentTheme === 'light') {
        return DIAMOND_COLOR_LIGHT;
      } else {
        // System theme - check actual preference
        return getSystemTheme() === 'dark' ? DIAMOND_COLOR_DARK : DIAMOND_COLOR_LIGHT;
      }
    }
    
    function getThemeColors() {
      const currentTheme = THEMES[currentThemeIndex];
      const isDark = currentTheme === 'dark' || (currentTheme === 'system' && getSystemTheme() === 'dark');
      
      return {
        modalBg: isDark ? '#1a1a2e' : '#fff',
        modalText: isDark ? '#eee' : '#222'
      };
    }
    
    // --- STATE ---
    let score = 0;
    let diamonds = 0;
    let grid = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(null));
    let availableShapes = [];
    let draggingShape = null;
    let dragOffset = {x:0, y:0};
    let dragPos = {x:0, y:0};
    let rngSeed = 12345;
    const SHAPES_AREA_ROWS = 4; // Reserve 4 grid rows for available shapes area
    let highestScore = 0;
let diamondsBought = 0;
let piecesPlaced = 0;
let lavaPlaced = 0;
let gameOver = false;
let peakScore = 0;
    // --- UTILS ---
    function seededRandom() {
      // xorshift
      rngSeed ^= rngSeed << 13;
      rngSeed ^= rngSeed >> 17;
      rngSeed ^= rngSeed << 5;
      return Math.abs(rngSeed) % 10000 / 10000;
    }
    function rotateShape(blocks, rot) {
      // rot: 0=0¬∞, 1=90¬∞, 2=180¬∞, 3=270¬∞
      let newBlocks = blocks.map(b => ({x:b.x, y:b.y}));
      for (let r=0; r<rot; r++) {
        // Rotate 90¬∞ clockwise around (0,0)
        newBlocks = newBlocks.map(b => ({x: b.y, y: -b.x}));
        // Normalize to top-left
        let minX = Math.min(...newBlocks.map(b=>b.x));
        let minY = Math.min(...newBlocks.map(b=>b.y));
        newBlocks = newBlocks.map(b => ({x: b.x-minX, y: b.y-minY}));
      }
      return newBlocks;
    }
    function pickShape(isDiamond=false, isLava=false) {
      const idx = Math.floor(seededRandom()*SHAPES.length);
      const rot = Math.floor(seededRandom()*4); // 0,1,2,3
      let blocks = rotateShape(SHAPES[idx].map(([x,y])=>({x,y})), rot);
      let color;
      if (isDiamond) {
        color = getDiamondColor();
      } else if (isLava) {
        color = LAVA_COLOR;
      } else {
        color = SHAPE_COLORS[Math.floor(seededRandom()*SHAPE_COLORS.length)];
      }
      return {
        blocks,
        color,
        isDiamond,
        isLava,
        rot
      };
    }
    function refillShapes() {
      while (availableShapes.length < 3) {
        const rand = seededRandom();
        if (rand < 0.125) {
          // 1 in 8 chance for diamond
          availableShapes.push(pickShape(true, false));
        } else if (rand < 0.25) {
          // 1 in 8 chance for lava (next 1/8)
          availableShapes.push(pickShape(false, true));
        } else {
          // Normal piece
          availableShapes.push(pickShape(false, false));
        }
      }
    }
    function updateScoreDisplay() {
      if (score > peakScore) peakScore = score;
      document.getElementById('score').textContent = `Score: ${score}`;
      document.getElementById('diamond-btn').disabled = score < DIAMOND_COST;
    }
    // --- CANVAS ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      // Calculate available space, accounting for UI elements
      const isMobile = window.innerWidth <= 768;
      const controlsHeight = isMobile ? 45 : 60; // Smaller on mobile
      const buttonHeight = isMobile ? 35 : 50;   // Smaller on mobile
      const margin = isMobile ? 10 : 20;         // Smaller margins on mobile
      const totalUIHeight = controlsHeight + buttonHeight + margin * 3;
      
      const availableWidth = window.innerWidth - (isMobile ? 10 : 20);
      const availableHeight = window.innerHeight - totalUIHeight;
      
      // Use more space on mobile (98% vs 95%)
      const spaceUtilization = isMobile ? 0.98 : 0.95;
      const size = Math.min(availableWidth, availableHeight) * spaceUtilization;
      canvas.width = size;
      canvas.height = size;
      
      // Only render if game is initialized (availableShapes exist)
      if (availableShapes.length > 0) {
        render();
      }
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    // Calculate cell size so grid and shapes fit vertically
    function getCellSize() {
      // Reserve space for grid, margin, and fixed shapes area
      // 1 cell margin above, SHAPES_AREA_ROWS cells for shapes area, 1 cell margin below
      return canvas.height / (GRID_SIZE + SHAPES_AREA_ROWS + 2);
    }
    function getShapeBoundingBox(shape) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const block of shape.blocks) {
        minX = Math.min(minX, block.x);
        minY = Math.min(minY, block.y);
        maxX = Math.max(maxX, block.x);
        maxY = Math.max(maxY, block.y);
      }
      return {minX, minY, maxX, maxY};
    }
    // --- DRAW ---
    function drawGrid() {
  const cell = getCellSize();
  const gridWidth = cell * GRID_SIZE;
  const gridHeight = cell * GRID_SIZE;
  // Center grid horizontally, add top margin
  const gridX = (canvas.width - gridWidth) / 2;
  const gridY = cell * 1.0; // 1 cell margin at top
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Draw grid
      ctx.save();
      ctx.translate(gridX, gridY);
      for (let y=0; y<GRID_SIZE; y++) {
        for (let x=0; x<GRID_SIZE; x++) {
          ctx.strokeStyle = '#bbb';
          ctx.lineWidth = 2;
          ctx.strokeRect(x*cell, y*cell, cell, cell);
          if (grid[y][x]) {
            ctx.fillStyle = grid[y][x].color;
            ctx.fillRect(x*cell+2, y*cell+2, cell-4, cell-4);
            if (grid[y][x].isDiamond) {
              ctx.strokeStyle = '#00bcd4';
              ctx.lineWidth = 3;
              ctx.strokeRect(x*cell+6, y*cell+6, cell-12, cell-12);
            } else if (grid[y][x].isLava) {
              // Lava effect: glowing border
              ctx.strokeStyle = '#ff8a50';
              ctx.lineWidth = 3;
              ctx.strokeRect(x*cell+6, y*cell+6, cell-12, cell-12);
            } else if (grid[y][x].isCooledLava) {
              // Cooled lava effect: darker border
              ctx.strokeStyle = '#5d4037';
              ctx.lineWidth = 2;
              ctx.strokeRect(x*cell+8, y*cell+8, cell-16, cell-16);
            }
          }
        }
      }
      ctx.restore();
    }
    function drawAvailableShapes() {
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      // Fixed area for shapes below grid
      const y0 = cell * (GRID_SIZE + 1.5); // 1.5 cells below grid
      const shapesAreaWidth = gridWidth;
      const shapeSpacing = shapesAreaWidth / 3;
      for (let i=0; i<availableShapes.length; i++) {
        const shape = availableShapes[i];
        const box = getShapeBoundingBox(shape);
        // Center each shape horizontally and vertically in its third of the fixed area
        const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
        const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
        for (const block of shape.blocks) {
          ctx.fillStyle = shape.color;
          ctx.fillRect(x0+(block.x-box.minX)*cell, yCenter+(block.y-box.minY)*cell, cell-4, cell-4);
          if (shape.isDiamond) {
            ctx.strokeStyle = '#00bcd4';
            ctx.lineWidth = 3;
            ctx.strokeRect(x0+(block.x-box.minX)*cell+6, yCenter+(block.y-box.minY)*cell+6, cell-12, cell-12);
          } else if (shape.isLava) {
            ctx.strokeStyle = '#ff8a50';
            ctx.lineWidth = 3;
            ctx.strokeRect(x0+(block.x-box.minX)*cell+6, yCenter+(block.y-box.minY)*cell+6, cell-12, cell-12);
          }
        }
      }
    }
    function drawDraggingShape() {
      if (!draggingShape) return;
      const cell = getCellSize();
      const box = draggingShape.box || getShapeBoundingBox(draggingShape);
      const minX = box.minX;
      const minY = box.minY;
      for (const block of draggingShape.blocks) {
        ctx.fillStyle = draggingShape.color;
        ctx.globalAlpha = 0.7;
        ctx.fillRect(
          dragPos.x + (block.x-minX)*cell,
          dragPos.y + (block.y-minY)*cell,
          cell-4, cell-4
        );
        ctx.globalAlpha = 1;
        if (draggingShape.isDiamond) {
          ctx.strokeStyle = '#00bcd4';
          ctx.lineWidth = 3;
          ctx.strokeRect(
            dragPos.x + (block.x-minX)*cell+6,
            dragPos.y + (block.y-minY)*cell+6,
            cell-12, cell-12
          );
        } else if (draggingShape.isLava) {
          ctx.strokeStyle = '#ff8a50';
          ctx.lineWidth = 3;
          ctx.strokeRect(
            dragPos.x + (block.x-minX)*cell+6,
            dragPos.y + (block.y-minY)*cell+6,
            cell-12, cell-12
          );
        }
      }
    }
    let coinAnim = null;
// let shakeAnim = null;
let freeCoinAnims = null;
function animateCoin(fromX, fromY) {
  const start = Date.now();
  const duration = 700;
  const endX = canvas.width/2;
  const endY = 0;
  coinAnim = {fromX, fromY, endX, endY, start, duration};
  requestAnimationFrame(render);
}

function animateFreeCoins(fromX, fromY) {
  // Use a single animation instance for all coins, matching diamond buy
  const start = Date.now();
  const duration = 700;
  const coins = [];
  for (let i=0; i<10; i++) {
    const angle = (-1.2 + 2.4*Math.random());
    const speed = 1 + 0.7*(Math.random()-0.5);
    coins.push({
      duration: duration * speed,
      angle,
    });
  }
  freeCoinAnims = {
    start,
    fromX,
    fromY,
    toX: canvas.width/2,
    toY: 0,
    coins
  };
  requestAnimationFrame(render);
}

function renderFreeCoinAnims() {
  if (!freeCoinAnims) return;
  const now = Date.now();
  let stillAnimating = false;
  for (const coin of freeCoinAnims.coins) {
    const t = Math.min(1, (now-freeCoinAnims.start)/coin.duration);
    if (t < 1) stillAnimating = true;
    const ease = 1 - Math.pow(1-t,3);
    const x = freeCoinAnims.fromX + (freeCoinAnims.toX-freeCoinAnims.fromX)*ease + Math.sin(coin.angle)*120*(1-t);
    const y = freeCoinAnims.fromY + (freeCoinAnims.toY-freeCoinAnims.fromY)*ease + Math.sin(coin.angle)*60*(1-t);
    ctx.save();
    ctx.font = `${canvas.height/24}px serif`;
    ctx.globalAlpha = 0.7 + 0.3*(1-t);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ü™ô', x, y);
    ctx.restore();
  }
  if (!stillAnimating) {
    freeCoinAnims = null;
  }
  return stillAnimating;
}
function renderCoinAnim() {
  if (!coinAnim) return;
  const now = Date.now();
  const t = Math.min(1, (now-coinAnim.start)/coinAnim.duration);
  // Ease out cubic
  const ease = 1 - Math.pow(1-t,3);
  const x = coinAnim.fromX + (coinAnim.endX-coinAnim.fromX)*ease;
  const y = coinAnim.fromY + (coinAnim.endY-coinAnim.fromY)*ease;
  ctx.save();
  ctx.font = `${canvas.height/18}px serif`;
  ctx.globalAlpha = 0.7 + 0.3*(1-t);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('ü™ô', x, y);
  ctx.restore();
  if (t >= 1) {
    coinAnim = null;
  }
  return t < 1;
}
let diamondCoinAnims = [];
function animateDiamondCoins(toX, toY) {
  diamondCoinAnims = [];
  const start = Date.now();
  const duration = 700;
  for (let i=0; i<10; i++) {
    const angle = (-1.2 + 2.4*Math.random()); // much wider arc offset
    const speed = 1 + 0.7*(Math.random()-0.5); // greater speed variation
    diamondCoinAnims.push({
      start,
      duration: duration * speed,
      fromX: canvas.width/2,
      fromY: 0,
      toX,
      toY,
      angle,
    });
  }
  requestAnimationFrame(render);
}
function renderDiamondCoinAnims() {
  if (!diamondCoinAnims.length) return;
  const now = Date.now();
  let stillAnimating = false;
  for (const anim of diamondCoinAnims) {
    const t = Math.min(1, (now-anim.start)/anim.duration);
    if (t < 1) stillAnimating = true;
    // Arc trajectory
    const ease = 1 - Math.pow(1-t,3);
    const x = anim.fromX + (anim.toX-anim.fromX)*ease + Math.sin(anim.angle)*120*(1-t);
    const y = anim.fromY + (anim.toY-anim.fromY)*ease + Math.sin(anim.angle)*60*(1-t);
    ctx.save();
    ctx.font = `${canvas.height/24}px serif`;
    ctx.globalAlpha = 0.7 + 0.3*(1-t);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ü™ô', x, y);
    ctx.restore();
  }
  if (!stillAnimating) {
    diamondCoinAnims = [];
  }
  return stillAnimating;
}
    function resetGame() {
  score = 0;
  peakScore = 0;
  diamonds = 0;
  diamondsBought = 0;
  piecesPlaced = 0;
  lavaPlaced = 0;
  grid = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(null));
  availableShapes = [];
  draggingShape = null;
  dragOffset = {x:0, y:0};
  dragPos = {x:0, y:0};
  rngSeed = Math.floor(Math.random()*100000);
  gameOver = false;
  refillShapes();
  updateScoreDisplay();
  render();
}
    function canAnyShapeFit() {
  // Only count non-diamond and non-lava shapes for fit check
  for (const shape of availableShapes) {
    if (shape.isDiamond || shape.isLava) continue;
    for (let gy=0; gy<GRID_SIZE; gy++) {
      for (let gx=0; gx<GRID_SIZE; gx++) {
        if (canPlace(shape, gx, gy)) return true;
      }
    }
  }
  return false;
}
    function hasDiamondAvailable() {
  return availableShapes.some(shape => shape.isDiamond);
}
    function hasLavaAvailable() {
  return availableShapes.some(shape => shape.isLava);
}
    function checkGameEnd() {
  // End only if no non-special shapes can fit, no diamonds or lava available, and not enough score to buy a diamond
  if (!canAnyShapeFit() && !hasDiamondAvailable() && !hasLavaAvailable() && score < DIAMOND_COST) {
    gameOver = true;
    if (score > highestScore) highestScore = score;
    render();
  }
}
    function placeShape(shape, gx, gy) {
      // Find center of placed piece for coin animation
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      const gridY = cell * 1.0;
      let sumX = 0, sumY = 0;
      for (const block of shape.blocks) {
        const x = gx+block.x, y = gy+block.y;
        // Place the piece first (lava becomes cooled when placed)
        if (shape.isLava) {
          grid[y][x] = {color: COOLED_LAVA_COLOR, isDiamond: false, isLava: false, isCooledLava: true};
        } else {
          grid[y][x] = {color: shape.color, isDiamond: shape.isDiamond, isLava: shape.isLava};
        }
        sumX += gridX + x*cell + cell/2;
        sumY += gridY + y*cell + cell/2;
      }
      
      // If it's a lava piece, burn adjacent cells (including diagonals)
      if (shape.isLava) {
        for (const block of shape.blocks) {
          const bx = gx+block.x, by = gy+block.y;
          // Check all 8 adjacent cells (including diagonals)
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue; // Skip the lava piece itself (now cooled)
              const adjX = bx + dx, adjY = by + dy;
              if (adjX >= 0 && adjX < GRID_SIZE && adjY >= 0 && adjY < GRID_SIZE) {
                // Only burn if it's not the lava piece we just placed
                let isLavaPiece = false;
                for (const lavaBlock of shape.blocks) {
                  if (adjX === gx + lavaBlock.x && adjY === gy + lavaBlock.y) {
                    isLavaPiece = true;
                    break;
                  }
                }
                if (!isLavaPiece) {
                  grid[adjY][adjX] = null; // Burn the adjacent cell
                }
              }
            }
          }
        }
      }
      
      piecesPlaced++;
      if (shape.isLava) {
        lavaPlaced++;
      }
      // Animate coin from piece center
      animateCoin(sumX/shape.blocks.length, sumY/shape.blocks.length);
      // Clear rows/cols
      // First, find all full rows and columns before clearing anything
      let fullRows = [];
      let fullCols = [];
      for (let y=0; y<GRID_SIZE; y++) {
        if (grid[y].every(cell=>cell)) fullRows.push(y);
      }
      for (let x=0; x<GRID_SIZE; x++) {
        if (grid.every(row=>row[x])) fullCols.push(x);
      }
      // If both a row and column are cleared, trigger free coins animation only
      if (fullRows.length > 0 && fullCols.length > 0) {
        // Accumulate all intersection points
        let sumX = 0, sumY = 0, count = 0;
        for (const y of fullRows) {
          for (const x of fullCols) {
            sumX += gridX + x*cell + cell/2;
            sumY += gridY + y*cell + cell/2;
            count++;
          }
        }
        // Animate coins from average intersection center
        if (count > 0) {
          animateFreeCoins(sumX/count, sumY/count);
        }
        score += 10; // Free coins
      }
      // Now clear all full rows
      for (const y of fullRows) {
        for (let x=0; x<GRID_SIZE; x++) grid[y][x]=null;
      }
      // Now clear all full columns
      for (const x of fullCols) {
        for (let y=0; y<GRID_SIZE; y++) grid[y][x]=null;
      }
      let cleared = fullRows.length + fullCols.length;
      score += cleared*5 + 1;
      updateScoreDisplay();
      // Don't check game end here - wait until after refill
    }
    function renderGameOver() {
  const themeColors = getThemeColors();
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = themeColors.modalBg;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.globalAlpha = 1;
  ctx.fillStyle = themeColors.modalText;
  ctx.textAlign = 'center';
  ctx.font = `bold ${canvas.height/14}px sans-serif`;
  ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - canvas.height/10);
  ctx.font = `${canvas.height/28}px sans-serif`;
  ctx.fillText(`Peak Score: ${peakScore}`, canvas.width/2, canvas.height/2);
  ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + canvas.height/18);
  ctx.fillText(`Diamonds Bought: ${diamondsBought}`, canvas.width/2, canvas.height/2 + canvas.height/9);
  ctx.fillText(`Lava Pieces Placed: ${lavaPlaced}`, canvas.width/2, canvas.height/2 + canvas.height/7.2);
  ctx.fillText(`Pieces Placed: ${piecesPlaced}`, canvas.width/2, canvas.height/2 + canvas.height/6);
  ctx.font = `bold ${canvas.height/32}px sans-serif`;
  ctx.fillText('Click anywhere to start a new game', canvas.width/2, canvas.height/2 + canvas.height/4);
  ctx.restore();
}
    function render() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  drawAvailableShapes();
  drawDraggingShape();
  const coinAnimating = renderCoinAnim();
  const diamondAnimating = renderDiamondCoinAnims();
  const freeAnimating = renderFreeCoinAnims();
  if (gameOver) renderGameOver();
  
  // Continue animation loop if any animation is still running
  if (coinAnimating || diamondAnimating || freeAnimating) {
    requestAnimationFrame(render);
  }
    }
    // --- GAME LOGIC ---
    function canPlace(shape, gx, gy) {
      for (const block of shape.blocks) {
        const x = gx+block.x, y = gy+block.y;
        if (x<0||x>=GRID_SIZE||y<0||y>=GRID_SIZE) return false;
        if (!shape.isDiamond && !shape.isLava && grid[y][x]) return false;
        // Diamonds cannot be placed on active lava (but can be placed on cooled lava and other pieces)
        if (shape.isDiamond && grid[y][x] && grid[y][x].isLava) return false;
      }
      return true;
    }
    // --- DRAG & DROP ---
    function getEventPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches.length > 0) {
        // Touch event
        return {
          x: e.touches[0].clientX - rect.left,
          y: e.touches[0].clientY - rect.top
        };
      } else {
        // Mouse event
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
      }
    }
    
    function handleStart(e) {
      e.preventDefault(); // Prevent scrolling and other default behaviors
      
      if (gameOver) {
        resetGame();
        return;
      }
      
      const pos = getEventPos(e);
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      const y0 = cell * (GRID_SIZE + 1.5);
      const shapesAreaWidth = gridWidth;
      const shapeSpacing = shapesAreaWidth / 3;
      const isTouch = e.touches && e.touches.length > 0;
      
      for (let i=0; i<availableShapes.length; i++) {
        const shape = availableShapes[i];
        const box = getShapeBoundingBox(shape);
        const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
        const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
        // Use bounding box for hit detection
        const shapeLeft = x0;
        const shapeTop = yCenter;
        const shapeRight = x0 + (box.maxX-box.minX+1)*cell;
        const shapeBottom = yCenter + (box.maxY-box.minY+1)*cell;
        
        if (pos.x > shapeLeft && pos.x < shapeRight && pos.y > shapeTop && pos.y < shapeBottom) {
          draggingShape = shape;
          
          if (isTouch) {
            // For touch: offset the shape above the finger by the shape's height plus some padding
            const shapeHeight = (box.maxY - box.minY + 1) * cell;
            const touchOffset = shapeHeight + cell * 0.5; // Add half a cell padding
            dragOffset.x = pos.x - shapeLeft;
            dragOffset.y = pos.y - shapeTop + touchOffset; // Move shape up by this amount
            dragPos.x = pos.x - dragOffset.x;
            dragPos.y = pos.y - dragOffset.y;
          } else {
            // For mouse: use normal offset (shape follows cursor position)
            dragOffset.x = pos.x - shapeLeft;
            dragOffset.y = pos.y - shapeTop;
            dragPos.x = pos.x - dragOffset.x;
            dragPos.y = pos.y - dragOffset.y;
          }
          
          draggingShape.startX = x0;
          draggingShape.startY = yCenter;
          draggingShape.box = box;
          draggingShape.isTouch = isTouch; // Remember if this drag started with touch
          availableShapes.splice(i,1);
          render();
          return;
        }
      }
    }
    
    function handleMove(e) {
      e.preventDefault(); // Prevent scrolling
      
      if (!draggingShape) return;
      
      const pos = getEventPos(e);
      dragPos.x = pos.x - dragOffset.x;
      dragPos.y = pos.y - dragOffset.y;
      render();
    }
    
    function handleEnd(e) {
      e.preventDefault(); // Prevent scrolling
      
      if (!draggingShape) return;
      
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      const gridY = cell * 1.0; // match drawGrid
      const box = draggingShape.box || getShapeBoundingBox(draggingShape);
      
      // Use dragOffset to calculate drop position
      const pos = getEventPos(e.changedTouches ? {touches: e.changedTouches} : e);
      const gx = Math.round((pos.x - dragOffset.x - gridX)/cell - box.minX);
      const gy = Math.round((pos.y - dragOffset.y - gridY)/cell - box.minY);
      
      if (canPlace(draggingShape, gx, gy)) {
        placeShape(draggingShape, gx, gy);
        draggingShape = null;
        refillShapes();
        checkGameEnd(); // Check game end after refilling shapes
        render();
      } else {
        availableShapes.push(draggingShape);
        draggingShape = null;
        render();
      }
    }
    
    // Mouse events
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    
    // Touch events
    canvas.addEventListener('touchstart', handleStart, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    canvas.addEventListener('touchend', handleEnd, { passive: false });
    // --- DIAMOND BUY ---
    document.getElementById('diamond-btn').onclick = () => {
      if (score >= DIAMOND_COST) {
        score -= DIAMOND_COST;
        diamonds++;
        diamondsBought++;
        // Replace a non-diamond shape
        for (let i=0; i<availableShapes.length; i++) {
          if (!availableShapes[i].isDiamond && !availableShapes[i].isLava) {
            availableShapes[i] = pickShape(true, false);
            // Animate coins to new diamond piece
            // Find diamond piece's center
            const cell = getCellSize();
            const gridWidth = cell * GRID_SIZE;
            const gridX = (canvas.width - gridWidth) / 2;
            const y0 = cell * (GRID_SIZE + 1.5);
            const shapesAreaWidth = gridWidth;
            const shapeSpacing = shapesAreaWidth / 3;
            const shape = availableShapes[i];
            const box = getShapeBoundingBox(shape);
            const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
            const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
            let sumX = 0, sumY = 0;
            for (const block of shape.blocks) {
              sumX += x0 + (block.x-box.minX)*cell + cell/2;
              sumY += yCenter + (block.y-box.minY)*cell + cell/2;
            }
            const pieceCenterX = sumX/shape.blocks.length;
            const pieceCenterY = sumY/shape.blocks.length;
            animateDiamondCoins(pieceCenterX, pieceCenterY);
            break;
          }
        }
        updateScoreDisplay();
        render();
        checkGameEnd(); // Check game end after buying diamond
      }
    };
    // --- THEME BUTTON ---
    document.getElementById('theme-btn').onclick = cycleTheme;
    
    // --- INIT ---
    initTheme();
    refillShapes();
    updateScoreDisplay();
    render();
  </script>
</body>
</html>
