<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fit the Shapes</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f8f8fc;
      overflow: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #score {
      font-size: 2em;
      margin-bottom: 0.5em;
      color: #222;
      text-align: center;
    }
    #diamond-btn {
      font-size: 1em;
      margin-bottom: 1em;
      background: #e0f7fa;
      border: none;
      border-radius: 0.5em;
      padding: 0.5em 1em;
      cursor: pointer;
      color: #00796b;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    #diamond-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    #game-canvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      border-radius: 1em;
      box-shadow: 0 2px 16px rgba(0,0,0,0.12);
    }
  </style>
</head>
<body>
  <div id="score">Score: 0 | Diamonds: 0</div>
  <button id="diamond-btn">Buy Diamond Shape (10 pts)</button>
  <canvas id="game-canvas"></canvas>
  <script>
    // --- CONFIG ---
    const GRID_SIZE = 10;
    const CELL_SIZE = 40; // Will be scaled
    const SHAPE_COLORS = ["#ff5252", "#ffd600", "#40c4ff", "#69f0ae", "#ff4081", "#7c4dff", "#ffab40", "#00bfae"];
    const DIAMOND_COLOR = "#e0f7fa";
    const DIAMOND_COST = 10;
    const SHAPES = [
      // I
      [[0,0],[1,0],[2,0],[3,0]],
      // O
      [[0,0],[1,0],[0,1],[1,1]],
      // T
      [[1,0],[0,1],[1,1],[2,1]],
      // S
      [[1,0],[2,0],[0,1],[1,1]],
      // Z
      [[0,0],[1,0],[1,1],[2,1]],
      // J
      [[0,0],[0,1],[1,1],[2,1]],
      // L
      [[2,0],[0,1],[1,1],[2,1]]
    ];
    // --- STATE ---
    let score = 0;
    let diamonds = 0;
    let grid = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(null));
    let availableShapes = [];
    let draggingShape = null;
    let dragOffset = {x:0, y:0};
    let dragPos = {x:0, y:0};
    let rngSeed = 12345;
    const SHAPES_AREA_ROWS = 4; // Reserve 4 grid rows for available shapes area
    // --- UTILS ---
    function seededRandom() {
      // xorshift
      rngSeed ^= rngSeed << 13;
      rngSeed ^= rngSeed >> 17;
      rngSeed ^= rngSeed << 5;
      return Math.abs(rngSeed) % 10000 / 10000;
    }
    function rotateShape(blocks, rot) {
      // rot: 0=0°, 1=90°, 2=180°, 3=270°
      let newBlocks = blocks.map(b => ({x:b.x, y:b.y}));
      for (let r=0; r<rot; r++) {
        // Rotate 90° clockwise around (0,0)
        newBlocks = newBlocks.map(b => ({x: b.y, y: -b.x}));
        // Normalize to top-left
        let minX = Math.min(...newBlocks.map(b=>b.x));
        let minY = Math.min(...newBlocks.map(b=>b.y));
        newBlocks = newBlocks.map(b => ({x: b.x-minX, y: b.y-minY}));
      }
      return newBlocks;
    }
    function pickShape(isDiamond=false) {
      const idx = Math.floor(seededRandom()*SHAPES.length);
      const rot = Math.floor(seededRandom()*4); // 0,1,2,3
      let blocks = rotateShape(SHAPES[idx].map(([x,y])=>({x,y})), rot);
      return {
        blocks,
        color: isDiamond ? DIAMOND_COLOR : SHAPE_COLORS[Math.floor(seededRandom()*SHAPE_COLORS.length)],
        isDiamond,
        rot
      };
    }
    function refillShapes() {
      while (availableShapes.length < 3) {
        // 1 in 8 chance for diamond
        const isDiamond = seededRandom() < 0.125;
        availableShapes.push(pickShape(isDiamond));
      }
    }
    function updateScoreDisplay() {
      document.getElementById('score').textContent = `Score: ${score} | Diamonds: ${diamonds}`;
      document.getElementById('diamond-btn').disabled = score < DIAMOND_COST;
    }
    // --- CANVAS ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      const size = Math.min(window.innerWidth, window.innerHeight) * 0.8;
      canvas.width = size;
      canvas.height = size;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    // Calculate cell size so grid and shapes fit vertically
    function getCellSize() {
      // Reserve space for grid, margin, and fixed shapes area
      // 1 cell margin above, SHAPES_AREA_ROWS cells for shapes area, 1 cell margin below
      return canvas.height / (GRID_SIZE + SHAPES_AREA_ROWS + 2);
    }
    function getShapeBoundingBox(shape) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const block of shape.blocks) {
        minX = Math.min(minX, block.x);
        minY = Math.min(minY, block.y);
        maxX = Math.max(maxX, block.x);
        maxY = Math.max(maxY, block.y);
      }
      return {minX, minY, maxX, maxY};
    }
    // --- DRAW ---
    function drawGrid() {
  const cell = getCellSize();
  const gridWidth = cell * GRID_SIZE;
  const gridHeight = cell * GRID_SIZE;
  // Center grid horizontally, add top margin
  const gridX = (canvas.width - gridWidth) / 2;
  const gridY = cell * 1.0; // 1 cell margin at top
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Draw grid
      ctx.save();
      ctx.translate(gridX, gridY);
      for (let y=0; y<GRID_SIZE; y++) {
        for (let x=0; x<GRID_SIZE; x++) {
          ctx.strokeStyle = '#bbb';
          ctx.lineWidth = 2;
          ctx.strokeRect(x*cell, y*cell, cell, cell);
          if (grid[y][x]) {
            ctx.fillStyle = grid[y][x].color;
            ctx.fillRect(x*cell+2, y*cell+2, cell-4, cell-4);
            if (grid[y][x].isDiamond) {
              ctx.strokeStyle = '#00bcd4';
              ctx.lineWidth = 3;
              ctx.strokeRect(x*cell+6, y*cell+6, cell-12, cell-12);
            }
          }
        }
      }
      ctx.restore();
    }
    function drawAvailableShapes() {
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      // Fixed area for shapes below grid
      const y0 = cell * (GRID_SIZE + 1.5); // 1.5 cells below grid
      const shapesAreaWidth = gridWidth;
      const shapeSpacing = shapesAreaWidth / 3;
      for (let i=0; i<availableShapes.length; i++) {
        const shape = availableShapes[i];
        const box = getShapeBoundingBox(shape);
        // Center each shape horizontally and vertically in its third of the fixed area
        const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
        const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
        for (const block of shape.blocks) {
          ctx.fillStyle = shape.color;
          ctx.fillRect(x0+(block.x-box.minX)*cell, yCenter+(block.y-box.minY)*cell, cell-4, cell-4);
          if (shape.isDiamond) {
            ctx.strokeStyle = '#00bcd4';
            ctx.lineWidth = 3;
            ctx.strokeRect(x0+(block.x-box.minX)*cell+6, yCenter+(block.y-box.minY)*cell+6, cell-12, cell-12);
          }
        }
      }
    }
    function drawDraggingShape() {
      if (!draggingShape) return;
      const cell = getCellSize();
      const box = draggingShape.box || getShapeBoundingBox(draggingShape);
      const minX = box.minX;
      const minY = box.minY;
      for (const block of draggingShape.blocks) {
        ctx.fillStyle = draggingShape.color;
        ctx.globalAlpha = 0.7;
        ctx.fillRect(
          dragPos.x + (block.x-minX)*cell,
          dragPos.y + (block.y-minY)*cell,
          cell-4, cell-4
        );
        ctx.globalAlpha = 1;
        if (draggingShape.isDiamond) {
          ctx.strokeStyle = '#00bcd4';
          ctx.lineWidth = 3;
          ctx.strokeRect(
            dragPos.x + (block.x-minX)*cell+6,
            dragPos.y + (block.y-minY)*cell+6,
            cell-12, cell-12
          );
        }
      }
    }
    function render() {
      drawGrid();
      drawAvailableShapes();
      drawDraggingShape();
    }
    // --- GAME LOGIC ---
    function canPlace(shape, gx, gy) {
      for (const block of shape.blocks) {
        const x = gx+block.x, y = gy+block.y;
        if (x<0||x>=GRID_SIZE||y<0||y>=GRID_SIZE) return false;
        if (!shape.isDiamond && grid[y][x]) return false;
      }
      return true;
    }
    function placeShape(shape, gx, gy) {
      for (const block of shape.blocks) {
        const x = gx+block.x, y = gy+block.y;
        grid[y][x] = {color:shape.color, isDiamond:shape.isDiamond};
      }
      // Clear rows/cols
      let cleared = 0;
      for (let y=0; y<GRID_SIZE; y++) {
        if (grid[y].every(cell=>cell)) {
          for (let x=0; x<GRID_SIZE; x++) grid[y][x]=null;
          cleared++;
        }
      }
      for (let x=0; x<GRID_SIZE; x++) {
        if (grid.every(row=>row[x])) {
          for (let y=0; y<GRID_SIZE; y++) grid[y][x]=null;
          cleared++;
        }
      }
      score += cleared*5 + 1;
      updateScoreDisplay();
    }
    // --- DRAG & DROP ---
    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const cell = getCellSize();
      const gridWidth = cell * GRID_SIZE;
      const gridX = (canvas.width - gridWidth) / 2;
      const y0 = cell * (GRID_SIZE + 1.5);
      const shapesAreaWidth = gridWidth;
      const shapeSpacing = shapesAreaWidth / 3;
      for (let i=0; i<availableShapes.length; i++) {
        const shape = availableShapes[i];
        const box = getShapeBoundingBox(shape);
        const x0 = gridX + i * shapeSpacing + (shapeSpacing - cell*(box.maxX-box.minX+1)) / 2;
        const yCenter = y0 + ((cell*SHAPES_AREA_ROWS) - cell*(box.maxY-box.minY+1)) / 2;
        // Use bounding box for hit detection
        const shapeLeft = x0;
        const shapeTop = yCenter;
        const shapeRight = x0 + (box.maxX-box.minX+1)*cell;
        const shapeBottom = yCenter + (box.maxY-box.minY+1)*cell;
        if (mx > shapeLeft && mx < shapeRight && my > shapeTop && my < shapeBottom) {
          draggingShape = shape;
          dragOffset.x = mx - shapeLeft;
          dragOffset.y = my - shapeTop;
          dragPos.x = mx - dragOffset.x;
          dragPos.y = my - dragOffset.y;
          draggingShape.startX = x0;
          draggingShape.startY = yCenter;
          draggingShape.box = box;
          availableShapes.splice(i,1);
          render();
          return;
        }
      }
    });
    canvas.addEventListener('mousemove', e => {
  if (!draggingShape) return;
  const rect = canvas.getBoundingClientRect();
  dragPos.x = e.clientX - rect.left - dragOffset.x;
  dragPos.y = e.clientY - rect.top - dragOffset.y;
  render();
    });
    canvas.addEventListener('mouseup', e => {
      if (!draggingShape) return;
  const cell = getCellSize();
  const gridWidth = cell * GRID_SIZE;
  const gridX = (canvas.width - gridWidth) / 2;
  const gridY = cell * 1.0; // match drawGrid
  const box = draggingShape.box || getShapeBoundingBox(draggingShape);
  // Use dragOffset to calculate drop position
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const gx = Math.round((mx - dragOffset.x - gridX)/cell - box.minX);
  const gy = Math.round((my - dragOffset.y - gridY)/cell - box.minY);
      if (canPlace(draggingShape, gx, gy)) {
        placeShape(draggingShape, gx, gy);
        draggingShape = null;
        refillShapes();
        render();
      } else {
        availableShapes.push(draggingShape);
        draggingShape = null;
        render();
      }
    });
    // --- DIAMOND BUY ---
    document.getElementById('diamond-btn').onclick = () => {
      if (score >= DIAMOND_COST) {
        score -= DIAMOND_COST;
        diamonds++;
        // Replace a non-diamond shape
        for (let i=0; i<availableShapes.length; i++) {
          if (!availableShapes[i].isDiamond) {
            availableShapes[i] = pickShape(true);
            break;
          }
        }
        updateScoreDisplay();
        render();
      }
    };
    // --- INIT ---
    refillShapes();
    updateScoreDisplay();
    render();
  </script>
</body>
</html>
