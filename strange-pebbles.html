<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="application-name" content="IdleGames">
    <script src="assets/js/pwa.js" defer></script>
    <meta name="theme-color" content="#1a1a1a">
    <title>Strange Pebbles</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        :root {
            --bg-sand: #1a1a1a;
            --wood-dark: #3e2723;
            --wood-light: #5d4037;
            --velvet: #2c2c2c;
            --velvet-highlight: #3a3a3a;
            --text-color: #e0e0e0;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--bg-sand);
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.03) 0%, transparent 60%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E");
            font-family: "Inter", system-ui, sans-serif;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }

        #game-container {
            flex: 1;
            position: relative;
            margin: 20px;
            border: 12px solid var(--wood-dark);
            border-radius: 8px;
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.8),
                0 10px 20px rgba(0,0,0,0.5);
            background: #0a0a0a;
            overflow: hidden;
            /* Wood texture effect on border */
            border-image: repeating-linear-gradient(45deg, var(--wood-dark), var(--wood-dark) 10px, var(--wood-light) 10px, var(--wood-light) 12px) 12;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #toolbox {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 140px;
            background: var(--velvet);
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,0.02) 2px, rgba(255,255,255,0.02) 4px),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.1'/%3E%3C/svg%3E");
            box-shadow: 0 -5px 15px rgba(0,0,0,0.5);
            transform: translateY(110%);
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 100;
            display: flex;
            flex-direction: row;
            pointer-events: auto;
            padding: 0;
        }

        #toolbox.open {
            transform: translateY(0);
        }

        #toolbox-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 4px solid var(--wood-light);
            background: var(--wood-dark);
            /* Wood texture */
            background-image: repeating-linear-gradient(45deg, var(--wood-dark), var(--wood-dark) 5px, var(--wood-light) 5px, var(--wood-light) 6px);
            color: #e0e0e0;
            font-size: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 101;
            transition: transform 0.1s, bottom 0.3s;
            outline: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #toolbox-toggle:active {
            transform: scale(0.95);
        }
        
        /* Move button up when toolbox is open */
        body.toolbox-open #toolbox-toggle {
            bottom: 160px;
        }

        #toolbox-static {
            display: flex;
            align-items: center;
            padding: 0 10px 0 20px;
            gap: 15px;
            height: 100%;
            flex-shrink: 0;
            background: rgba(0,0,0,0.2);
            border-right: 1px solid rgba(255,255,255,0.1);
            z-index: 2;
        }

        #toolbox-content {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 0 20px;
            overflow-x: auto;
            gap: 15px;
            height: 100%;
        }

        .pebble-slot, .toolbox-tool {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            transition: transform 0.1s;
            flex-shrink: 0;
            position: relative;
        }

        .pebble-slot:active, .toolbox-tool:active {
            cursor: grabbing;
            transform: scale(0.95);
        }
        
        .toolbox-tool {
            background: rgba(255,255,255,0.05);
            border-color: rgba(255,255,255,0.2);
            font-size: 24px;
            cursor: pointer;
        }
        
        .toolbox-tool.drag-over {
            background: rgba(255, 50, 50, 0.3);
            border-color: rgba(255, 50, 50, 0.5);
            transform: scale(1.1);
        }

        .pebble-slot .delete-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: #ff5252;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .pebble-slot:hover .delete-btn {
            opacity: 1;
        }

        #waste-bin {
            display: none; /* Removed fixed bin */
        }

        .tutorial-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.3);
            font-size: 1.2rem;
            pointer-events: none;
            text-align: center;
            opacity: 1;
            transition: opacity 1s;
        }
        
        .tutorial-hint.fade-out {
            opacity: 0;
        }

        /* Deluxe Modal */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #modal-content {
            background: var(--velvet);
            border: 4px solid var(--wood-light);
            border-radius: 12px;
            padding: 30px;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            color: var(--text-color);
            font-size: 1.5rem;
            line-height: 1.6;
        }

        #modal-overlay.visible #modal-content {
            transform: scale(1);
        }

        #modal-content h2 {
            margin-top: 0;
            color: #ffeb3b;
            font-size: 2rem;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Drag Ghost */
        #drag-ghost {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2000;
            display: none;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-layer">
            <div class="tutorial-hint" id="hint">Click to place a pebble<br>Drag to move</div>
        </div>
    </div>

    <button id="toolbox-toggle" aria-label="Toggle Toolbox">ðŸ§°</button>

    <div id="toolbox">
        <div id="toolbox-static">
            <!-- Static tools (Reset, Bin, Info) -->
        </div>
        <div id="toolbox-content">
            <!-- Pebble slots will be generated here -->
        </div>
    </div>
    
    <div id="drag-ghost"></div>

    <!-- Modal -->
    <div id="modal-overlay">
        <div id="modal-content">
            <h2 id="modal-title">Info</h2>
            <p id="modal-text">Description goes here.</p>
            <div style="margin-top: 20px; font-size: 0.9rem; opacity: 0.6;">(Tap anywhere to close)</div>
        </div>
    </div>

    <script>
        // --- Game Constants & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hint = document.getElementById('hint');
        const toolboxContent = document.getElementById('toolbox-content');
        const toolboxStatic = document.getElementById('toolbox-static');
        const dragGhost = document.getElementById('drag-ghost');
        
        let width, height;
        let pebbles = [];
        let miniPebbles = [];
        let particles = [];
        let lastTime = 0;
        
        // Interaction State
        let isDragging = false;
        let draggedPebble = null; // Can be a Pebble instance or a "ghost" from toolbox
        let dragOffset = { x: 0, y: 0 };
        let dragStartPos = { x: 0, y: 0 }; // To revert moves
        let dragSource = null; // 'canvas' or 'toolbox'
        let draggedType = null; // For toolbox dragging
        
        // --- Pebble Types ---
        const PEBBLE_TYPES = {
            EMITTER: 'emitter',       // Emits particles
            ATTRACTOR: 'attractor',   // Pulls particles
            REPELLER: 'repeller',     // Pushes particles
            OSCILLATOR: 'oscillator', // Pulses field strength
            LENS: 'lens',             // Refracts particles
            MINI_EMITTER: 'mini_emitter', // Spawns rolling mini-pebbles
            COLOR_RED: 'color_red',   // Tints particles red
            COLOR_GREEN: 'color_green', // Tints particles green
            COLOR_BLUE: 'color_blue',  // Tints particles blue
            ACCELERATOR: 'accelerator', // Speeds up approaching particles
            DECELERATOR: 'decelerator',  // Slows down approaching particles
            ENLARGER: 'enlarger',     // Increases particle size
            SHRINKER: 'shrinker',      // Decreases particle size
            COLLIMATOR: 'collimator'   // Steers particles towards weighted center
        };

        const COLORS = {
            [PEBBLE_TYPES.EMITTER]: '#4fc3f7',
            [PEBBLE_TYPES.ATTRACTOR]: '#ba68c8',
            [PEBBLE_TYPES.REPELLER]: '#ff8a65',
            [PEBBLE_TYPES.OSCILLATOR]: '#4db6ac',
            [PEBBLE_TYPES.LENS]: '#e0e0e0',
            [PEBBLE_TYPES.MINI_EMITTER]: '#8d6e63',
            [PEBBLE_TYPES.COLOR_RED]: '#ff5252',
            [PEBBLE_TYPES.COLOR_GREEN]: '#69f0ae',
            [PEBBLE_TYPES.COLOR_BLUE]: '#448aff',
            [PEBBLE_TYPES.ACCELERATOR]: '#ffeb3b',
            [PEBBLE_TYPES.DECELERATOR]: '#78909c',
            [PEBBLE_TYPES.ENLARGER]: '#ff9100',
            [PEBBLE_TYPES.SHRINKER]: '#3f51b5',
            [PEBBLE_TYPES.COLLIMATOR]: '#d500f9'
        };

        const PEBBLE_DESCRIPTIONS = {
            [PEBBLE_TYPES.EMITTER]: 'Emitter: Spawns particles periodically.',
            [PEBBLE_TYPES.ATTRACTOR]: 'Attractor: Pulls particles towards it.',
            [PEBBLE_TYPES.REPELLER]: 'Repeller: Pushes particles away.',
            [PEBBLE_TYPES.OSCILLATOR]: 'Oscillator: Pushes and pulls rhythmically.',
            [PEBBLE_TYPES.LENS]: 'Lens: Deflects particles in a vortex.',
            [PEBBLE_TYPES.MINI_EMITTER]: 'Mini Emitter: Spawns rolling mini-pebbles.',
            [PEBBLE_TYPES.COLOR_RED]: 'Red Tint: Colors particles red.',
            [PEBBLE_TYPES.COLOR_GREEN]: 'Green Tint: Colors particles green.',
            [PEBBLE_TYPES.COLOR_BLUE]: 'Blue Tint: Colors particles blue.',
            [PEBBLE_TYPES.ACCELERATOR]: 'Accelerator: Speeds up approaching particles.',
            [PEBBLE_TYPES.DECELERATOR]: 'Decelerator: Slows down approaching particles.',
            [PEBBLE_TYPES.ENLARGER]: 'Enlarger: Increases particle size.',
            [PEBBLE_TYPES.SHRINKER]: 'Shrinker: Decreases particle size.',
            [PEBBLE_TYPES.COLLIMATOR]: 'Collimator: Steers particles to align with the average direction of nearby collimators.'
        };

        // --- Utils ---
        function randomRange(min, max) { return Math.random() * (max - min) + min; }
        function distSq(x1, y1, x2, y2) { return (x1-x2)**2 + (y1-y2)**2; }

        // --- Classes ---
        class Pebble {
            constructor(x, y, type, config = {}) {
                this.x = x;
                this.y = y;
                this.type = type || this.randomType();
                this.radius = config.radius || randomRange(18, 28);
                this.color = COLORS[this.type];
                this.angle = config.angle || Math.random() * Math.PI * 2;
                this.oscillationPhase = config.oscillationPhase || Math.random() * Math.PI * 2;
                this.forceType = config.forceType || (Math.random() > 0.5 ? 'inverse-square' : 'linear');
                
                // Shape irregularity
                if (config.points) {
                    this.points = config.points;
                } else {
                    this.points = [];
                    const segments = 8;
                    for (let i = 0; i < segments; i++) {
                        this.points.push(randomRange(0.8, 1.2));
                    }
                }
            }

            randomType() {
                const types = Object.values(PEBBLE_TYPES);
                return types[Math.floor(Math.random() * types.length)];
            }

            update(dt) {
                this.oscillationPhase += dt;
                
                // Emitter logic
                if (this.type === PEBBLE_TYPES.EMITTER && Math.random() < 0.05) {
                    particles.push(new Particle(this.x, this.y, Math.random() * Math.PI * 2));
                }
                
                // Mini Emitter logic
                if (this.type === PEBBLE_TYPES.MINI_EMITTER && Math.random() < 0.01) {
                    miniPebbles.push(new MiniPebble(this.x, this.y));
                }

                // Oscillator visual
                if (this.type === PEBBLE_TYPES.OSCILLATOR) {
                    // Just visual pulse, logic handled in Particle
                }
                
                // Keep within bounds if moved by physics
                if (this.x < this.radius) this.x = this.radius;
                if (this.x > width - this.radius) this.x = width - this.radius;
                if (this.y < this.radius) this.y = this.radius;
                if (this.y > height - this.radius) this.y = height - this.radius;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Shadow
                ctx.shadowColor = 'rgba(0,0,0,0.6)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetY = 8;

                // Draw irregular shape
                ctx.beginPath();
                const segments = this.points.length;
                for (let i = 0; i <= segments; i++) {
                    const idx = i % segments;
                    const r = this.radius * this.points[idx];
                    const theta = (i / segments) * Math.PI * 2;
                    const px = Math.cos(theta) * r;
                    const py = Math.sin(theta) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();

                // Gradient fill
                const grad = ctx.createRadialGradient(-this.radius*0.3, -this.radius*0.3, 0, 0, 0, this.radius);
                grad.addColorStop(0, lighten(this.color, 40));
                grad.addColorStop(0.5, this.color);
                grad.addColorStop(1, darken(this.color, 20));
                
                ctx.fillStyle = grad;
                ctx.fill();

                // Inner detail/symbol based on type
                ctx.shadowColor = 'transparent';
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                // Simple icon logic
                if (this.type === PEBBLE_TYPES.ATTRACTOR) {
                    ctx.arc(0, 0, 5, 0, Math.PI*2);
                } else if (this.type === PEBBLE_TYPES.REPELLER) {
                    ctx.arc(0, 0, 8, 0, Math.PI*2);
                    ctx.moveTo(0,0); ctx.arc(0,0, 4, 0, Math.PI*2, true);
                } else if (this.type === PEBBLE_TYPES.COLOR_RED || this.type === PEBBLE_TYPES.COLOR_GREEN || this.type === PEBBLE_TYPES.COLOR_BLUE) {
                    ctx.arc(0, 0, 6, 0, Math.PI*2);
                } else if (this.type === PEBBLE_TYPES.ACCELERATOR) {
                    // Triangle
                    ctx.moveTo(0, -6);
                    ctx.lineTo(5, 4);
                    ctx.lineTo(-5, 4);
                } else if (this.type === PEBBLE_TYPES.DECELERATOR) {
                    // Square
                    ctx.rect(-5, -5, 10, 10);
                } else if (this.type === PEBBLE_TYPES.ENLARGER) {
                    // Plus / Ring
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.arc(0, 0, 8, 0, Math.PI*2);
                    ctx.stroke();
                } else if (this.type === PEBBLE_TYPES.SHRINKER) {
                    // Dot
                    ctx.arc(0, 0, 3, 0, Math.PI*2);
                } else if (this.type === PEBBLE_TYPES.COLLIMATOR) {
                    // Focus / Target
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    // > < shape
                    ctx.beginPath();
                    ctx.moveTo(-4, -6); ctx.lineTo(2, 0); ctx.lineTo(-4, 6);
                    ctx.moveTo(4, -6); ctx.lineTo(-2, 0); ctx.lineTo(4, 6);
                    ctx.stroke();
                }
                ctx.fill();

                ctx.restore();
            }
            
            contains(x, y) {
                return distSq(this.x, this.y, x, y) < this.radius * this.radius;
            }
        }

        class MiniPebble {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 6;
                this.vx = randomRange(-50, 50);
                this.vy = randomRange(-50, 50);
                this.life = randomRange(10, 15); // Seconds before turning into photon
                this.color = '#a1887f';
            }

            update(dt) {
                this.life -= dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Wall bounce
                if (this.x < this.radius || this.x > width - this.radius) this.vx *= -0.8;
                if (this.y < this.radius || this.y > height - this.radius) this.vy *= -0.8;
                
                // Constrain
                this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));

                // Pebble collision (simple circle)
                for (const p of pebbles) {
                    const d2 = distSq(this.x, this.y, p.x, p.y);
                    const minDist = this.radius + p.radius;
                    
                    // Field interaction
                    if (d2 < 200*200 && d2 > minDist*minDist) {
                        const dist = Math.sqrt(d2);
                        const nx = (this.x - p.x) / dist;
                        const ny = (this.y - p.y) / dist;
                        
                        let force = 0;
                        if (p.type === PEBBLE_TYPES.ATTRACTOR) force = -500;
                        else if (p.type === PEBBLE_TYPES.REPELLER) force = 500;
                        
                        if (force !== 0) {
                            // Apply force based on distance (inverse square-ish)
                            const f = force / (d2/100 + 1);
                            this.vx += nx * f * dt;
                            this.vy += ny * f * dt;
                        }
                    }

                    if (d2 < minDist * minDist) {
                        const dist = Math.sqrt(d2);
                        const nx = (this.x - p.x) / dist;
                        const ny = (this.y - p.y) / dist;
                        
                        // Reflect velocity
                        const dot = this.vx * nx + this.vy * ny;
                        this.vx = this.vx - 2 * dot * nx;
                        this.vy = this.vy - 2 * dot * ny;
                        
                        // Push out
                        const overlap = minDist - dist;
                        this.x += nx * overlap;
                        this.y += ny * overlap;
                    }
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * randomRange(30, 60);
                this.vy = Math.sin(angle) * randomRange(30, 60);
                this.life = randomRange(15, 25); // Seconds
                // Start white
                this.r = 255;
                this.g = 255;
                this.b = 255;
                this.radius = 2;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;

                // Collimator Data
                let collimators = [];
                let minColDistSq = Infinity;

                // Interaction with pebbles
                for (const p of pebbles) {
                    const dx = this.x - p.x;
                    const dy = this.y - p.y;
                    const d2 = dx*dx + dy*dy;
                    
                    // Collect Collimators
                    if (p.type === PEBBLE_TYPES.COLLIMATOR) {
                        if (d2 < minColDistSq) minColDistSq = d2;
                        collimators.push({p, d2});
                        continue; 
                    }

                    const dist = Math.sqrt(d2);

                    if (dist < 150) { // Interaction range
                        // Normalized vector
                        const nx = dx / dist;
                        const ny = dy / dist;
                        
                        // Calculate force magnitude based on pebble's forceType
                        let forceMag = 0;
                        if (p.forceType === 'inverse-square') {
                            forceMag = 800 / (d2 + 100);
                        } else {
                            // Linear falloff
                            forceMag = Math.max(0, (150 - dist) / 150) * 5;
                        }

                        if (p.type === PEBBLE_TYPES.ATTRACTOR) {
                            this.vx -= nx * forceMag * dt * 60;
                            this.vy -= ny * forceMag * dt * 60;
                        } else if (p.type === PEBBLE_TYPES.REPELLER) {
                            this.vx += nx * forceMag * dt * 60;
                            this.vy += ny * forceMag * dt * 60;
                        } else if (p.type === PEBBLE_TYPES.OSCILLATOR) {
                            const wave = Math.sin(p.oscillationPhase * 3);
                            const force = (wave * 500) / (d2 + 10);
                            this.vx += nx * force * dt;
                            this.vy += ny * force * dt;
                        } else if (p.type === PEBBLE_TYPES.LENS) {
                            // Deflect perpendicular to radius (vortex)
                            this.vx += ny * 20 * dt;
                            this.vy -= nx * 20 * dt;
                        } else if (p.type === PEBBLE_TYPES.COLOR_RED) {
                            const strength = Math.max(0, (150 - dist) / 150) * 2.0;
                            this.lerpColor(255, 50, 50, strength * dt);
                        } else if (p.type === PEBBLE_TYPES.COLOR_GREEN) {
                            const strength = Math.max(0, (150 - dist) / 150) * 2.0;
                            this.lerpColor(50, 255, 50, strength * dt);
                        } else if (p.type === PEBBLE_TYPES.COLOR_BLUE) {
                            const strength = Math.max(0, (150 - dist) / 150) * 2.0;
                            this.lerpColor(50, 100, 255, strength * dt);
                        } else if (p.type === PEBBLE_TYPES.ACCELERATOR || p.type === PEBBLE_TYPES.DECELERATOR) {
                            // Check if approaching (dot product < 0)
                            // dx, dy are vector from pebble to particle
                            const dot = this.vx * dx + this.vy * dy;
                            
                            if (dot < 0) {
                                const strength = Math.max(0, (150 - dist) / 150);
                                let multiplier = 1;
                                
                                if (p.type === PEBBLE_TYPES.ACCELERATOR) {
                                    multiplier = 1 + (2.0 * strength * dt);
                                } else {
                                    multiplier = 1 - (1.5 * strength * dt);
                                }
                                
                                this.vx *= multiplier;
                                this.vy *= multiplier;
                            }
                        } else if (p.type === PEBBLE_TYPES.ENLARGER) {
                            const strength = Math.max(0, (150 - dist) / 150);
                            // Grow up to 1.5x rate
                            this.radius *= (1 + 1.5 * strength * dt);
                            if (this.radius > 20) this.radius = 20;
                        } else if (p.type === PEBBLE_TYPES.SHRINKER) {
                            const strength = Math.max(0, (150 - dist) / 150);
                            // Shrink
                            this.radius *= (1 - 1.0 * strength * dt);
                            if (this.radius < 0.5) this.radius = 0.5;
                        }
                    }
                }
                
                // Apply Collimator Logic
                if (collimators.length >= 2 && minColDistSq < Infinity) {
                    // Filter for cluster: within 25% of closest distance
                    // Use squared distance: (1.25)^2 = 1.5625
                    const thresholdSq = minColDistSq * 1.5625;
                    
                    let colSumW = 0;
                    let colSumWX = 0;
                    let colSumWY = 0;
                    let colSumWXX = 0;
                    let colSumWYY = 0;
                    let colSumWXY = 0;
                    let clusterCount = 0;

                    for (const c of collimators) {
                        if (c.d2 <= thresholdSq) {
                            // Weight by inverse square distance within the cluster for precision
                            const w = 1 / (c.d2 + 100); 
                            colSumW += w;
                            colSumWX += w * c.p.x;
                            colSumWY += w * c.p.y;
                            colSumWXX += w * c.p.x * c.p.x;
                            colSumWYY += w * c.p.y * c.p.y;
                            colSumWXY += w * c.p.x * c.p.y;
                            clusterCount++;
                        }
                    }

                    if (clusterCount >= 2 && colSumW > 0) {
                        const meanX = colSumWX / colSumW;
                        const meanY = colSumWY / colSumW;
                        
                        const varX = (colSumWXX / colSumW) - (meanX * meanX);
                        const varY = (colSumWYY / colSumW) - (meanY * meanY);
                        const covXY = (colSumWXY / colSumW) - (meanX * meanY);
                        
                        // Principal axis angle
                        const theta = 0.5 * Math.atan2(2 * covXY, varX - varY);
                        
                        // Linearity
                        const delta = Math.sqrt((varX - varY)**2 + 4 * covXY * covXY);
                        const sum = varX + varY;
                        const linearity = sum > 1e-6 ? delta / sum : 0;
                        
                        const tx = Math.cos(theta);
                        const ty = Math.sin(theta);
                        
                        // Align with velocity
                        const dot = this.vx * tx + this.vy * ty;
                        const targetX = dot >= 0 ? tx : -tx;
                        const targetY = dot >= 0 ? ty : -ty;
                        
                        // Strength based on proximity to the CLOSEST pebble in the cluster
                        // This provides the "dynamic falloff" requested
                        const proximityFactor = 1 / (minColDistSq + 1000);
                        const strength = proximityFactor * 50000 * linearity * dt;
                        
                        const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                        if (speed > 0.1) {
                            const vxNorm = this.vx / speed;
                            const vyNorm = this.vy / speed;
                            
                            const newVx = vxNorm + (targetX - vxNorm) * strength;
                            const newVy = vyNorm + (targetY - vyNorm) * strength;
                            
                            const newLen = Math.sqrt(newVx*newVx + newVy*newVy);
                            this.vx = (newVx / newLen) * speed;
                            this.vy = (newVy / newLen) * speed;
                        }
                    }
                }
                
                // Wall bounce
                if (this.x < 0 || this.x > width) this.vx *= -0.9;
                if (this.y < 0 || this.y > height) this.vy *= -0.9;
            }
            
            lerpColor(tr, tg, tb, amt) {
                amt = Math.min(1, Math.max(0, amt));
                this.r += (tr - this.r) * amt;
                this.g += (tg - this.g) * amt;
                this.b += (tb - this.b) * amt;
            }

            draw(ctx) {
                // Fade out in the last 2 seconds
                const alpha = Math.min(1, Math.max(0, this.life / 2));
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgb(${Math.round(this.r)}, ${Math.round(this.g)}, ${Math.round(this.b)})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- Helpers ---
        function lighten(hex, percent) {
            // Simple hex lighten (not perfect but fast)
            const num = parseInt(hex.replace('#',''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
        }
        function darken(hex, percent) { return lighten(hex, -percent); }

        // --- Main Loop ---
        function resize() {
            const rect = document.getElementById('game-container').getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            width = canvas.width;
            height = canvas.height;
        }

        function loop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            update(dt);
            draw();

            requestAnimationFrame(loop);
        }

        function update(dt) {
            pebbles.forEach(p => p.update(dt));
            
            // Pebble-to-Pebble interactions (Oscillator)
            for (let i = 0; i < pebbles.length; i++) {
                for (let j = i + 1; j < pebbles.length; j++) {
                    const p1 = pebbles[i];
                    const p2 = pebbles[j];
                    
                    // Oscillator effect on other pebbles
                    if (p1.type === PEBBLE_TYPES.OSCILLATOR || p2.type === PEBBLE_TYPES.OSCILLATOR) {
                        const d2 = distSq(p1.x, p1.y, p2.x, p2.y);
                        if (d2 < 40000) { // 200px range
                            const dist = Math.sqrt(d2);
                            const nx = (p2.x - p1.x) / dist;
                            const ny = (p2.y - p1.y) / dist;
                            
                            if (p1.type === PEBBLE_TYPES.OSCILLATOR) {
                                const force = Math.sin(p1.oscillationPhase * 2) * 20; // Gentle push/pull
                                p2.x += nx * force * dt;
                                p2.y += ny * force * dt;
                            }
                            if (p2.type === PEBBLE_TYPES.OSCILLATOR) {
                                const force = Math.sin(p2.oscillationPhase * 2) * 20;
                                p1.x -= nx * force * dt;
                                p1.y -= ny * force * dt;
                            }
                        }
                    }
                }
            }
            
            for (let i = miniPebbles.length - 1; i >= 0; i--) {
                miniPebbles[i].update(dt);
                if (miniPebbles[i].life <= 0) {
                    // Burst into particles
                    for(let j=0; j<5; j++) {
                        particles.push(new Particle(miniPebbles[i].x, miniPebbles[i].y, Math.random()*Math.PI*2));
                    }
                    miniPebbles.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function draw() {
            // Clear canvas completely (no trails)
            ctx.clearRect(0, 0, width, height);

            // Draw particles (glow effect)
            ctx.globalCompositeOperation = 'screen';
            particles.forEach(p => p.draw(ctx));
            ctx.globalCompositeOperation = 'source-over';

            // Draw mini pebbles
            miniPebbles.forEach(p => p.draw(ctx));

            // Draw pebbles
            pebbles.forEach(p => p.draw(ctx));
            
            // Draw dragged ghost
            // Ghost is now a DOM element, no canvas drawing needed
        }

        // --- Input Handling ---
        function getCanvasPos(evt) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (evt.touches && evt.touches.length > 0) {
                clientX = evt.touches[0].clientX;
                clientY = evt.touches[0].clientY;
            } else if (evt.changedTouches && evt.changedTouches.length > 0) {
                clientX = evt.changedTouches[0].clientX;
                clientY = evt.changedTouches[0].clientY;
            } else {
                clientX = evt.clientX;
                clientY = evt.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        function handleStart(e) {
            if (e.target !== canvas) return;
            e.preventDefault();
            const pos = getCanvasPos(e);
            
            // Check if clicked on a pebble
            // Use a slightly larger hit area for better UX
            for (let i = pebbles.length - 1; i >= 0; i--) {
                const p = pebbles[i];
                const hitRadius = p.radius + 15; // Forgiving hit area
                if (distSq(p.x, p.y, pos.x, pos.y) < hitRadius * hitRadius) {
                    isDragging = true;
                    dragSource = 'canvas';
                    draggedPebble = p;
                    dragOffset.x = pos.x - p.x;
                    dragOffset.y = pos.y - p.y;
                    
                    // Store original position
                    dragStartPos.x = p.x;
                    dragStartPos.y = p.y;

                    return;
                }
            }

            // If not, create new random pebble AND start dragging it immediately
            if (!isDragging) {
                const newPebble = new Pebble(pos.x, pos.y);
                pebbles.push(newPebble);
                
                isDragging = true;
                dragSource = 'canvas';
                draggedPebble = newPebble;
                dragOffset.x = 0;
                dragOffset.y = 0;
            }
        }

        function handleMove(e) {
            if (!isDragging) return;
            
            const pos = getCanvasPos(e);
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            if (dragSource === 'canvas' && draggedPebble) {
                draggedPebble.x = pos.x - dragOffset.x;
                draggedPebble.y = pos.y - dragOffset.y;
                
                // Check waste bin hover
                checkBinHover(clientX, clientY); // Use screen coords for DOM element check
                checkInfoHover(clientX, clientY);
                
                // Auto-open toolbox if dragging near bottom
                if (clientY > window.innerHeight - 100) {
                    openToolbox();
                }
            } else if (dragSource === 'toolbox') {
                // Update ghost position
                dragOffset = pos; // Reuse variable for current pos
                
                // Move DOM ghost
                dragGhost.style.left = clientX + 'px';
                dragGhost.style.top = clientY + 'px';
                
                checkInfoHover(clientX, clientY);

                if (draggedType === 'eraser') {
                    // Erase pebbles under cursor
                    for (let i = pebbles.length - 1; i >= 0; i--) {
                        const p = pebbles[i];
                        if (p.contains(pos.x, pos.y)) {
                            pebbles.splice(i, 1);
                            // Optional: spawn particles or effect
                            saveState();
                        }
                    }
                }
            }
        }

        function handleEnd(e) {
            if (!isDragging) return;

            const toolboxBin = document.getElementById('toolbox-bin');
            const toolboxInfo = document.getElementById('toolbox-info');
            const toolbox = document.getElementById('toolbox');
            const toolboxRect = toolbox.getBoundingClientRect();
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            
            // Hide ghost
            dragGhost.style.display = 'none';
            
            let changed = false;

            if (dragSource === 'canvas' && draggedPebble) {
                // Drop in bin?
                if (toolboxBin && toolboxBin.classList.contains('drag-over')) {
                    const index = pebbles.indexOf(draggedPebble);
                    if (index > -1) pebbles.splice(index, 1);
                    toolboxBin.classList.remove('drag-over');
                    changed = true;
                }
                // Drop in Info?
                else if (toolboxInfo && toolboxInfo.classList.contains('drag-over')) {
                    // Show info
                    showModal('Pebble Info', PEBBLE_DESCRIPTIONS[draggedPebble.type] || 'Unknown Pebble');
                    
                    // Revert position (Cancel Drag)
                    draggedPebble.x = dragStartPos.x;
                    draggedPebble.y = dragStartPos.y;
                    
                    toolboxInfo.classList.remove('drag-over');
                    changed = true; // State changed (reverted)
                }
                // Drop in toolbox?
                // Check if dropped in toolbox area (if open) or near bottom
                else if (document.body.classList.contains('toolbox-open') && clientY > toolboxRect.top) {
                    addToToolbox(draggedPebble.type);
                    const index = pebbles.indexOf(draggedPebble);
                    if (index > -1) pebbles.splice(index, 1);
                    changed = true;
                } else {
                    // Just moved
                    changed = true;
                }
            } else if (dragSource === 'toolbox' && draggedType) {
                // Check if dropped on info
                const rect = toolboxInfo.getBoundingClientRect();
                const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                
                if (clientX >= rect.left && clientX <= rect.right &&
                    clientY >= rect.top && clientY <= rect.bottom) {
                    
                    showModal('Pebble Info', PEBBLE_DESCRIPTIONS[draggedType] || 'Unknown Pebble');
                    // Do nothing else (don't create pebble)
                    toolboxInfo.classList.remove('drag-over');
                    
                } else if (draggedType !== 'eraser') {
                    // Drop on canvas
                    const pos = getCanvasPos(e);
                    // Check bounds
                    if (pos.x >= 0 && pos.x <= width && pos.y >= 0 && pos.y <= height) {
                        pebbles.push(new Pebble(pos.x, pos.y, draggedType));
                        changed = true;
                    }
                }
            }

            isDragging = false;
            draggedPebble = null;
            dragSource = null;
            draggedType = null;
            
            if (changed) saveState();
        }
        
        function checkBinHover(clientX, clientY) {
            const bin = document.getElementById('toolbox-bin');
            if (!bin) return;
            
            const rect = bin.getBoundingClientRect();
            if (clientX >= rect.left && clientX <= rect.right &&
                clientY >= rect.top && clientY <= rect.bottom) {
                bin.classList.add('drag-over');
            } else {
                bin.classList.remove('drag-over');
            }
        }

        function checkInfoHover(clientX, clientY) {
            const info = document.getElementById('toolbox-info');
            if (!info) return;
            
            const rect = info.getBoundingClientRect();
            if (clientX >= rect.left && clientX <= rect.right &&
                clientY >= rect.top && clientY <= rect.bottom) {
                info.classList.add('drag-over');
            } else {
                info.classList.remove('drag-over');
            }
        }

        // --- Toolbox Logic ---
        const STORAGE_KEY = 'idlegames-strange-pebbles-state';

        function saveState() {
            const state = {
                pebbles: pebbles.map(p => ({
                    x: p.x,
                    y: p.y,
                    type: p.type,
                    radius: p.radius,
                    angle: p.angle,
                    oscillationPhase: p.oscillationPhase,
                    forceType: p.forceType,
                    points: p.points
                })),
                toolbox: Array.from(toolboxContent.querySelectorAll('.pebble-slot')).map(slot => slot.dataset.type),
                toolboxOpen: document.body.classList.contains('toolbox-open')
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function loadState() {
            const json = localStorage.getItem(STORAGE_KEY);
            if (!json) return false;
            
            try {
                const state = JSON.parse(json);
                
                // Restore pebbles
                pebbles = state.pebbles.map(p => new Pebble(p.x, p.y, p.type, p));
                
                // Restore toolbox items (append them)
                state.toolbox.forEach(type => {
                    if (type && COLORS[type]) addToToolbox(type, false);
                });

                // Restore toolbox open state
                if (state.toolboxOpen) {
                    openToolbox();
                } else {
                    closeToolbox();
                }
                
                return true;
            } catch (e) {
                console.error('Failed to load state', e);
                return false;
            }
        }

        function initToolbox() {
            toolboxContent.innerHTML = ''; // Clear pebbles
            toolboxStatic.innerHTML = ''; // Clear static tools
            
            addStaticTools(); // Add static tools

            if (!loadState()) {
                // If no state, add defaults
                Object.values(PEBBLE_TYPES).forEach(type => addToToolbox(type, false));
            }
        }
        
        function addStaticTools() {
            // Reset Button
            const resetBtn = document.createElement('div');
            resetBtn.className = 'toolbox-tool';
            resetBtn.innerHTML = 'â†»';
            resetBtn.title = 'Reset Game';
            resetBtn.onclick = resetGame;
            toolboxStatic.appendChild(resetBtn);
            
            // Waste Bin
            const bin = document.createElement('div');
            bin.className = 'toolbox-tool';
            bin.id = 'toolbox-bin';
            bin.innerHTML = 'ðŸ—‘ï¸';
            bin.title = 'Drag to erase';
            
            // Drag start for eraser
            bin.addEventListener('mousedown', (e) => startToolboxDrag(e, 'eraser'));
            bin.addEventListener('touchstart', (e) => startToolboxDrag(e, 'eraser'), {passive: false});
            
            toolboxStatic.appendChild(bin);

            // Info / Cancel Tool
            const info = document.createElement('div');
            info.className = 'toolbox-tool';
            info.id = 'toolbox-info';
            info.innerHTML = '?';
            info.title = 'Drag here to cancel or see info';
            toolboxStatic.appendChild(info);
            
            // Separator (Visual only, border handles it now)
            // const sep = document.createElement('div');
            // ...
        }

        function addToToolbox(type, save = true) {
            const slot = document.createElement('div');
            slot.className = 'pebble-slot';
            slot.dataset.type = type;
            
            const preview = document.createElement('div');
            preview.style.width = '30px';
            preview.style.height = '30px';
            preview.style.borderRadius = '50%';
            preview.style.backgroundColor = COLORS[type];
            preview.style.boxShadow = 'inset 0 0 5px rgba(0,0,0,0.5)';
            
            const delBtn = document.createElement('div');
            delBtn.className = 'delete-btn';
            delBtn.innerHTML = 'Ã—';
            delBtn.onclick = (e) => {
                e.stopPropagation();
                slot.remove();
                saveState();
            };

            slot.appendChild(preview);
            slot.appendChild(delBtn);
            toolboxContent.appendChild(slot);
            
            // Drag start
            slot.addEventListener('mousedown', (e) => startToolboxDrag(e, type));
            slot.addEventListener('touchstart', (e) => startToolboxDrag(e, type), {passive: false});
            
            if (save) saveState();
        }

        function startToolboxDrag(e, type) {
            e.preventDefault();
            isDragging = true;
            dragSource = 'toolbox';
            draggedType = type;
            
            // Initial pos
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            dragOffset = {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
            
            // Setup Ghost
            dragGhost.style.display = 'flex';
            dragGhost.style.left = clientX + 'px';
            dragGhost.style.top = clientY + 'px';
            
            if (type === 'eraser') {
                dragGhost.innerHTML = 'ðŸ—‘ï¸';
                dragGhost.style.background = 'transparent';
                dragGhost.style.boxShadow = 'none';
            } else {
                dragGhost.innerHTML = '';
                dragGhost.style.background = COLORS[type];
                dragGhost.style.boxShadow = '0 5px 15px rgba(0,0,0,0.5)';
            }
        }

        // Toolbox toggle
        const toggleBtn = document.getElementById('toolbox-toggle');
        toggleBtn.addEventListener('click', () => {
            if (document.body.classList.contains('toolbox-open')) {
                closeToolbox();
            } else {
                openToolbox();
            }
            saveState();
        });
        
        function openToolbox() {
            document.getElementById('toolbox').classList.add('open');
            document.body.classList.add('toolbox-open');
        }
        
        function closeToolbox() {
            document.getElementById('toolbox').classList.remove('open');
            document.body.classList.remove('toolbox-open');
        }

        function resetGame() {
            // Clear storage
            localStorage.removeItem(STORAGE_KEY);
            
            // Reset state variables
            pebbles = [];
            miniPebbles = [];
            particles = [];
            
            // Reset interaction state
            isDragging = false;
            draggedPebble = null;
            dragSource = null;
            draggedType = null;
            dragGhost.style.display = 'none';
            
            // Clear canvas artifacts immediately (shadows, trails)
            ctx.clearRect(0, 0, width, height);
            
            // Re-init toolbox (restores default pebbles)
            initToolbox();
            
            // Save the "clean" state so it persists if they reload manually
            saveState();
            
            // Reset hint
            hint.style.display = '';
            hint.classList.remove('fade-out');
            window.addEventListener('mousedown', dismissHint, {once: true});
            window.addEventListener('touchstart', dismissHint, {once: true});
        }        // Modal Logic
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalText = document.getElementById('modal-text');

        function showModal(title, text) {
            modalTitle.textContent = title;
            modalText.textContent = text;
            modalOverlay.classList.add('visible');
        }

        function hideModal() {
            modalOverlay.classList.remove('visible');
        }

        modalOverlay.addEventListener('click', hideModal);
        modalOverlay.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent ghost clicks
            hideModal();
        });

        // Init
        window.addEventListener('resize', resize);
        resize();
        initToolbox();

        // Dismiss hint on any interaction
        function dismissHint() { hint.classList.add('fade-out'); }
        window.addEventListener('mousedown', dismissHint, {once: true});
        window.addEventListener('touchstart', dismissHint, {once: true});

        // Hide hint immediately if pebbles exist from save state
        if (pebbles.length > 0) {
            hint.style.display = 'none';
        }

        requestAnimationFrame(loop);

    </script>
    <script src="parental.js" defer></script>
</body>
</html>